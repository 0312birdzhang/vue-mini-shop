(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/usr/lib/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/usr/lib/node_modules/vue-hot-reload-api/index.js":[function(require,module,exports){
var Vue // late bind
var map = Object.create(null)
var shimmed = false
var isBrowserify = false

/**
 * Determine compatibility and apply patch.
 *
 * @param {Function} vue
 * @param {Boolean} browserify
 */

exports.install = function (vue, browserify) {
  if (shimmed) return
  shimmed = true

  Vue = vue
  isBrowserify = browserify

  exports.compatible = !!Vue.internalDirectives
  if (!exports.compatible) {
    console.warn(
      '[HMR] vue-loader hot reload is only compatible with ' +
      'Vue.js 1.0.0+.'
    )
    return
  }

  // patch view directive
  patchView(Vue.internalDirectives.component)
  console.log('[HMR] Vue component hot reload shim applied.')
  // shim router-view if present
  var routerView = Vue.elementDirective('router-view')
  if (routerView) {
    patchView(routerView)
    console.log('[HMR] vue-router <router-view> hot reload shim applied.')
  }
}

/**
 * Shim the view directive (component or router-view).
 *
 * @param {Object} View
 */

function patchView (View) {
  var unbuild = View.unbuild
  View.unbuild = function (defer) {
    if (!this.hotUpdating) {
      var prevComponent = this.childVM && this.childVM.constructor
      removeView(prevComponent, this)
      // defer = true means we are transitioning to a new
      // Component. Register this new component to the list.
      if (defer) {
        addView(this.Component, this)
      }
    }
    // call original
    return unbuild.call(this, defer)
  }
}

/**
 * Add a component view to a Component's hot list
 *
 * @param {Function} Component
 * @param {Directive} view - view directive instance
 */

function addView (Component, view) {
  var id = Component && Component.options.hotID
  if (id) {
    if (!map[id]) {
      map[id] = {
        Component: Component,
        views: [],
        instances: []
      }
    }
    map[id].views.push(view)
  }
}

/**
 * Remove a component view from a Component's hot list
 *
 * @param {Function} Component
 * @param {Directive} view - view directive instance
 */

function removeView (Component, view) {
  var id = Component && Component.options.hotID
  if (id) {
    map[id].views.$remove(view)
  }
}

/**
 * Create a record for a hot module, which keeps track of its construcotr,
 * instnaces and views (component directives or router-views).
 *
 * @param {String} id
 * @param {Object} options
 */

exports.createRecord = function (id, options) {
  if (typeof options === 'function') {
    options = options.options
  }
  if (typeof options.el !== 'string' && typeof options.data !== 'object') {
    makeOptionsHot(id, options)
    map[id] = {
      Component: null,
      views: [],
      instances: []
    }
  }
}

/**
 * Make a Component options object hot.
 *
 * @param {String} id
 * @param {Object} options
 */

function makeOptionsHot (id, options) {
  options.hotID = id
  injectHook(options, 'created', function () {
    var record = map[id]
    if (!record.Component) {
      record.Component = this.constructor
    }
    record.instances.push(this)
  })
  injectHook(options, 'beforeDestroy', function () {
    map[id].instances.$remove(this)
  })
}

/**
 * Inject a hook to a hot reloadable component so that
 * we can keep track of it.
 *
 * @param {Object} options
 * @param {String} name
 * @param {Function} hook
 */

function injectHook (options, name, hook) {
  var existing = options[name]
  options[name] = existing
    ? Array.isArray(existing)
      ? existing.concat(hook)
      : [existing, hook]
    : [hook]
}

/**
 * Update a hot component.
 *
 * @param {String} id
 * @param {Object|null} newOptions
 * @param {String|null} newTemplate
 */

exports.update = function (id, newOptions, newTemplate) {
  var record = map[id]
  // force full-reload if an instance of the component is active but is not
  // managed by a view
  if (!record || (record.instances.length && !record.views.length)) {
    console.log('[HMR] Root or manually-mounted instance modified. Full reload may be required.')
    if (!isBrowserify) {
      window.location.reload()
    } else {
      // browserify-hmr somehow sends incomplete bundle if we reload here
      return
    }
  }
  if (!isBrowserify) {
    // browserify-hmr already logs this
    console.log('[HMR] Updating component: ' + format(id))
  }
  var Component = record.Component
  // update constructor
  if (newOptions) {
    // in case the user exports a constructor
    Component = record.Component = typeof newOptions === 'function'
      ? newOptions
      : Vue.extend(newOptions)
    makeOptionsHot(id, Component.options)
  }
  if (newTemplate) {
    Component.options.template = newTemplate
  }
  // handle recursive lookup
  if (Component.options.name) {
    Component.options.components[Component.options.name] = Component
  }
  // reset constructor cached linker
  Component.linker = null
  // reload all views
  record.views.forEach(function (view) {
    updateView(view, Component)
  })
  // flush devtools
  if (window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {
    window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('flush')
  }
}

/**
 * Update a component view instance
 *
 * @param {Directive} view
 * @param {Function} Component
 */

function updateView (view, Component) {
  if (!view._bound) {
    return
  }
  view.Component = Component
  view.hotUpdating = true
  // disable transitions
  view.vm._isCompiled = false
  // save state
  var state = extractState(view.childVM)
  // remount, make sure to disable keep-alive
  var keepAlive = view.keepAlive
  view.keepAlive = false
  view.mountComponent()
  view.keepAlive = keepAlive
  // restore state
  restoreState(view.childVM, state, true)
  // re-eanble transitions
  view.vm._isCompiled = true
  view.hotUpdating = false
}

/**
 * Extract state from a Vue instance.
 *
 * @param {Vue} vm
 * @return {Object}
 */

function extractState (vm) {
  return {
    cid: vm.constructor.cid,
    data: vm.$data,
    children: vm.$children.map(extractState)
  }
}

/**
 * Restore state to a reloaded Vue instance.
 *
 * @param {Vue} vm
 * @param {Object} state
 */

function restoreState (vm, state, isRoot) {
  var oldAsyncConfig
  if (isRoot) {
    // set Vue into sync mode during state rehydration
    oldAsyncConfig = Vue.config.async
    Vue.config.async = false
  }
  // actual restore
  if (isRoot || !vm._props) {
    vm.$data = state.data
  } else {
    Object.keys(state.data).forEach(function (key) {
      if (!vm._props[key]) {
        // for non-root, only restore non-props fields
        vm.$data[key] = state.data[key]
      }
    })
  }
  // verify child consistency
  var hasSameChildren = vm.$children.every(function (c, i) {
    return state.children[i] && state.children[i].cid === c.constructor.cid
  })
  if (hasSameChildren) {
    // rehydrate children
    vm.$children.forEach(function (c, i) {
      restoreState(c, state.children[i])
    })
  }
  if (isRoot) {
    Vue.config.async = oldAsyncConfig
  }
}

function format (id) {
  return id.match(/[^\/]+\.vue$/)[0]
}

},{}],"/usr/lib/node_modules/vue/dist/vue.common.js":[function(require,module,exports){
(function (process,global){
/*!
 * Vue.js v1.0.18
 * (c) 2016 Evan You
 * Released under the MIT License.
 */
'use strict';

function set(obj, key, val) {
  if (hasOwn(obj, key)) {
    obj[key] = val;
    return;
  }
  if (obj._isVue) {
    set(obj._data, key, val);
    return;
  }
  var ob = obj.__ob__;
  if (!ob) {
    obj[key] = val;
    return;
  }
  ob.convert(key, val);
  ob.dep.notify();
  if (ob.vms) {
    var i = ob.vms.length;
    while (i--) {
      var vm = ob.vms[i];
      vm._proxy(key);
      vm._digest();
    }
  }
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 *
 * @param {Object} obj
 * @param {String} key
 */

function del(obj, key) {
  if (!hasOwn(obj, key)) {
    return;
  }
  delete obj[key];
  var ob = obj.__ob__;
  if (!ob) {
    return;
  }
  ob.dep.notify();
  if (ob.vms) {
    var i = ob.vms.length;
    while (i--) {
      var vm = ob.vms[i];
      vm._unproxy(key);
      vm._digest();
    }
  }
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * Check whether the object has the property.
 *
 * @param {Object} obj
 * @param {String} key
 * @return {Boolean}
 */

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Check if an expression is a literal value.
 *
 * @param {String} exp
 * @return {Boolean}
 */

var literalValueRE = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;

function isLiteral(exp) {
  return literalValueRE.test(exp);
}

/**
 * Check if a string starts with $ or _
 *
 * @param {String} str
 * @return {Boolean}
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Guard text output, make sure undefined outputs
 * empty string
 *
 * @param {*} value
 * @return {String}
 */

function _toString(value) {
  return value == null ? '' : value.toString();
}

/**
 * Check and convert possible numeric strings to numbers
 * before setting back to data
 *
 * @param {*} value
 * @return {*|Number}
 */

function toNumber(value) {
  if (typeof value !== 'string') {
    return value;
  } else {
    var parsed = Number(value);
    return isNaN(parsed) ? value : parsed;
  }
}

/**
 * Convert string boolean literals into real booleans.
 *
 * @param {*} value
 * @return {*|Boolean}
 */

function toBoolean(value) {
  return value === 'true' ? true : value === 'false' ? false : value;
}

/**
 * Strip quotes from a string
 *
 * @param {String} str
 * @return {String | false}
 */

function stripQuotes(str) {
  var a = str.charCodeAt(0);
  var b = str.charCodeAt(str.length - 1);
  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
}

/**
 * Camelize a hyphen-delmited string.
 *
 * @param {String} str
 * @return {String}
 */

var camelizeRE = /-(\w)/g;

function camelize(str) {
  return str.replace(camelizeRE, toUpper);
}

function toUpper(_, c) {
  return c ? c.toUpperCase() : '';
}

/**
 * Hyphenate a camelCase string.
 *
 * @param {String} str
 * @return {String}
 */

var hyphenateRE = /([a-z\d])([A-Z])/g;

function hyphenate(str) {
  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
}

/**
 * Converts hyphen/underscore/slash delimitered names into
 * camelized classNames.
 *
 * e.g. my-component => MyComponent
 *      some_else    => SomeElse
 *      some/comp    => SomeComp
 *
 * @param {String} str
 * @return {String}
 */

var classifyRE = /(?:^|[-_\/])(\w)/g;

function classify(str) {
  return str.replace(classifyRE, toUpper);
}

/**
 * Simple bind, faster than native
 *
 * @param {Function} fn
 * @param {Object} ctx
 * @return {Function}
 */

function bind(fn, ctx) {
  return function (a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  };
}

/**
 * Convert an Array-like object to a real Array.
 *
 * @param {Array-like} list
 * @param {Number} [start] - start index
 * @return {Array}
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 *
 * @param {Object} to
 * @param {Object} from
 */

function extend(to, from) {
  var keys = Object.keys(from);
  var i = keys.length;
  while (i--) {
    to[keys[i]] = from[keys[i]];
  }
  return to;
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 *
 * @param {*} obj
 * @return {Boolean}
 */

function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 *
 * @param {*} obj
 * @return {Boolean}
 */

var toString = Object.prototype.toString;
var OBJECT_STRING = '[object Object]';

function isPlainObject(obj) {
  return toString.call(obj) === OBJECT_STRING;
}

/**
 * Array type check.
 *
 * @param {*} obj
 * @return {Boolean}
 */

var isArray = Array.isArray;

/**
 * Define a property.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {*} val
 * @param {Boolean} [enumerable]
 */

function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Debounce a function so it only gets called after the
 * input stops arriving after the given wait period.
 *
 * @param {Function} func
 * @param {Number} wait
 * @return {Function} - the debounced function
 */

function _debounce(func, wait) {
  var timeout, args, context, timestamp, result;
  var later = function later() {
    var last = Date.now() - timestamp;
    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    }
  };
  return function () {
    context = this;
    args = arguments;
    timestamp = Date.now();
    if (!timeout) {
      timeout = setTimeout(later, wait);
    }
    return result;
  };
}

/**
 * Manual indexOf because it's slightly faster than
 * native.
 *
 * @param {Array} arr
 * @param {*} obj
 */

function indexOf(arr, obj) {
  var i = arr.length;
  while (i--) {
    if (arr[i] === obj) return i;
  }
  return -1;
}

/**
 * Make a cancellable version of an async callback.
 *
 * @param {Function} fn
 * @return {Function}
 */

function cancellable(fn) {
  var cb = function cb() {
    if (!cb.cancelled) {
      return fn.apply(this, arguments);
    }
  };
  cb.cancel = function () {
    cb.cancelled = true;
  };
  return cb;
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 *
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 */

function looseEqual(a, b) {
  /* eslint-disable eqeqeq */
  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
  /* eslint-enable eqeqeq */
}

var hasProto = ('__proto__' in {});

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

// UA sniffing for working around browser-specific quirks
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;

var transitionProp = undefined;
var transitionEndEvent = undefined;
var animationProp = undefined;
var animationEndEvent = undefined;

// Transition property/event sniffing
if (inBrowser && !isIE9) {
  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
}

/**
 * Defer a task to execute it asynchronously. Ideally this
 * should be executed as a microtask, so we leverage
 * MutationObserver if it's available, and fallback to
 * setTimeout(0).
 *
 * @param {Function} cb
 * @param {Object} ctx
 */

var nextTick = (function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;
  function nextTickHandler() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks = [];
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  /* istanbul ignore if */
  if (typeof MutationObserver !== 'undefined') {
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(counter);
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = counter;
    };
  } else {
    // webpack attempts to inject a shim for setImmediate
    // if it is used as a global, so we have to work around that to
    // avoid bundling unnecessary code.
    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};
    timerFunc = context.setImmediate || setTimeout;
  }
  return function (cb, ctx) {
    var func = ctx ? function () {
      cb.call(ctx);
    } : cb;
    callbacks.push(func);
    if (pending) return;
    pending = true;
    timerFunc(nextTickHandler, 0);
  };
})();

function Cache(limit) {
  this.size = 0;
  this.limit = limit;
  this.head = this.tail = undefined;
  this._keymap = Object.create(null);
}

var p = Cache.prototype;

/**
 * Put <value> into the cache associated with <key>.
 * Returns the entry which was removed to make room for
 * the new entry. Otherwise undefined is returned.
 * (i.e. if there was enough room already).
 *
 * @param {String} key
 * @param {*} value
 * @return {Entry|undefined}
 */

p.put = function (key, value) {
  var removed;
  if (this.size === this.limit) {
    removed = this.shift();
  }

  var entry = this.get(key, true);
  if (!entry) {
    entry = {
      key: key
    };
    this._keymap[key] = entry;
    if (this.tail) {
      this.tail.newer = entry;
      entry.older = this.tail;
    } else {
      this.head = entry;
    }
    this.tail = entry;
    this.size++;
  }
  entry.value = value;

  return removed;
};

/**
 * Purge the least recently used (oldest) entry from the
 * cache. Returns the removed entry or undefined if the
 * cache was empty.
 */

p.shift = function () {
  var entry = this.head;
  if (entry) {
    this.head = this.head.newer;
    this.head.older = undefined;
    entry.newer = entry.older = undefined;
    this._keymap[entry.key] = undefined;
    this.size--;
  }
  return entry;
};

/**
 * Get and register recent use of <key>. Returns the value
 * associated with <key> or undefined if not in cache.
 *
 * @param {String} key
 * @param {Boolean} returnEntry
 * @return {Entry|*}
 */

p.get = function (key, returnEntry) {
  var entry = this._keymap[key];
  if (entry === undefined) return;
  if (entry === this.tail) {
    return returnEntry ? entry : entry.value;
  }
  // HEAD--------------TAIL
  //   <.older   .newer>
  //  <--- add direction --
  //   A  B  C  <D>  E
  if (entry.newer) {
    if (entry === this.head) {
      this.head = entry.newer;
    }
    entry.newer.older = entry.older; // C <-- E.
  }
  if (entry.older) {
    entry.older.newer = entry.newer; // C. --> E
  }
  entry.newer = undefined; // D --x
  entry.older = this.tail; // D. --> E
  if (this.tail) {
    this.tail.newer = entry; // E. <-- D
  }
  this.tail = entry;
  return returnEntry ? entry : entry.value;
};

var cache$1 = new Cache(1000);
var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
var reservedArgRE = /^in$|^-?\d+/;

/**
 * Parser state
 */

var str;
var dir;
var c;
var prev;
var i;
var l;
var lastFilterIndex;
var inSingle;
var inDouble;
var curly;
var square;
var paren;
/**
 * Push a filter to the current directive object
 */

function pushFilter() {
  var exp = str.slice(lastFilterIndex, i).trim();
  var filter;
  if (exp) {
    filter = {};
    var tokens = exp.match(filterTokenRE);
    filter.name = tokens[0];
    if (tokens.length > 1) {
      filter.args = tokens.slice(1).map(processFilterArg);
    }
  }
  if (filter) {
    (dir.filters = dir.filters || []).push(filter);
  }
  lastFilterIndex = i + 1;
}

/**
 * Check if an argument is dynamic and strip quotes.
 *
 * @param {String} arg
 * @return {Object}
 */

function processFilterArg(arg) {
  if (reservedArgRE.test(arg)) {
    return {
      value: toNumber(arg),
      dynamic: false
    };
  } else {
    var stripped = stripQuotes(arg);
    var dynamic = stripped === arg;
    return {
      value: dynamic ? arg : stripped,
      dynamic: dynamic
    };
  }
}

/**
 * Parse a directive value and extract the expression
 * and its filters into a descriptor.
 *
 * Example:
 *
 * "a + 1 | uppercase" will yield:
 * {
 *   expression: 'a + 1',
 *   filters: [
 *     { name: 'uppercase', args: null }
 *   ]
 * }
 *
 * @param {String} str
 * @return {Object}
 */

function parseDirective(s) {
  var hit = cache$1.get(s);
  if (hit) {
    return hit;
  }

  // reset parser state
  str = s;
  inSingle = inDouble = false;
  curly = square = paren = 0;
  lastFilterIndex = 0;
  dir = {};

  for (i = 0, l = str.length; i < l; i++) {
    prev = c;
    c = str.charCodeAt(i);
    if (inSingle) {
      // check single quote
      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;
    } else if (inDouble) {
      // check double quote
      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;
    } else if (c === 0x7C && // pipe
    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
      if (dir.expression == null) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        dir.expression = str.slice(0, i).trim();
      } else {
        // already has filter
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;break; // "
        case 0x27:
          inSingle = true;break; // '
        case 0x28:
          paren++;break; // (
        case 0x29:
          paren--;break; // )
        case 0x5B:
          square++;break; // [
        case 0x5D:
          square--;break; // ]
        case 0x7B:
          curly++;break; // {
        case 0x7D:
          curly--;break; // }
      }
    }
  }

  if (dir.expression == null) {
    dir.expression = str.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  cache$1.put(s, dir);
  return dir;
}

var directive = Object.freeze({
  parseDirective: parseDirective
});

var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
var cache = undefined;
var tagRE = undefined;
var htmlRE = undefined;
/**
 * Escape a string so it can be used in a RegExp
 * constructor.
 *
 * @param {String} str
 */

function escapeRegex(str) {
  return str.replace(regexEscapeRE, '\\$&');
}

function compileRegex() {
  var open = escapeRegex(config.delimiters[0]);
  var close = escapeRegex(config.delimiters[1]);
  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
  tagRE = new RegExp(unsafeOpen + '(.+?)' + unsafeClose + '|' + open + '(.+?)' + close, 'g');
  htmlRE = new RegExp('^' + unsafeOpen + '.*' + unsafeClose + '$');
  // reset cache
  cache = new Cache(1000);
}

/**
 * Parse a template text string into an array of tokens.
 *
 * @param {String} text
 * @return {Array<Object> | null}
 *               - {String} type
 *               - {String} value
 *               - {Boolean} [html]
 *               - {Boolean} [oneTime]
 */

function parseText(text) {
  if (!cache) {
    compileRegex();
  }
  var hit = cache.get(text);
  if (hit) {
    return hit;
  }
  text = text.replace(/\n/g, '');
  if (!tagRE.test(text)) {
    return null;
  }
  var tokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, html, value, first, oneTime;
  /* eslint-disable no-cond-assign */
  while (match = tagRE.exec(text)) {
    /* eslint-enable no-cond-assign */
    index = match.index;
    // push text token
    if (index > lastIndex) {
      tokens.push({
        value: text.slice(lastIndex, index)
      });
    }
    // tag token
    html = htmlRE.test(match[0]);
    value = html ? match[1] : match[2];
    first = value.charCodeAt(0);
    oneTime = first === 42; // *
    value = oneTime ? value.slice(1) : value;
    tokens.push({
      tag: true,
      value: value.trim(),
      html: html,
      oneTime: oneTime
    });
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    tokens.push({
      value: text.slice(lastIndex)
    });
  }
  cache.put(text, tokens);
  return tokens;
}

/**
 * Format a list of tokens into an expression.
 * e.g. tokens parsed from 'a {{b}} c' can be serialized
 * into one single expression as '"a " + b + " c"'.
 *
 * @param {Array} tokens
 * @param {Vue} [vm]
 * @return {String}
 */

function tokensToExp(tokens, vm) {
  if (tokens.length > 1) {
    return tokens.map(function (token) {
      return formatToken(token, vm);
    }).join('+');
  } else {
    return formatToken(tokens[0], vm, true);
  }
}

/**
 * Format a single token.
 *
 * @param {Object} token
 * @param {Vue} [vm]
 * @param {Boolean} [single]
 * @return {String}
 */

function formatToken(token, vm, single) {
  return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"';
}

/**
 * For an attribute with multiple interpolation tags,
 * e.g. attr="some-{{thing | filter}}", in order to combine
 * the whole thing into a single watchable expression, we
 * have to inline those filters. This function does exactly
 * that. This is a bit hacky but it avoids heavy changes
 * to directive parser and watcher mechanism.
 *
 * @param {String} exp
 * @param {Boolean} single
 * @return {String}
 */

var filterRE = /[^|]\|[^|]/;
function inlineFilters(exp, single) {
  if (!filterRE.test(exp)) {
    return single ? exp : '(' + exp + ')';
  } else {
    var dir = parseDirective(exp);
    if (!dir.filters) {
      return '(' + exp + ')';
    } else {
      return 'this._applyFilters(' + dir.expression + // value
      ',null,' + // oldValue (null for read)
      JSON.stringify(dir.filters) + // filter descriptors
      ',false)'; // write?
    }
  }
}

var text = Object.freeze({
  compileRegex: compileRegex,
  parseText: parseText,
  tokensToExp: tokensToExp
});

var delimiters = ['{{', '}}'];
var unsafeDelimiters = ['{{{', '}}}'];

var config = Object.defineProperties({

  /**
   * Whether to print debug messages.
   * Also enables stack trace for warnings.
   *
   * @type {Boolean}
   */

  debug: false,

  /**
   * Whether to suppress warnings.
   *
   * @type {Boolean}
   */

  silent: false,

  /**
   * Whether to use async rendering.
   */

  async: true,

  /**
   * Whether to warn against errors caught when evaluating
   * expressions.
   */

  warnExpressionErrors: true,

  /**
   * Whether to allow devtools inspection.
   * Disabled by default in production builds.
   */

  devtools: process.env.NODE_ENV !== 'production',

  /**
   * Internal flag to indicate the delimiters have been
   * changed.
   *
   * @type {Boolean}
   */

  _delimitersChanged: true,

  /**
   * List of asset types that a component can own.
   *
   * @type {Array}
   */

  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],

  /**
   * prop binding modes
   */

  _propBindingModes: {
    ONE_WAY: 0,
    TWO_WAY: 1,
    ONE_TIME: 2
  },

  /**
   * Max circular updates allowed in a batcher flush cycle.
   */

  _maxUpdateCount: 100

}, {
  delimiters: { /**
                 * Interpolation delimiters. Changing these would trigger
                 * the text parser to re-compile the regular expressions.
                 *
                 * @type {Array<String>}
                 */

    get: function get() {
      return delimiters;
    },
    set: function set(val) {
      delimiters = val;
      compileRegex();
    },
    configurable: true,
    enumerable: true
  },
  unsafeDelimiters: {
    get: function get() {
      return unsafeDelimiters;
    },
    set: function set(val) {
      unsafeDelimiters = val;
      compileRegex();
    },
    configurable: true,
    enumerable: true
  }
});

var warn = undefined;

if (process.env.NODE_ENV !== 'production') {
  (function () {
    var hasConsole = typeof console !== 'undefined';
    warn = function (msg, e) {
      if (hasConsole && (!config.silent || config.debug)) {
        console.warn('[Vue warn]: ' + msg);
        /* istanbul ignore if */
        if (config.debug) {
          if (e) {
            throw e;
          } else {
            console.warn(new Error('Warning Stack Trace').stack);
          }
        }
      }
    };
  })();
}

/**
 * Append with transition.
 *
 * @param {Element} el
 * @param {Element} target
 * @param {Vue} vm
 * @param {Function} [cb]
 */

function appendWithTransition(el, target, vm, cb) {
  applyTransition(el, 1, function () {
    target.appendChild(el);
  }, vm, cb);
}

/**
 * InsertBefore with transition.
 *
 * @param {Element} el
 * @param {Element} target
 * @param {Vue} vm
 * @param {Function} [cb]
 */

function beforeWithTransition(el, target, vm, cb) {
  applyTransition(el, 1, function () {
    before(el, target);
  }, vm, cb);
}

/**
 * Remove with transition.
 *
 * @param {Element} el
 * @param {Vue} vm
 * @param {Function} [cb]
 */

function removeWithTransition(el, vm, cb) {
  applyTransition(el, -1, function () {
    remove(el);
  }, vm, cb);
}

/**
 * Apply transitions with an operation callback.
 *
 * @param {Element} el
 * @param {Number} direction
 *                  1: enter
 *                 -1: leave
 * @param {Function} op - the actual DOM operation
 * @param {Vue} vm
 * @param {Function} [cb]
 */

function applyTransition(el, direction, op, vm, cb) {
  var transition = el.__v_trans;
  if (!transition ||
  // skip if there are no js hooks and CSS transition is
  // not supported
  !transition.hooks && !transitionEndEvent ||
  // skip transitions for initial compile
  !vm._isCompiled ||
  // if the vm is being manipulated by a parent directive
  // during the parent's compilation phase, skip the
  // animation.
  vm.$parent && !vm.$parent._isCompiled) {
    op();
    if (cb) cb();
    return;
  }
  var action = direction > 0 ? 'enter' : 'leave';
  transition[action](op, cb);
}

var transition = Object.freeze({
  appendWithTransition: appendWithTransition,
  beforeWithTransition: beforeWithTransition,
  removeWithTransition: removeWithTransition,
  applyTransition: applyTransition
});

/**
 * Query an element selector if it's not an element already.
 *
 * @param {String|Element} el
 * @return {Element}
 */

function query(el) {
  if (typeof el === 'string') {
    var selector = el;
    el = document.querySelector(el);
    if (!el) {
      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);
    }
  }
  return el;
}

/**
 * Check if a node is in the document.
 * Note: document.documentElement.contains should work here
 * but always returns false for comment nodes in phantomjs,
 * making unit tests difficult. This is fixed by doing the
 * contains() check on the node's parentNode instead of
 * the node itself.
 *
 * @param {Node} node
 * @return {Boolean}
 */

function inDoc(node) {
  var doc = document.documentElement;
  var parent = node && node.parentNode;
  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
}

/**
 * Get and remove an attribute from a node.
 *
 * @param {Node} node
 * @param {String} _attr
 */

function getAttr(node, _attr) {
  var val = node.getAttribute(_attr);
  if (val !== null) {
    node.removeAttribute(_attr);
  }
  return val;
}

/**
 * Get an attribute with colon or v-bind: prefix.
 *
 * @param {Node} node
 * @param {String} name
 * @return {String|null}
 */

function getBindAttr(node, name) {
  var val = getAttr(node, ':' + name);
  if (val === null) {
    val = getAttr(node, 'v-bind:' + name);
  }
  return val;
}

/**
 * Check the presence of a bind attribute.
 *
 * @param {Node} node
 * @param {String} name
 * @return {Boolean}
 */

function hasBindAttr(node, name) {
  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
}

/**
 * Insert el before target
 *
 * @param {Element} el
 * @param {Element} target
 */

function before(el, target) {
  target.parentNode.insertBefore(el, target);
}

/**
 * Insert el after target
 *
 * @param {Element} el
 * @param {Element} target
 */

function after(el, target) {
  if (target.nextSibling) {
    before(el, target.nextSibling);
  } else {
    target.parentNode.appendChild(el);
  }
}

/**
 * Remove el from DOM
 *
 * @param {Element} el
 */

function remove(el) {
  el.parentNode.removeChild(el);
}

/**
 * Prepend el to target
 *
 * @param {Element} el
 * @param {Element} target
 */

function prepend(el, target) {
  if (target.firstChild) {
    before(el, target.firstChild);
  } else {
    target.appendChild(el);
  }
}

/**
 * Replace target with el
 *
 * @param {Element} target
 * @param {Element} el
 */

function replace(target, el) {
  var parent = target.parentNode;
  if (parent) {
    parent.replaceChild(el, target);
  }
}

/**
 * Add event listener shorthand.
 *
 * @param {Element} el
 * @param {String} event
 * @param {Function} cb
 * @param {Boolean} [useCapture]
 */

function on(el, event, cb, useCapture) {
  el.addEventListener(event, cb, useCapture);
}

/**
 * Remove event listener shorthand.
 *
 * @param {Element} el
 * @param {String} event
 * @param {Function} cb
 */

function off(el, event, cb) {
  el.removeEventListener(event, cb);
}

/**
 * In IE9, setAttribute('class') will result in empty class
 * if the element also has the :class attribute; However in
 * PhantomJS, setting `className` does not work on SVG elements...
 * So we have to do a conditional check here.
 *
 * @param {Element} el
 * @param {String} cls
 */

function setClass(el, cls) {
  /* istanbul ignore if */
  if (isIE9 && !/svg$/.test(el.namespaceURI)) {
    el.className = cls;
  } else {
    el.setAttribute('class', cls);
  }
}

/**
 * Add class with compatibility for IE & SVG
 *
 * @param {Element} el
 * @param {String} cls
 */

function addClass(el, cls) {
  if (el.classList) {
    el.classList.add(cls);
  } else {
    var cur = ' ' + (el.getAttribute('class') || '') + ' ';
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      setClass(el, (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for IE & SVG
 *
 * @param {Element} el
 * @param {String} cls
 */

function removeClass(el, cls) {
  if (el.classList) {
    el.classList.remove(cls);
  } else {
    var cur = ' ' + (el.getAttribute('class') || '') + ' ';
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    setClass(el, cur.trim());
  }
  if (!el.className) {
    el.removeAttribute('class');
  }
}

/**
 * Extract raw content inside an element into a temporary
 * container div
 *
 * @param {Element} el
 * @param {Boolean} asFragment
 * @return {Element|DocumentFragment}
 */

function extractContent(el, asFragment) {
  var child;
  var rawContent;
  /* istanbul ignore if */
  if (isTemplate(el) && isFragment(el.content)) {
    el = el.content;
  }
  if (el.hasChildNodes()) {
    trimNode(el);
    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
    /* eslint-disable no-cond-assign */
    while (child = el.firstChild) {
      /* eslint-enable no-cond-assign */
      rawContent.appendChild(child);
    }
  }
  return rawContent;
}

/**
 * Trim possible empty head/tail text and comment
 * nodes inside a parent.
 *
 * @param {Node} node
 */

function trimNode(node) {
  var child;
  /* eslint-disable no-sequences */
  while ((child = node.firstChild, isTrimmable(child))) {
    node.removeChild(child);
  }
  while ((child = node.lastChild, isTrimmable(child))) {
    node.removeChild(child);
  }
  /* eslint-enable no-sequences */
}

function isTrimmable(node) {
  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);
}

/**
 * Check if an element is a template tag.
 * Note if the template appears inside an SVG its tagName
 * will be in lowercase.
 *
 * @param {Element} el
 */

function isTemplate(el) {
  return el.tagName && el.tagName.toLowerCase() === 'template';
}

/**
 * Create an "anchor" for performing dom insertion/removals.
 * This is used in a number of scenarios:
 * - fragment instance
 * - v-html
 * - v-if
 * - v-for
 * - component
 *
 * @param {String} content
 * @param {Boolean} persist - IE trashes empty textNodes on
 *                            cloneNode(true), so in certain
 *                            cases the anchor needs to be
 *                            non-empty to be persisted in
 *                            templates.
 * @return {Comment|Text}
 */

function createAnchor(content, persist) {
  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
  anchor.__v_anchor = true;
  return anchor;
}

/**
 * Find a component ref attribute that starts with $.
 *
 * @param {Element} node
 * @return {String|undefined}
 */

var refRE = /^v-ref:/;

function findRef(node) {
  if (node.hasAttributes()) {
    var attrs = node.attributes;
    for (var i = 0, l = attrs.length; i < l; i++) {
      var name = attrs[i].name;
      if (refRE.test(name)) {
        return camelize(name.replace(refRE, ''));
      }
    }
  }
}

/**
 * Map a function to a range of nodes .
 *
 * @param {Node} node
 * @param {Node} end
 * @param {Function} op
 */

function mapNodeRange(node, end, op) {
  var next;
  while (node !== end) {
    next = node.nextSibling;
    op(node);
    node = next;
  }
  op(end);
}

/**
 * Remove a range of nodes with transition, store
 * the nodes in a fragment with correct ordering,
 * and call callback when done.
 *
 * @param {Node} start
 * @param {Node} end
 * @param {Vue} vm
 * @param {DocumentFragment} frag
 * @param {Function} cb
 */

function removeNodeRange(start, end, vm, frag, cb) {
  var done = false;
  var removed = 0;
  var nodes = [];
  mapNodeRange(start, end, function (node) {
    if (node === end) done = true;
    nodes.push(node);
    removeWithTransition(node, vm, onRemoved);
  });
  function onRemoved() {
    removed++;
    if (done && removed >= nodes.length) {
      for (var i = 0; i < nodes.length; i++) {
        frag.appendChild(nodes[i]);
      }
      cb && cb();
    }
  }
}

/**
 * Check if a node is a DocumentFragment.
 *
 * @param {Node} node
 * @return {Boolean}
 */

function isFragment(node) {
  return node && node.nodeType === 11;
}

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 *
 * @param {Element} el
 * @return {String}
 */

function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 *
 * @constructor
 */
function Dep() {
  this.id = uid$1++;
  this.subs = [];
}

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;

/**
 * Add a directive subscriber.
 *
 * @param {Directive} sub
 */

Dep.prototype.addSub = function (sub) {
  this.subs.push(sub);
};

/**
 * Remove a directive subscriber.
 *
 * @param {Directive} sub
 */

Dep.prototype.removeSub = function (sub) {
  this.subs.$remove(sub);
};

/**
 * Add self as a dependency to the target watcher.
 */

Dep.prototype.depend = function () {
  Dep.target.addDep(this);
};

/**
 * Notify all subscribers of a new value.
 */

Dep.prototype.notify = function () {
  // stablize the subscriber list first
  var subs = toArray(this.subs);
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto)

/**
 * Intercept mutating methods and emit events
 */

;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    var i = arguments.length;
    var args = new Array(i);
    while (i--) {
      args[i] = arguments[i];
    }
    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
        inserted = args;
        break;
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) ob.observeArray(inserted);
    // notify change
    ob.dep.notify();
    return result;
  });
});

/**
 * Swap the element at the given index with a new value
 * and emits corresponding event.
 *
 * @param {Number} index
 * @param {*} val
 * @return {*} - replaced element
 */

def(arrayProto, '$set', function $set(index, val) {
  if (index >= this.length) {
    this.length = Number(index) + 1;
  }
  return this.splice(index, 1, val)[0];
});

/**
 * Convenience method to remove the element at given index.
 *
 * @param {Number} index
 * @param {*} val
 */

def(arrayProto, '$remove', function $remove(item) {
  /* istanbul ignore if */
  if (!this.length) return;
  var index = indexOf(this, item);
  if (index > -1) {
    return this.splice(index, 1);
  }
});

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 *
 * @param {Array|Object} value
 * @constructor
 */

function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  def(value, '__ob__', this);
  if (isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
}

// Instance methods

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 *
 * @param {Object} obj
 */

Observer.prototype.walk = function (obj) {
  var keys = Object.keys(obj);
  for (var i = 0, l = keys.length; i < l; i++) {
    this.convert(keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 *
 * @param {Array} items
 */

Observer.prototype.observeArray = function (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

/**
 * Convert a property into getter/setter so we can emit
 * the events when the property is accessed/changed.
 *
 * @param {String} key
 * @param {*} val
 */

Observer.prototype.convert = function (key, val) {
  defineReactive(this.value, key, val);
};

/**
 * Add an owner vm, so that when $set/$delete mutations
 * happen we can notify owner vms to proxy the keys and
 * digest the watchers. This is only called when the object
 * is observed as an instance's root $data.
 *
 * @param {Vue} vm
 */

Observer.prototype.addVm = function (vm) {
  (this.vms || (this.vms = [])).push(vm);
};

/**
 * Remove an owner vm. This is called when the object is
 * swapped out as an instance's $data object.
 *
 * @param {Vue} vm
 */

Observer.prototype.removeVm = function (vm) {
  this.vms.$remove(vm);
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 *
 * @param {Object|Array} target
 * @param {Object} proto
 */

function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 *
 * @param {Object|Array} target
 * @param {Object} proto
 */

function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 *
 * @param {*} value
 * @param {Vue} [vm]
 * @return {Observer|undefined}
 * @static
 */

function observe(value, vm) {
  if (!value || typeof value !== 'object') {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if ((isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (ob && vm) {
    ob.addVm(vm);
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {*} val
 * @param {Boolean} doNotObserve
 */

function defineReactive(obj, key, val, doNotObserve) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  // if doNotObserve is true, only use the child value observer
  // if it already exists, and do not attempt to create it.
  // this allows freezing a large object from the root and
  // avoid unnecessary observation inside v-for fragments.
  var childOb = doNotObserve ? isObject(val) && val.__ob__ : observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (isArray(value)) {
          for (var e, i = 0, l = value.length; i < l; i++) {
            e = value[i];
            e && e.__ob__ && e.__ob__.dep.depend();
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      if (newVal === value) {
        return;
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = doNotObserve ? isObject(newVal) && newVal.__ob__ : observe(newVal);
      dep.notify();
    }
  });
}

var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;
var reservedTagRE = /^(slot|partial|component)$/i;

var isUnknownElement = undefined;
if (process.env.NODE_ENV !== 'production') {
  isUnknownElement = function (el, tag) {
    if (tag.indexOf('-') > -1) {
      // http://stackoverflow.com/a/28210364/1070244
      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
    } else {
      return (/HTMLUnknownElement/.test(el.toString()) &&
        // Chrome returns unknown for several HTML5 elements.
        // https://code.google.com/p/chromium/issues/detail?id=540526
        !/^(data|time|rtc|rb)$/.test(tag)
      );
    }
  };
}

/**
 * Check if an element is a component, if yes return its
 * component id.
 *
 * @param {Element} el
 * @param {Object} options
 * @return {Object|undefined}
 */

function checkComponentAttr(el, options) {
  var tag = el.tagName.toLowerCase();
  var hasAttrs = el.hasAttributes();
  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
    if (resolveAsset(options, 'components', tag)) {
      return { id: tag };
    } else {
      var is = hasAttrs && getIsBinding(el);
      if (is) {
        return is;
      } else if (process.env.NODE_ENV !== 'production') {
        var expectedTag = options._componentNameMap && options._componentNameMap[tag];
        if (expectedTag) {
          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');
        } else if (isUnknownElement(el, tag)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.');
        }
      }
    }
  } else if (hasAttrs) {
    return getIsBinding(el);
  }
}

/**
 * Get "is" binding from an element.
 *
 * @param {Element} el
 * @return {Object|undefined}
 */

function getIsBinding(el) {
  // dynamic syntax
  var exp = getAttr(el, 'is');
  if (exp != null) {
    return { id: exp };
  } else {
    exp = getBindAttr(el, 'is');
    if (exp != null) {
      return { id: exp, dynamic: true };
    }
  }
}

/**
 * Set a prop's initial value on a vm and its data object.
 *
 * @param {Vue} vm
 * @param {Object} prop
 * @param {*} value
 */

function initProp(vm, prop, value) {
  var key = prop.path;
  value = coerceProp(prop, value);
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop.options);
  }
  if (assertProp(prop, value)) {
    defineReactive(vm, key, value, true /* doNotObserve */);
  }
}

/**
 * Get the default value of a prop.
 *
 * @param {Vue} vm
 * @param {Object} options
 * @return {*}
 */

function getPropDefaultValue(vm, options) {
  // no default, return undefined
  if (!hasOwn(options, 'default')) {
    // absent boolean value defaults to false
    return options.type === Boolean ? false : undefined;
  }
  var def = options['default'];
  // warn against non-factory defaults for Object & Array
  if (isObject(def)) {
    process.env.NODE_ENV !== 'production' && warn('Object/Array as default prop values will be shared ' + 'across multiple instances. Use a factory function ' + 'to return the default value instead.');
  }
  // call factory function for non-Function types
  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 *
 * @param {Object} prop
 * @param {*} value
 */

function assertProp(prop, value) {
  if (!prop.options.required && ( // non-required
  prop.raw === null || // abscent
  value == null) // null or undefined
  ) {
      return true;
    }
  var options = prop.options;
  var type = options.type;
  var valid = true;
  var expectedType;
  if (type) {
    if (type === String) {
      expectedType = 'string';
      valid = typeof value === expectedType;
    } else if (type === Number) {
      expectedType = 'number';
      valid = typeof value === 'number';
    } else if (type === Boolean) {
      expectedType = 'boolean';
      valid = typeof value === 'boolean';
    } else if (type === Function) {
      expectedType = 'function';
      valid = typeof value === 'function';
    } else if (type === Object) {
      expectedType = 'object';
      valid = isPlainObject(value);
    } else if (type === Array) {
      expectedType = 'array';
      valid = isArray(value);
    } else {
      valid = value instanceof type;
    }
  }
  if (!valid) {
    process.env.NODE_ENV !== 'production' && warn('Invalid prop: type check failed for ' + prop.path + '="' + prop.raw + '".' + ' Expected ' + formatType(expectedType) + ', got ' + formatValue(value) + '.');
    return false;
  }
  var validator = options.validator;
  if (validator) {
    if (!validator(value)) {
      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for ' + prop.path + '="' + prop.raw + '"');
      return false;
    }
  }
  return true;
}

/**
 * Force parsing value with coerce option.
 *
 * @param {*} value
 * @param {Object} options
 * @return {*}
 */

function coerceProp(prop, value) {
  var coerce = prop.options.coerce;
  if (!coerce) {
    return value;
  }
  // coerce is a function
  return coerce(value);
}

function formatType(val) {
  return val ? val.charAt(0).toUpperCase() + val.slice(1) : 'custom type';
}

function formatValue(val) {
  return Object.prototype.toString.call(val).slice(8, -1);
}

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 *
 * All strategy functions follow the same signature:
 *
 * @param {*} parentVal
 * @param {*} childVal
 * @param {Vue} [vm]
 */

var strats = config.optionMergeStrategies = Object.create(null);

/**
 * Helper that recursively merges two data objects together.
 */

function mergeData(to, from) {
  var key, toVal, fromVal;
  for (key in from) {
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isObject(toVal) && isObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(childVal.call(this), parentVal.call(this));
    };
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
};

/**
 * El
 */

strats.el = function (parentVal, childVal, vm) {
  if (!vm && childVal && typeof childVal !== 'function') {
    process.env.NODE_ENV !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');
    return;
  }
  var ret = childVal || parentVal;
  // invoke the element factory if this is instance merge
  return vm && typeof ret === 'function' ? ret.call(vm) : ret;
};

/**
 * Hooks and param attributes are merged as arrays.
 */

strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
};

/**
 * 0.11 deprecation warning
 */

strats.paramAttributes = function () {
  /* istanbul ignore next */
  process.env.NODE_ENV !== 'production' && warn('"paramAttributes" option has been deprecated in 0.12. ' + 'Use "props" instead.');
};

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal) {
  var res = Object.create(parentVal);
  return childVal ? extend(res, guardArrayAssets(childVal)) : res;
}

config._assetTypes.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Events & Watchers.
 *
 * Events & watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = strats.events = function (parentVal, childVal) {
  if (!childVal) return parentVal;
  if (!parentVal) return childVal;
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent ? parent.concat(child) : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */

strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
  if (!childVal) return parentVal;
  if (!parentVal) return childVal;
  var ret = Object.create(null);
  extend(ret, parentVal);
  extend(ret, childVal);
  return ret;
};

/**
 * Default strategy.
 */

var defaultStrat = function defaultStrat(parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Make sure component options get converted to actual
 * constructors.
 *
 * @param {Object} options
 */

function guardComponents(options) {
  if (options.components) {
    var components = options.components = guardArrayAssets(options.components);
    var ids = Object.keys(components);
    var def;
    if (process.env.NODE_ENV !== 'production') {
      var map = options._componentNameMap = {};
    }
    for (var i = 0, l = ids.length; i < l; i++) {
      var key = ids[i];
      if (commonTagRE.test(key) || reservedTagRE.test(key)) {
        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
        continue;
      }
      // record a all lowercase <-> kebab-case mapping for
      // possible custom element case error warning
      if (process.env.NODE_ENV !== 'production') {
        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);
      }
      def = components[key];
      if (isPlainObject(def)) {
        components[key] = Vue.extend(def);
      }
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 *
 * @param {Object} options
 */

function guardProps(options) {
  var props = options.props;
  var i, val;
  if (isArray(props)) {
    options.props = {};
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        options.props[val] = null;
      } else if (val.name) {
        options.props[val.name] = val;
      }
    }
  } else if (isPlainObject(props)) {
    var keys = Object.keys(props);
    i = keys.length;
    while (i--) {
      val = props[keys[i]];
      if (typeof val === 'function') {
        props[keys[i]] = { type: val };
      }
    }
  }
}

/**
 * Guard an Array-format assets option and converted it
 * into the key-value Object format.
 *
 * @param {Object|Array} assets
 * @return {Object}
 */

function guardArrayAssets(assets) {
  if (isArray(assets)) {
    var res = {};
    var i = assets.length;
    var asset;
    while (i--) {
      asset = assets[i];
      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
      if (!id) {
        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
      } else {
        res[id] = asset;
      }
    }
    return res;
  }
  return assets;
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 *
 * @param {Object} parent
 * @param {Object} child
 * @param {Vue} [vm] - if vm is present, indicates this is
 *                     an instantiation merge.
 */

function mergeOptions(parent, child, vm) {
  guardComponents(child);
  guardProps(child);
  var options = {};
  var key;
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 *
 * @param {Object} options
 * @param {String} type
 * @param {String} id
 * @return {Object|Function}
 */

function resolveAsset(options, type, id) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  var camelizedId;
  return assets[id] ||
  // camelCase ID
  assets[camelizedId = camelize(id)] ||
  // Pascal Case ID
  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
}

/**
 * Assert asset exists
 */

function assertAsset(val, type, id) {
  if (!val) {
    process.env.NODE_ENV !== 'production' && warn('Failed to resolve ' + type + ': ' + id);
  }
}



var util = Object.freeze({
	defineReactive: defineReactive,
	set: set,
	del: del,
	hasOwn: hasOwn,
	isLiteral: isLiteral,
	isReserved: isReserved,
	_toString: _toString,
	toNumber: toNumber,
	toBoolean: toBoolean,
	stripQuotes: stripQuotes,
	camelize: camelize,
	hyphenate: hyphenate,
	classify: classify,
	bind: bind,
	toArray: toArray,
	extend: extend,
	isObject: isObject,
	isPlainObject: isPlainObject,
	def: def,
	debounce: _debounce,
	indexOf: indexOf,
	cancellable: cancellable,
	looseEqual: looseEqual,
	isArray: isArray,
	hasProto: hasProto,
	inBrowser: inBrowser,
	devtools: devtools,
	isIE9: isIE9,
	isAndroid: isAndroid,
	get transitionProp () { return transitionProp; },
	get transitionEndEvent () { return transitionEndEvent; },
	get animationProp () { return animationProp; },
	get animationEndEvent () { return animationEndEvent; },
	nextTick: nextTick,
	query: query,
	inDoc: inDoc,
	getAttr: getAttr,
	getBindAttr: getBindAttr,
	hasBindAttr: hasBindAttr,
	before: before,
	after: after,
	remove: remove,
	prepend: prepend,
	replace: replace,
	on: on,
	off: off,
	setClass: setClass,
	addClass: addClass,
	removeClass: removeClass,
	extractContent: extractContent,
	trimNode: trimNode,
	isTemplate: isTemplate,
	createAnchor: createAnchor,
	findRef: findRef,
	mapNodeRange: mapNodeRange,
	removeNodeRange: removeNodeRange,
	isFragment: isFragment,
	getOuterHTML: getOuterHTML,
	mergeOptions: mergeOptions,
	resolveAsset: resolveAsset,
	assertAsset: assertAsset,
	checkComponentAttr: checkComponentAttr,
	initProp: initProp,
	assertProp: assertProp,
	coerceProp: coerceProp,
	commonTagRE: commonTagRE,
	reservedTagRE: reservedTagRE,
	get warn () { return warn; }
});

var uid = 0;

function initMixin (Vue) {
  /**
   * The main init sequence. This is called for every
   * instance, including ones that are created from extended
   * constructors.
   *
   * @param {Object} options - this options object should be
   *                           the result of merging class
   *                           options and the options passed
   *                           in to the constructor.
   */

  Vue.prototype._init = function (options) {
    options = options || {};

    this.$el = null;
    this.$parent = options.parent;
    this.$root = this.$parent ? this.$parent.$root : this;
    this.$children = [];
    this.$refs = {}; // child vm references
    this.$els = {}; // element references
    this._watchers = []; // all watchers as an array
    this._directives = []; // all directives

    // a uid
    this._uid = uid++;

    // a flag to avoid this being observed
    this._isVue = true;

    // events bookkeeping
    this._events = {}; // registered callbacks
    this._eventsCount = {}; // for $broadcast optimization

    // fragment instance properties
    this._isFragment = false;
    this._fragment = // @type {DocumentFragment}
    this._fragmentStart = // @type {Text|Comment}
    this._fragmentEnd = null; // @type {Text|Comment}

    // lifecycle state
    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;
    this._unlinkFn = null;

    // context:
    // if this is a transcluded component, context
    // will be the common parent vm of this instance
    // and its host.
    this._context = options._context || this.$parent;

    // scope:
    // if this is inside an inline v-for, the scope
    // will be the intermediate scope created for this
    // repeat fragment. this is used for linking props
    // and container directives.
    this._scope = options._scope;

    // fragment:
    // if this instance is compiled inside a Fragment, it
    // needs to reigster itself as a child of that fragment
    // for attach/detach to work properly.
    this._frag = options._frag;
    if (this._frag) {
      this._frag.children.push(this);
    }

    // push self into parent / transclusion host
    if (this.$parent) {
      this.$parent.$children.push(this);
    }

    // merge options.
    options = this.$options = mergeOptions(this.constructor.options, options, this);

    // set ref
    this._updateRef();

    // initialize data as empty object.
    // it will be filled up in _initScope().
    this._data = {};

    // save raw constructor data before merge
    // so that we know which properties are provided at
    // instantiation.
    this._runtimeData = options.data;

    // call init hook
    this._callHook('init');

    // initialize data observation and scope inheritance.
    this._initState();

    // setup event system and option events.
    this._initEvents();

    // call created hook
    this._callHook('created');

    // if `el` option is passed, start compilation.
    if (options.el) {
      this.$mount(options.el);
    }
  };
}

var pathCache = new Cache(1000);

// actions
var APPEND = 0;
var PUSH = 1;
var INC_SUB_PATH_DEPTH = 2;
var PUSH_SUB_PATH = 3;

// states
var BEFORE_PATH = 0;
var IN_PATH = 1;
var BEFORE_IDENT = 2;
var IN_IDENT = 3;
var IN_SUB_PATH = 4;
var IN_SINGLE_QUOTE = 5;
var IN_DOUBLE_QUOTE = 6;
var AFTER_PATH = 7;
var ERROR = 8;

var pathStateMachine = [];

pathStateMachine[BEFORE_PATH] = {
  'ws': [BEFORE_PATH],
  'ident': [IN_IDENT, APPEND],
  '[': [IN_SUB_PATH],
  'eof': [AFTER_PATH]
};

pathStateMachine[IN_PATH] = {
  'ws': [IN_PATH],
  '.': [BEFORE_IDENT],
  '[': [IN_SUB_PATH],
  'eof': [AFTER_PATH]
};

pathStateMachine[BEFORE_IDENT] = {
  'ws': [BEFORE_IDENT],
  'ident': [IN_IDENT, APPEND]
};

pathStateMachine[IN_IDENT] = {
  'ident': [IN_IDENT, APPEND],
  '0': [IN_IDENT, APPEND],
  'number': [IN_IDENT, APPEND],
  'ws': [IN_PATH, PUSH],
  '.': [BEFORE_IDENT, PUSH],
  '[': [IN_SUB_PATH, PUSH],
  'eof': [AFTER_PATH, PUSH]
};

pathStateMachine[IN_SUB_PATH] = {
  "'": [IN_SINGLE_QUOTE, APPEND],
  '"': [IN_DOUBLE_QUOTE, APPEND],
  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
  ']': [IN_PATH, PUSH_SUB_PATH],
  'eof': ERROR,
  'else': [IN_SUB_PATH, APPEND]
};

pathStateMachine[IN_SINGLE_QUOTE] = {
  "'": [IN_SUB_PATH, APPEND],
  'eof': ERROR,
  'else': [IN_SINGLE_QUOTE, APPEND]
};

pathStateMachine[IN_DOUBLE_QUOTE] = {
  '"': [IN_SUB_PATH, APPEND],
  'eof': ERROR,
  'else': [IN_DOUBLE_QUOTE, APPEND]
};

/**
 * Determine the type of a character in a keypath.
 *
 * @param {Char} ch
 * @return {String} type
 */

function getPathCharType(ch) {
  if (ch === undefined) {
    return 'eof';
  }

  var code = ch.charCodeAt(0);

  switch (code) {
    case 0x5B: // [
    case 0x5D: // ]
    case 0x2E: // .
    case 0x22: // "
    case 0x27: // '
    case 0x30:
      // 0
      return ch;

    case 0x5F: // _
    case 0x24:
      // $
      return 'ident';

    case 0x20: // Space
    case 0x09: // Tab
    case 0x0A: // Newline
    case 0x0D: // Return
    case 0xA0: // No-break space
    case 0xFEFF: // Byte Order Mark
    case 0x2028: // Line Separator
    case 0x2029:
      // Paragraph Separator
      return 'ws';
  }

  // a-z, A-Z
  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
    return 'ident';
  }

  // 1-9
  if (code >= 0x31 && code <= 0x39) {
    return 'number';
  }

  return 'else';
}

/**
 * Format a subPath, return its plain form if it is
 * a literal string or number. Otherwise prepend the
 * dynamic indicator (*).
 *
 * @param {String} path
 * @return {String}
 */

function formatSubPath(path) {
  var trimmed = path.trim();
  // invalid leading 0
  if (path.charAt(0) === '0' && isNaN(path)) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
}

/**
 * Parse a string path into an array of segments
 *
 * @param {String} path
 * @return {Array|undefined}
 */

function parse(path) {
  var keys = [];
  var index = -1;
  var mode = BEFORE_PATH;
  var subPathDepth = 0;
  var c, newChar, key, type, transition, action, typeMap;

  var actions = [];

  actions[PUSH] = function () {
    if (key !== undefined) {
      keys.push(key);
      key = undefined;
    }
  };

  actions[APPEND] = function () {
    if (key === undefined) {
      key = newChar;
    } else {
      key += newChar;
    }
  };

  actions[INC_SUB_PATH_DEPTH] = function () {
    actions[APPEND]();
    subPathDepth++;
  };

  actions[PUSH_SUB_PATH] = function () {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = IN_SUB_PATH;
      actions[APPEND]();
    } else {
      subPathDepth = 0;
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[PUSH]();
      }
    }
  };

  function maybeUnescapeQuote() {
    var nextChar = path[index + 1];
    if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
      index++;
      newChar = '\\' + nextChar;
      actions[APPEND]();
      return true;
    }
  }

  while (mode != null) {
    index++;
    c = path[index];

    if (c === '\\' && maybeUnescapeQuote()) {
      continue;
    }

    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap['else'] || ERROR;

    if (transition === ERROR) {
      return; // parse error
    }

    mode = transition[0];
    action = actions[transition[1]];
    if (action) {
      newChar = transition[2];
      newChar = newChar === undefined ? c : newChar;
      if (action() === false) {
        return;
      }
    }

    if (mode === AFTER_PATH) {
      keys.raw = path;
      return keys;
    }
  }
}

/**
 * External parse that check for a cache hit first
 *
 * @param {String} path
 * @return {Array|undefined}
 */

function parsePath(path) {
  var hit = pathCache.get(path);
  if (!hit) {
    hit = parse(path);
    if (hit) {
      pathCache.put(path, hit);
    }
  }
  return hit;
}

/**
 * Get from an object from a path string
 *
 * @param {Object} obj
 * @param {String} path
 */

function getPath(obj, path) {
  return parseExpression(path).get(obj);
}

/**
 * Warn against setting non-existent root path on a vm.
 */

var warnNonExistent;
if (process.env.NODE_ENV !== 'production') {
  warnNonExistent = function (path) {
    warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.');
  };
}

/**
 * Set on an object from a path
 *
 * @param {Object} obj
 * @param {String | Array} path
 * @param {*} val
 */

function setPath(obj, path, val) {
  var original = obj;
  if (typeof path === 'string') {
    path = parse(path);
  }
  if (!path || !isObject(obj)) {
    return false;
  }
  var last, key;
  for (var i = 0, l = path.length; i < l; i++) {
    last = obj;
    key = path[i];
    if (key.charAt(0) === '*') {
      key = parseExpression(key.slice(1)).get.call(original, original);
    }
    if (i < l - 1) {
      obj = obj[key];
      if (!isObject(obj)) {
        obj = {};
        if (process.env.NODE_ENV !== 'production' && last._isVue) {
          warnNonExistent(path);
        }
        set(last, key, obj);
      }
    } else {
      if (isArray(obj)) {
        obj.$set(key, val);
      } else if (key in obj) {
        obj[key] = val;
      } else {
        if (process.env.NODE_ENV !== 'production' && obj._isVue) {
          warnNonExistent(path);
        }
        set(obj, key, val);
      }
    }
  }
  return true;
}

var path = Object.freeze({
  parsePath: parsePath,
  getPath: getPath,
  setPath: setPath
});

var expressionCache = new Cache(1000);

var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');

// keywords that don't make sense inside expressions
var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';
var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');

var wsRE = /\s/g;
var newlineRE = /\n/g;
var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g;
var restoreRE = /"(\d+)"/g;
var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
var booleanLiteralRE = /^(?:true|false)$/;

/**
 * Save / Rewrite / Restore
 *
 * When rewriting paths found in an expression, it is
 * possible for the same letter sequences to be found in
 * strings and Object literal property keys. Therefore we
 * remove and store these parts in a temporary array, and
 * restore them after the path rewrite.
 */

var saved = [];

/**
 * Save replacer
 *
 * The save regex can match two possible cases:
 * 1. An opening object literal
 * 2. A string
 * If matched as a plain string, we need to escape its
 * newlines, since the string needs to be preserved when
 * generating the function body.
 *
 * @param {String} str
 * @param {String} isString - str if matched as a string
 * @return {String} - placeholder with index
 */

function save(str, isString) {
  var i = saved.length;
  saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
  return '"' + i + '"';
}

/**
 * Path rewrite replacer
 *
 * @param {String} raw
 * @return {String}
 */

function rewrite(raw) {
  var c = raw.charAt(0);
  var path = raw.slice(1);
  if (allowedKeywordsRE.test(path)) {
    return raw;
  } else {
    path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
    return c + 'scope.' + path;
  }
}

/**
 * Restore replacer
 *
 * @param {String} str
 * @param {String} i - matched save index
 * @return {String}
 */

function restore(str, i) {
  return saved[i];
}

/**
 * Rewrite an expression, prefixing all path accessors with
 * `scope.` and generate getter/setter functions.
 *
 * @param {String} exp
 * @return {Function}
 */

function compileGetter(exp) {
  if (improperKeywordsRE.test(exp)) {
    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
  }
  // reset state
  saved.length = 0;
  // save strings and object literal keys
  var body = exp.replace(saveRE, save).replace(wsRE, '');
  // rewrite all paths
  // pad 1 space here becaue the regex matches 1 extra char
  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
  return makeGetterFn(body);
}

/**
 * Build a getter function. Requires eval.
 *
 * We isolate the try/catch so it doesn't affect the
 * optimization of the parse function when it is not called.
 *
 * @param {String} body
 * @return {Function|undefined}
 */

function makeGetterFn(body) {
  try {
    /* eslint-disable no-new-func */
    return new Function('scope', 'return ' + body + ';');
    /* eslint-enable no-new-func */
  } catch (e) {
    process.env.NODE_ENV !== 'production' && warn('Invalid expression. ' + 'Generated function body: ' + body);
  }
}

/**
 * Compile a setter function for the expression.
 *
 * @param {String} exp
 * @return {Function|undefined}
 */

function compileSetter(exp) {
  var path = parsePath(exp);
  if (path) {
    return function (scope, val) {
      setPath(scope, path, val);
    };
  } else {
    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);
  }
}

/**
 * Parse an expression into re-written getter/setters.
 *
 * @param {String} exp
 * @param {Boolean} needSet
 * @return {Function}
 */

function parseExpression(exp, needSet) {
  exp = exp.trim();
  // try cache
  var hit = expressionCache.get(exp);
  if (hit) {
    if (needSet && !hit.set) {
      hit.set = compileSetter(hit.exp);
    }
    return hit;
  }
  var res = { exp: exp };
  res.get = isSimplePath(exp) && exp.indexOf('[') < 0
  // optimized super simple getter
  ? makeGetterFn('scope.' + exp)
  // dynamic getter
  : compileGetter(exp);
  if (needSet) {
    res.set = compileSetter(exp);
  }
  expressionCache.put(exp, res);
  return res;
}

/**
 * Check if an expression is a simple path.
 *
 * @param {String} exp
 * @return {Boolean}
 */

function isSimplePath(exp) {
  return pathTestRE.test(exp) &&
  // don't treat true/false as paths
  !booleanLiteralRE.test(exp) &&
  // Math constants e.g. Math.PI, Math.E etc.
  exp.slice(0, 5) !== 'Math.';
}

var expression = Object.freeze({
  parseExpression: parseExpression,
  isSimplePath: isSimplePath
});

// we have two separate queues: one for directive updates
// and one for user watcher registered via $watch().
// we want to guarantee directive updates to be called
// before user watchers so that when user watchers are
// triggered, the DOM would have already been in updated
// state.

var queueIndex;
var queue = [];
var userQueue = [];
var has = {};
var circular = {};
var waiting = false;
var internalQueueDepleted = false;

/**
 * Reset the batcher's state.
 */

function resetBatcherState() {
  queue = [];
  userQueue = [];
  has = {};
  circular = {};
  waiting = internalQueueDepleted = false;
}

/**
 * Flush both queues and run the watchers.
 */

function flushBatcherQueue() {
  runBatcherQueue(queue);
  internalQueueDepleted = true;
  runBatcherQueue(userQueue);
  // dev tool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
  resetBatcherState();
}

/**
 * Run the watchers in a single queue.
 *
 * @param {Array} queue
 */

function runBatcherQueue(queue) {
  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (queueIndex = 0; queueIndex < queue.length; queueIndex++) {
    var watcher = queue[queueIndex];
    var id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > config._maxUpdateCount) {
        queue.splice(has[id], 1);
        warn('You may have an infinite update loop for watcher ' + 'with expression: ' + watcher.expression);
      }
    }
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 *
 * @param {Watcher} watcher
 *   properties:
 *   - {Number} id
 *   - {Function} run
 */

function pushWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    if (internalQueueDepleted && !watcher.user) {
      // an internal watcher triggered by a user watcher...
      // let's run it immediately after current user watcher is done.
      userQueue.splice(queueIndex + 1, 0, watcher);
    } else {
      // push watcher into appropriate queue
      var q = watcher.user ? userQueue : queue;
      has[id] = q.length;
      q.push(watcher);
      // queue the flush
      if (!waiting) {
        waiting = true;
        nextTick(flushBatcherQueue);
      }
    }
  }
}

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 *
 * @param {Vue} vm
 * @param {String} expression
 * @param {Function} cb
 * @param {Object} options
 *                 - {Array} filters
 *                 - {Boolean} twoWay
 *                 - {Boolean} deep
 *                 - {Boolean} user
 *                 - {Boolean} sync
 *                 - {Boolean} lazy
 *                 - {Function} [preProcess]
 *                 - {Function} [postProcess]
 * @constructor
 */
function Watcher(vm, expOrFn, cb, options) {
  // mix in options
  if (options) {
    extend(this, options);
  }
  var isFn = typeof expOrFn === 'function';
  this.vm = vm;
  vm._watchers.push(this);
  this.expression = expOrFn;
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = Object.create(null);
  this.newDepIds = null;
  this.prevError = null; // for async error stacks
  // parse expression for getter/setter
  if (isFn) {
    this.getter = expOrFn;
    this.setter = undefined;
  } else {
    var res = parseExpression(expOrFn, this.twoWay);
    this.getter = res.get;
    this.setter = res.set;
  }
  this.value = this.lazy ? undefined : this.get();
  // state for avoiding false triggers for deep and Array
  // watchers during vm._digest()
  this.queued = this.shallow = false;
}

/**
 * Evaluate the getter, and re-collect dependencies.
 */

Watcher.prototype.get = function () {
  this.beforeGet();
  var scope = this.scope || this.vm;
  var value;
  try {
    value = this.getter.call(scope, scope);
  } catch (e) {
    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
      warn('Error when evaluating expression "' + this.expression + '". ' + (config.debug ? '' : 'Turn on debug mode to see stack trace.'), e);
    }
  }
  // "touch" every property so they are all tracked as
  // dependencies for deep watching
  if (this.deep) {
    traverse(value);
  }
  if (this.preProcess) {
    value = this.preProcess(value);
  }
  if (this.filters) {
    value = scope._applyFilters(value, null, this.filters, false);
  }
  if (this.postProcess) {
    value = this.postProcess(value);
  }
  this.afterGet();
  return value;
};

/**
 * Set the corresponding value with the setter.
 *
 * @param {*} value
 */

Watcher.prototype.set = function (value) {
  var scope = this.scope || this.vm;
  if (this.filters) {
    value = scope._applyFilters(value, this.value, this.filters, true);
  }
  try {
    this.setter.call(scope, scope, value);
  } catch (e) {
    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
      warn('Error when evaluating setter "' + this.expression + '"', e);
    }
  }
  // two-way sync for v-for alias
  var forContext = scope.$forContext;
  if (forContext && forContext.alias === this.expression) {
    if (forContext.filters) {
      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.');
      return;
    }
    forContext._withLock(function () {
      if (scope.$key) {
        // original is an object
        forContext.rawValue[scope.$key] = value;
      } else {
        forContext.rawValue.$set(scope.$index, value);
      }
    });
  }
};

/**
 * Prepare for dependency collection.
 */

Watcher.prototype.beforeGet = function () {
  Dep.target = this;
  this.newDepIds = Object.create(null);
  this.newDeps.length = 0;
};

/**
 * Add a dependency to this directive.
 *
 * @param {Dep} dep
 */

Watcher.prototype.addDep = function (dep) {
  var id = dep.id;
  if (!this.newDepIds[id]) {
    this.newDepIds[id] = true;
    this.newDeps.push(dep);
    if (!this.depIds[id]) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */

Watcher.prototype.afterGet = function () {
  Dep.target = null;
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds[dep.id]) {
      dep.removeSub(this);
    }
  }
  this.depIds = this.newDepIds;
  var tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 *
 * @param {Boolean} shallow
 */

Watcher.prototype.update = function (shallow) {
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync || !config.async) {
    this.run();
  } else {
    // if queued, only overwrite shallow with non-shallow,
    // but not the other way around.
    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
    this.queued = true;
    // record before-push error stack in debug mode
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.debug) {
      this.prevError = new Error('[vue] async stack trace');
    }
    pushWatcher(this);
  }
};

/**
 * Batcher job interface.
 * Will be called by the batcher.
 */

Watcher.prototype.run = function () {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated; but only do so if this is a
    // non-shallow update (caused by a vm digest).
    (isObject(value) || this.deep) && !this.shallow) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      // in debug + async mode, when a watcher callbacks
      // throws, we also throw the saved before-push error
      // so the full cross-tick stack trace is available.
      var prevError = this.prevError;
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {
        this.prevError = null;
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          nextTick(function () {
            throw prevError;
          }, 0);
          throw e;
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
    this.queued = this.shallow = false;
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */

Watcher.prototype.evaluate = function () {
  // avoid overwriting another watcher that is being
  // collected.
  var current = Dep.target;
  this.value = this.get();
  this.dirty = false;
  Dep.target = current;
};

/**
 * Depend on all deps collected by this watcher.
 */

Watcher.prototype.depend = function () {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subcriber list.
 */

Watcher.prototype.teardown = function () {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed or is performing a v-for
    // re-render (the watcher list is then filtered by v-for).
    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
      this.vm._watchers.$remove(this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
    this.vm = this.cb = this.value = null;
  }
};

/**
 * Recrusively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 *
 * @param {*} val
 */

function traverse(val) {
  var i, keys;
  if (isArray(val)) {
    i = val.length;
    while (i--) traverse(val[i]);
  } else if (isObject(val)) {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) traverse(val[keys[i]]);
  }
}

var text$1 = {

  bind: function bind() {
    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
  },

  update: function update(value) {
    this.el[this.attr] = _toString(value);
  }
};

var templateCache = new Cache(1000);
var idSelectorCache = new Cache(1000);

var map = {
  efault: [0, '', ''],
  legend: [1, '<fieldset>', '</fieldset>'],
  tr: [2, '<table><tbody>', '</tbody></table>'],
  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
};

map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];

map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];

map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];

/**
 * Check if a node is a supported template node with a
 * DocumentFragment content.
 *
 * @param {Node} node
 * @return {Boolean}
 */

function isRealTemplate(node) {
  return isTemplate(node) && isFragment(node.content);
}

var tagRE$1 = /<([\w:-]+)/;
var entityRE = /&#?\w+?;/;

/**
 * Convert a string template to a DocumentFragment.
 * Determines correct wrapping by tag types. Wrapping
 * strategy found in jQuery & component/domify.
 *
 * @param {String} templateString
 * @param {Boolean} raw
 * @return {DocumentFragment}
 */

function stringToFragment(templateString, raw) {
  // try a cache hit first
  var cacheKey = raw ? templateString : templateString.trim();
  var hit = templateCache.get(cacheKey);
  if (hit) {
    return hit;
  }

  var frag = document.createDocumentFragment();
  var tagMatch = templateString.match(tagRE$1);
  var entityMatch = entityRE.test(templateString);

  if (!tagMatch && !entityMatch) {
    // text only, return a single text node.
    frag.appendChild(document.createTextNode(templateString));
  } else {
    var tag = tagMatch && tagMatch[1];
    var wrap = map[tag] || map.efault;
    var depth = wrap[0];
    var prefix = wrap[1];
    var suffix = wrap[2];
    var node = document.createElement('div');

    node.innerHTML = prefix + templateString + suffix;
    while (depth--) {
      node = node.lastChild;
    }

    var child;
    /* eslint-disable no-cond-assign */
    while (child = node.firstChild) {
      /* eslint-enable no-cond-assign */
      frag.appendChild(child);
    }
  }
  if (!raw) {
    trimNode(frag);
  }
  templateCache.put(cacheKey, frag);
  return frag;
}

/**
 * Convert a template node to a DocumentFragment.
 *
 * @param {Node} node
 * @return {DocumentFragment}
 */

function nodeToFragment(node) {
  // if its a template tag and the browser supports it,
  // its content is already a document fragment.
  if (isRealTemplate(node)) {
    trimNode(node.content);
    return node.content;
  }
  // script template
  if (node.tagName === 'SCRIPT') {
    return stringToFragment(node.textContent);
  }
  // normal node, clone it to avoid mutating the original
  var clonedNode = cloneNode(node);
  var frag = document.createDocumentFragment();
  var child;
  /* eslint-disable no-cond-assign */
  while (child = clonedNode.firstChild) {
    /* eslint-enable no-cond-assign */
    frag.appendChild(child);
  }
  trimNode(frag);
  return frag;
}

// Test for the presence of the Safari template cloning bug
// https://bugs.webkit.org/showug.cgi?id=137755
var hasBrokenTemplate = (function () {
  /* istanbul ignore else */
  if (inBrowser) {
    var a = document.createElement('div');
    a.innerHTML = '<template>1</template>';
    return !a.cloneNode(true).firstChild.innerHTML;
  } else {
    return false;
  }
})();

// Test for IE10/11 textarea placeholder clone bug
var hasTextareaCloneBug = (function () {
  /* istanbul ignore else */
  if (inBrowser) {
    var t = document.createElement('textarea');
    t.placeholder = 't';
    return t.cloneNode(true).value === 't';
  } else {
    return false;
  }
})();

/**
 * 1. Deal with Safari cloning nested <template> bug by
 *    manually cloning all template instances.
 * 2. Deal with IE10/11 textarea placeholder bug by setting
 *    the correct value after cloning.
 *
 * @param {Element|DocumentFragment} node
 * @return {Element|DocumentFragment}
 */

function cloneNode(node) {
  /* istanbul ignore if */
  if (!node.querySelectorAll) {
    return node.cloneNode();
  }
  var res = node.cloneNode(true);
  var i, original, cloned;
  /* istanbul ignore if */
  if (hasBrokenTemplate) {
    var tempClone = res;
    if (isRealTemplate(node)) {
      node = node.content;
      tempClone = res.content;
    }
    original = node.querySelectorAll('template');
    if (original.length) {
      cloned = tempClone.querySelectorAll('template');
      i = cloned.length;
      while (i--) {
        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
      }
    }
  }
  /* istanbul ignore if */
  if (hasTextareaCloneBug) {
    if (node.tagName === 'TEXTAREA') {
      res.value = node.value;
    } else {
      original = node.querySelectorAll('textarea');
      if (original.length) {
        cloned = res.querySelectorAll('textarea');
        i = cloned.length;
        while (i--) {
          cloned[i].value = original[i].value;
        }
      }
    }
  }
  return res;
}

/**
 * Process the template option and normalizes it into a
 * a DocumentFragment that can be used as a partial or a
 * instance template.
 *
 * @param {*} template
 *        Possible values include:
 *        - DocumentFragment object
 *        - Node object of type Template
 *        - id selector: '#some-template-id'
 *        - template string: '<div><span>{{msg}}</span></div>'
 * @param {Boolean} shouldClone
 * @param {Boolean} raw
 *        inline HTML interpolation. Do not check for id
 *        selector and keep whitespace in the string.
 * @return {DocumentFragment|undefined}
 */

function parseTemplate(template, shouldClone, raw) {
  var node, frag;

  // if the template is already a document fragment,
  // do nothing
  if (isFragment(template)) {
    trimNode(template);
    return shouldClone ? cloneNode(template) : template;
  }

  if (typeof template === 'string') {
    // id selector
    if (!raw && template.charAt(0) === '#') {
      // id selector can be cached too
      frag = idSelectorCache.get(template);
      if (!frag) {
        node = document.getElementById(template.slice(1));
        if (node) {
          frag = nodeToFragment(node);
          // save selector to cache
          idSelectorCache.put(template, frag);
        }
      }
    } else {
      // normal string template
      frag = stringToFragment(template, raw);
    }
  } else if (template.nodeType) {
    // a direct node
    frag = nodeToFragment(template);
  }

  return frag && shouldClone ? cloneNode(frag) : frag;
}

var template = Object.freeze({
  cloneNode: cloneNode,
  parseTemplate: parseTemplate
});

var html = {

  bind: function bind() {
    // a comment node means this is a binding for
    // {{{ inline unescaped html }}}
    if (this.el.nodeType === 8) {
      // hold nodes
      this.nodes = [];
      // replace the placeholder with proper anchor
      this.anchor = createAnchor('v-html');
      replace(this.el, this.anchor);
    }
  },

  update: function update(value) {
    value = _toString(value);
    if (this.nodes) {
      this.swap(value);
    } else {
      this.el.innerHTML = value;
    }
  },

  swap: function swap(value) {
    // remove old nodes
    var i = this.nodes.length;
    while (i--) {
      remove(this.nodes[i]);
    }
    // convert new value to a fragment
    // do not attempt to retrieve from id selector
    var frag = parseTemplate(value, true, true);
    // save a reference to these nodes so we can remove later
    this.nodes = toArray(frag.childNodes);
    before(frag, this.anchor);
  }
};

/**
 * Abstraction for a partially-compiled fragment.
 * Can optionally compile content with a child scope.
 *
 * @param {Function} linker
 * @param {Vue} vm
 * @param {DocumentFragment} frag
 * @param {Vue} [host]
 * @param {Object} [scope]
 */
function Fragment(linker, vm, frag, host, scope, parentFrag) {
  this.children = [];
  this.childFrags = [];
  this.vm = vm;
  this.scope = scope;
  this.inserted = false;
  this.parentFrag = parentFrag;
  if (parentFrag) {
    parentFrag.childFrags.push(this);
  }
  this.unlink = linker(vm, frag, host, scope, this);
  var single = this.single = frag.childNodes.length === 1 &&
  // do not go single mode if the only node is an anchor
  !frag.childNodes[0].__v_anchor;
  if (single) {
    this.node = frag.childNodes[0];
    this.before = singleBefore;
    this.remove = singleRemove;
  } else {
    this.node = createAnchor('fragment-start');
    this.end = createAnchor('fragment-end');
    this.frag = frag;
    prepend(this.node, frag);
    frag.appendChild(this.end);
    this.before = multiBefore;
    this.remove = multiRemove;
  }
  this.node.__v_frag = this;
}

/**
 * Call attach/detach for all components contained within
 * this fragment. Also do so recursively for all child
 * fragments.
 *
 * @param {Function} hook
 */

Fragment.prototype.callHook = function (hook) {
  var i, l;
  for (i = 0, l = this.childFrags.length; i < l; i++) {
    this.childFrags[i].callHook(hook);
  }
  for (i = 0, l = this.children.length; i < l; i++) {
    hook(this.children[i]);
  }
};

/**
 * Insert fragment before target, single node version
 *
 * @param {Node} target
 * @param {Boolean} withTransition
 */

function singleBefore(target, withTransition) {
  this.inserted = true;
  var method = withTransition !== false ? beforeWithTransition : before;
  method(this.node, target, this.vm);
  if (inDoc(this.node)) {
    this.callHook(attach);
  }
}

/**
 * Remove fragment, single node version
 */

function singleRemove() {
  this.inserted = false;
  var shouldCallRemove = inDoc(this.node);
  var self = this;
  this.beforeRemove();
  removeWithTransition(this.node, this.vm, function () {
    if (shouldCallRemove) {
      self.callHook(detach);
    }
    self.destroy();
  });
}

/**
 * Insert fragment before target, multi-nodes version
 *
 * @param {Node} target
 * @param {Boolean} withTransition
 */

function multiBefore(target, withTransition) {
  this.inserted = true;
  var vm = this.vm;
  var method = withTransition !== false ? beforeWithTransition : before;
  mapNodeRange(this.node, this.end, function (node) {
    method(node, target, vm);
  });
  if (inDoc(this.node)) {
    this.callHook(attach);
  }
}

/**
 * Remove fragment, multi-nodes version
 */

function multiRemove() {
  this.inserted = false;
  var self = this;
  var shouldCallRemove = inDoc(this.node);
  this.beforeRemove();
  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
    if (shouldCallRemove) {
      self.callHook(detach);
    }
    self.destroy();
  });
}

/**
 * Prepare the fragment for removal.
 */

Fragment.prototype.beforeRemove = function () {
  var i, l;
  for (i = 0, l = this.childFrags.length; i < l; i++) {
    // call the same method recursively on child
    // fragments, depth-first
    this.childFrags[i].beforeRemove(false);
  }
  for (i = 0, l = this.children.length; i < l; i++) {
    // Call destroy for all contained instances,
    // with remove:false and defer:true.
    // Defer is necessary because we need to
    // keep the children to call detach hooks
    // on them.
    this.children[i].$destroy(false, true);
  }
  var dirs = this.unlink.dirs;
  for (i = 0, l = dirs.length; i < l; i++) {
    // disable the watchers on all the directives
    // so that the rendered content stays the same
    // during removal.
    dirs[i]._watcher && dirs[i]._watcher.teardown();
  }
};

/**
 * Destroy the fragment.
 */

Fragment.prototype.destroy = function () {
  if (this.parentFrag) {
    this.parentFrag.childFrags.$remove(this);
  }
  this.node.__v_frag = null;
  this.unlink();
};

/**
 * Call attach hook for a Vue instance.
 *
 * @param {Vue} child
 */

function attach(child) {
  if (!child._isAttached && inDoc(child.$el)) {
    child._callHook('attached');
  }
}

/**
 * Call detach hook for a Vue instance.
 *
 * @param {Vue} child
 */

function detach(child) {
  if (child._isAttached && !inDoc(child.$el)) {
    child._callHook('detached');
  }
}

var linkerCache = new Cache(5000);

/**
 * A factory that can be used to create instances of a
 * fragment. Caches the compiled linker if possible.
 *
 * @param {Vue} vm
 * @param {Element|String} el
 */
function FragmentFactory(vm, el) {
  this.vm = vm;
  var template;
  var isString = typeof el === 'string';
  if (isString || isTemplate(el)) {
    template = parseTemplate(el, true);
  } else {
    template = document.createDocumentFragment();
    template.appendChild(el);
  }
  this.template = template;
  // linker can be cached, but only for components
  var linker;
  var cid = vm.constructor.cid;
  if (cid > 0) {
    var cacheId = cid + (isString ? el : getOuterHTML(el));
    linker = linkerCache.get(cacheId);
    if (!linker) {
      linker = compile(template, vm.$options, true);
      linkerCache.put(cacheId, linker);
    }
  } else {
    linker = compile(template, vm.$options, true);
  }
  this.linker = linker;
}

/**
 * Create a fragment instance with given host and scope.
 *
 * @param {Vue} host
 * @param {Object} scope
 * @param {Fragment} parentFrag
 */

FragmentFactory.prototype.create = function (host, scope, parentFrag) {
  var frag = cloneNode(this.template);
  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
};

var ON = 700;
var MODEL = 800;
var BIND = 850;
var TRANSITION = 1100;
var EL = 1500;
var COMPONENT = 1500;
var PARTIAL = 1750;
var FOR = 2000;
var IF = 2000;
var SLOT = 2100;

var uid$3 = 0;

var vFor = {

  priority: FOR,

  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],

  bind: function bind() {
    // support "item in/of items" syntax
    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);
    if (inMatch) {
      var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
      if (itMatch) {
        this.iterator = itMatch[1].trim();
        this.alias = itMatch[2].trim();
      } else {
        this.alias = inMatch[1].trim();
      }
      this.expression = inMatch[2];
    }

    if (!this.alias) {
      process.env.NODE_ENV !== 'production' && warn('Alias is required in v-for.');
      return;
    }

    // uid as a cache identifier
    this.id = '__v-for__' + ++uid$3;

    // check if this is an option list,
    // so that we know if we need to update the <select>'s
    // v-model when the option list has changed.
    // because v-model has a lower priority than v-for,
    // the v-model is not bound here yet, so we have to
    // retrive it in the actual updateModel() function.
    var tag = this.el.tagName;
    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';

    // setup anchor nodes
    this.start = createAnchor('v-for-start');
    this.end = createAnchor('v-for-end');
    replace(this.el, this.end);
    before(this.start, this.end);

    // cache
    this.cache = Object.create(null);

    // fragment factory
    this.factory = new FragmentFactory(this.vm, this.el);
  },

  update: function update(data) {
    this.diff(data);
    this.updateRef();
    this.updateModel();
  },

  /**
   * Diff, based on new data and old data, determine the
   * minimum amount of DOM manipulations needed to make the
   * DOM reflect the new data Array.
   *
   * The algorithm diffs the new data Array by storing a
   * hidden reference to an owner vm instance on previously
   * seen data. This allows us to achieve O(n) which is
   * better than a levenshtein distance based algorithm,
   * which is O(m * n).
   *
   * @param {Array} data
   */

  diff: function diff(data) {
    // check if the Array was converted from an Object
    var item = data[0];
    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');

    var trackByKey = this.params.trackBy;
    var oldFrags = this.frags;
    var frags = this.frags = new Array(data.length);
    var alias = this.alias;
    var iterator = this.iterator;
    var start = this.start;
    var end = this.end;
    var inDocument = inDoc(start);
    var init = !oldFrags;
    var i, l, frag, key, value, primitive;

    // First pass, go through the new Array and fill up
    // the new frags array. If a piece of data has a cached
    // instance for it, we reuse it. Otherwise build a new
    // instance.
    for (i = 0, l = data.length; i < l; i++) {
      item = data[i];
      key = convertedFromObject ? item.$key : null;
      value = convertedFromObject ? item.$value : item;
      primitive = !isObject(value);
      frag = !init && this.getCachedFrag(value, i, key);
      if (frag) {
        // reusable fragment
        frag.reused = true;
        // update $index
        frag.scope.$index = i;
        // update $key
        if (key) {
          frag.scope.$key = key;
        }
        // update iterator
        if (iterator) {
          frag.scope[iterator] = key !== null ? key : i;
        }
        // update data for track-by, object repeat &
        // primitive values.
        if (trackByKey || convertedFromObject || primitive) {
          frag.scope[alias] = value;
        }
      } else {
        // new isntance
        frag = this.create(value, alias, i, key);
        frag.fresh = !init;
      }
      frags[i] = frag;
      if (init) {
        frag.before(end);
      }
    }

    // we're done for the initial render.
    if (init) {
      return;
    }

    // Second pass, go through the old fragments and
    // destroy those who are not reused (and remove them
    // from cache)
    var removalIndex = 0;
    var totalRemoved = oldFrags.length - frags.length;
    // when removing a large number of fragments, watcher removal
    // turns out to be a perf bottleneck, so we batch the watcher
    // removals into a single filter call!
    this.vm._vForRemoving = true;
    for (i = 0, l = oldFrags.length; i < l; i++) {
      frag = oldFrags[i];
      if (!frag.reused) {
        this.deleteCachedFrag(frag);
        this.remove(frag, removalIndex++, totalRemoved, inDocument);
      }
    }
    this.vm._vForRemoving = false;
    if (removalIndex) {
      this.vm._watchers = this.vm._watchers.filter(function (w) {
        return w.active;
      });
    }

    // Final pass, move/insert new fragments into the
    // right place.
    var targetPrev, prevEl, currentPrev;
    var insertionIndex = 0;
    for (i = 0, l = frags.length; i < l; i++) {
      frag = frags[i];
      // this is the frag that we should be after
      targetPrev = frags[i - 1];
      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
      if (frag.reused && !frag.staggerCb) {
        currentPrev = findPrevFrag(frag, start, this.id);
        if (currentPrev !== targetPrev && (!currentPrev ||
        // optimization for moving a single item.
        // thanks to suggestions by @livoras in #1807
        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
          this.move(frag, prevEl);
        }
      } else {
        // new instance, or still in stagger.
        // insert with updated stagger index.
        this.insert(frag, insertionIndex++, prevEl, inDocument);
      }
      frag.reused = frag.fresh = false;
    }
  },

  /**
   * Create a new fragment instance.
   *
   * @param {*} value
   * @param {String} alias
   * @param {Number} index
   * @param {String} [key]
   * @return {Fragment}
   */

  create: function create(value, alias, index, key) {
    var host = this._host;
    // create iteration scope
    var parentScope = this._scope || this.vm;
    var scope = Object.create(parentScope);
    // ref holder for the scope
    scope.$refs = Object.create(parentScope.$refs);
    scope.$els = Object.create(parentScope.$els);
    // make sure point $parent to parent scope
    scope.$parent = parentScope;
    // for two-way binding on alias
    scope.$forContext = this;
    // define scope properties
    defineReactive(scope, alias, value, true /* do not observe */);
    defineReactive(scope, '$index', index);
    if (key) {
      defineReactive(scope, '$key', key);
    } else if (scope.$key) {
      // avoid accidental fallback
      def(scope, '$key', null);
    }
    if (this.iterator) {
      defineReactive(scope, this.iterator, key !== null ? key : index);
    }
    var frag = this.factory.create(host, scope, this._frag);
    frag.forId = this.id;
    this.cacheFrag(value, frag, index, key);
    return frag;
  },

  /**
   * Update the v-ref on owner vm.
   */

  updateRef: function updateRef() {
    var ref = this.descriptor.ref;
    if (!ref) return;
    var hash = (this._scope || this.vm).$refs;
    var refs;
    if (!this.fromObject) {
      refs = this.frags.map(findVmFromFrag);
    } else {
      refs = {};
      this.frags.forEach(function (frag) {
        refs[frag.scope.$key] = findVmFromFrag(frag);
      });
    }
    hash[ref] = refs;
  },

  /**
   * For option lists, update the containing v-model on
   * parent <select>.
   */

  updateModel: function updateModel() {
    if (this.isOption) {
      var parent = this.start.parentNode;
      var model = parent && parent.__v_model;
      if (model) {
        model.forceUpdate();
      }
    }
  },

  /**
   * Insert a fragment. Handles staggering.
   *
   * @param {Fragment} frag
   * @param {Number} index
   * @param {Node} prevEl
   * @param {Boolean} inDocument
   */

  insert: function insert(frag, index, prevEl, inDocument) {
    if (frag.staggerCb) {
      frag.staggerCb.cancel();
      frag.staggerCb = null;
    }
    var staggerAmount = this.getStagger(frag, index, null, 'enter');
    if (inDocument && staggerAmount) {
      // create an anchor and insert it synchronously,
      // so that we can resolve the correct order without
      // worrying about some elements not inserted yet
      var anchor = frag.staggerAnchor;
      if (!anchor) {
        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
        anchor.__v_frag = frag;
      }
      after(anchor, prevEl);
      var op = frag.staggerCb = cancellable(function () {
        frag.staggerCb = null;
        frag.before(anchor);
        remove(anchor);
      });
      setTimeout(op, staggerAmount);
    } else {
      frag.before(prevEl.nextSibling);
    }
  },

  /**
   * Remove a fragment. Handles staggering.
   *
   * @param {Fragment} frag
   * @param {Number} index
   * @param {Number} total
   * @param {Boolean} inDocument
   */

  remove: function remove(frag, index, total, inDocument) {
    if (frag.staggerCb) {
      frag.staggerCb.cancel();
      frag.staggerCb = null;
      // it's not possible for the same frag to be removed
      // twice, so if we have a pending stagger callback,
      // it means this frag is queued for enter but removed
      // before its transition started. Since it is already
      // destroyed, we can just leave it in detached state.
      return;
    }
    var staggerAmount = this.getStagger(frag, index, total, 'leave');
    if (inDocument && staggerAmount) {
      var op = frag.staggerCb = cancellable(function () {
        frag.staggerCb = null;
        frag.remove();
      });
      setTimeout(op, staggerAmount);
    } else {
      frag.remove();
    }
  },

  /**
   * Move a fragment to a new position.
   * Force no transition.
   *
   * @param {Fragment} frag
   * @param {Node} prevEl
   */

  move: function move(frag, prevEl) {
    // fix a common issue with Sortable:
    // if prevEl doesn't have nextSibling, this means it's
    // been dragged after the end anchor. Just re-position
    // the end anchor to the end of the container.
    /* istanbul ignore if */
    if (!prevEl.nextSibling) {
      this.end.parentNode.appendChild(this.end);
    }
    frag.before(prevEl.nextSibling, false);
  },

  /**
   * Cache a fragment using track-by or the object key.
   *
   * @param {*} value
   * @param {Fragment} frag
   * @param {Number} index
   * @param {String} [key]
   */

  cacheFrag: function cacheFrag(value, frag, index, key) {
    var trackByKey = this.params.trackBy;
    var cache = this.cache;
    var primitive = !isObject(value);
    var id;
    if (key || trackByKey || primitive) {
      id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
      if (!cache[id]) {
        cache[id] = frag;
      } else if (trackByKey !== '$index') {
        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
      }
    } else {
      id = this.id;
      if (hasOwn(value, id)) {
        if (value[id] === null) {
          value[id] = frag;
        } else {
          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
        }
      } else {
        def(value, id, frag);
      }
    }
    frag.raw = value;
  },

  /**
   * Get a cached fragment from the value/index/key
   *
   * @param {*} value
   * @param {Number} index
   * @param {String} key
   * @return {Fragment}
   */

  getCachedFrag: function getCachedFrag(value, index, key) {
    var trackByKey = this.params.trackBy;
    var primitive = !isObject(value);
    var frag;
    if (key || trackByKey || primitive) {
      var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
      frag = this.cache[id];
    } else {
      frag = value[this.id];
    }
    if (frag && (frag.reused || frag.fresh)) {
      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
    }
    return frag;
  },

  /**
   * Delete a fragment from cache.
   *
   * @param {Fragment} frag
   */

  deleteCachedFrag: function deleteCachedFrag(frag) {
    var value = frag.raw;
    var trackByKey = this.params.trackBy;
    var scope = frag.scope;
    var index = scope.$index;
    // fix #948: avoid accidentally fall through to
    // a parent repeater which happens to have $key.
    var key = hasOwn(scope, '$key') && scope.$key;
    var primitive = !isObject(value);
    if (trackByKey || key || primitive) {
      var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
      this.cache[id] = null;
    } else {
      value[this.id] = null;
      frag.raw = null;
    }
  },

  /**
   * Get the stagger amount for an insertion/removal.
   *
   * @param {Fragment} frag
   * @param {Number} index
   * @param {Number} total
   * @param {String} type
   */

  getStagger: function getStagger(frag, index, total, type) {
    type = type + 'Stagger';
    var trans = frag.node.__v_trans;
    var hooks = trans && trans.hooks;
    var hook = hooks && (hooks[type] || hooks.stagger);
    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
  },

  /**
   * Pre-process the value before piping it through the
   * filters. This is passed to and called by the watcher.
   */

  _preProcess: function _preProcess(value) {
    // regardless of type, store the un-filtered raw value.
    this.rawValue = value;
    return value;
  },

  /**
   * Post-process the value after it has been piped through
   * the filters. This is passed to and called by the watcher.
   *
   * It is necessary for this to be called during the
   * wathcer's dependency collection phase because we want
   * the v-for to update when the source Object is mutated.
   */

  _postProcess: function _postProcess(value) {
    if (isArray(value)) {
      return value;
    } else if (isPlainObject(value)) {
      // convert plain object to array.
      var keys = Object.keys(value);
      var i = keys.length;
      var res = new Array(i);
      var key;
      while (i--) {
        key = keys[i];
        res[i] = {
          $key: key,
          $value: value[key]
        };
      }
      return res;
    } else {
      if (typeof value === 'number' && !isNaN(value)) {
        value = range(value);
      }
      return value || [];
    }
  },

  unbind: function unbind() {
    if (this.descriptor.ref) {
      (this._scope || this.vm).$refs[this.descriptor.ref] = null;
    }
    if (this.frags) {
      var i = this.frags.length;
      var frag;
      while (i--) {
        frag = this.frags[i];
        this.deleteCachedFrag(frag);
        frag.destroy();
      }
    }
  }
};

/**
 * Helper to find the previous element that is a fragment
 * anchor. This is necessary because a destroyed frag's
 * element could still be lingering in the DOM before its
 * leaving transition finishes, but its inserted flag
 * should have been set to false so we can skip them.
 *
 * If this is a block repeat, we want to make sure we only
 * return frag that is bound to this v-for. (see #929)
 *
 * @param {Fragment} frag
 * @param {Comment|Text} anchor
 * @param {String} id
 * @return {Fragment}
 */

function findPrevFrag(frag, anchor, id) {
  var el = frag.node.previousSibling;
  /* istanbul ignore if */
  if (!el) return;
  frag = el.__v_frag;
  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
    el = el.previousSibling;
    /* istanbul ignore if */
    if (!el) return;
    frag = el.__v_frag;
  }
  return frag;
}

/**
 * Find a vm from a fragment.
 *
 * @param {Fragment} frag
 * @return {Vue|undefined}
 */

function findVmFromFrag(frag) {
  var node = frag.node;
  // handle multi-node frag
  if (frag.end) {
    while (!node.__vue__ && node !== frag.end && node.nextSibling) {
      node = node.nextSibling;
    }
  }
  return node.__vue__;
}

/**
 * Create a range array from given number.
 *
 * @param {Number} n
 * @return {Array}
 */

function range(n) {
  var i = -1;
  var ret = new Array(Math.floor(n));
  while (++i < n) {
    ret[i] = i;
  }
  return ret;
}

if (process.env.NODE_ENV !== 'production') {
  vFor.warnDuplicate = function (value) {
    warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.');
  };
}

var vIf = {

  priority: IF,

  bind: function bind() {
    var el = this.el;
    if (!el.__vue__) {
      // check else block
      var next = el.nextElementSibling;
      if (next && getAttr(next, 'v-else') !== null) {
        remove(next);
        this.elseEl = next;
      }
      // check main block
      this.anchor = createAnchor('v-if');
      replace(el, this.anchor);
    } else {
      process.env.NODE_ENV !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.');
      this.invalid = true;
    }
  },

  update: function update(value) {
    if (this.invalid) return;
    if (value) {
      if (!this.frag) {
        this.insert();
      }
    } else {
      this.remove();
    }
  },

  insert: function insert() {
    if (this.elseFrag) {
      this.elseFrag.remove();
      this.elseFrag = null;
    }
    // lazy init factory
    if (!this.factory) {
      this.factory = new FragmentFactory(this.vm, this.el);
    }
    this.frag = this.factory.create(this._host, this._scope, this._frag);
    this.frag.before(this.anchor);
  },

  remove: function remove() {
    if (this.frag) {
      this.frag.remove();
      this.frag = null;
    }
    if (this.elseEl && !this.elseFrag) {
      if (!this.elseFactory) {
        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);
      }
      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
      this.elseFrag.before(this.anchor);
    }
  },

  unbind: function unbind() {
    if (this.frag) {
      this.frag.destroy();
    }
    if (this.elseFrag) {
      this.elseFrag.destroy();
    }
  }
};

var show = {

  bind: function bind() {
    // check else block
    var next = this.el.nextElementSibling;
    if (next && getAttr(next, 'v-else') !== null) {
      this.elseEl = next;
    }
  },

  update: function update(value) {
    this.apply(this.el, value);
    if (this.elseEl) {
      this.apply(this.elseEl, !value);
    }
  },

  apply: function apply(el, value) {
    if (inDoc(el)) {
      applyTransition(el, value ? 1 : -1, toggle, this.vm);
    } else {
      toggle();
    }
    function toggle() {
      el.style.display = value ? '' : 'none';
    }
  }
};

var text$2 = {

  bind: function bind() {
    var self = this;
    var el = this.el;
    var isRange = el.type === 'range';
    var lazy = this.params.lazy;
    var number = this.params.number;
    var debounce = this.params.debounce;

    // handle composition events.
    //   http://blog.evanyou.me/2014/01/03/composition-event/
    // skip this for Android because it handles composition
    // events quite differently. Android doesn't trigger
    // composition events for language input methods e.g.
    // Chinese, but instead triggers them for spelling
    // suggestions... (see Discussion/#162)
    var composing = false;
    if (!isAndroid && !isRange) {
      this.on('compositionstart', function () {
        composing = true;
      });
      this.on('compositionend', function () {
        composing = false;
        // in IE11 the "compositionend" event fires AFTER
        // the "input" event, so the input handler is blocked
        // at the end... have to call it here.
        //
        // #1327: in lazy mode this is unecessary.
        if (!lazy) {
          self.listener();
        }
      });
    }

    // prevent messing with the input when user is typing,
    // and force update on blur.
    this.focused = false;
    if (!isRange && !lazy) {
      this.on('focus', function () {
        self.focused = true;
      });
      this.on('blur', function () {
        self.focused = false;
        // do not sync value after fragment removal (#2017)
        if (!self._frag || self._frag.inserted) {
          self.rawListener();
        }
      });
    }

    // Now attach the main listener
    this.listener = this.rawListener = function () {
      if (composing || !self._bound) {
        return;
      }
      var val = number || isRange ? toNumber(el.value) : el.value;
      self.set(val);
      // force update on next tick to avoid lock & same value
      // also only update when user is not typing
      nextTick(function () {
        if (self._bound && !self.focused) {
          self.update(self._watcher.value);
        }
      });
    };

    // apply debounce
    if (debounce) {
      this.listener = _debounce(this.listener, debounce);
    }

    // Support jQuery events, since jQuery.trigger() doesn't
    // trigger native events in some cases and some plugins
    // rely on $.trigger()
    //
    // We want to make sure if a listener is attached using
    // jQuery, it is also removed with jQuery, that's why
    // we do the check for each directive instance and
    // store that check result on itself. This also allows
    // easier test coverage control by unsetting the global
    // jQuery variable in tests.
    this.hasjQuery = typeof jQuery === 'function';
    if (this.hasjQuery) {
      var method = jQuery.fn.on ? 'on' : 'bind';
      jQuery(el)[method]('change', this.rawListener);
      if (!lazy) {
        jQuery(el)[method]('input', this.listener);
      }
    } else {
      this.on('change', this.rawListener);
      if (!lazy) {
        this.on('input', this.listener);
      }
    }

    // IE9 doesn't fire input event on backspace/del/cut
    if (!lazy && isIE9) {
      this.on('cut', function () {
        nextTick(self.listener);
      });
      this.on('keyup', function (e) {
        if (e.keyCode === 46 || e.keyCode === 8) {
          self.listener();
        }
      });
    }

    // set initial value if present
    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
      this.afterBind = this.listener;
    }
  },

  update: function update(value) {
    this.el.value = _toString(value);
  },

  unbind: function unbind() {
    var el = this.el;
    if (this.hasjQuery) {
      var method = jQuery.fn.off ? 'off' : 'unbind';
      jQuery(el)[method]('change', this.listener);
      jQuery(el)[method]('input', this.listener);
    }
  }
};

var radio = {

  bind: function bind() {
    var self = this;
    var el = this.el;

    this.getValue = function () {
      // value overwrite via v-bind:value
      if (el.hasOwnProperty('_value')) {
        return el._value;
      }
      var val = el.value;
      if (self.params.number) {
        val = toNumber(val);
      }
      return val;
    };

    this.listener = function () {
      self.set(self.getValue());
    };
    this.on('change', this.listener);

    if (el.hasAttribute('checked')) {
      this.afterBind = this.listener;
    }
  },

  update: function update(value) {
    this.el.checked = looseEqual(value, this.getValue());
  }
};

var select = {

  bind: function bind() {
    var self = this;
    var el = this.el;

    // method to force update DOM using latest value.
    this.forceUpdate = function () {
      if (self._watcher) {
        self.update(self._watcher.get());
      }
    };

    // check if this is a multiple select
    var multiple = this.multiple = el.hasAttribute('multiple');

    // attach listener
    this.listener = function () {
      var value = getValue(el, multiple);
      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
      self.set(value);
    };
    this.on('change', this.listener);

    // if has initial value, set afterBind
    var initValue = getValue(el, multiple, true);
    if (multiple && initValue.length || !multiple && initValue !== null) {
      this.afterBind = this.listener;
    }

    // All major browsers except Firefox resets
    // selectedIndex with value -1 to 0 when the element
    // is appended to a new parent, therefore we have to
    // force a DOM update whenever that happens...
    this.vm.$on('hook:attached', this.forceUpdate);
  },

  update: function update(value) {
    var el = this.el;
    el.selectedIndex = -1;
    var multi = this.multiple && isArray(value);
    var options = el.options;
    var i = options.length;
    var op, val;
    while (i--) {
      op = options[i];
      val = op.hasOwnProperty('_value') ? op._value : op.value;
      /* eslint-disable eqeqeq */
      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
      /* eslint-enable eqeqeq */
    }
  },

  unbind: function unbind() {
    /* istanbul ignore next */
    this.vm.$off('hook:attached', this.forceUpdate);
  }
};

/**
 * Get select value
 *
 * @param {SelectElement} el
 * @param {Boolean} multi
 * @param {Boolean} init
 * @return {Array|*}
 */

function getValue(el, multi, init) {
  var res = multi ? [] : null;
  var op, val, selected;
  for (var i = 0, l = el.options.length; i < l; i++) {
    op = el.options[i];
    selected = init ? op.hasAttribute('selected') : op.selected;
    if (selected) {
      val = op.hasOwnProperty('_value') ? op._value : op.value;
      if (multi) {
        res.push(val);
      } else {
        return val;
      }
    }
  }
  return res;
}

/**
 * Native Array.indexOf uses strict equal, but in this
 * case we need to match string/numbers with custom equal.
 *
 * @param {Array} arr
 * @param {*} val
 */

function indexOf$1(arr, val) {
  var i = arr.length;
  while (i--) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

var checkbox = {

  bind: function bind() {
    var self = this;
    var el = this.el;

    this.getValue = function () {
      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
    };

    function getBooleanValue() {
      var val = el.checked;
      if (val && el.hasOwnProperty('_trueValue')) {
        return el._trueValue;
      }
      if (!val && el.hasOwnProperty('_falseValue')) {
        return el._falseValue;
      }
      return val;
    }

    this.listener = function () {
      var model = self._watcher.value;
      if (isArray(model)) {
        var val = self.getValue();
        if (el.checked) {
          if (indexOf(model, val) < 0) {
            model.push(val);
          }
        } else {
          model.$remove(val);
        }
      } else {
        self.set(getBooleanValue());
      }
    };

    this.on('change', this.listener);
    if (el.hasAttribute('checked')) {
      this.afterBind = this.listener;
    }
  },

  update: function update(value) {
    var el = this.el;
    if (isArray(value)) {
      el.checked = indexOf(value, this.getValue()) > -1;
    } else {
      if (el.hasOwnProperty('_trueValue')) {
        el.checked = looseEqual(value, el._trueValue);
      } else {
        el.checked = !!value;
      }
    }
  }
};

var handlers = {
  text: text$2,
  radio: radio,
  select: select,
  checkbox: checkbox
};

var model = {

  priority: MODEL,
  twoWay: true,
  handlers: handlers,
  params: ['lazy', 'number', 'debounce'],

  /**
   * Possible elements:
   *   <select>
   *   <textarea>
   *   <input type="*">
   *     - text
   *     - checkbox
   *     - radio
   *     - number
   */

  bind: function bind() {
    // friendly warning...
    this.checkFilters();
    if (this.hasRead && !this.hasWrite) {
      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model. You might want to use a two-way filter ' + 'to ensure correct behavior.');
    }
    var el = this.el;
    var tag = el.tagName;
    var handler;
    if (tag === 'INPUT') {
      handler = handlers[el.type] || handlers.text;
    } else if (tag === 'SELECT') {
      handler = handlers.select;
    } else if (tag === 'TEXTAREA') {
      handler = handlers.text;
    } else {
      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag);
      return;
    }
    el.__v_model = this;
    handler.bind.call(this);
    this.update = handler.update;
    this._unbind = handler.unbind;
  },

  /**
   * Check read/write filter stats.
   */

  checkFilters: function checkFilters() {
    var filters = this.filters;
    if (!filters) return;
    var i = filters.length;
    while (i--) {
      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
      if (typeof filter === 'function' || filter.read) {
        this.hasRead = true;
      }
      if (filter.write) {
        this.hasWrite = true;
      }
    }
  },

  unbind: function unbind() {
    this.el.__v_model = null;
    this._unbind && this._unbind();
  }
};

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  'delete': [8, 46],
  up: 38,
  left: 37,
  right: 39,
  down: 40
};

function keyFilter(handler, keys) {
  var codes = keys.map(function (key) {
    var charCode = key.charCodeAt(0);
    if (charCode > 47 && charCode < 58) {
      return parseInt(key, 10);
    }
    if (key.length === 1) {
      charCode = key.toUpperCase().charCodeAt(0);
      if (charCode > 64 && charCode < 91) {
        return charCode;
      }
    }
    return keyCodes[key];
  });
  codes = [].concat.apply([], codes);
  return function keyHandler(e) {
    if (codes.indexOf(e.keyCode) > -1) {
      return handler.call(this, e);
    }
  };
}

function stopFilter(handler) {
  return function stopHandler(e) {
    e.stopPropagation();
    return handler.call(this, e);
  };
}

function preventFilter(handler) {
  return function preventHandler(e) {
    e.preventDefault();
    return handler.call(this, e);
  };
}

function selfFilter(handler) {
  return function selfHandler(e) {
    if (e.target === e.currentTarget) {
      return handler.call(this, e);
    }
  };
}

var on$1 = {

  priority: ON,
  acceptStatement: true,
  keyCodes: keyCodes,

  bind: function bind() {
    // deal with iframes
    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
      var self = this;
      this.iframeBind = function () {
        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);
      };
      this.on('load', this.iframeBind);
    }
  },

  update: function update(handler) {
    // stub a noop for v-on with no value,
    // e.g. @mousedown.prevent
    if (!this.descriptor.raw) {
      handler = function () {};
    }

    if (typeof handler !== 'function') {
      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler);
      return;
    }

    // apply modifiers
    if (this.modifiers.stop) {
      handler = stopFilter(handler);
    }
    if (this.modifiers.prevent) {
      handler = preventFilter(handler);
    }
    if (this.modifiers.self) {
      handler = selfFilter(handler);
    }
    // key filter
    var keys = Object.keys(this.modifiers).filter(function (key) {
      return key !== 'stop' && key !== 'prevent' && key !== 'self';
    });
    if (keys.length) {
      handler = keyFilter(handler, keys);
    }

    this.reset();
    this.handler = handler;

    if (this.iframeBind) {
      this.iframeBind();
    } else {
      on(this.el, this.arg, this.handler, this.modifiers.capture);
    }
  },

  reset: function reset() {
    var el = this.iframeBind ? this.el.contentWindow : this.el;
    if (this.handler) {
      off(el, this.arg, this.handler);
    }
  },

  unbind: function unbind() {
    this.reset();
  }
};

var prefixes = ['-webkit-', '-moz-', '-ms-'];
var camelPrefixes = ['Webkit', 'Moz', 'ms'];
var importantRE = /!important;?$/;
var propCache = Object.create(null);

var testEl = null;

var style = {

  deep: true,

  update: function update(value) {
    if (typeof value === 'string') {
      this.el.style.cssText = value;
    } else if (isArray(value)) {
      this.handleObject(value.reduce(extend, {}));
    } else {
      this.handleObject(value || {});
    }
  },

  handleObject: function handleObject(value) {
    // cache object styles so that only changed props
    // are actually updated.
    var cache = this.cache || (this.cache = {});
    var name, val;
    for (name in cache) {
      if (!(name in value)) {
        this.handleSingle(name, null);
        delete cache[name];
      }
    }
    for (name in value) {
      val = value[name];
      if (val !== cache[name]) {
        cache[name] = val;
        this.handleSingle(name, val);
      }
    }
  },

  handleSingle: function handleSingle(prop, value) {
    prop = normalize(prop);
    if (!prop) return; // unsupported prop
    // cast possible numbers/booleans into strings
    if (value != null) value += '';
    if (value) {
      var isImportant = importantRE.test(value) ? 'important' : '';
      if (isImportant) {
        value = value.replace(importantRE, '').trim();
      }
      this.el.style.setProperty(prop, value, isImportant);
    } else {
      this.el.style.removeProperty(prop);
    }
  }

};

/**
 * Normalize a CSS property name.
 * - cache result
 * - auto prefix
 * - camelCase -> dash-case
 *
 * @param {String} prop
 * @return {String}
 */

function normalize(prop) {
  if (propCache[prop]) {
    return propCache[prop];
  }
  var res = prefix(prop);
  propCache[prop] = propCache[res] = res;
  return res;
}

/**
 * Auto detect the appropriate prefix for a CSS property.
 * https://gist.github.com/paulirish/523692
 *
 * @param {String} prop
 * @return {String}
 */

function prefix(prop) {
  prop = hyphenate(prop);
  var camel = camelize(prop);
  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
  if (!testEl) {
    testEl = document.createElement('div');
  }
  var i = prefixes.length;
  var prefixed;
  while (i--) {
    prefixed = camelPrefixes[i] + upper;
    if (prefixed in testEl.style) {
      return prefixes[i] + prop;
    }
  }
  if (camel in testEl.style) {
    return prop;
  }
}

// xlink
var xlinkNS = 'http://www.w3.org/1999/xlink';
var xlinkRE = /^xlink:/;

// check for attributes that prohibit interpolations
var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
// these attributes should also set their corresponding properties
// because they only affect the initial state of the element
var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;
// these attributes expect enumrated values of "true" or "false"
// but are not boolean attributes
var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;

// these attributes should set a hidden property for
// binding v-model to object values
var modelProps = {
  value: '_value',
  'true-value': '_trueValue',
  'false-value': '_falseValue'
};

var bind$1 = {

  priority: BIND,

  bind: function bind() {
    var attr = this.arg;
    var tag = this.el.tagName;
    // should be deep watch on object mode
    if (!attr) {
      this.deep = true;
    }
    // handle interpolation bindings
    var descriptor = this.descriptor;
    var tokens = descriptor.interp;
    if (tokens) {
      // handle interpolations with one-time tokens
      if (descriptor.hasOneTime) {
        this.expression = tokensToExp(tokens, this._scope || this.vm);
      }

      // only allow binding on native attributes
      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
        process.env.NODE_ENV !== 'production' && warn(attr + '="' + descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.');
        this.el.removeAttribute(attr);
        this.invalid = true;
      }

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production') {
        var raw = attr + '="' + descriptor.raw + '": ';
        // warn src
        if (attr === 'src') {
          warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.');
        }

        // warn style
        if (attr === 'style') {
          warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.');
        }
      }
    }
  },

  update: function update(value) {
    if (this.invalid) {
      return;
    }
    var attr = this.arg;
    if (this.arg) {
      this.handleSingle(attr, value);
    } else {
      this.handleObject(value || {});
    }
  },

  // share object handler with v-bind:class
  handleObject: style.handleObject,

  handleSingle: function handleSingle(attr, value) {
    var el = this.el;
    var interp = this.descriptor.interp;
    if (this.modifiers.camel) {
      attr = camelize(attr);
    }
    if (!interp && attrWithPropsRE.test(attr) && attr in el) {
      el[attr] = attr === 'value' ? value == null // IE9 will set input.value to "null" for null...
      ? '' : value : value;
    }
    // set model props
    var modelProp = modelProps[attr];
    if (!interp && modelProp) {
      el[modelProp] = value;
      // update v-model if present
      var model = el.__v_model;
      if (model) {
        model.listener();
      }
    }
    // do not set value attribute for textarea
    if (attr === 'value' && el.tagName === 'TEXTAREA') {
      el.removeAttribute(attr);
      return;
    }
    // update attribute
    if (enumeratedAttrRE.test(attr)) {
      el.setAttribute(attr, value ? 'true' : 'false');
    } else if (value != null && value !== false) {
      if (attr === 'class') {
        // handle edge case #1960:
        // class interpolation should not overwrite Vue transition class
        if (el.__v_trans) {
          value += ' ' + el.__v_trans.id + '-transition';
        }
        setClass(el, value);
      } else if (xlinkRE.test(attr)) {
        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);
      } else {
        el.setAttribute(attr, value === true ? '' : value);
      }
    } else {
      el.removeAttribute(attr);
    }
  }
};

var el = {

  priority: EL,

  bind: function bind() {
    /* istanbul ignore if */
    if (!this.arg) {
      return;
    }
    var id = this.id = camelize(this.arg);
    var refs = (this._scope || this.vm).$els;
    if (hasOwn(refs, id)) {
      refs[id] = this.el;
    } else {
      defineReactive(refs, id, this.el);
    }
  },

  unbind: function unbind() {
    var refs = (this._scope || this.vm).$els;
    if (refs[this.id] === this.el) {
      refs[this.id] = null;
    }
  }
};

var ref = {
  bind: function bind() {
    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.');
  }
};

var cloak = {
  bind: function bind() {
    var el = this.el;
    this.vm.$once('pre-hook:compiled', function () {
      el.removeAttribute('v-cloak');
    });
  }
};

// must export plain object
var directives = {
  text: text$1,
  html: html,
  'for': vFor,
  'if': vIf,
  show: show,
  model: model,
  on: on$1,
  bind: bind$1,
  el: el,
  ref: ref,
  cloak: cloak
};

var vClass = {

  deep: true,

  update: function update(value) {
    if (value && typeof value === 'string') {
      this.handleObject(stringToObject(value));
    } else if (isPlainObject(value)) {
      this.handleObject(value);
    } else if (isArray(value)) {
      this.handleArray(value);
    } else {
      this.cleanup();
    }
  },

  handleObject: function handleObject(value) {
    this.cleanup(value);
    var keys = this.prevKeys = Object.keys(value);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      if (value[key]) {
        addClass(this.el, key);
      } else {
        removeClass(this.el, key);
      }
    }
  },

  handleArray: function handleArray(value) {
    this.cleanup(value);
    for (var i = 0, l = value.length; i < l; i++) {
      if (value[i]) {
        addClass(this.el, value[i]);
      }
    }
    this.prevKeys = value.slice();
  },

  cleanup: function cleanup(value) {
    if (this.prevKeys) {
      var i = this.prevKeys.length;
      while (i--) {
        var key = this.prevKeys[i];
        if (key && (!value || !contains(value, key))) {
          removeClass(this.el, key);
        }
      }
    }
  }
};

function stringToObject(value) {
  var res = {};
  var keys = value.trim().split(/\s+/);
  var i = keys.length;
  while (i--) {
    res[keys[i]] = true;
  }
  return res;
}

function contains(value, key) {
  return isArray(value) ? value.indexOf(key) > -1 : hasOwn(value, key);
}

var component = {

  priority: COMPONENT,

  params: ['keep-alive', 'transition-mode', 'inline-template'],

  /**
   * Setup. Two possible usages:
   *
   * - static:
   *   <comp> or <div v-component="comp">
   *
   * - dynamic:
   *   <component :is="view">
   */

  bind: function bind() {
    if (!this.el.__vue__) {
      // keep-alive cache
      this.keepAlive = this.params.keepAlive;
      if (this.keepAlive) {
        this.cache = {};
      }
      // check inline-template
      if (this.params.inlineTemplate) {
        // extract inline template as a DocumentFragment
        this.inlineTemplate = extractContent(this.el, true);
      }
      // component resolution related state
      this.pendingComponentCb = this.Component = null;
      // transition related state
      this.pendingRemovals = 0;
      this.pendingRemovalCb = null;
      // create a ref anchor
      this.anchor = createAnchor('v-component');
      replace(this.el, this.anchor);
      // remove is attribute.
      // this is removed during compilation, but because compilation is
      // cached, when the component is used elsewhere this attribute
      // will remain at link time.
      this.el.removeAttribute('is');
      // remove ref, same as above
      if (this.descriptor.ref) {
        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
      }
      // if static, build right now.
      if (this.literal) {
        this.setComponent(this.expression);
      }
    } else {
      process.env.NODE_ENV !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
    }
  },

  /**
   * Public update, called by the watcher in the dynamic
   * literal scenario, e.g. <component :is="view">
   */

  update: function update(value) {
    if (!this.literal) {
      this.setComponent(value);
    }
  },

  /**
   * Switch dynamic components. May resolve the component
   * asynchronously, and perform transition based on
   * specified transition mode. Accepts a few additional
   * arguments specifically for vue-router.
   *
   * The callback is called when the full transition is
   * finished.
   *
   * @param {String} value
   * @param {Function} [cb]
   */

  setComponent: function setComponent(value, cb) {
    this.invalidatePending();
    if (!value) {
      // just remove current
      this.unbuild(true);
      this.remove(this.childVM, cb);
      this.childVM = null;
    } else {
      var self = this;
      this.resolveComponent(value, function () {
        self.mountComponent(cb);
      });
    }
  },

  /**
   * Resolve the component constructor to use when creating
   * the child vm.
   */

  resolveComponent: function resolveComponent(id, cb) {
    var self = this;
    this.pendingComponentCb = cancellable(function (Component) {
      self.ComponentName = Component.options.name || id;
      self.Component = Component;
      cb();
    });
    this.vm._resolveComponent(id, this.pendingComponentCb);
  },

  /**
   * Create a new instance using the current constructor and
   * replace the existing instance. This method doesn't care
   * whether the new component and the old one are actually
   * the same.
   *
   * @param {Function} [cb]
   */

  mountComponent: function mountComponent(cb) {
    // actual mount
    this.unbuild(true);
    var self = this;
    var activateHooks = this.Component.options.activate;
    var cached = this.getCached();
    var newComponent = this.build();
    if (activateHooks && !cached) {
      this.waitingFor = newComponent;
      callActivateHooks(activateHooks, newComponent, function () {
        if (self.waitingFor !== newComponent) {
          return;
        }
        self.waitingFor = null;
        self.transition(newComponent, cb);
      });
    } else {
      // update ref for kept-alive component
      if (cached) {
        newComponent._updateRef();
      }
      this.transition(newComponent, cb);
    }
  },

  /**
   * When the component changes or unbinds before an async
   * constructor is resolved, we need to invalidate its
   * pending callback.
   */

  invalidatePending: function invalidatePending() {
    if (this.pendingComponentCb) {
      this.pendingComponentCb.cancel();
      this.pendingComponentCb = null;
    }
  },

  /**
   * Instantiate/insert a new child vm.
   * If keep alive and has cached instance, insert that
   * instance; otherwise build a new one and cache it.
   *
   * @param {Object} [extraOptions]
   * @return {Vue} - the created instance
   */

  build: function build(extraOptions) {
    var cached = this.getCached();
    if (cached) {
      return cached;
    }
    if (this.Component) {
      // default options
      var options = {
        name: this.ComponentName,
        el: cloneNode(this.el),
        template: this.inlineTemplate,
        // make sure to add the child with correct parent
        // if this is a transcluded component, its parent
        // should be the transclusion host.
        parent: this._host || this.vm,
        // if no inline-template, then the compiled
        // linker can be cached for better performance.
        _linkerCachable: !this.inlineTemplate,
        _ref: this.descriptor.ref,
        _asComponent: true,
        _isRouterView: this._isRouterView,
        // if this is a transcluded component, context
        // will be the common parent vm of this instance
        // and its host.
        _context: this.vm,
        // if this is inside an inline v-for, the scope
        // will be the intermediate scope created for this
        // repeat fragment. this is used for linking props
        // and container directives.
        _scope: this._scope,
        // pass in the owner fragment of this component.
        // this is necessary so that the fragment can keep
        // track of its contained components in order to
        // call attach/detach hooks for them.
        _frag: this._frag
      };
      // extra options
      // in 1.0.0 this is used by vue-router only
      /* istanbul ignore if */
      if (extraOptions) {
        extend(options, extraOptions);
      }
      var child = new this.Component(options);
      if (this.keepAlive) {
        this.cache[this.Component.cid] = child;
      }
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template);
      }
      return child;
    }
  },

  /**
   * Try to get a cached instance of the current component.
   *
   * @return {Vue|undefined}
   */

  getCached: function getCached() {
    return this.keepAlive && this.cache[this.Component.cid];
  },

  /**
   * Teardown the current child, but defers cleanup so
   * that we can separate the destroy and removal steps.
   *
   * @param {Boolean} defer
   */

  unbuild: function unbuild(defer) {
    if (this.waitingFor) {
      this.waitingFor.$destroy();
      this.waitingFor = null;
    }
    var child = this.childVM;
    if (!child || this.keepAlive) {
      if (child) {
        // remove ref
        child._inactive = true;
        child._updateRef(true);
      }
      return;
    }
    // the sole purpose of `deferCleanup` is so that we can
    // "deactivate" the vm right now and perform DOM removal
    // later.
    child.$destroy(false, defer);
  },

  /**
   * Remove current destroyed child and manually do
   * the cleanup after removal.
   *
   * @param {Function} cb
   */

  remove: function remove(child, cb) {
    var keepAlive = this.keepAlive;
    if (child) {
      // we may have a component switch when a previous
      // component is still being transitioned out.
      // we want to trigger only one lastest insertion cb
      // when the existing transition finishes. (#1119)
      this.pendingRemovals++;
      this.pendingRemovalCb = cb;
      var self = this;
      child.$remove(function () {
        self.pendingRemovals--;
        if (!keepAlive) child._cleanup();
        if (!self.pendingRemovals && self.pendingRemovalCb) {
          self.pendingRemovalCb();
          self.pendingRemovalCb = null;
        }
      });
    } else if (cb) {
      cb();
    }
  },

  /**
   * Actually swap the components, depending on the
   * transition mode. Defaults to simultaneous.
   *
   * @param {Vue} target
   * @param {Function} [cb]
   */

  transition: function transition(target, cb) {
    var self = this;
    var current = this.childVM;
    // for devtool inspection
    if (current) current._inactive = true;
    target._inactive = false;
    this.childVM = target;
    switch (self.params.transitionMode) {
      case 'in-out':
        target.$before(self.anchor, function () {
          self.remove(current, cb);
        });
        break;
      case 'out-in':
        self.remove(current, function () {
          target.$before(self.anchor, cb);
        });
        break;
      default:
        self.remove(current);
        target.$before(self.anchor, cb);
    }
  },

  /**
   * Unbind.
   */

  unbind: function unbind() {
    this.invalidatePending();
    // Do not defer cleanup when unbinding
    this.unbuild();
    // destroy all keep-alive cached instances
    if (this.cache) {
      for (var key in this.cache) {
        this.cache[key].$destroy();
      }
      this.cache = null;
    }
  }
};

/**
 * Call activate hooks in order (asynchronous)
 *
 * @param {Array} hooks
 * @param {Vue} vm
 * @param {Function} cb
 */

function callActivateHooks(hooks, vm, cb) {
  var total = hooks.length;
  var called = 0;
  hooks[0].call(vm, next);
  function next() {
    if (++called >= total) {
      cb();
    } else {
      hooks[called].call(vm, next);
    }
  }
}

var bindingModes = config._propBindingModes;

var propDef = {

  bind: function bind() {
    var child = this.vm;
    var parent = child._context;
    // passed in from compiler directly
    var prop = this.descriptor.prop;
    var childKey = prop.path;
    var parentKey = prop.parentPath;
    var twoWay = prop.mode === bindingModes.TWO_WAY;

    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
      val = coerceProp(prop, val);
      if (assertProp(prop, val)) {
        child[childKey] = val;
      }
    }, {
      twoWay: twoWay,
      filters: prop.filters,
      // important: props need to be observed on the
      // v-for scope if present
      scope: this._scope
    });

    // set the child initial value.
    initProp(child, prop, parentWatcher.value);

    // setup two-way binding
    if (twoWay) {
      // important: defer the child watcher creation until
      // the created hook (after data observation)
      var self = this;
      child.$once('pre-hook:created', function () {
        self.childWatcher = new Watcher(child, childKey, function (val) {
          parentWatcher.set(val);
        }, {
          // ensure sync upward before parent sync down.
          // this is necessary in cases e.g. the child
          // mutates a prop array, then replaces it. (#1683)
          sync: true
        });
      });
    }
  },

  unbind: function unbind() {
    this.parentWatcher.teardown();
    if (this.childWatcher) {
      this.childWatcher.teardown();
    }
  }
};

var queue$1 = [];
var queued = false;

/**
 * Push a job into the queue.
 *
 * @param {Function} job
 */

function pushJob(job) {
  queue$1.push(job);
  if (!queued) {
    queued = true;
    nextTick(flush);
  }
}

/**
 * Flush the queue, and do one forced reflow before
 * triggering transitions.
 */

function flush() {
  // Force layout
  var f = document.documentElement.offsetHeight;
  for (var i = 0; i < queue$1.length; i++) {
    queue$1[i]();
  }
  queue$1 = [];
  queued = false;
  // dummy return, so js linters don't complain about
  // unused variable f
  return f;
}

var TYPE_TRANSITION = 'transition';
var TYPE_ANIMATION = 'animation';
var transDurationProp = transitionProp + 'Duration';
var animDurationProp = animationProp + 'Duration';

/**
 * A Transition object that encapsulates the state and logic
 * of the transition.
 *
 * @param {Element} el
 * @param {String} id
 * @param {Object} hooks
 * @param {Vue} vm
 */
function Transition(el, id, hooks, vm) {
  this.id = id;
  this.el = el;
  this.enterClass = hooks && hooks.enterClass || id + '-enter';
  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';
  this.hooks = hooks;
  this.vm = vm;
  // async state
  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
  this.justEntered = false;
  this.entered = this.left = false;
  this.typeCache = {};
  // check css transition type
  this.type = hooks && hooks.type;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production') {
    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {
      warn('invalid CSS transition type for transition="' + this.id + '": ' + this.type);
    }
  }
  // bind
  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
    self[m] = bind(self[m], self);
  });
}

var p$1 = Transition.prototype;

/**
 * Start an entering transition.
 *
 * 1. enter transition triggered
 * 2. call beforeEnter hook
 * 3. add enter class
 * 4. insert/show element
 * 5. call enter hook (with possible explicit js callback)
 * 6. reflow
 * 7. based on transition type:
 *    - transition:
 *        remove class now, wait for transitionend,
 *        then done if there's no explicit js callback.
 *    - animation:
 *        wait for animationend, remove class,
 *        then done if there's no explicit js callback.
 *    - no css transition:
 *        done now if there's no explicit js callback.
 * 8. wait for either done or js callback, then call
 *    afterEnter hook.
 *
 * @param {Function} op - insert/show the element
 * @param {Function} [cb]
 */

p$1.enter = function (op, cb) {
  this.cancelPending();
  this.callHook('beforeEnter');
  this.cb = cb;
  addClass(this.el, this.enterClass);
  op();
  this.entered = false;
  this.callHookWithCb('enter');
  if (this.entered) {
    return; // user called done synchronously.
  }
  this.cancel = this.hooks && this.hooks.enterCancelled;
  pushJob(this.enterNextTick);
};

/**
 * The "nextTick" phase of an entering transition, which is
 * to be pushed into a queue and executed after a reflow so
 * that removing the class can trigger a CSS transition.
 */

p$1.enterNextTick = function () {
  // Important hack:
  // in Chrome, if a just-entered element is applied the
  // leave class while its interpolated property still has
  // a very small value (within one frame), Chrome will
  // skip the leave transition entirely and not firing the
  // transtionend event. Therefore we need to protected
  // against such cases using a one-frame timeout.
  this.justEntered = true;
  var self = this;
  setTimeout(function () {
    self.justEntered = false;
  }, 17);

  var enterDone = this.enterDone;
  var type = this.getCssTransitionType(this.enterClass);
  if (!this.pendingJsCb) {
    if (type === TYPE_TRANSITION) {
      // trigger transition by removing enter class now
      removeClass(this.el, this.enterClass);
      this.setupCssCb(transitionEndEvent, enterDone);
    } else if (type === TYPE_ANIMATION) {
      this.setupCssCb(animationEndEvent, enterDone);
    } else {
      enterDone();
    }
  } else if (type === TYPE_TRANSITION) {
    removeClass(this.el, this.enterClass);
  }
};

/**
 * The "cleanup" phase of an entering transition.
 */

p$1.enterDone = function () {
  this.entered = true;
  this.cancel = this.pendingJsCb = null;
  removeClass(this.el, this.enterClass);
  this.callHook('afterEnter');
  if (this.cb) this.cb();
};

/**
 * Start a leaving transition.
 *
 * 1. leave transition triggered.
 * 2. call beforeLeave hook
 * 3. add leave class (trigger css transition)
 * 4. call leave hook (with possible explicit js callback)
 * 5. reflow if no explicit js callback is provided
 * 6. based on transition type:
 *    - transition or animation:
 *        wait for end event, remove class, then done if
 *        there's no explicit js callback.
 *    - no css transition:
 *        done if there's no explicit js callback.
 * 7. wait for either done or js callback, then call
 *    afterLeave hook.
 *
 * @param {Function} op - remove/hide the element
 * @param {Function} [cb]
 */

p$1.leave = function (op, cb) {
  this.cancelPending();
  this.callHook('beforeLeave');
  this.op = op;
  this.cb = cb;
  addClass(this.el, this.leaveClass);
  this.left = false;
  this.callHookWithCb('leave');
  if (this.left) {
    return; // user called done synchronously.
  }
  this.cancel = this.hooks && this.hooks.leaveCancelled;
  // only need to handle leaveDone if
  // 1. the transition is already done (synchronously called
  //    by the user, which causes this.op set to null)
  // 2. there's no explicit js callback
  if (this.op && !this.pendingJsCb) {
    // if a CSS transition leaves immediately after enter,
    // the transitionend event never fires. therefore we
    // detect such cases and end the leave immediately.
    if (this.justEntered) {
      this.leaveDone();
    } else {
      pushJob(this.leaveNextTick);
    }
  }
};

/**
 * The "nextTick" phase of a leaving transition.
 */

p$1.leaveNextTick = function () {
  var type = this.getCssTransitionType(this.leaveClass);
  if (type) {
    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
    this.setupCssCb(event, this.leaveDone);
  } else {
    this.leaveDone();
  }
};

/**
 * The "cleanup" phase of a leaving transition.
 */

p$1.leaveDone = function () {
  this.left = true;
  this.cancel = this.pendingJsCb = null;
  this.op();
  removeClass(this.el, this.leaveClass);
  this.callHook('afterLeave');
  if (this.cb) this.cb();
  this.op = null;
};

/**
 * Cancel any pending callbacks from a previously running
 * but not finished transition.
 */

p$1.cancelPending = function () {
  this.op = this.cb = null;
  var hasPending = false;
  if (this.pendingCssCb) {
    hasPending = true;
    off(this.el, this.pendingCssEvent, this.pendingCssCb);
    this.pendingCssEvent = this.pendingCssCb = null;
  }
  if (this.pendingJsCb) {
    hasPending = true;
    this.pendingJsCb.cancel();
    this.pendingJsCb = null;
  }
  if (hasPending) {
    removeClass(this.el, this.enterClass);
    removeClass(this.el, this.leaveClass);
  }
  if (this.cancel) {
    this.cancel.call(this.vm, this.el);
    this.cancel = null;
  }
};

/**
 * Call a user-provided synchronous hook function.
 *
 * @param {String} type
 */

p$1.callHook = function (type) {
  if (this.hooks && this.hooks[type]) {
    this.hooks[type].call(this.vm, this.el);
  }
};

/**
 * Call a user-provided, potentially-async hook function.
 * We check for the length of arguments to see if the hook
 * expects a `done` callback. If true, the transition's end
 * will be determined by when the user calls that callback;
 * otherwise, the end is determined by the CSS transition or
 * animation.
 *
 * @param {String} type
 */

p$1.callHookWithCb = function (type) {
  var hook = this.hooks && this.hooks[type];
  if (hook) {
    if (hook.length > 1) {
      this.pendingJsCb = cancellable(this[type + 'Done']);
    }
    hook.call(this.vm, this.el, this.pendingJsCb);
  }
};

/**
 * Get an element's transition type based on the
 * calculated styles.
 *
 * @param {String} className
 * @return {Number}
 */

p$1.getCssTransitionType = function (className) {
  /* istanbul ignore if */
  if (!transitionEndEvent ||
  // skip CSS transitions if page is not visible -
  // this solves the issue of transitionend events not
  // firing until the page is visible again.
  // pageVisibility API is supported in IE10+, same as
  // CSS transitions.
  document.hidden ||
  // explicit js-only transition
  this.hooks && this.hooks.css === false ||
  // element is hidden
  isHidden(this.el)) {
    return;
  }
  var type = this.type || this.typeCache[className];
  if (type) return type;
  var inlineStyles = this.el.style;
  var computedStyles = window.getComputedStyle(this.el);
  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
  if (transDuration && transDuration !== '0s') {
    type = TYPE_TRANSITION;
  } else {
    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
    if (animDuration && animDuration !== '0s') {
      type = TYPE_ANIMATION;
    }
  }
  if (type) {
    this.typeCache[className] = type;
  }
  return type;
};

/**
 * Setup a CSS transitionend/animationend callback.
 *
 * @param {String} event
 * @param {Function} cb
 */

p$1.setupCssCb = function (event, cb) {
  this.pendingCssEvent = event;
  var self = this;
  var el = this.el;
  var onEnd = this.pendingCssCb = function (e) {
    if (e.target === el) {
      off(el, event, onEnd);
      self.pendingCssEvent = self.pendingCssCb = null;
      if (!self.pendingJsCb && cb) {
        cb();
      }
    }
  };
  on(el, event, onEnd);
};

/**
 * Check if an element is hidden - in that case we can just
 * skip the transition alltogether.
 *
 * @param {Element} el
 * @return {Boolean}
 */

function isHidden(el) {
  if (/svg$/.test(el.namespaceURI)) {
    // SVG elements do not have offset(Width|Height)
    // so we need to check the client rect
    var rect = el.getBoundingClientRect();
    return !(rect.width || rect.height);
  } else {
    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
  }
}

var transition$1 = {

  priority: TRANSITION,

  update: function update(id, oldId) {
    var el = this.el;
    // resolve on owner vm
    var hooks = resolveAsset(this.vm.$options, 'transitions', id);
    id = id || 'v';
    el.__v_trans = new Transition(el, id, hooks, this.vm);
    if (oldId) {
      removeClass(el, oldId + '-transition');
    }
    addClass(el, id + '-transition');
  }
};

var internalDirectives = {
  style: style,
  'class': vClass,
  component: component,
  prop: propDef,
  transition: transition$1
};

var propBindingModes = config._propBindingModes;
var empty = {};

// regexes
var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;

/**
 * Compile props on a root element and return
 * a props link function.
 *
 * @param {Element|DocumentFragment} el
 * @param {Array} propOptions
 * @return {Function} propsLinkFn
 */

function compileProps(el, propOptions) {
  var props = [];
  var names = Object.keys(propOptions);
  var i = names.length;
  var options, name, attr, value, path, parsed, prop;
  while (i--) {
    name = names[i];
    options = propOptions[name] || empty;

    if (process.env.NODE_ENV !== 'production' && name === '$data') {
      warn('Do not use $data as prop.');
      continue;
    }

    // props could contain dashes, which will be
    // interpreted as minus calculations by the parser
    // so we need to camelize the path here
    path = camelize(name);
    if (!identRE$1.test(path)) {
      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.');
      continue;
    }

    prop = {
      name: name,
      path: path,
      options: options,
      mode: propBindingModes.ONE_WAY,
      raw: null
    };

    attr = hyphenate(name);
    // first check dynamic version
    if ((value = getBindAttr(el, attr)) === null) {
      if ((value = getBindAttr(el, attr + '.sync')) !== null) {
        prop.mode = propBindingModes.TWO_WAY;
      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
        prop.mode = propBindingModes.ONE_TIME;
      }
    }
    if (value !== null) {
      // has dynamic binding!
      prop.raw = value;
      parsed = parseDirective(value);
      value = parsed.expression;
      prop.filters = parsed.filters;
      // check binding type
      if (isLiteral(value) && !parsed.filters) {
        // for expressions containing literal numbers and
        // booleans, there's no need to setup a prop binding,
        // so we can optimize them as a one-time set.
        prop.optimizedLiteral = true;
      } else {
        prop.dynamic = true;
        // check non-settable path for two-way bindings
        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
          prop.mode = propBindingModes.ONE_WAY;
          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value);
        }
      }
      prop.parentPath = value;

      // warn required two-way
      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
        warn('Prop "' + name + '" expects a two-way binding type.');
      }
    } else if ((value = getAttr(el, attr)) !== null) {
      // has literal binding!
      prop.raw = value;
    } else if (process.env.NODE_ENV !== 'production') {
      // check possible camelCase prop usage
      var lowerCaseName = path.toLowerCase();
      value = /[A-Z\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));
      if (value) {
        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.');
      } else if (options.required) {
        // warn missing required
        warn('Missing required prop: ' + name);
      }
    }
    // push prop
    props.push(prop);
  }
  return makePropsLinkFn(props);
}

/**
 * Build a function that applies props to a vm.
 *
 * @param {Array} props
 * @return {Function} propsLinkFn
 */

function makePropsLinkFn(props) {
  return function propsLinkFn(vm, scope) {
    // store resolved props info
    vm._props = {};
    var i = props.length;
    var prop, path, options, value, raw;
    while (i--) {
      prop = props[i];
      raw = prop.raw;
      path = prop.path;
      options = prop.options;
      vm._props[path] = prop;
      if (raw === null) {
        // initialize absent prop
        initProp(vm, prop, undefined);
      } else if (prop.dynamic) {
        // dynamic prop
        if (prop.mode === propBindingModes.ONE_TIME) {
          // one time binding
          value = (scope || vm._context || vm).$get(prop.parentPath);
          initProp(vm, prop, value);
        } else {
          if (vm._context) {
            // dynamic binding
            vm._bindDir({
              name: 'prop',
              def: propDef,
              prop: prop
            }, null, null, scope); // el, host, scope
          } else {
              // root instance
              initProp(vm, prop, vm.$get(prop.parentPath));
            }
        }
      } else if (prop.optimizedLiteral) {
        // optimized literal, cast it and just set once
        var stripped = stripQuotes(raw);
        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
        initProp(vm, prop, value);
      } else {
        // string literal, but we need to cater for
        // Boolean props with no value
        value = options.type === Boolean && raw === '' ? true : raw;
        initProp(vm, prop, value);
      }
    }
  };
}

// special binding prefixes
var bindRE = /^v-bind:|^:/;
var onRE = /^v-on:|^@/;
var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;
var modifierRE = /\.[^\.]+/g;
var transitionRE = /^(v-bind:|:)?transition$/;

// terminal directives
var terminalDirectives = ['for', 'if'];

// default directive priority
var DEFAULT_PRIORITY = 1000;

/**
 * Compile a template and return a reusable composite link
 * function, which recursively contains more link functions
 * inside. This top level compile function would normally
 * be called on instance root nodes, but can also be used
 * for partial compilation if the partial argument is true.
 *
 * The returned composite link function, when called, will
 * return an unlink function that tearsdown all directives
 * created during the linking phase.
 *
 * @param {Element|DocumentFragment} el
 * @param {Object} options
 * @param {Boolean} partial
 * @return {Function}
 */

function compile(el, options, partial) {
  // link function for the node itself.
  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
  // link function for the childNodes
  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && el.tagName !== 'SCRIPT' && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;

  /**
   * A composite linker function to be called on a already
   * compiled piece of DOM, which instantiates all directive
   * instances.
   *
   * @param {Vue} vm
   * @param {Element|DocumentFragment} el
   * @param {Vue} [host] - host vm of transcluded content
   * @param {Object} [scope] - v-for scope
   * @param {Fragment} [frag] - link context fragment
   * @return {Function|undefined}
   */

  return function compositeLinkFn(vm, el, host, scope, frag) {
    // cache childNodes before linking parent, fix #657
    var childNodes = toArray(el.childNodes);
    // link
    var dirs = linkAndCapture(function compositeLinkCapturer() {
      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
    }, vm);
    return makeUnlinkFn(vm, dirs);
  };
}

/**
 * Apply a linker to a vm/element pair and capture the
 * directives created during the process.
 *
 * @param {Function} linker
 * @param {Vue} vm
 */

function linkAndCapture(linker, vm) {
  /* istanbul ignore if */
  if (process.env.NODE_ENV === 'production') {
    // reset directives before every capture in production
    // mode, so that when unlinking we don't need to splice
    // them out (which turns out to be a perf hit).
    // they are kept in development mode because they are
    // useful for Vue's own tests.
    vm._directives = [];
  }
  var originalDirCount = vm._directives.length;
  linker();
  var dirs = vm._directives.slice(originalDirCount);
  dirs.sort(directiveComparator);
  for (var i = 0, l = dirs.length; i < l; i++) {
    dirs[i]._bind();
  }
  return dirs;
}

/**
 * Directive priority sort comparator
 *
 * @param {Object} a
 * @param {Object} b
 */

function directiveComparator(a, b) {
  a = a.descriptor.def.priority || DEFAULT_PRIORITY;
  b = b.descriptor.def.priority || DEFAULT_PRIORITY;
  return a > b ? -1 : a === b ? 0 : 1;
}

/**
 * Linker functions return an unlink function that
 * tearsdown all directives instances generated during
 * the process.
 *
 * We create unlink functions with only the necessary
 * information to avoid retaining additional closures.
 *
 * @param {Vue} vm
 * @param {Array} dirs
 * @param {Vue} [context]
 * @param {Array} [contextDirs]
 * @return {Function}
 */

function makeUnlinkFn(vm, dirs, context, contextDirs) {
  function unlink(destroying) {
    teardownDirs(vm, dirs, destroying);
    if (context && contextDirs) {
      teardownDirs(context, contextDirs);
    }
  }
  // expose linked directives
  unlink.dirs = dirs;
  return unlink;
}

/**
 * Teardown partial linked directives.
 *
 * @param {Vue} vm
 * @param {Array} dirs
 * @param {Boolean} destroying
 */

function teardownDirs(vm, dirs, destroying) {
  var i = dirs.length;
  while (i--) {
    dirs[i]._teardown();
    if (process.env.NODE_ENV !== 'production' && !destroying) {
      vm._directives.$remove(dirs[i]);
    }
  }
}

/**
 * Compile link props on an instance.
 *
 * @param {Vue} vm
 * @param {Element} el
 * @param {Object} props
 * @param {Object} [scope]
 * @return {Function}
 */

function compileAndLinkProps(vm, el, props, scope) {
  var propsLinkFn = compileProps(el, props);
  var propDirs = linkAndCapture(function () {
    propsLinkFn(vm, scope);
  }, vm);
  return makeUnlinkFn(vm, propDirs);
}

/**
 * Compile the root element of an instance.
 *
 * 1. attrs on context container (context scope)
 * 2. attrs on the component template root node, if
 *    replace:true (child scope)
 *
 * If this is a fragment instance, we only need to compile 1.
 *
 * @param {Element} el
 * @param {Object} options
 * @param {Object} contextOptions
 * @return {Function}
 */

function compileRoot(el, options, contextOptions) {
  var containerAttrs = options._containerAttrs;
  var replacerAttrs = options._replacerAttrs;
  var contextLinkFn, replacerLinkFn;

  // only need to compile other attributes for
  // non-fragment instances
  if (el.nodeType !== 11) {
    // for components, container and replacer need to be
    // compiled separately and linked in different scopes.
    if (options._asComponent) {
      // 2. container attributes
      if (containerAttrs && contextOptions) {
        contextLinkFn = compileDirectives(containerAttrs, contextOptions);
      }
      if (replacerAttrs) {
        // 3. replacer attributes
        replacerLinkFn = compileDirectives(replacerAttrs, options);
      }
    } else {
      // non-component, just compile as a normal element.
      replacerLinkFn = compileDirectives(el.attributes, options);
    }
  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {
    // warn container directives for fragment instances
    var names = containerAttrs.filter(function (attr) {
      // allow vue-loader/vueify scoped css attributes
      return attr.name.indexOf('_v-') < 0 &&
      // allow event listeners
      !onRE.test(attr.name) &&
      // allow slots
      attr.name !== 'slot';
    }).map(function (attr) {
      return '"' + attr.name + '"';
    });
    if (names.length) {
      var plural = names.length > 1;
      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment_Instance');
    }
  }

  options._containerAttrs = options._replacerAttrs = null;
  return function rootLinkFn(vm, el, scope) {
    // link context scope dirs
    var context = vm._context;
    var contextDirs;
    if (context && contextLinkFn) {
      contextDirs = linkAndCapture(function () {
        contextLinkFn(context, el, null, scope);
      }, context);
    }

    // link self
    var selfDirs = linkAndCapture(function () {
      if (replacerLinkFn) replacerLinkFn(vm, el);
    }, vm);

    // return the unlink function that tearsdown context
    // container directives.
    return makeUnlinkFn(vm, selfDirs, context, contextDirs);
  };
}

/**
 * Compile a node and return a nodeLinkFn based on the
 * node type.
 *
 * @param {Node} node
 * @param {Object} options
 * @return {Function|null}
 */

function compileNode(node, options) {
  var type = node.nodeType;
  if (type === 1 && node.tagName !== 'SCRIPT') {
    return compileElement(node, options);
  } else if (type === 3 && node.data.trim()) {
    return compileTextNode(node, options);
  } else {
    return null;
  }
}

/**
 * Compile an element and return a nodeLinkFn.
 *
 * @param {Element} el
 * @param {Object} options
 * @return {Function|null}
 */

function compileElement(el, options) {
  // preprocess textareas.
  // textarea treats its text content as the initial value.
  // just bind it as an attr directive for value.
  if (el.tagName === 'TEXTAREA') {
    var tokens = parseText(el.value);
    if (tokens) {
      el.setAttribute(':value', tokensToExp(tokens));
      el.value = '';
    }
  }
  var linkFn;
  var hasAttrs = el.hasAttributes();
  // check terminal directives (for & if)
  if (hasAttrs) {
    linkFn = checkTerminalDirectives(el, options);
  }
  // check element directives
  if (!linkFn) {
    linkFn = checkElementDirectives(el, options);
  }
  // check component
  if (!linkFn) {
    linkFn = checkComponent(el, options);
  }
  // normal directives
  if (!linkFn && hasAttrs) {
    linkFn = compileDirectives(el.attributes, options);
  }
  return linkFn;
}

/**
 * Compile a textNode and return a nodeLinkFn.
 *
 * @param {TextNode} node
 * @param {Object} options
 * @return {Function|null} textNodeLinkFn
 */

function compileTextNode(node, options) {
  // skip marked text nodes
  if (node._skip) {
    return removeText;
  }

  var tokens = parseText(node.wholeText);
  if (!tokens) {
    return null;
  }

  // mark adjacent text nodes as skipped,
  // because we are using node.wholeText to compile
  // all adjacent text nodes together. This fixes
  // issues in IE where sometimes it splits up a single
  // text node into multiple ones.
  var next = node.nextSibling;
  while (next && next.nodeType === 3) {
    next._skip = true;
    next = next.nextSibling;
  }

  var frag = document.createDocumentFragment();
  var el, token;
  for (var i = 0, l = tokens.length; i < l; i++) {
    token = tokens[i];
    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
    frag.appendChild(el);
  }
  return makeTextNodeLinkFn(tokens, frag, options);
}

/**
 * Linker for an skipped text node.
 *
 * @param {Vue} vm
 * @param {Text} node
 */

function removeText(vm, node) {
  remove(node);
}

/**
 * Process a single text token.
 *
 * @param {Object} token
 * @param {Object} options
 * @return {Node}
 */

function processTextToken(token, options) {
  var el;
  if (token.oneTime) {
    el = document.createTextNode(token.value);
  } else {
    if (token.html) {
      el = document.createComment('v-html');
      setTokenType('html');
    } else {
      // IE will clean up empty textNodes during
      // frag.cloneNode(true), so we have to give it
      // something here...
      el = document.createTextNode(' ');
      setTokenType('text');
    }
  }
  function setTokenType(type) {
    if (token.descriptor) return;
    var parsed = parseDirective(token.value);
    token.descriptor = {
      name: type,
      def: directives[type],
      expression: parsed.expression,
      filters: parsed.filters
    };
  }
  return el;
}

/**
 * Build a function that processes a textNode.
 *
 * @param {Array<Object>} tokens
 * @param {DocumentFragment} frag
 */

function makeTextNodeLinkFn(tokens, frag) {
  return function textNodeLinkFn(vm, el, host, scope) {
    var fragClone = frag.cloneNode(true);
    var childNodes = toArray(fragClone.childNodes);
    var token, value, node;
    for (var i = 0, l = tokens.length; i < l; i++) {
      token = tokens[i];
      value = token.value;
      if (token.tag) {
        node = childNodes[i];
        if (token.oneTime) {
          value = (scope || vm).$eval(value);
          if (token.html) {
            replace(node, parseTemplate(value, true));
          } else {
            node.data = value;
          }
        } else {
          vm._bindDir(token.descriptor, node, host, scope);
        }
      }
    }
    replace(el, fragClone);
  };
}

/**
 * Compile a node list and return a childLinkFn.
 *
 * @param {NodeList} nodeList
 * @param {Object} options
 * @return {Function|undefined}
 */

function compileNodeList(nodeList, options) {
  var linkFns = [];
  var nodeLinkFn, childLinkFn, node;
  for (var i = 0, l = nodeList.length; i < l; i++) {
    node = nodeList[i];
    nodeLinkFn = compileNode(node, options);
    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
    linkFns.push(nodeLinkFn, childLinkFn);
  }
  return linkFns.length ? makeChildLinkFn(linkFns) : null;
}

/**
 * Make a child link function for a node's childNodes.
 *
 * @param {Array<Function>} linkFns
 * @return {Function} childLinkFn
 */

function makeChildLinkFn(linkFns) {
  return function childLinkFn(vm, nodes, host, scope, frag) {
    var node, nodeLinkFn, childrenLinkFn;
    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
      node = nodes[n];
      nodeLinkFn = linkFns[i++];
      childrenLinkFn = linkFns[i++];
      // cache childNodes before linking parent, fix #657
      var childNodes = toArray(node.childNodes);
      if (nodeLinkFn) {
        nodeLinkFn(vm, node, host, scope, frag);
      }
      if (childrenLinkFn) {
        childrenLinkFn(vm, childNodes, host, scope, frag);
      }
    }
  };
}

/**
 * Check for element directives (custom elements that should
 * be resovled as terminal directives).
 *
 * @param {Element} el
 * @param {Object} options
 */

function checkElementDirectives(el, options) {
  var tag = el.tagName.toLowerCase();
  if (commonTagRE.test(tag)) {
    return;
  }
  var def = resolveAsset(options, 'elementDirectives', tag);
  if (def) {
    return makeTerminalNodeLinkFn(el, tag, '', options, def);
  }
}

/**
 * Check if an element is a component. If yes, return
 * a component link function.
 *
 * @param {Element} el
 * @param {Object} options
 * @return {Function|undefined}
 */

function checkComponent(el, options) {
  var component = checkComponentAttr(el, options);
  if (component) {
    var ref = findRef(el);
    var descriptor = {
      name: 'component',
      ref: ref,
      expression: component.id,
      def: internalDirectives.component,
      modifiers: {
        literal: !component.dynamic
      }
    };
    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
      if (ref) {
        defineReactive((scope || vm).$refs, ref, null);
      }
      vm._bindDir(descriptor, el, host, scope, frag);
    };
    componentLinkFn.terminal = true;
    return componentLinkFn;
  }
}

/**
 * Check an element for terminal directives in fixed order.
 * If it finds one, return a terminal link function.
 *
 * @param {Element} el
 * @param {Object} options
 * @return {Function} terminalLinkFn
 */

function checkTerminalDirectives(el, options) {
  // skip v-pre
  if (getAttr(el, 'v-pre') !== null) {
    return skip;
  }
  // skip v-else block, but only if following v-if
  if (el.hasAttribute('v-else')) {
    var prev = el.previousElementSibling;
    if (prev && prev.hasAttribute('v-if')) {
      return skip;
    }
  }
  var value, dirName;
  for (var i = 0, l = terminalDirectives.length; i < l; i++) {
    dirName = terminalDirectives[i];
    value = el.getAttribute('v-' + dirName);
    if (value != null) {
      return makeTerminalNodeLinkFn(el, dirName, value, options);
    }
  }
}

function skip() {}
skip.terminal = true;

/**
 * Build a node link function for a terminal directive.
 * A terminal link function terminates the current
 * compilation recursion and handles compilation of the
 * subtree in the directive.
 *
 * @param {Element} el
 * @param {String} dirName
 * @param {String} value
 * @param {Object} options
 * @param {Object} [def]
 * @return {Function} terminalLinkFn
 */

function makeTerminalNodeLinkFn(el, dirName, value, options, def) {
  var parsed = parseDirective(value);
  var descriptor = {
    name: dirName,
    expression: parsed.expression,
    filters: parsed.filters,
    raw: value,
    // either an element directive, or if/for
    // #2366 or custom terminal directive
    def: def || resolveAsset(options, 'directives', dirName)
  };
  // check ref for v-for and router-view
  if (dirName === 'for' || dirName === 'router-view') {
    descriptor.ref = findRef(el);
  }
  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
    if (descriptor.ref) {
      defineReactive((scope || vm).$refs, descriptor.ref, null);
    }
    vm._bindDir(descriptor, el, host, scope, frag);
  };
  fn.terminal = true;
  return fn;
}

/**
 * Compile the directives on an element and return a linker.
 *
 * @param {Array|NamedNodeMap} attrs
 * @param {Object} options
 * @return {Function}
 */

function compileDirectives(attrs, options) {
  var i = attrs.length;
  var dirs = [];
  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;
  while (i--) {
    attr = attrs[i];
    name = rawName = attr.name;
    value = rawValue = attr.value;
    tokens = parseText(value);
    // reset arg
    arg = null;
    // check modifiers
    modifiers = parseModifiers(name);
    name = name.replace(modifierRE, '');

    // attribute interpolations
    if (tokens) {
      value = tokensToExp(tokens);
      arg = name;
      pushDir('bind', directives.bind, tokens);
      // warn against mixing mustaches with v-bind
      if (process.env.NODE_ENV !== 'production') {
        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
          return attr.name === ':class' || attr.name === 'v-bind:class';
        })) {
          warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.');
        }
      }
    } else

      // special attribute: transition
      if (transitionRE.test(name)) {
        modifiers.literal = !bindRE.test(name);
        pushDir('transition', internalDirectives.transition);
      } else

        // event handlers
        if (onRE.test(name)) {
          arg = name.replace(onRE, '');
          pushDir('on', directives.on);
        } else

          // attribute bindings
          if (bindRE.test(name)) {
            dirName = name.replace(bindRE, '');
            if (dirName === 'style' || dirName === 'class') {
              pushDir(dirName, internalDirectives[dirName]);
            } else {
              arg = dirName;
              pushDir('bind', directives.bind);
            }
          } else

            // normal directives
            if (matched = name.match(dirAttrRE)) {
              dirName = matched[1];
              arg = matched[2];

              // skip v-else (when used with v-show)
              if (dirName === 'else') {
                continue;
              }

              dirDef = resolveAsset(options, 'directives', dirName);

              if (process.env.NODE_ENV !== 'production') {
                assertAsset(dirDef, 'directive', dirName);
              }

              if (dirDef) {
                pushDir(dirName, dirDef);
              }
            }
  }

  /**
   * Push a directive.
   *
   * @param {String} dirName
   * @param {Object|Function} def
   * @param {Array} [interpTokens]
   */

  function pushDir(dirName, def, interpTokens) {
    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);
    var parsed = !hasOneTimeToken && parseDirective(value);
    dirs.push({
      name: dirName,
      attr: rawName,
      raw: rawValue,
      def: def,
      arg: arg,
      modifiers: modifiers,
      // conversion from interpolation strings with one-time token
      // to expression is differed until directive bind time so that we
      // have access to the actual vm context for one-time bindings.
      expression: parsed && parsed.expression,
      filters: parsed && parsed.filters,
      interp: interpTokens,
      hasOneTime: hasOneTimeToken
    });
  }

  if (dirs.length) {
    return makeNodeLinkFn(dirs);
  }
}

/**
 * Parse modifiers from directive attribute name.
 *
 * @param {String} name
 * @return {Object}
 */

function parseModifiers(name) {
  var res = Object.create(null);
  var match = name.match(modifierRE);
  if (match) {
    var i = match.length;
    while (i--) {
      res[match[i].slice(1)] = true;
    }
  }
  return res;
}

/**
 * Build a link function for all directives on a single node.
 *
 * @param {Array} directives
 * @return {Function} directivesLinkFn
 */

function makeNodeLinkFn(directives) {
  return function nodeLinkFn(vm, el, host, scope, frag) {
    // reverse apply because it's sorted low to high
    var i = directives.length;
    while (i--) {
      vm._bindDir(directives[i], el, host, scope, frag);
    }
  };
}

/**
 * Check if an interpolation string contains one-time tokens.
 *
 * @param {Array} tokens
 * @return {Boolean}
 */

function hasOneTime(tokens) {
  var i = tokens.length;
  while (i--) {
    if (tokens[i].oneTime) return true;
  }
}

var specialCharRE = /[^\w\-:\.]/;

/**
 * Process an element or a DocumentFragment based on a
 * instance option object. This allows us to transclude
 * a template node/fragment before the instance is created,
 * so the processed fragment can then be cloned and reused
 * in v-for.
 *
 * @param {Element} el
 * @param {Object} options
 * @return {Element|DocumentFragment}
 */

function transclude(el, options) {
  // extract container attributes to pass them down
  // to compiler, because they need to be compiled in
  // parent scope. we are mutating the options object here
  // assuming the same object will be used for compile
  // right after this.
  if (options) {
    options._containerAttrs = extractAttrs(el);
  }
  // for template tags, what we want is its content as
  // a documentFragment (for fragment instances)
  if (isTemplate(el)) {
    el = parseTemplate(el);
  }
  if (options) {
    if (options._asComponent && !options.template) {
      options.template = '<slot></slot>';
    }
    if (options.template) {
      options._content = extractContent(el);
      el = transcludeTemplate(el, options);
    }
  }
  if (isFragment(el)) {
    // anchors for fragment instance
    // passing in `persist: true` to avoid them being
    // discarded by IE during template cloning
    prepend(createAnchor('v-start', true), el);
    el.appendChild(createAnchor('v-end', true));
  }
  return el;
}

/**
 * Process the template option.
 * If the replace option is true this will swap the $el.
 *
 * @param {Element} el
 * @param {Object} options
 * @return {Element|DocumentFragment}
 */

function transcludeTemplate(el, options) {
  var template = options.template;
  var frag = parseTemplate(template, true);
  if (frag) {
    var replacer = frag.firstChild;
    var tag = replacer.tagName && replacer.tagName.toLowerCase();
    if (options.replace) {
      /* istanbul ignore if */
      if (el === document.body) {
        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
      }
      // there are many cases where the instance must
      // become a fragment instance: basically anything that
      // can create more than 1 root nodes.
      if (
      // multi-children template
      frag.childNodes.length > 1 ||
      // non-element template
      replacer.nodeType !== 1 ||
      // single nested component
      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||
      // element directive
      resolveAsset(options, 'elementDirectives', tag) ||
      // for block
      replacer.hasAttribute('v-for') ||
      // if block
      replacer.hasAttribute('v-if')) {
        return frag;
      } else {
        options._replacerAttrs = extractAttrs(replacer);
        mergeAttrs(el, replacer);
        return replacer;
      }
    } else {
      el.appendChild(frag);
      return el;
    }
  } else {
    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);
  }
}

/**
 * Helper to extract a component container's attributes
 * into a plain object array.
 *
 * @param {Element} el
 * @return {Array}
 */

function extractAttrs(el) {
  if (el.nodeType === 1 && el.hasAttributes()) {
    return toArray(el.attributes);
  }
}

/**
 * Merge the attributes of two elements, and make sure
 * the class names are merged properly.
 *
 * @param {Element} from
 * @param {Element} to
 */

function mergeAttrs(from, to) {
  var attrs = from.attributes;
  var i = attrs.length;
  var name, value;
  while (i--) {
    name = attrs[i].name;
    value = attrs[i].value;
    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
      to.setAttribute(name, value);
    } else if (name === 'class' && !parseText(value)) {
      value.trim().split(/\s+/).forEach(function (cls) {
        addClass(to, cls);
      });
    }
  }
}

/**
 * Scan and determine slot content distribution.
 * We do this during transclusion instead at compile time so that
 * the distribution is decoupled from the compilation order of
 * the slots.
 *
 * @param {Element|DocumentFragment} template
 * @param {Element} content
 * @param {Vue} vm
 */

function resolveSlots(vm, content) {
  if (!content) {
    return;
  }
  var contents = vm._slotContents = Object.create(null);
  var el, name;
  for (var i = 0, l = content.children.length; i < l; i++) {
    el = content.children[i];
    /* eslint-disable no-cond-assign */
    if (name = el.getAttribute('slot')) {
      (contents[name] || (contents[name] = [])).push(el);
    }
    /* eslint-enable no-cond-assign */
  }
  for (name in contents) {
    contents[name] = extractFragment(contents[name], content);
  }
  if (content.hasChildNodes()) {
    contents['default'] = extractFragment(content.childNodes, content);
  }
}

/**
 * Extract qualified content nodes from a node list.
 *
 * @param {NodeList} nodes
 * @return {DocumentFragment}
 */

function extractFragment(nodes, parent) {
  var frag = document.createDocumentFragment();
  nodes = toArray(nodes);
  for (var i = 0, l = nodes.length; i < l; i++) {
    var node = nodes[i];
    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
      parent.removeChild(node);
      node = parseTemplate(node);
    }
    frag.appendChild(node);
  }
  return frag;
}



var compiler = Object.freeze({
	compile: compile,
	compileAndLinkProps: compileAndLinkProps,
	compileRoot: compileRoot,
	terminalDirectives: terminalDirectives,
	transclude: transclude,
	resolveSlots: resolveSlots
});

function stateMixin (Vue) {
  /**
   * Accessor for `$data` property, since setting $data
   * requires observing the new object and updating
   * proxied properties.
   */

  Object.defineProperty(Vue.prototype, '$data', {
    get: function get() {
      return this._data;
    },
    set: function set(newData) {
      if (newData !== this._data) {
        this._setData(newData);
      }
    }
  });

  /**
   * Setup the scope of an instance, which contains:
   * - observed data
   * - computed properties
   * - user methods
   * - meta properties
   */

  Vue.prototype._initState = function () {
    this._initProps();
    this._initMeta();
    this._initMethods();
    this._initData();
    this._initComputed();
  };

  /**
   * Initialize props.
   */

  Vue.prototype._initProps = function () {
    var options = this.$options;
    var el = options.el;
    var props = options.props;
    if (props && !el) {
      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.');
    }
    // make sure to convert string selectors into element now
    el = options.el = query(el);
    this._propsUnlinkFn = el && el.nodeType === 1 && props
    // props must be linked in proper scope if inside v-for
    ? compileAndLinkProps(this, el, props, this._scope) : null;
  };

  /**
   * Initialize the data.
   */

  Vue.prototype._initData = function () {
    var dataFn = this.$options.data;
    var data = this._data = dataFn ? dataFn() : {};
    var props = this._props;
    var runtimeData = this._runtimeData ? typeof this._runtimeData === 'function' ? this._runtimeData() : this._runtimeData : null;
    // proxy data on instance
    var keys = Object.keys(data);
    var i, key;
    i = keys.length;
    while (i--) {
      key = keys[i];
      // there are two scenarios where we can proxy a data key:
      // 1. it's not already defined as a prop
      // 2. it's provided via a instantiation option AND there are no
      //    template prop present
      if (!props || !hasOwn(props, key) || runtimeData && hasOwn(runtimeData, key) && props[key].raw === null) {
        this._proxy(key);
      } else if (process.env.NODE_ENV !== 'production') {
        warn('Data field "' + key + '" is already defined ' + 'as a prop. Use prop default value instead.');
      }
    }
    // observe data
    observe(data, this);
  };

  /**
   * Swap the instance's $data. Called in $data's setter.
   *
   * @param {Object} newData
   */

  Vue.prototype._setData = function (newData) {
    newData = newData || {};
    var oldData = this._data;
    this._data = newData;
    var keys, key, i;
    // unproxy keys not present in new data
    keys = Object.keys(oldData);
    i = keys.length;
    while (i--) {
      key = keys[i];
      if (!(key in newData)) {
        this._unproxy(key);
      }
    }
    // proxy keys not already proxied,
    // and trigger change for changed values
    keys = Object.keys(newData);
    i = keys.length;
    while (i--) {
      key = keys[i];
      if (!hasOwn(this, key)) {
        // new property
        this._proxy(key);
      }
    }
    oldData.__ob__.removeVm(this);
    observe(newData, this);
    this._digest();
  };

  /**
   * Proxy a property, so that
   * vm.prop === vm._data.prop
   *
   * @param {String} key
   */

  Vue.prototype._proxy = function (key) {
    if (!isReserved(key)) {
      // need to store ref to self here
      // because these getter/setters might
      // be called by child scopes via
      // prototype inheritance.
      var self = this;
      Object.defineProperty(self, key, {
        configurable: true,
        enumerable: true,
        get: function proxyGetter() {
          return self._data[key];
        },
        set: function proxySetter(val) {
          self._data[key] = val;
        }
      });
    }
  };

  /**
   * Unproxy a property.
   *
   * @param {String} key
   */

  Vue.prototype._unproxy = function (key) {
    if (!isReserved(key)) {
      delete this[key];
    }
  };

  /**
   * Force update on every watcher in scope.
   */

  Vue.prototype._digest = function () {
    for (var i = 0, l = this._watchers.length; i < l; i++) {
      this._watchers[i].update(true); // shallow updates
    }
  };

  /**
   * Setup computed properties. They are essentially
   * special getter/setters
   */

  function noop() {}
  Vue.prototype._initComputed = function () {
    var computed = this.$options.computed;
    if (computed) {
      for (var key in computed) {
        var userDef = computed[key];
        var def = {
          enumerable: true,
          configurable: true
        };
        if (typeof userDef === 'function') {
          def.get = makeComputedGetter(userDef, this);
          def.set = noop;
        } else {
          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;
          def.set = userDef.set ? bind(userDef.set, this) : noop;
        }
        Object.defineProperty(this, key, def);
      }
    }
  };

  function makeComputedGetter(getter, owner) {
    var watcher = new Watcher(owner, getter, null, {
      lazy: true
    });
    return function computedGetter() {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    };
  }

  /**
   * Setup instance methods. Methods must be bound to the
   * instance since they might be passed down as a prop to
   * child components.
   */

  Vue.prototype._initMethods = function () {
    var methods = this.$options.methods;
    if (methods) {
      for (var key in methods) {
        this[key] = bind(methods[key], this);
      }
    }
  };

  /**
   * Initialize meta information like $index, $key & $value.
   */

  Vue.prototype._initMeta = function () {
    var metas = this.$options._meta;
    if (metas) {
      for (var key in metas) {
        defineReactive(this, key, metas[key]);
      }
    }
  };
}

var eventRE = /^v-on:|^@/;

function eventsMixin (Vue) {
  /**
   * Setup the instance's option events & watchers.
   * If the value is a string, we pull it from the
   * instance's methods by name.
   */

  Vue.prototype._initEvents = function () {
    var options = this.$options;
    if (options._asComponent) {
      registerComponentEvents(this, options.el);
    }
    registerCallbacks(this, '$on', options.events);
    registerCallbacks(this, '$watch', options.watch);
  };

  /**
   * Register v-on events on a child component
   *
   * @param {Vue} vm
   * @param {Element} el
   */

  function registerComponentEvents(vm, el) {
    var attrs = el.attributes;
    var name, handler;
    for (var i = 0, l = attrs.length; i < l; i++) {
      name = attrs[i].name;
      if (eventRE.test(name)) {
        name = name.replace(eventRE, '');
        handler = (vm._scope || vm._context).$eval(attrs[i].value, true);
        if (typeof handler === 'function') {
          handler._fromParent = true;
          vm.$on(name.replace(eventRE), handler);
        } else if (process.env.NODE_ENV !== 'production') {
          warn('v-on:' + name + '="' + attrs[i].value + '"' + (vm.$options.name ? ' on component <' + vm.$options.name + '>' : '') + ' expects a function value, got ' + handler);
        }
      }
    }
  }

  /**
   * Register callbacks for option events and watchers.
   *
   * @param {Vue} vm
   * @param {String} action
   * @param {Object} hash
   */

  function registerCallbacks(vm, action, hash) {
    if (!hash) return;
    var handlers, key, i, j;
    for (key in hash) {
      handlers = hash[key];
      if (isArray(handlers)) {
        for (i = 0, j = handlers.length; i < j; i++) {
          register(vm, action, key, handlers[i]);
        }
      } else {
        register(vm, action, key, handlers);
      }
    }
  }

  /**
   * Helper to register an event/watch callback.
   *
   * @param {Vue} vm
   * @param {String} action
   * @param {String} key
   * @param {Function|String|Object} handler
   * @param {Object} [options]
   */

  function register(vm, action, key, handler, options) {
    var type = typeof handler;
    if (type === 'function') {
      vm[action](key, handler, options);
    } else if (type === 'string') {
      var methods = vm.$options.methods;
      var method = methods && methods[handler];
      if (method) {
        vm[action](key, method, options);
      } else {
        process.env.NODE_ENV !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".');
      }
    } else if (handler && type === 'object') {
      register(vm, action, key, handler.handler, handler);
    }
  }

  /**
   * Setup recursive attached/detached calls
   */

  Vue.prototype._initDOMHooks = function () {
    this.$on('hook:attached', onAttached);
    this.$on('hook:detached', onDetached);
  };

  /**
   * Callback to recursively call attached hook on children
   */

  function onAttached() {
    if (!this._isAttached) {
      this._isAttached = true;
      this.$children.forEach(callAttach);
    }
  }

  /**
   * Iterator to call attached hook
   *
   * @param {Vue} child
   */

  function callAttach(child) {
    if (!child._isAttached && inDoc(child.$el)) {
      child._callHook('attached');
    }
  }

  /**
   * Callback to recursively call detached hook on children
   */

  function onDetached() {
    if (this._isAttached) {
      this._isAttached = false;
      this.$children.forEach(callDetach);
    }
  }

  /**
   * Iterator to call detached hook
   *
   * @param {Vue} child
   */

  function callDetach(child) {
    if (child._isAttached && !inDoc(child.$el)) {
      child._callHook('detached');
    }
  }

  /**
   * Trigger all handlers for a hook
   *
   * @param {String} hook
   */

  Vue.prototype._callHook = function (hook) {
    this.$emit('pre-hook:' + hook);
    var handlers = this.$options[hook];
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        handlers[i].call(this);
      }
    }
    this.$emit('hook:' + hook);
  };
}

function noop() {}

/**
 * A directive links a DOM element with a piece of data,
 * which is the result of evaluating an expression.
 * It registers a watcher with the expression and calls
 * the DOM update function when a change is triggered.
 *
 * @param {String} name
 * @param {Node} el
 * @param {Vue} vm
 * @param {Object} descriptor
 *                 - {String} name
 *                 - {Object} def
 *                 - {String} expression
 *                 - {Array<Object>} [filters]
 *                 - {Boolean} literal
 *                 - {String} attr
 *                 - {String} raw
 * @param {Object} def - directive definition object
 * @param {Vue} [host] - transclusion host component
 * @param {Object} [scope] - v-for scope
 * @param {Fragment} [frag] - owner fragment
 * @constructor
 */
function Directive(descriptor, vm, el, host, scope, frag) {
  this.vm = vm;
  this.el = el;
  // copy descriptor properties
  this.descriptor = descriptor;
  this.name = descriptor.name;
  this.expression = descriptor.expression;
  this.arg = descriptor.arg;
  this.modifiers = descriptor.modifiers;
  this.filters = descriptor.filters;
  this.literal = this.modifiers && this.modifiers.literal;
  // private
  this._locked = false;
  this._bound = false;
  this._listeners = null;
  // link context
  this._host = host;
  this._scope = scope;
  this._frag = frag;
  // store directives on node in dev mode
  if (process.env.NODE_ENV !== 'production' && this.el) {
    this.el._vue_directives = this.el._vue_directives || [];
    this.el._vue_directives.push(this);
  }
}

/**
 * Initialize the directive, mixin definition properties,
 * setup the watcher, call definition bind() and update()
 * if present.
 *
 * @param {Object} def
 */

Directive.prototype._bind = function () {
  var name = this.name;
  var descriptor = this.descriptor;

  // remove attribute
  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
    var attr = descriptor.attr || 'v-' + name;
    this.el.removeAttribute(attr);
  }

  // copy def properties
  var def = descriptor.def;
  if (typeof def === 'function') {
    this.update = def;
  } else {
    extend(this, def);
  }

  // setup directive params
  this._setupParams();

  // initial bind
  if (this.bind) {
    this.bind();
  }
  this._bound = true;

  if (this.literal) {
    this.update && this.update(descriptor.raw);
  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
    // wrapped updater for context
    var dir = this;
    if (this.update) {
      this._update = function (val, oldVal) {
        if (!dir._locked) {
          dir.update(val, oldVal);
        }
      };
    } else {
      this._update = noop;
    }
    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;
    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;
    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
    {
      filters: this.filters,
      twoWay: this.twoWay,
      deep: this.deep,
      preProcess: preProcess,
      postProcess: postProcess,
      scope: this._scope
    });
    // v-model with inital inline value need to sync back to
    // model instead of update to DOM on init. They would
    // set the afterBind hook to indicate that.
    if (this.afterBind) {
      this.afterBind();
    } else if (this.update) {
      this.update(watcher.value);
    }
  }
};

/**
 * Setup all param attributes, e.g. track-by,
 * transition-mode, etc...
 */

Directive.prototype._setupParams = function () {
  if (!this.params) {
    return;
  }
  var params = this.params;
  // swap the params array with a fresh object.
  this.params = Object.create(null);
  var i = params.length;
  var key, val, mappedKey;
  while (i--) {
    key = params[i];
    mappedKey = camelize(key);
    val = getBindAttr(this.el, key);
    if (val != null) {
      // dynamic
      this._setupParamWatcher(mappedKey, val);
    } else {
      // static
      val = getAttr(this.el, key);
      if (val != null) {
        this.params[mappedKey] = val === '' ? true : val;
      }
    }
  }
};

/**
 * Setup a watcher for a dynamic param.
 *
 * @param {String} key
 * @param {String} expression
 */

Directive.prototype._setupParamWatcher = function (key, expression) {
  var self = this;
  var called = false;
  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
    self.params[key] = val;
    // since we are in immediate mode,
    // only call the param change callbacks if this is not the first update.
    if (called) {
      var cb = self.paramWatchers && self.paramWatchers[key];
      if (cb) {
        cb.call(self, val, oldVal);
      }
    } else {
      called = true;
    }
  }, {
    immediate: true,
    user: false
  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
};

/**
 * Check if the directive is a function caller
 * and if the expression is a callable one. If both true,
 * we wrap up the expression and use it as the event
 * handler.
 *
 * e.g. on-click="a++"
 *
 * @return {Boolean}
 */

Directive.prototype._checkStatement = function () {
  var expression = this.expression;
  if (expression && this.acceptStatement && !isSimplePath(expression)) {
    var fn = parseExpression(expression).get;
    var scope = this._scope || this.vm;
    var handler = function handler(e) {
      scope.$event = e;
      fn.call(scope, scope);
      scope.$event = null;
    };
    if (this.filters) {
      handler = scope._applyFilters(handler, null, this.filters);
    }
    this.update(handler);
    return true;
  }
};

/**
 * Set the corresponding value with the setter.
 * This should only be used in two-way directives
 * e.g. v-model.
 *
 * @param {*} value
 * @public
 */

Directive.prototype.set = function (value) {
  /* istanbul ignore else */
  if (this.twoWay) {
    this._withLock(function () {
      this._watcher.set(value);
    });
  } else if (process.env.NODE_ENV !== 'production') {
    warn('Directive.set() can only be used inside twoWay' + 'directives.');
  }
};

/**
 * Execute a function while preventing that function from
 * triggering updates on this directive instance.
 *
 * @param {Function} fn
 */

Directive.prototype._withLock = function (fn) {
  var self = this;
  self._locked = true;
  fn.call(self);
  nextTick(function () {
    self._locked = false;
  });
};

/**
 * Convenience method that attaches a DOM event listener
 * to the directive element and autometically tears it down
 * during unbind.
 *
 * @param {String} event
 * @param {Function} handler
 * @param {Boolean} [useCapture]
 */

Directive.prototype.on = function (event, handler, useCapture) {
  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);
};

/**
 * Teardown the watcher and call unbind.
 */

Directive.prototype._teardown = function () {
  if (this._bound) {
    this._bound = false;
    if (this.unbind) {
      this.unbind();
    }
    if (this._watcher) {
      this._watcher.teardown();
    }
    var listeners = this._listeners;
    var i;
    if (listeners) {
      i = listeners.length;
      while (i--) {
        off(this.el, listeners[i][0], listeners[i][1]);
      }
    }
    var unwatchFns = this._paramUnwatchFns;
    if (unwatchFns) {
      i = unwatchFns.length;
      while (i--) {
        unwatchFns[i]();
      }
    }
    if (process.env.NODE_ENV !== 'production' && this.el) {
      this.el._vue_directives.$remove(this);
    }
    this.vm = this.el = this._watcher = this._listeners = null;
  }
};

function lifecycleMixin (Vue) {
  /**
   * Update v-ref for component.
   *
   * @param {Boolean} remove
   */

  Vue.prototype._updateRef = function (remove) {
    var ref = this.$options._ref;
    if (ref) {
      var refs = (this._scope || this._context).$refs;
      if (remove) {
        if (refs[ref] === this) {
          refs[ref] = null;
        }
      } else {
        refs[ref] = this;
      }
    }
  };

  /**
   * Transclude, compile and link element.
   *
   * If a pre-compiled linker is available, that means the
   * passed in element will be pre-transcluded and compiled
   * as well - all we need to do is to call the linker.
   *
   * Otherwise we need to call transclude/compile/link here.
   *
   * @param {Element} el
   */

  Vue.prototype._compile = function (el) {
    var options = this.$options;

    // transclude and init element
    // transclude can potentially replace original
    // so we need to keep reference; this step also injects
    // the template and caches the original attributes
    // on the container node and replacer node.
    var original = el;
    el = transclude(el, options);
    this._initElement(el);

    // handle v-pre on root node (#2026)
    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
      return;
    }

    // root is always compiled per-instance, because
    // container attrs and props can be different every time.
    var contextOptions = this._context && this._context.$options;
    var rootLinker = compileRoot(el, options, contextOptions);

    // resolve slot distribution
    resolveSlots(this, options._content);

    // compile and link the rest
    var contentLinkFn;
    var ctor = this.constructor;
    // component compilation can be cached
    // as long as it's not using inline-template
    if (options._linkerCachable) {
      contentLinkFn = ctor.linker;
      if (!contentLinkFn) {
        contentLinkFn = ctor.linker = compile(el, options);
      }
    }

    // link phase
    // make sure to link root with prop scope!
    var rootUnlinkFn = rootLinker(this, el, this._scope);
    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);

    // register composite unlink function
    // to be called during instance destruction
    this._unlinkFn = function () {
      rootUnlinkFn();
      // passing destroying: true to avoid searching and
      // splicing the directives
      contentUnlinkFn(true);
    };

    // finally replace original
    if (options.replace) {
      replace(original, el);
    }

    this._isCompiled = true;
    this._callHook('compiled');
  };

  /**
   * Initialize instance element. Called in the public
   * $mount() method.
   *
   * @param {Element} el
   */

  Vue.prototype._initElement = function (el) {
    if (isFragment(el)) {
      this._isFragment = true;
      this.$el = this._fragmentStart = el.firstChild;
      this._fragmentEnd = el.lastChild;
      // set persisted text anchors to empty
      if (this._fragmentStart.nodeType === 3) {
        this._fragmentStart.data = this._fragmentEnd.data = '';
      }
      this._fragment = el;
    } else {
      this.$el = el;
    }
    this.$el.__vue__ = this;
    this._callHook('beforeCompile');
  };

  /**
   * Create and bind a directive to an element.
   *
   * @param {String} name - directive name
   * @param {Node} node   - target node
   * @param {Object} desc - parsed directive descriptor
   * @param {Object} def  - directive definition object
   * @param {Vue} [host] - transclusion host component
   * @param {Object} [scope] - v-for scope
   * @param {Fragment} [frag] - owner fragment
   */

  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
  };

  /**
   * Teardown an instance, unobserves the data, unbind all the
   * directives, turn off all the event listeners, etc.
   *
   * @param {Boolean} remove - whether to remove the DOM node.
   * @param {Boolean} deferCleanup - if true, defer cleanup to
   *                                 be called later
   */

  Vue.prototype._destroy = function (remove, deferCleanup) {
    if (this._isBeingDestroyed) {
      if (!deferCleanup) {
        this._cleanup();
      }
      return;
    }

    var destroyReady;
    var pendingRemoval;

    var self = this;
    // Cleanup should be called either synchronously or asynchronoysly as
    // callback of this.$remove(), or if remove and deferCleanup are false.
    // In any case it should be called after all other removing, unbinding and
    // turning of is done
    var cleanupIfPossible = function cleanupIfPossible() {
      if (destroyReady && !pendingRemoval && !deferCleanup) {
        self._cleanup();
      }
    };

    // remove DOM element
    if (remove && this.$el) {
      pendingRemoval = true;
      this.$remove(function () {
        pendingRemoval = false;
        cleanupIfPossible();
      });
    }

    this._callHook('beforeDestroy');
    this._isBeingDestroyed = true;
    var i;
    // remove self from parent. only necessary
    // if parent is not being destroyed as well.
    var parent = this.$parent;
    if (parent && !parent._isBeingDestroyed) {
      parent.$children.$remove(this);
      // unregister ref (remove: true)
      this._updateRef(true);
    }
    // destroy all children.
    i = this.$children.length;
    while (i--) {
      this.$children[i].$destroy();
    }
    // teardown props
    if (this._propsUnlinkFn) {
      this._propsUnlinkFn();
    }
    // teardown all directives. this also tearsdown all
    // directive-owned watchers.
    if (this._unlinkFn) {
      this._unlinkFn();
    }
    i = this._watchers.length;
    while (i--) {
      this._watchers[i].teardown();
    }
    // remove reference to self on $el
    if (this.$el) {
      this.$el.__vue__ = null;
    }

    destroyReady = true;
    cleanupIfPossible();
  };

  /**
   * Clean up to ensure garbage collection.
   * This is called after the leave transition if there
   * is any.
   */

  Vue.prototype._cleanup = function () {
    if (this._isDestroyed) {
      return;
    }
    // remove self from owner fragment
    // do it in cleanup so that we can call $destroy with
    // defer right when a fragment is about to be removed.
    if (this._frag) {
      this._frag.children.$remove(this);
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (this._data.__ob__) {
      this._data.__ob__.removeVm(this);
    }
    // Clean up references to private properties and other
    // instances. preserve reference to _data so that proxy
    // accessors still work. The only potential side effect
    // here is that mutating the instance after it's destroyed
    // may affect the state of other components that are still
    // observing the same object, but that seems to be a
    // reasonable responsibility for the user rather than
    // always throwing an error on them.
    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
    // call the last hook...
    this._isDestroyed = true;
    this._callHook('destroyed');
    // turn off all instance listeners.
    this.$off();
  };
}

function miscMixin (Vue) {
  /**
   * Apply a list of filter (descriptors) to a value.
   * Using plain for loops here because this will be called in
   * the getter of any watcher with filters so it is very
   * performance sensitive.
   *
   * @param {*} value
   * @param {*} [oldValue]
   * @param {Array} filters
   * @param {Boolean} write
   * @return {*}
   */

  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
    var filter, fn, args, arg, offset, i, l, j, k;
    for (i = 0, l = filters.length; i < l; i++) {
      filter = filters[i];
      fn = resolveAsset(this.$options, 'filters', filter.name);
      if (process.env.NODE_ENV !== 'production') {
        assertAsset(fn, 'filter', filter.name);
      }
      if (!fn) continue;
      fn = write ? fn.write : fn.read || fn;
      if (typeof fn !== 'function') continue;
      args = write ? [value, oldValue] : [value];
      offset = write ? 2 : 1;
      if (filter.args) {
        for (j = 0, k = filter.args.length; j < k; j++) {
          arg = filter.args[j];
          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
        }
      }
      value = fn.apply(this, args);
    }
    return value;
  };

  /**
   * Resolve a component, depending on whether the component
   * is defined normally or using an async factory function.
   * Resolves synchronously if already resolved, otherwise
   * resolves asynchronously and caches the resolved
   * constructor on the factory.
   *
   * @param {String} id
   * @param {Function} cb
   */

  Vue.prototype._resolveComponent = function (id, cb) {
    var factory = resolveAsset(this.$options, 'components', id);
    if (process.env.NODE_ENV !== 'production') {
      assertAsset(factory, 'component', id);
    }
    if (!factory) {
      return;
    }
    // async component factory
    if (!factory.options) {
      if (factory.resolved) {
        // cached
        cb(factory.resolved);
      } else if (factory.requested) {
        // pool callbacks
        factory.pendingCallbacks.push(cb);
      } else {
        factory.requested = true;
        var cbs = factory.pendingCallbacks = [cb];
        factory.call(this, function resolve(res) {
          if (isPlainObject(res)) {
            res = Vue.extend(res);
          }
          // cache resolved
          factory.resolved = res;
          // invoke callbacks
          for (var i = 0, l = cbs.length; i < l; i++) {
            cbs[i](res);
          }
        }, function reject(reason) {
          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component: ' + id + '. ' + (reason ? '\nReason: ' + reason : ''));
        });
      }
    } else {
      // normal component
      cb(factory);
    }
  };
}

var filterRE$1 = /[^|]\|[^|]/;

function dataAPI (Vue) {
  /**
   * Get the value from an expression on this vm.
   *
   * @param {String} exp
   * @param {Boolean} [asStatement]
   * @return {*}
   */

  Vue.prototype.$get = function (exp, asStatement) {
    var res = parseExpression(exp);
    if (res) {
      if (asStatement && !isSimplePath(exp)) {
        var self = this;
        return function statementHandler() {
          self.$arguments = toArray(arguments);
          var result = res.get.call(self, self);
          self.$arguments = null;
          return result;
        };
      } else {
        try {
          return res.get.call(this, this);
        } catch (e) {}
      }
    }
  };

  /**
   * Set the value from an expression on this vm.
   * The expression must be a valid left-hand
   * expression in an assignment.
   *
   * @param {String} exp
   * @param {*} val
   */

  Vue.prototype.$set = function (exp, val) {
    var res = parseExpression(exp, true);
    if (res && res.set) {
      res.set.call(this, this, val);
    }
  };

  /**
   * Delete a property on the VM
   *
   * @param {String} key
   */

  Vue.prototype.$delete = function (key) {
    del(this._data, key);
  };

  /**
   * Watch an expression, trigger callback when its
   * value changes.
   *
   * @param {String|Function} expOrFn
   * @param {Function} cb
   * @param {Object} [options]
   *                 - {Boolean} deep
   *                 - {Boolean} immediate
   * @return {Function} - unwatchFn
   */

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    var parsed;
    if (typeof expOrFn === 'string') {
      parsed = parseDirective(expOrFn);
      expOrFn = parsed.expression;
    }
    var watcher = new Watcher(vm, expOrFn, cb, {
      deep: options && options.deep,
      sync: options && options.sync,
      filters: parsed && parsed.filters,
      user: !options || options.user !== false
    });
    if (options && options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };

  /**
   * Evaluate a text directive, including filters.
   *
   * @param {String} text
   * @param {Boolean} [asStatement]
   * @return {String}
   */

  Vue.prototype.$eval = function (text, asStatement) {
    // check for filters.
    if (filterRE$1.test(text)) {
      var dir = parseDirective(text);
      // the filter regex check might give false positive
      // for pipes inside strings, so it's possible that
      // we don't get any filters here
      var val = this.$get(dir.expression, asStatement);
      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
    } else {
      // no filter
      return this.$get(text, asStatement);
    }
  };

  /**
   * Interpolate a piece of template text.
   *
   * @param {String} text
   * @return {String}
   */

  Vue.prototype.$interpolate = function (text) {
    var tokens = parseText(text);
    var vm = this;
    if (tokens) {
      if (tokens.length === 1) {
        return vm.$eval(tokens[0].value) + '';
      } else {
        return tokens.map(function (token) {
          return token.tag ? vm.$eval(token.value) : token.value;
        }).join('');
      }
    } else {
      return text;
    }
  };

  /**
   * Log instance data as a plain JS object
   * so that it is easier to inspect in console.
   * This method assumes console is available.
   *
   * @param {String} [path]
   */

  Vue.prototype.$log = function (path) {
    var data = path ? getPath(this._data, path) : this._data;
    if (data) {
      data = clean(data);
    }
    // include computed fields
    if (!path) {
      var key;
      for (key in this.$options.computed) {
        data[key] = clean(this[key]);
      }
      if (this._props) {
        for (key in this._props) {
          data[key] = clean(this[key]);
        }
      }
    }
    console.log(data);
  };

  /**
   * "clean" a getter/setter converted object into a plain
   * object copy.
   *
   * @param {Object} - obj
   * @return {Object}
   */

  function clean(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
}

function domAPI (Vue) {
  /**
   * Convenience on-instance nextTick. The callback is
   * auto-bound to the instance, and this avoids component
   * modules having to rely on the global Vue.
   *
   * @param {Function} fn
   */

  Vue.prototype.$nextTick = function (fn) {
    nextTick(fn, this);
  };

  /**
   * Append instance to target
   *
   * @param {Node} target
   * @param {Function} [cb]
   * @param {Boolean} [withTransition] - defaults to true
   */

  Vue.prototype.$appendTo = function (target, cb, withTransition) {
    return insert(this, target, cb, withTransition, append, appendWithTransition);
  };

  /**
   * Prepend instance to target
   *
   * @param {Node} target
   * @param {Function} [cb]
   * @param {Boolean} [withTransition] - defaults to true
   */

  Vue.prototype.$prependTo = function (target, cb, withTransition) {
    target = query(target);
    if (target.hasChildNodes()) {
      this.$before(target.firstChild, cb, withTransition);
    } else {
      this.$appendTo(target, cb, withTransition);
    }
    return this;
  };

  /**
   * Insert instance before target
   *
   * @param {Node} target
   * @param {Function} [cb]
   * @param {Boolean} [withTransition] - defaults to true
   */

  Vue.prototype.$before = function (target, cb, withTransition) {
    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
  };

  /**
   * Insert instance after target
   *
   * @param {Node} target
   * @param {Function} [cb]
   * @param {Boolean} [withTransition] - defaults to true
   */

  Vue.prototype.$after = function (target, cb, withTransition) {
    target = query(target);
    if (target.nextSibling) {
      this.$before(target.nextSibling, cb, withTransition);
    } else {
      this.$appendTo(target.parentNode, cb, withTransition);
    }
    return this;
  };

  /**
   * Remove instance from DOM
   *
   * @param {Function} [cb]
   * @param {Boolean} [withTransition] - defaults to true
   */

  Vue.prototype.$remove = function (cb, withTransition) {
    if (!this.$el.parentNode) {
      return cb && cb();
    }
    var inDocument = this._isAttached && inDoc(this.$el);
    // if we are not in document, no need to check
    // for transitions
    if (!inDocument) withTransition = false;
    var self = this;
    var realCb = function realCb() {
      if (inDocument) self._callHook('detached');
      if (cb) cb();
    };
    if (this._isFragment) {
      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
    } else {
      var op = withTransition === false ? removeWithCb : removeWithTransition;
      op(this.$el, this, realCb);
    }
    return this;
  };

  /**
   * Shared DOM insertion function.
   *
   * @param {Vue} vm
   * @param {Element} target
   * @param {Function} [cb]
   * @param {Boolean} [withTransition]
   * @param {Function} op1 - op for non-transition insert
   * @param {Function} op2 - op for transition insert
   * @return vm
   */

  function insert(vm, target, cb, withTransition, op1, op2) {
    target = query(target);
    var targetIsDetached = !inDoc(target);
    var op = withTransition === false || targetIsDetached ? op1 : op2;
    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
    if (vm._isFragment) {
      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
        op(node, target, vm);
      });
      cb && cb();
    } else {
      op(vm.$el, target, vm, cb);
    }
    if (shouldCallHook) {
      vm._callHook('attached');
    }
    return vm;
  }

  /**
   * Check for selectors
   *
   * @param {String|Element} el
   */

  function query(el) {
    return typeof el === 'string' ? document.querySelector(el) : el;
  }

  /**
   * Append operation that takes a callback.
   *
   * @param {Node} el
   * @param {Node} target
   * @param {Vue} vm - unused
   * @param {Function} [cb]
   */

  function append(el, target, vm, cb) {
    target.appendChild(el);
    if (cb) cb();
  }

  /**
   * InsertBefore operation that takes a callback.
   *
   * @param {Node} el
   * @param {Node} target
   * @param {Vue} vm - unused
   * @param {Function} [cb]
   */

  function beforeWithCb(el, target, vm, cb) {
    before(el, target);
    if (cb) cb();
  }

  /**
   * Remove operation that takes a callback.
   *
   * @param {Node} el
   * @param {Vue} vm - unused
   * @param {Function} [cb]
   */

  function removeWithCb(el, vm, cb) {
    remove(el);
    if (cb) cb();
  }
}

function eventsAPI (Vue) {
  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   */

  Vue.prototype.$on = function (event, fn) {
    (this._events[event] || (this._events[event] = [])).push(fn);
    modifyListenerCount(this, event, 1);
    return this;
  };

  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   */

  Vue.prototype.$once = function (event, fn) {
    var self = this;
    function on() {
      self.$off(event, on);
      fn.apply(this, arguments);
    }
    on.fn = fn;
    this.$on(event, on);
    return this;
  };

  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   */

  Vue.prototype.$off = function (event, fn) {
    var cbs;
    // all
    if (!arguments.length) {
      if (this.$parent) {
        for (event in this._events) {
          cbs = this._events[event];
          if (cbs) {
            modifyListenerCount(this, event, -cbs.length);
          }
        }
      }
      this._events = {};
      return this;
    }
    // specific event
    cbs = this._events[event];
    if (!cbs) {
      return this;
    }
    if (arguments.length === 1) {
      modifyListenerCount(this, event, -cbs.length);
      this._events[event] = null;
      return this;
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        modifyListenerCount(this, event, -1);
        cbs.splice(i, 1);
        break;
      }
    }
    return this;
  };

  /**
   * Trigger an event on self.
   *
   * @param {String|Object} event
   * @return {Boolean} shouldPropagate
   */

  Vue.prototype.$emit = function (event) {
    var isSource = typeof event === 'string';
    event = isSource ? event : event.name;
    var cbs = this._events[event];
    var shouldPropagate = isSource || !cbs;
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      // this is a somewhat hacky solution to the question raised
      // in #2102: for an inline component listener like <comp @test="doThis">,
      // the propagation handling is somewhat broken. Therefore we
      // need to treat these inline callbacks differently.
      var hasParentCbs = isSource && cbs.some(function (cb) {
        return cb._fromParent;
      });
      if (hasParentCbs) {
        shouldPropagate = false;
      }
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        var cb = cbs[i];
        var res = cb.apply(this, args);
        if (res === true && (!hasParentCbs || cb._fromParent)) {
          shouldPropagate = true;
        }
      }
    }
    return shouldPropagate;
  };

  /**
   * Recursively broadcast an event to all children instances.
   *
   * @param {String|Object} event
   * @param {...*} additional arguments
   */

  Vue.prototype.$broadcast = function (event) {
    var isSource = typeof event === 'string';
    event = isSource ? event : event.name;
    // if no child has registered for this event,
    // then there's no need to broadcast.
    if (!this._eventsCount[event]) return;
    var children = this.$children;
    var args = toArray(arguments);
    if (isSource) {
      // use object event to indicate non-source emit
      // on children
      args[0] = { name: event, source: this };
    }
    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
      var shouldPropagate = child.$emit.apply(child, args);
      if (shouldPropagate) {
        child.$broadcast.apply(child, args);
      }
    }
    return this;
  };

  /**
   * Recursively propagate an event up the parent chain.
   *
   * @param {String} event
   * @param {...*} additional arguments
   */

  Vue.prototype.$dispatch = function (event) {
    var shouldPropagate = this.$emit.apply(this, arguments);
    if (!shouldPropagate) return;
    var parent = this.$parent;
    var args = toArray(arguments);
    // use object event to indicate non-source emit
    // on parents
    args[0] = { name: event, source: this };
    while (parent) {
      shouldPropagate = parent.$emit.apply(parent, args);
      parent = shouldPropagate ? parent.$parent : null;
    }
    return this;
  };

  /**
   * Modify the listener counts on all parents.
   * This bookkeeping allows $broadcast to return early when
   * no child has listened to a certain event.
   *
   * @param {Vue} vm
   * @param {String} event
   * @param {Number} count
   */

  var hookRE = /^hook:/;
  function modifyListenerCount(vm, event, count) {
    var parent = vm.$parent;
    // hooks do not get broadcasted so no need
    // to do bookkeeping for them
    if (!parent || !count || hookRE.test(event)) return;
    while (parent) {
      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
      parent = parent.$parent;
    }
  }
}

function lifecycleAPI (Vue) {
  /**
   * Set instance target element and kick off the compilation
   * process. The passed in `el` can be a selector string, an
   * existing Element, or a DocumentFragment (for block
   * instances).
   *
   * @param {Element|DocumentFragment|string} el
   * @public
   */

  Vue.prototype.$mount = function (el) {
    if (this._isCompiled) {
      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.');
      return;
    }
    el = query(el);
    if (!el) {
      el = document.createElement('div');
    }
    this._compile(el);
    this._initDOMHooks();
    if (inDoc(this.$el)) {
      this._callHook('attached');
      ready.call(this);
    } else {
      this.$once('hook:attached', ready);
    }
    return this;
  };

  /**
   * Mark an instance as ready.
   */

  function ready() {
    this._isAttached = true;
    this._isReady = true;
    this._callHook('ready');
  }

  /**
   * Teardown the instance, simply delegate to the internal
   * _destroy.
   */

  Vue.prototype.$destroy = function (remove, deferCleanup) {
    this._destroy(remove, deferCleanup);
  };

  /**
   * Partially compile a piece of DOM and return a
   * decompile function.
   *
   * @param {Element|DocumentFragment} el
   * @param {Vue} [host]
   * @return {Function}
   */

  Vue.prototype.$compile = function (el, host, scope, frag) {
    return compile(el, this.$options, true)(this, el, host, scope, frag);
  };
}

/**
 * The exposed Vue constructor.
 *
 * API conventions:
 * - public API methods/properties are prefixed with `$`
 * - internal methods/properties are prefixed with `_`
 * - non-prefixed properties are assumed to be proxied user
 *   data.
 *
 * @constructor
 * @param {Object} [options]
 * @public
 */

function Vue(options) {
  this._init(options);
}

// install internals
initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
miscMixin(Vue);

// install instance APIs
dataAPI(Vue);
domAPI(Vue);
eventsAPI(Vue);
lifecycleAPI(Vue);

var slot = {

  priority: SLOT,
  params: ['name'],

  bind: function bind() {
    // this was resolved during component transclusion
    var name = this.params.name || 'default';
    var content = this.vm._slotContents && this.vm._slotContents[name];
    if (!content || !content.hasChildNodes()) {
      this.fallback();
    } else {
      this.compile(content.cloneNode(true), this.vm._context, this.vm);
    }
  },

  compile: function compile(content, context, host) {
    if (content && context) {
      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {
        // if the inserted slot has v-if
        // inject fallback content as the v-else
        var elseBlock = document.createElement('template');
        elseBlock.setAttribute('v-else', '');
        elseBlock.innerHTML = this.el.innerHTML;
        // the else block should be compiled in child scope
        elseBlock._context = this.vm;
        content.appendChild(elseBlock);
      }
      var scope = host ? host._scope : this._scope;
      this.unlink = context.$compile(content, host, scope, this._frag);
    }
    if (content) {
      replace(this.el, content);
    } else {
      remove(this.el);
    }
  },

  fallback: function fallback() {
    this.compile(extractContent(this.el, true), this.vm);
  },

  unbind: function unbind() {
    if (this.unlink) {
      this.unlink();
    }
  }
};

var partial = {

  priority: PARTIAL,

  params: ['name'],

  // watch changes to name for dynamic partials
  paramWatchers: {
    name: function name(value) {
      vIf.remove.call(this);
      if (value) {
        this.insert(value);
      }
    }
  },

  bind: function bind() {
    this.anchor = createAnchor('v-partial');
    replace(this.el, this.anchor);
    this.insert(this.params.name);
  },

  insert: function insert(id) {
    var partial = resolveAsset(this.vm.$options, 'partials', id);
    if (process.env.NODE_ENV !== 'production') {
      assertAsset(partial, 'partial', id);
    }
    if (partial) {
      this.factory = new FragmentFactory(this.vm, partial);
      vIf.insert.call(this);
    }
  },

  unbind: function unbind() {
    if (this.frag) {
      this.frag.destroy();
    }
  }
};

var elementDirectives = {
  slot: slot,
  partial: partial
};

var convertArray = vFor._postProcess;

/**
 * Limit filter for arrays
 *
 * @param {Number} n
 * @param {Number} offset (Decimal expected)
 */

function limitBy(arr, n, offset) {
  offset = offset ? parseInt(offset, 10) : 0;
  n = toNumber(n);
  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
}

/**
 * Filter filter for arrays
 *
 * @param {String} search
 * @param {String} [delimiter]
 * @param {String} ...dataKeys
 */

function filterBy(arr, search, delimiter) {
  arr = convertArray(arr);
  if (search == null) {
    return arr;
  }
  if (typeof search === 'function') {
    return arr.filter(search);
  }
  // cast to lowercase string
  search = ('' + search).toLowerCase();
  // allow optional `in` delimiter
  // because why not
  var n = delimiter === 'in' ? 3 : 2;
  // extract and flatten keys
  var keys = toArray(arguments, n).reduce(function (prev, cur) {
    return prev.concat(cur);
  }, []);
  var res = [];
  var item, key, val, j;
  for (var i = 0, l = arr.length; i < l; i++) {
    item = arr[i];
    val = item && item.$value || item;
    j = keys.length;
    if (j) {
      while (j--) {
        key = keys[j];
        if (key === '$key' && contains$1(item.$key, search) || contains$1(getPath(val, key), search)) {
          res.push(item);
          break;
        }
      }
    } else if (contains$1(item, search)) {
      res.push(item);
    }
  }
  return res;
}

/**
 * Filter filter for arrays
 *
 * @param {String} sortKey
 * @param {String} reverse
 */

function orderBy(arr, sortKey, reverse) {
  arr = convertArray(arr);
  if (!sortKey) {
    return arr;
  }
  var order = reverse && reverse < 0 ? -1 : 1;
  // sort on a copy to avoid mutating original array
  return arr.slice().sort(function (a, b) {
    if (sortKey !== '$key') {
      if (isObject(a) && '$value' in a) a = a.$value;
      if (isObject(b) && '$value' in b) b = b.$value;
    }
    a = isObject(a) ? getPath(a, sortKey) : a;
    b = isObject(b) ? getPath(b, sortKey) : b;
    return a === b ? 0 : a > b ? order : -order;
  });
}

/**
 * String contain helper
 *
 * @param {*} val
 * @param {String} search
 */

function contains$1(val, search) {
  var i;
  if (isPlainObject(val)) {
    var keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      if (contains$1(val[keys[i]], search)) {
        return true;
      }
    }
  } else if (isArray(val)) {
    i = val.length;
    while (i--) {
      if (contains$1(val[i], search)) {
        return true;
      }
    }
  } else if (val != null) {
    return val.toString().toLowerCase().indexOf(search) > -1;
  }
}

var digitsRE = /(\d{3})(?=\d)/g;

// asset collections must be a plain object.
var filters = {

  orderBy: orderBy,
  filterBy: filterBy,
  limitBy: limitBy,

  /**
   * Stringify value.
   *
   * @param {Number} indent
   */

  json: {
    read: function read(value, indent) {
      return typeof value === 'string' ? value : JSON.stringify(value, null, Number(indent) || 2);
    },
    write: function write(value) {
      try {
        return JSON.parse(value);
      } catch (e) {
        return value;
      }
    }
  },

  /**
   * 'abc' => 'Abc'
   */

  capitalize: function capitalize(value) {
    if (!value && value !== 0) return '';
    value = value.toString();
    return value.charAt(0).toUpperCase() + value.slice(1);
  },

  /**
   * 'abc' => 'ABC'
   */

  uppercase: function uppercase(value) {
    return value || value === 0 ? value.toString().toUpperCase() : '';
  },

  /**
   * 'AbC' => 'abc'
   */

  lowercase: function lowercase(value) {
    return value || value === 0 ? value.toString().toLowerCase() : '';
  },

  /**
   * 12345 => $12,345.00
   *
   * @param {String} sign
   */

  currency: function currency(value, _currency) {
    value = parseFloat(value);
    if (!isFinite(value) || !value && value !== 0) return '';
    _currency = _currency != null ? _currency : '$';
    var stringified = Math.abs(value).toFixed(2);
    var _int = stringified.slice(0, -3);
    var i = _int.length % 3;
    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
    var _float = stringified.slice(-3);
    var sign = value < 0 ? '-' : '';
    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
  },

  /**
   * 'item' => 'items'
   *
   * @params
   *  an array of strings corresponding to
   *  the single, double, triple ... forms of the word to
   *  be pluralized. When the number to be pluralized
   *  exceeds the length of the args, it will use the last
   *  entry in the array.
   *
   *  e.g. ['single', 'double', 'triple', 'multiple']
   */

  pluralize: function pluralize(value) {
    var args = toArray(arguments, 1);
    return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');
  },

  /**
   * Debounce a handler function.
   *
   * @param {Function} handler
   * @param {Number} delay = 300
   * @return {Function}
   */

  debounce: function debounce(handler, delay) {
    if (!handler) return;
    if (!delay) {
      delay = 300;
    }
    return _debounce(handler, delay);
  }
};

function installGlobalAPI (Vue) {
  /**
   * Vue and every constructor that extends Vue has an
   * associated options object, which can be accessed during
   * compilation steps as `this.constructor.options`.
   *
   * These can be seen as the default options of every
   * Vue instance.
   */

  Vue.options = {
    directives: directives,
    elementDirectives: elementDirectives,
    filters: filters,
    transitions: {},
    components: {},
    partials: {},
    replace: true
  };

  /**
   * Expose useful internals
   */

  Vue.util = util;
  Vue.config = config;
  Vue.set = set;
  Vue['delete'] = del;
  Vue.nextTick = nextTick;

  /**
   * The following are exposed for advanced usage / plugins
   */

  Vue.compiler = compiler;
  Vue.FragmentFactory = FragmentFactory;
  Vue.internalDirectives = internalDirectives;
  Vue.parsers = {
    path: path,
    text: text,
    template: template,
    directive: directive,
    expression: expression
  };

  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */

  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   *
   * @param {Object} extendOptions
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var isFirstExtend = Super.cid === 0;
    if (isFirstExtend && extendOptions._Ctor) {
      return extendOptions._Ctor;
    }
    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production') {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');
        name = null;
      }
    }
    var Sub = createClass(name || 'VueComponent');
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;
    // allow further extension
    Sub.extend = Super.extend;
    // create asset registers, so extended classes
    // can have their private assets too.
    config._assetTypes.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }
    // cache constructor
    if (isFirstExtend) {
      extendOptions._Ctor = Sub;
    }
    return Sub;
  };

  /**
   * A function that returns a sub-class constructor with the
   * given name. This gives us much nicer output when
   * logging instances in the console.
   *
   * @param {String} name
   * @return {Function}
   */

  function createClass(name) {
    /* eslint-disable no-new-func */
    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
    /* eslint-enable no-new-func */
  }

  /**
   * Plugin system
   *
   * @param {Object} plugin
   */

  Vue.use = function (plugin) {
    /* istanbul ignore if */
    if (plugin.installed) {
      return;
    }
    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else {
      plugin.apply(null, args);
    }
    plugin.installed = true;
    return this;
  };

  /**
   * Apply a global mixin by merging it into the default
   * options.
   */

  Vue.mixin = function (mixin) {
    Vue.options = mergeOptions(Vue.options, mixin);
  };

  /**
   * Create asset registration methods with the following
   * signature:
   *
   * @param {String} id
   * @param {*} definition
   */

  config._assetTypes.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production') {
          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = id;
          definition = Vue.extend(definition);
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });

  // expose internal transition API
  extend(Vue.transition, transition);
}

installGlobalAPI(Vue);

Vue.version = '1.0.18';

// devtools global hook
/* istanbul ignore next */
if (config.devtools) {
  if (devtools) {
    devtools.emit('init', Vue);
  } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)) {
    console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
  }
}

module.exports = Vue;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":"/usr/lib/node_modules/browserify/node_modules/process/browser.js"}],"/usr/lib/node_modules/vueify-insert-css/index.js":[function(require,module,exports){
var inserted = exports.cache = {}

exports.insert = function (css) {
  if (inserted[css]) return
  inserted[css] = true

  var elem = document.createElement('style')
  elem.setAttribute('type', 'text/css')

  if ('textContent' in elem) {
    elem.textContent = css
  } else {
    elem.styleSheet.cssText = css
  }

  document.getElementsByTagName('head')[0].appendChild(elem)
  return elem
}

},{}],"/var/www/github/vue-mini-shop/assets/js/components/app.vue":[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = require('../libs/vue.js');

var _vue2 = _interopRequireDefault(_vue);

var _vueReadableNumber = require('../libs/vue-readable-number.js');

var _vueReadableNumber2 = _interopRequireDefault(_vueReadableNumber);

var _vueClickOutside = require('../libs/vue-click-outside.js');

var _vueClickOutside2 = _interopRequireDefault(_vueClickOutside);

var _vueLoadingBar = require('./other/vue-loading-bar.vue');

var _vueLoadingBar2 = _interopRequireDefault(_vueLoadingBar);

var _grid = require('./other/grid.vue');

var _grid2 = _interopRequireDefault(_grid);

var _navigation = require('./nav/navigation.vue');

var _navigation2 = _interopRequireDefault(_navigation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Debug mode


// Import the library
_vue2.default.config.debug = true;

// Import Component


// Import Plugin

_vue2.default.config.devtools = true;

// Global Function
global.cleanUp = function (data) {
  return JSON.parse(JSON.stringify(data));
};

// Global Filter
_vue2.default.filter('readable-number', _vueReadableNumber2.default);

// Global Directive
_vue2.default.directive('click-outside', _vueClickOutside2.default);

// Global Component
_vue2.default.component('grid', _grid2.default);

exports.default = {

  replace: false,

  components: { navigation: _navigation2.default, loadingBar: _vueLoadingBar2.default },

  methods: {
    backToTop: function backToTop() {
      document.body.scrollTop = 0;
    }
  },

  created: function created() {
    this.$action('services:initial_state');
  }
};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div><div class=\"container-mini\"><loading-bar v-bind:progress.sync=\"state.services.progress\"></loading-bar></div><navigation></navigation><div class=\"main-wrapper\"><div class=\"container-mini\"><router-view></router-view></div></div><a @click.prevent=\"backToTop\" class=\"back-to-top\"><i class=\"ion-chevron-up\"></i></a><footer><div class=\"container-mini\"><p class=\"copyright\">Copyright (c) By<a href=\"https://github.com/BosNaufal\"> Bos Naufal</a></p></div></footer></div>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/app.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../libs/vue-click-outside.js":"/var/www/github/vue-mini-shop/assets/js/libs/vue-click-outside.js","../libs/vue-readable-number.js":"/var/www/github/vue-mini-shop/assets/js/libs/vue-readable-number.js","../libs/vue.js":"/var/www/github/vue-mini-shop/assets/js/libs/vue.js","./nav/navigation.vue":"/var/www/github/vue-mini-shop/assets/js/components/nav/navigation.vue","./other/grid.vue":"/var/www/github/vue-mini-shop/assets/js/components/other/grid.vue","./other/vue-loading-bar.vue":"/var/www/github/vue-mini-shop/assets/js/components/other/vue-loading-bar.vue","vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/nav/categories.vue":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {

  props: {
    hasChoosen: {
      type: Function,
      default: function _default() {}
    }
  },

  computed: {
    categories: function categories() {
      var category = this.$route.params.category;
      var categories = [];
      this.state.product.all.forEach(function (product) {
        product.categories.forEach(function (category) {
          category = category.toLowerCase();

          var duplicated = false;

          categories.forEach(function (duplicate) {
            if (category === duplicate) duplicated = true;
          });
          if (!duplicated) categories.push(category);
        });
      });
      return categories;
    }
  }

};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div class=\"categories animated fadeInDown\"><h3>Choose a category:</h3><a v-for=\"category in categories\" href=\"#!/category/{{ category }}\" @click=\"hasChoosen()\">{{ category | capitalize }}</a></div>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/nav/categories.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/nav/navigation.vue":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _search = require('./search.vue');

var _search2 = _interopRequireDefault(_search);

var _categories = require('./categories.vue');

var _categories2 = _interopRequireDefault(_categories);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      searching: false,
      choosingCategory: false,
      newItem: false
    };
  },


  components: {
    search: _search2.default,
    categories: _categories2.default
  },

  watch: {
    'state.cart.totalItem': function stateCartTotalItem(val, old) {
      var me = this;
      if (val > old) {
        me.newItem = true;
        setTimeout(function () {
          me.newItem = false;
        }, 750);
      }
    }
  },

  methods: {
    toggleSearchBar: function toggleSearchBar() {
      this.choosingCategory = false;
      this.searching = !this.searching;
    },
    toggleCategoryList: function toggleCategoryList() {
      this.searching = false;
      this.choosingCategory = !this.choosingCategory;
    }
  },

  ready: function ready() {
    var me = this;
    me.newItem = true;
    setTimeout(function () {
      me.newItem = false;
    }, 750);
  }
};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<nav><div class=\"container-mini\"><div class=\"row\"><grid xs=\"8\"><a href=\"#!/\"><img src=\"./assets/img/logo.png\"/></a></grid><grid xs=\"4\" classes=\"text-right\"><button @click=\"toggleSearchBar\"><i class=\"{{ searching ? 'ion-android-close color-red' : 'ion-ios-search-strong' }}\"></i></button><button><a href=\"#!/cart\"><i class=\"ion-bag\"><span v-if=\"state.cart.totalItem\" v-bind:class=\"{ bounceIn: newItem }\" class=\"badge animated\">{{ state.cart.totalItem }}</span></i></a></button><button @click=\"toggleCategoryList\"><i class=\"{{ choosingCategory ? 'ion-android-close color-red' : 'ion-pricetags' }}\"></i></button></grid></div><search v-if=\"searching\" v-bind:has-searched=\"toggleSearchBar\"></search><categories v-if=\"choosingCategory\" v-bind:has-choosen=\"toggleCategoryList\"></categories></div></nav>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/nav/navigation.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"./categories.vue":"/var/www/github/vue-mini-shop/assets/js/components/nav/categories.vue","./search.vue":"/var/www/github/vue-mini-shop/assets/js/components/nav/search.vue","vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/nav/search.vue":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {

  props: {
    hasSearched: {
      type: Function,
      default: function _default() {}
    }
  },

  data: function data() {
    return {
      focus: false,
      search: ""
    };
  },


  methods: {
    blur: function blur() {
      this.focus = false;
      this.search = "";
    },
    submit: function submit() {
      router.go('/search?q=' + encodeURI(this.search));
      this.hasSearched();
    }
  }

};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<form v-bind:class=\"{ focus: focus }\" @submit.prevent=\"submit\" class=\"search-bar animated fadeInDown\"><div class=\"row\"><grid xs=\"10\"><input type=\"text\" placeholder=\"Cari Produk...\" @focus=\"$set('focus',true)\" @blur=\"blur\" v-model=\"search\"/></grid><grid xs=\"2\" classes=\"text-right animated bounceIn\" v-if=\"focus\"><button type=\"submit\"><i class=\"ion-arrow-right-c\"></i></button></grid></div></form>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/nav/search.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/other/grid.vue":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = {

	props: {
		'xs': {},
		'xsOffset': {},
		'sm': {},
		'smOffset': {},
		'md': {},
		'mdOffset': {},
		'lg': {},
		'lgOffset': {},
		'id': {},
		'classes': {
			default: ""
		},
		'bindClass': {}
	},

	data: function data() {
		return {
			allClasses: "",
			bindedClasses: ""
		};
	},


	computed: {
		allClasses: function allClasses() {
			return this.classes + ' ' + this.bindedClasses + ' ' + this.colClasses;
		},
		bindedClasses: function bindedClasses() {
			var clean = Object.assign({}, this.bindClass, {});

			var binded = clean;
			var keys = Object.keys(clean);

			var hasBinded = [];
			for (var i in keys) {
				var classes = keys[i];
				if (binded[classes]) hasBinded.push(classes);
			}

			return hasBinded.join(" ");
		},
		colClasses: function colClasses() {
			var xs = this.xs ? " col-xs-" + this.xs : "";
			var sm = this.sm ? " col-sm-" + this.sm : "";
			var md = this.md ? " col-md-" + this.md : "";
			var lg = this.lg ? " col-lg-" + this.lg : "";
			var xsOffset = this.xsOffset ? " col-xs-offset-" + this.xsOffset : "";
			var smOffset = this.smOffset ? " col-sm-offset-" + this.smOffset : "";
			var mdOffset = this.mdOffset ? " col-md-offset-" + this.mdOffset : "";
			var lgOffset = this.lgOffset ? " col-lg-offset-" + this.lgOffset : "";
			return xs + sm + md + lg + xsOffset + smOffset + mdOffset + lgOffset;
		}
	}

};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div :class=\"allClasses\" :id=\"id\"><slot></slot></div>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/other/grid.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/other/vue-loading-bar.vue":[function(require,module,exports){
var __vueify_style__ = require("vueify-insert-css").insert("\n\t.loading-bar{\n\t\ttransition:all 0.3s ease;\n\t\t-moz-transition:all 0.3s ease;\n\t\t-webkit-transition:all 0.3s ease;\n\t\t-o-transition:all 0.3s ease;\n\t}\n\t.loading-bar{\n\t\tposition: fixed;\n\t\ttop: 0;\n\t\tbackground: #036FFF;\n\t\theight: 3px;\n\t\topacity: 1;\n    z-index: 100;\n\t}\n\t.glow-bar{\n\t\ttop: 0;\n\t\tposition: absolute;\n\t\twidth: 100px;\n\t\theight: 100%;\n\t\tbox-shadow: -3px 0 15px 1px rgba(0, 20, 255, 0.4)\n\t}\n\n\t.to-right.loading-bar{\n\t\tleft: 0;\n\t}\n\t.to-right .glow-bar{\n\t\tright: 0;\n\t}\n\n\t.to-left.loading-bar{\n\t\tright: 0;\n\t}\n\t.to-left .glow-bar{\n\t\tleft: 0;\n\t}\n\n\t.full.loading-bar{\n\t\ttransition:all 0.1s ease;\n\t\t-moz-transition:all 0.1s ease;\n\t\t-webkit-transition:all 0.1s ease;\n\t\t-o-transition:all 0.1s ease;\n\t\theight: 0;\n\t\topacity: 0;\n\t}\n\n\t.error.loading-bar{\n\t\tbackground: #F44336;\n\t}\n\t.error .glow-bar{\n\t\tbox-shadow: -3px 0 15px 1px rgba(244, 67, 54, 0.4);\n\t}\n")
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});


/*! Copyright (c) 2016 Naufal Rabbani (http://github.com/BosNaufal)
* Licensed Under MIT (http://opensource.org/licenses/MIT)
*
* Vue Loding Bar - Version 0.0.1
*
*/

exports.default = {
	props: {
		id: String,
		class: String,

		progress: Number, // The progress of loading bar

		// the direction of loading bar
		direction: {
			type: String,
			default: "right"
		},

		error: Boolean // Loading Bar error state
	},

	data: function data() {
		return {
			// To show
			show: true,

			// binding class when it end
			full: '',

			// state to animate the width of loading bar
			width: 0,

			// indicate the loading bar is in 100% ( so, wait it till gone )
			wait: false
		};
	},


	watch: {
		progress: function progress(val, old) {
			var _this = this;

			if (old == 0 && val > 0) {
				// Callback Event when it's started
				this.$dispatch('loading-bar:started');
			}

			if (val > 1 && val < 100) {
				// Callback Event when it's loading
				this.$dispatch('loading-bar:loading');
			}

			// When the progress end
			if (this.progress == 100) {

				// Prevent new progress change
				this.wait = true;

				// Start animate it
				this.width = 100;

				setTimeout(function () {
					// animate when element removed
					_this.full = 'full';
					_this.error = false;

					setTimeout(function () {
						//remove bar element
						_this.show = false;

						// New Element is available to create now
						_this.progress = 0;
						_this.wait = false;

						setTimeout(function () {
							// Show Bar
							_this.full = '';
							_this.show = true;

							// Callback Event when it's loaded and totally gone
							_this.$dispatch('loading-bar:loaded');
						});

						// Duration to Waiting for slick hiding animation
					}, 250);

					// Duration is depend on css animation-duration of loading-bar
				}, 700);

				// When the progress doesn't end yet
			} else {

					// Do normaly loading bar animation
					this.full = '';
					this.width = val;
				}
		},
		error: function error(val, old) {
			this.progress = 100;
			// Callback Event when it's error
			this.$dispatch('loading-bar:error');
		}
	},

	methods: {
		styling: function styling() {
			// When loading bar still in progress
			if (!this.wait) {
				return { width: this.width + '%' };

				// When loading bar end
			} else {
					// Make it stuck at 100 to waiting the animation
					return { width: '100%' };
				}
		}
	}

};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "\n<div v-if=\"show\" class=\"loading-bar to-{{ direction }} {{ full }} {{ class != undefined ? class : '' }} {{ error ? 'error' : '' }}\" :id=\"id != undefined ? 'loading-bar-'+id : ''\" :style=\"styling()\">\n\n\t\t<div class=\"glow-bar\"></div>\n\n</div>\n"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/other/vue-loading-bar.vue"
  module.hot.dispose(function () {
    require("vueify-insert-css").cache["\n\t.loading-bar{\n\t\ttransition:all 0.3s ease;\n\t\t-moz-transition:all 0.3s ease;\n\t\t-webkit-transition:all 0.3s ease;\n\t\t-o-transition:all 0.3s ease;\n\t}\n\t.loading-bar{\n\t\tposition: fixed;\n\t\ttop: 0;\n\t\tbackground: #036FFF;\n\t\theight: 3px;\n\t\topacity: 1;\n    z-index: 100;\n\t}\n\t.glow-bar{\n\t\ttop: 0;\n\t\tposition: absolute;\n\t\twidth: 100px;\n\t\theight: 100%;\n\t\tbox-shadow: -3px 0 15px 1px rgba(0, 20, 255, 0.4)\n\t}\n\n\t.to-right.loading-bar{\n\t\tleft: 0;\n\t}\n\t.to-right .glow-bar{\n\t\tright: 0;\n\t}\n\n\t.to-left.loading-bar{\n\t\tright: 0;\n\t}\n\t.to-left .glow-bar{\n\t\tleft: 0;\n\t}\n\n\t.full.loading-bar{\n\t\ttransition:all 0.1s ease;\n\t\t-moz-transition:all 0.1s ease;\n\t\t-webkit-transition:all 0.1s ease;\n\t\t-o-transition:all 0.1s ease;\n\t\theight: 0;\n\t\topacity: 0;\n\t}\n\n\t.error.loading-bar{\n\t\tbackground: #F44336;\n\t}\n\t.error .glow-bar{\n\t\tbox-shadow: -3px 0 15px 1px rgba(244, 67, 54, 0.4);\n\t}\n"] = false
    document.head.removeChild(__vueify_style__)
  })
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js","vueify-insert-css":"/usr/lib/node_modules/vueify-insert-css/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/pages/cart.vue":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  computed: {
    total: function total() {
      var total = 0;
      this.state.cart.all.forEach(function (item) {
        var totalPrice = item.price * item.amount;
        total += totalPrice;
      });
      return total;
    }
  },

  methods: {
    checkOut: function checkOut() {
      this.$action('cart:checkout');
    }
  }

};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div class=\"cart\"><div v-if=\"state.cart.totalItem !== 0\"><h2>Your Cart Items</h2><table class=\"table table-hover checkout\"><tr><th class=\"text-center\">No.</th><th class=\"text-center\">Name</th><th class=\"text-center\">Qty.</th><th class=\"text-right\">Price</th><th class=\"text-right\">Total</th></tr><tr v-for=\"item in state.cart.all\"><td class=\"text-center\">{{ $index + 1 }}</td><td class=\"text-center\">{{ item.name }} - {{ item.color }}</td><td class=\"text-center\">{{ item.amount }}</td><td class=\"text-right\">{{ item.price | readable-number }}</td><td class=\"text-right\">{{ item.price * item.amount | readable-number }}</td></tr><tr><th colspan=\"2\">Total</th><th class=\"text-center\">{{ state.cart.totalItem }}</th><th></th><th class=\"text-right\">Rp. {{ total | readable-number }}</th></tr></table><button @click=\"checkOut\" class=\"btn\">Checkout</button></div><h2 v-else=\"\">You haven't bought something yet...</h2></div>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/pages/cart.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/pages/category.vue":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _product = require('../product/product.vue');

var _product2 = _interopRequireDefault(_product);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

  components: { product: _product2.default },

  computed: {
    products: function products() {
      var category = this.$route.params.category.toLowerCase();
      if (category === undefined || category === null || category === '') return function () {
        return [];
      };

      var theProducts = [];
      this.state.product.all.forEach(function (product) {
        var included = false;
        product.categories.forEach(function (cat) {
          cat = cat.toLowerCase();
          if (cat == category) included = true;
        });
        if (included) theProducts.push(product);
      });
      return theProducts;
    }
  }

};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div><p class=\"result\">The Result of Category \"{{ $route.params.category }}\"</p><product v-for=\"product in products\" v-bind:product=\"product\"></product><h3 v-if=\"products.length == 0\" class=\"not-found text-center\">Sorry... We can't found them :(</h3></div>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/pages/category.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"../product/product.vue":"/var/www/github/vue-mini-shop/assets/js/components/product/product.vue","vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/pages/detil.vue":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _product = require('../product/product.vue');

var _product2 = _interopRequireDefault(_product);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

  components: { product: _product2.default },

  computed: {
    product: function product() {
      var productName = this.$route.params.productName;
      var theProduct = this.state.product.all.find(function (product) {
        return product.kebabName == productName;
      });
      return theProduct;
    }
  }

};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div><product v-bind:product=\"product\"></product></div>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/pages/detil.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"../product/product.vue":"/var/www/github/vue-mini-shop/assets/js/components/product/product.vue","vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/pages/home.vue":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _product = require('../product/product.vue');

var _product2 = _interopRequireDefault(_product);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: { product: _product2.default }
};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div><product :product=\"product\" v-for=\"product in state.product.all\"></product></div>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/pages/home.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"../product/product.vue":"/var/www/github/vue-mini-shop/assets/js/components/product/product.vue","vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/pages/search.vue":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _product = require('../product/product.vue');

var _product2 = _interopRequireDefault(_product);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

  components: { product: _product2.default },

  computed: {
    products: function products() {
      var query = this.$route.query.q.toLowerCase();
      if (query === undefined || query === null || query === '') return function () {
        return [];
      };
      var theProducts = [];

      this.state.product.all.forEach(function (product) {
        var included = product.name.search(new RegExp('(' + query + ')', 'ig'));
        if (included !== -1) theProducts.push(product);
      });

      return theProducts;
    }
  }

};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div><p class=\"result\">The Result of Searching Query \"{{ $route.query.q }}\"</p><product v-for=\"product in products\" v-bind:product=\"product\"></product><h3 v-if=\"products.length == 0\" class=\"not-found text-center\">Sorry... We can't found them :(</h3></div>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/pages/search.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"../product/product.vue":"/var/www/github/vue-mini-shop/assets/js/components/product/product.vue","vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/product/actions.vue":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _product = require('../../stores/product.js');

var _product2 = _interopRequireDefault(_product);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  props: {
    product: {
      type: Object,
      default: {}
    },
    addToCartCallback: {
      type: Function,
      default: function _default() {}
    },
    colorSelected: {
      type: Boolean,
      default: false
    }
  },

  data: function data() {
    return {
      showShareList: false,
      addToCartClicked: false
    };
  },


  watch: {
    colorSelected: function colorSelected(val, old) {
      if (val === false) this.addToCartClicked = false;
    }
  },

  methods: {
    likeIt: function likeIt() {
      var me = this;
      this.$action('product:toggle_like', { product: me.product });
    },
    toggleShare: function toggleShare() {
      this.showShareList = !this.showShareList;
    },
    addToCart: function addToCart() {
      this.addToCartCallback();
      this.addToCartClicked = !this.addToCartClicked;
    }
  }

};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div class=\"actions\"><div class=\"row\"><grid xs=\"8\"><button @click=\"likeIt\" class=\"btn love {{ product.liked ? 'loved' : '' }}\"><i class=\"ion-ios-heart\"></i><span class=\"ml-small\">{{ product.liked ? 'Unlike' : 'Like' }}</span></button><div class=\"psr dib\"><button @click=\"toggleShare\" class=\"btn share ml-small\"><i class=\"ion-android-share-alt\"></i><span class=\"ml-small\">Share</span></button><div v-if=\"showShareList\" v-click-outside:delay=\"toggleShare\" class=\"share-list animated bounceIn\"><a href=\"http://twitter.com/home?status=Check the Vue Mini Shop Out! It's either example App, built with Vue js https://bosnaufal.github.io/vue-mini-shop #vuejs #javascript #github\" class=\"twitter\"><i class=\"ion-social-twitter\"></i><span>Twitter</span></a><a href=\"http://www.facebook.com/share.php?u=https://bosnaufal.github.io/vue-mini-shop\"><i class=\"ion-social-facebook\"></i><span>Facebook</span></a></div></div></grid><grid xs=\"4\" classes=\"text-right\"><button @click=\"addToCart\" class=\"psr btn buy\">{{ addToCartClicked ? 'Choose The Color' : 'Add To Cart' }}</button></grid></div></div>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/product/actions.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"../../stores/product.js":"/var/www/github/vue-mini-shop/assets/js/stores/product.js","vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/product/colors.vue":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  props: {
    selectedCallback: {
      type: Function,
      default: function _default() {}
    },
    product: {
      type: Object,
      default: {}
    }
  },

  methods: {
    colorSelected: function colorSelected(stock) {
      var me = this;

      me.selectedCallback();

      this.$action('cart:add_item', {
        product: me.product,
        color: stock.color
      });
    }
  }
};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div class=\"colors\"><button v-for=\"stock in product.stocks\" @click=\"colorSelected(stock)\" v-if=\"stock.stock !== 0\" class=\"btn\">{{ stock.color }}<span>{{ stock.stock }}</span></button></div>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/product/colors.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/product/comment-editor.vue":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {

  props: {
    product: {
      type: Object,
      default: {}
    }
  },

  data: function data() {
    return {
      comment: ""
    };
  },


  methods: {
    submit: function submit() {
      var me = this;
      this.$action('product:add_comment', {
        product: me.product,
        content: me.comment
      });
      me.comment = "";
    } //submit()

  }
};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div class=\"comment-editor\"><h4 class=\"mb-15\">Leave a Comment</h4><form @submit.prevent=\"submit\"><textarea v-model=\"comment\" placeholder=\"Write a comment here...\"></textarea><button type=\"submit\" class=\"btn\">Submit</button></form></div>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/product/comment-editor.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/product/comment.vue":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {

  props: {
    product: {
      type: Object,
      default: {}
    }
  },

  methods: {
    delete_comment: function delete_comment(comment) {
      var me = this;
      this.$action('product:delete_comment', {
        product: me.product,
        comment: comment
      });
    }
  }

};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div v-if=\"product.comments.length !== 0\" class=\"comment-wrapper\"><h4>{{ product.comments.length }} Comments</h4><div v-for=\"comment in product.comments\" class=\"comment\"><div class=\"row\"><grid xs=\"2\"><div class=\"avatar\"></div></grid><grid xs=\"10\" classes=\"pl-small\"><h5 class=\"name\">You</h5><p class=\"content\"><button @click=\"delete_comment( comment )\" class=\"delete\"><i class=\"ion-android-close\"></i></button>{{ comment.content }}</p></grid></div></div></div>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/product/comment.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/components/product/product.vue":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _colors = require('./colors.vue');

var _colors2 = _interopRequireDefault(_colors);

var _actions = require('./actions.vue');

var _actions2 = _interopRequireDefault(_actions);

var _comment = require('./comment.vue');

var _comment2 = _interopRequireDefault(_comment);

var _commentEditor = require('./comment-editor.vue');

var _commentEditor2 = _interopRequireDefault(_commentEditor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

  props: {
    product: {
      type: Object,
      default: {}
    }
  },

  data: function data() {
    return {
      showColor: false
    };
  },


  components: {
    colors: _colors2.default,
    actions: _actions2.default,
    comment: _comment2.default,
    commentEditor: _commentEditor2.default
  },

  computed: {
    totalStock: function totalStock() {
      var total = 0;
      this.product.stocks.forEach(function (item) {
        total += item.stock;
      });
      return total;
    },
    detilPage: function detilPage() {
      if (this.$route.path.search(/\/product\//ig) === 0) return true;
      return false;
    }
  },

  methods: {
    addToCartCallback: function addToCartCallback() {
      this.showColor = !this.showColor;
    },
    colorSelected: function colorSelected(color) {
      this.showColor = false;
    }
  }

};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div v-bind:class=\"{ 'detil-page': detilPage }\" class=\"product\"><div class=\"img\"><a href=\"#!/product/{{ product.kebabName }}\"><img :src=\"product.img\"/></a></div><div class=\"content\"><a href=\"#!/product/{{ product.kebabName }}\" class=\"name\">{{ product.name }}</a><p class=\"price\"><b>Rp. {{ product.price | readable-number }}</b></p><p class=\"stock text-right\"><b>Stocks:</b><span>&nbsp; {{ totalStock }} pcs</span></p></div><div v-if=\"detilPage\" class=\"detil\">{{{ product.detail }}}</div><colors v-if=\"showColor\" v-bind:product=\"product\" v-bind:selected-callback=\"colorSelected\"></colors><actions v-bind:product=\"product\" v-bind:add-to-cart-callback=\"addToCartCallback\" v-bind:color-selected=\"showColor\"></actions><comment v-if=\"detilPage\" v-bind:product=\"product\"></comment><comment-editor v-if=\"detilPage\" v-bind:product=\"product\"></comment-editor></div>"
if (module.hot) {(function () {  module.hot.accept()
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  var id = "/var/www/github/vue-mini-shop/assets/js/components/product/product.vue"
  if (!module.hot.data) {
    hotAPI.createRecord(id, module.exports)
  } else {
    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
  }
})()}
},{"./actions.vue":"/var/www/github/vue-mini-shop/assets/js/components/product/actions.vue","./colors.vue":"/var/www/github/vue-mini-shop/assets/js/components/product/colors.vue","./comment-editor.vue":"/var/www/github/vue-mini-shop/assets/js/components/product/comment-editor.vue","./comment.vue":"/var/www/github/vue-mini-shop/assets/js/components/product/comment.vue","vue":"/usr/lib/node_modules/vue/dist/vue.common.js","vue-hot-reload-api":"/usr/lib/node_modules/vue-hot-reload-api/index.js"}],"/var/www/github/vue-mini-shop/assets/js/libs/vue-click-outside.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*! Copyright (c) 2016 Naufal Rabbani (http://github.com/BosNaufal)
* Licensed Under MIT (http://opensource.org/licenses/MIT)
*
* Vue Click Outside - Version@1.0.0
*
*/

// Directive for outside click detections
exports.default = {

  time: 0, // need a delay when it come together with 'v-if'

  bind: function bind() {
    var me = this;

    // make a event handler for click event
    this.evt = function (e) {

      // Delay to let Vue evaluate v-if directive
      if (me.arg == 'delay') {
        me.time++;
        if (me.time > 1) {
          // if 'v-if' has been evaulated
          // then check the current click target element
          // if same with directive element,
          // call function from vm which is has a same name with the directive expression
          if (e.target != me.el) me.vm.$eval(me.expression)();
        }
      }
      // When there is no delay, usually not followed by v-if, v-show, v-cloak directive
      else {
          if (e.target != me.el) me.vm.$eval(me.expression)();
        }
    };
    // Attach Event Listener to body
    document.body.addEventListener('click', this.evt, false);
  },
  unbind: function unbind() {
    // Remove Event Listener from body
    document.body.removeEventListener('click', this.evt, false);
  }
};

},{}],"/var/www/github/vue-mini-shop/assets/js/libs/vue-readable-number.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
/*! Copyright (c) 2016 Naufal Rabbani (http://github.com/BosNaufal)
* Licensed Under MIT (http://opensource.org/licenses/MIT)
*
* Vue Readable Number - Version@1.0.0
*
*/
exports.default = {

	// Become Readable Number in Views
	read: function read(val) {

		// Prevent falling in undefined value
		if (val === '' || val === undefined || val === NaN) return 0;

		// if there's a truthy value..
		if (val) {

			// If the number is string..
			if (typeof val == 'string') {
				val = val.replace(/^0/ig, ''); // Remove first "0"
				val = val.replace(/\D/ig, ''); // Remove Non digit Char
				val = val.replace(/\W/ig, ''); // Remove Non Word Char
			}

			// Make a Regex
			var re = /\d{1,3}/g; // grouping each 3 digit
			var target = val.toString();
			var matchy;

			// make an array for matchy string
			var arr = [];
			while ((matchy = re.exec(target)) !== null) {
				arr.push(matchy[0].length);
			}

			// Convert String to Array
			var string = target.split('');

			// Add a comma every three digit from back
			arr.splice(arr.length - 1); // remove buggy first comma
			for (var i = 0; i < arr.length; i++) {
				var time = arr[i];
				var position = i * (time + 1);
				string.splice(string.length - position - time, 0, ',');
			}

			// join Array
			return string.join('');
		}

		// Prevent falling in undefined value
		return val;
	},

	// Two Way Filter...
	// become a integer in v-model
	write: function write(val) {
		// Prevent falling in undefined value
		if (val === '' || val === undefined || val === NaN) return 0;

		// make sure the val is string
		if (typeof val == 'string') {
			// remove non Word Character
			val = val.replace(/\W/ig, '');
		}
		// Make sure it return a real integer
		return parseFloat(val);
	}

};

},{}],"/var/www/github/vue-mini-shop/assets/js/libs/vue-router.min.js":[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

/*!
 * vue-router v0.7.5
 * (c) 2015 Evan You
 * Released under the MIT License.
 */
!function (t, e) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.VueRouter = e() : t.VueRouter = e();
}(undefined, function () {
  return function (t) {
    function e(r) {
      if (n[r]) return n[r].exports;var o = n[r] = { exports: {}, id: r, loaded: !1 };return t[r].call(o.exports, o, o.exports, e), o.loaded = !0, o.exports;
    }var n = {};return e.m = t, e.c = n, e.p = "", e(0);
  }([function (t, e, n) {
    "use strict";
    function r(t, e) {
      var n = e.component;A.util.isPlainObject(n) && (n = e.component = A.extend(n)), "function" != typeof n && (e.component = null, a.warn('invalid component for route "' + t + '".'));
    }var o = n(1)["default"],
        i = n(2)["default"];e.__esModule = !0;var a = n(3),
        s = i(a),
        u = n(7),
        c = i(u),
        h = n(4),
        l = i(h),
        f = n(8),
        p = i(f),
        d = n(18),
        v = i(d),
        g = n(28),
        y = i(g),
        m = n(29),
        _ = i(m),
        w = n(30),
        b = i(w),
        x = n(31),
        C = i(x),
        R = n(32),
        P = i(R),
        E = { "abstract": b["default"], hash: C["default"], html5: P["default"] },
        A = void 0,
        $ = function () {
      function t() {
        var e = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],
            n = e.hashbang,
            r = void 0 === n ? !0 : n,
            i = e["abstract"],
            a = void 0 === i ? !1 : i,
            s = e.history,
            u = void 0 === s ? !1 : s,
            c = e.saveScrollPosition,
            h = void 0 === c ? !1 : c,
            f = e.transitionOnLoad,
            p = void 0 === f ? !1 : f,
            d = e.suppressTransitionError,
            v = void 0 === d ? !1 : d,
            g = e.root,
            y = void 0 === g ? null : g,
            m = e.linkActiveClass,
            _ = void 0 === m ? "v-link-active" : m;if (o(this, t), !t.installed) throw new Error("Please install the Router with Vue.use() before creating an instance.");this.app = null, this._views = [], this._children = [], this._recognizer = new l["default"](), this._guardRecognizer = new l["default"](), this._started = !1, this._startCb = null, this._currentRoute = {}, this._currentTransition = null, this._previousTransition = null, this._notFoundHandler = null, this._notFoundRedirect = null, this._beforeEachHooks = [], this._afterEachHooks = [], this._hasPushState = "undefined" != typeof window && window.history && window.history.pushState, this._rendered = !1, this._transitionOnLoad = p, this._abstract = a, this._hashbang = r, this._history = this._hasPushState && u, this._saveScrollPosition = h, this._linkActiveClass = _, this._suppress = v;var w = A.util.inBrowser;this.mode = !w || this._abstract ? "abstract" : this._history ? "html5" : "hash";var b = E[this.mode],
            x = this;this.history = new b({ root: y, hashbang: this._hashbang, onChange: function onChange(t, e, n) {
            x._match(t, e, n);
          } });
      }return t.prototype.map = function (t) {
        for (var e in t) {
          this.on(e, t[e]);
        }
      }, t.prototype.on = function (t, e) {
        "*" === t ? this._notFound(e) : this._addRoute(t, e, []);
      }, t.prototype.redirect = function (t) {
        for (var e in t) {
          this._addRedirect(e, t[e]);
        }
      }, t.prototype.alias = function (t) {
        for (var e in t) {
          this._addAlias(e, t[e]);
        }
      }, t.prototype.beforeEach = function (t) {
        this._beforeEachHooks.push(t);
      }, t.prototype.afterEach = function (t) {
        this._afterEachHooks.push(t);
      }, t.prototype.go = function (t) {
        var e = !1,
            n = !1;A.util.isObject(t) && (e = t.replace, n = t.append), t = this._stringifyPath(t), t && this.history.go(t, e, n);
      }, t.prototype.replace = function (t) {
        this.go({ path: t, replace: !0 });
      }, t.prototype.start = function (t, e, n) {
        if (this._started) return void a.warn("already started.");if (this._started = !0, this._startCb = n, !this.app) {
          if (!t || !e) throw new Error("Must start vue-router with a component and a root container.");this._appContainer = e;var r = this._appConstructor = "function" == typeof t ? t : A.extend(t);r.options.name = r.options.name || "RouterApp";
        }this.history.start();
      }, t.prototype.stop = function () {
        this.history.stop(), this._started = !1;
      }, t.prototype._addRoute = function (t, e, n) {
        if (r(t, e), e.path = t, e.fullPath = (n.reduce(function (t, e) {
          return t + e.path;
        }, "") + t).replace("//", "/"), n.push({ path: t, handler: e }), this._recognizer.add(n, { as: e.name }), e.subRoutes) for (var o in e.subRoutes) {
          this._addRoute(o, e.subRoutes[o], n.slice());
        }
      }, t.prototype._notFound = function (t) {
        r("*", t), this._notFoundHandler = [{ handler: t }];
      }, t.prototype._addRedirect = function (t, e) {
        "*" === t ? this._notFoundRedirect = e : this._addGuard(t, e, this.replace);
      }, t.prototype._addAlias = function (t, e) {
        this._addGuard(t, e, this._match);
      }, t.prototype._addGuard = function (t, e, n) {
        var r = this;this._guardRecognizer.add([{ path: t, handler: function handler(t, o) {
            var i = a.mapParams(e, t.params, o);n.call(r, i);
          } }]);
      }, t.prototype._checkGuard = function (t) {
        var e = this._guardRecognizer.recognize(t);return e ? (e[0].handler(e[0], e.queryParams), !0) : this._notFoundRedirect && (e = this._recognizer.recognize(t), !e) ? (this.replace(this._notFoundRedirect), !0) : void 0;
      }, t.prototype._match = function (t, e, n) {
        var r = this;if (!this._checkGuard(t)) {
          var o = this._currentRoute,
              i = this._currentTransition;if (i) {
            if (i.to.path === t) return;if (o.path === t) return i.aborted = !0, void (this._currentTransition = this._prevTransition);i.aborted = !0;
          }var a = new p["default"](t, this),
              s = new v["default"](this, a, o);this._prevTransition = i, this._currentTransition = s, this.app || (this.app = new this._appConstructor({ el: this._appContainer, _meta: { $route: a } }));var u = this._beforeEachHooks,
              c = function c() {
            s.start(function () {
              r._postTransition(a, e, n);
            });
          };u.length ? s.runQueue(u, function (t, e, n) {
            s === r._currentTransition && s.callHook(t, null, n, { expectBoolean: !0 });
          }, c) : c(), !this._rendered && this._startCb && this._startCb.call(null), this._rendered = !0;
        }
      }, t.prototype._onTransitionValidated = function (t) {
        var e = this._currentRoute = t.to;this.app.$route !== e && (this.app.$route = e, this._children.forEach(function (t) {
          t.$route = e;
        })), this._afterEachHooks.length && this._afterEachHooks.forEach(function (e) {
          return e.call(null, { to: t.to, from: t.from });
        }), this._currentTransition.done = !0;
      }, t.prototype._postTransition = function (t, e, n) {
        var r = e && e.pos;r && this._saveScrollPosition ? A.nextTick(function () {
          window.scrollTo(r.x, r.y);
        }) : n && A.nextTick(function () {
          var t = document.getElementById(n.slice(1));t && window.scrollTo(window.scrollX, t.offsetTop);
        });
      }, t.prototype._stringifyPath = function (t) {
        if (t && "object" == (typeof t === "undefined" ? "undefined" : _typeof(t))) {
          if (t.name) {
            var e = t.params || {};return t.query && (e.queryParams = t.query), this._recognizer.generate(t.name, e);
          }return t.path ? t.path : "";
        }return t ? t + "" : "";
      }, t;
    }();$.installed = !1, $.install = function (t) {
      return $.installed ? void a.warn("already installed.") : (A = t, c["default"](A), y["default"](A), _["default"](A), s["default"].Vue = A, void ($.installed = !0));
    }, "undefined" != typeof window && window.Vue && window.Vue.use($), e["default"] = $, t.exports = e["default"];
  }, function (t, e) {
    "use strict";
    e["default"] = function (t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
    }, e.__esModule = !0;
  }, function (t, e) {
    "use strict";
    e["default"] = function (t) {
      return t && t.__esModule ? t : { "default": t };
    }, e.__esModule = !0;
  }, function (t, e, n) {
    "use strict";
    function r(t) {
      window.console && (console.warn("[vue-router] " + t), (!p.Vue || p.Vue.config.debug) && console.warn(new Error("warning stack trace:").stack));
    }function o(t, e, n) {
      var r = t.match(/(\?.*)$/);if (r && (r = r[1], t = t.slice(0, -r.length)), "?" === e.charAt(0)) return t + e;var o = t.split("/");n && o[o.length - 1] || o.pop();for (var i = e.replace(/^\//, "").split("/"), a = 0; a < i.length; a++) {
        var s = i[a];"." !== s && (".." === s ? o.pop() : o.push(s));
      }return "" !== o[0] && o.unshift(""), o.join("/");
    }function i(t) {
      return t && "function" == typeof t.then;
    }function a(t, e) {
      var n = t && (t.$options || t.options);return n && n.route && n.route[e];
    }function s(t, e) {
      d ? d.$options.components._ = t.component : d = { resolve: p.Vue.prototype._resolveComponent, $options: { components: { _: t.component } } }, d.resolve("_", function (n) {
        t.component = n, e(n);
      });
    }function u(t, e, n) {
      return void 0 === e && (e = {}), t = t.replace(/:([^\/]+)/g, function (n, o) {
        var i = e[o];return i || r('param "' + o + '" not found when generating path for "' + t + '" with params ' + JSON.stringify(e)), i || "";
      }), n && (t += f(n)), t;
    }var c = n(2)["default"];e.__esModule = !0, e.warn = r, e.resolvePath = o, e.isPromise = i, e.getRouteConfig = a, e.resolveAsyncComponent = s, e.mapParams = u;var h = n(4),
        l = c(h),
        f = l["default"].prototype.generateQueryString,
        p = {};e["default"] = p;var d = void 0;
  }, function (t, e, n) {
    var r;(function (t) {
      (function () {
        "use strict";
        function o(t, e, n) {
          this.path = t, this.matcher = e, this.delegate = n;
        }function i(t) {
          this.routes = {}, this.children = {}, this.target = t;
        }function a(t, e, n) {
          return function (r, i) {
            var s = t + r;return i ? void i(a(s, e, n)) : new o(t + r, e, n);
          };
        }function s(t, e, n) {
          for (var r = 0, o = 0, i = t.length; i > o; o++) {
            r += t[o].path.length;
          }e = e.substr(r);var a = { path: e, handler: n };t.push(a);
        }function u(t, e, n, r) {
          var o = e.routes;for (var i in o) {
            if (o.hasOwnProperty(i)) {
              var a = t.slice();s(a, i, o[i]), e.children[i] ? u(a, e.children[i], n, r) : n.call(r, a);
            }
          }
        }function c(t) {
          return "[object Array]" === Object.prototype.toString.call(t);
        }function h(t) {
          this.string = t;
        }function l(t) {
          this.name = t;
        }function f(t) {
          this.name = t;
        }function p() {}function d(t, e, n) {
          "/" === t.charAt(0) && (t = t.substr(1));var r = t.split("/"),
              o = [];n.val = "";for (var i = 0, a = r.length; a > i; i++) {
            var s,
                u = r[i];(s = u.match(/^:([^\/]+)$/)) ? (o.push(new l(s[1])), e.push(s[1]), n.val += "3") : (s = u.match(/^\*([^\/]+)$/)) ? (o.push(new f(s[1])), n.val += "2", e.push(s[1])) : "" === u ? (o.push(new p()), n.val += "1") : (o.push(new h(u)), n.val += "4");
          }return n.val = +n.val, o;
        }function v(t) {
          this.charSpec = t, this.nextStates = [];
        }function g(t) {
          return t.sort(function (t, e) {
            return e.specificity.val - t.specificity.val;
          });
        }function y(t, e) {
          for (var n = [], r = 0, o = t.length; o > r; r++) {
            var i = t[r];n = n.concat(i.match(e));
          }return n;
        }function m(t) {
          this.queryParams = t || {};
        }function _(t, e, n) {
          for (var r = t.handlers, o = t.regex, i = e.match(o), a = 1, s = new m(n), u = 0, c = r.length; c > u; u++) {
            for (var h = r[u], l = h.names, f = {}, p = 0, d = l.length; d > p; p++) {
              f[l[p]] = i[a++];
            }s.push({ handler: h.handler, params: f, isDynamic: !!l.length });
          }return s;
        }function w(t, e) {
          return e.eachChar(function (e) {
            t = t.put(e);
          }), t;
        }function b(t) {
          return t = t.replace(/\+/gm, "%20"), decodeURIComponent(t);
        }o.prototype = { to: function to(t, e) {
            var n = this.delegate;if (n && n.willAddRoute && (t = n.willAddRoute(this.matcher.target, t)), this.matcher.add(this.path, t), e) {
              if (0 === e.length) throw new Error("You must have an argument in the function passed to `to`");this.matcher.addChild(this.path, t, e, this.delegate);
            }return this;
          } }, i.prototype = { add: function add(t, e) {
            this.routes[t] = e;
          }, addChild: function addChild(t, e, n, r) {
            var o = new i(e);this.children[t] = o;var s = a(t, o, r);r && r.contextEntered && r.contextEntered(e, s), n(s);
          } };var x = function x(t, e) {
          var n = new i();t(a("", n, this.delegate)), u([], n, function (t) {
            e ? e(this, t) : this.add(t);
          }, this);
        },
            C = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\"],
            R = new RegExp("(\\" + C.join("|\\") + ")", "g");h.prototype = { eachChar: function eachChar(t) {
            for (var e, n = this.string, r = 0, o = n.length; o > r; r++) {
              e = n.charAt(r), t({ validChars: e });
            }
          }, regex: function regex() {
            return this.string.replace(R, "\\$1");
          }, generate: function generate() {
            return this.string;
          } }, l.prototype = { eachChar: function eachChar(t) {
            t({ invalidChars: "/", repeat: !0 });
          }, regex: function regex() {
            return "([^/]+)";
          }, generate: function generate(t) {
            return t[this.name];
          } }, f.prototype = { eachChar: function eachChar(t) {
            t({ invalidChars: "", repeat: !0 });
          }, regex: function regex() {
            return "(.+)";
          }, generate: function generate(t) {
            return t[this.name];
          } }, p.prototype = { eachChar: function eachChar() {}, regex: function regex() {
            return "";
          }, generate: function generate() {
            return "";
          } }, v.prototype = { get: function get(t) {
            for (var e = this.nextStates, n = 0, r = e.length; r > n; n++) {
              var o = e[n],
                  i = o.charSpec.validChars === t.validChars;if (i = i && o.charSpec.invalidChars === t.invalidChars) return o;
            }
          }, put: function put(t) {
            var e;return (e = this.get(t)) ? e : (e = new v(t), this.nextStates.push(e), t.repeat && e.nextStates.push(e), e);
          }, match: function match(t) {
            for (var e, n, r, o = this.nextStates, i = [], a = 0, s = o.length; s > a; a++) {
              e = o[a], n = e.charSpec, "undefined" != typeof (r = n.validChars) ? -1 !== r.indexOf(t) && i.push(e) : "undefined" != typeof (r = n.invalidChars) && -1 === r.indexOf(t) && i.push(e);
            }return i;
          } };var P = Object.create || function (t) {
          function e() {}return e.prototype = t, new e();
        };m.prototype = P({ splice: Array.prototype.splice, slice: Array.prototype.slice, push: Array.prototype.push, length: 0, queryParams: null });var E = function E() {
          this.rootState = new v(), this.names = {};
        };E.prototype = { add: function add(t, e) {
            for (var n, r = this.rootState, o = "^", i = {}, a = [], s = [], u = !0, c = 0, h = t.length; h > c; c++) {
              var l = t[c],
                  f = [],
                  v = d(l.path, f, i);s = s.concat(v);for (var g = 0, y = v.length; y > g; g++) {
                var m = v[g];m instanceof p || (u = !1, r = r.put({ validChars: "/" }), o += "/", r = w(r, m), o += m.regex());
              }var _ = { handler: l.handler, names: f };a.push(_);
            }u && (r = r.put({ validChars: "/" }), o += "/"), r.handlers = a, r.regex = new RegExp(o + "$"), r.specificity = i, (n = e && e.as) && (this.names[n] = { segments: s, handlers: a });
          }, handlersFor: function handlersFor(t) {
            var e = this.names[t],
                n = [];if (!e) throw new Error("There is no route named " + t);for (var r = 0, o = e.handlers.length; o > r; r++) {
              n.push(e.handlers[r]);
            }return n;
          }, hasRoute: function hasRoute(t) {
            return !!this.names[t];
          }, generate: function generate(t, e) {
            var n = this.names[t],
                r = "";if (!n) throw new Error("There is no route named " + t);for (var o = n.segments, i = 0, a = o.length; a > i; i++) {
              var s = o[i];s instanceof p || (r += "/", r += s.generate(e));
            }return "/" !== r.charAt(0) && (r = "/" + r), e && e.queryParams && (r += this.generateQueryString(e.queryParams, n.handlers)), r;
          }, generateQueryString: function generateQueryString(t, e) {
            var n = [],
                r = [];for (var o in t) {
              t.hasOwnProperty(o) && r.push(o);
            }r.sort();for (var i = 0, a = r.length; a > i; i++) {
              o = r[i];var s = t[o];if (null != s) {
                var u = encodeURIComponent(o);if (c(s)) for (var h = 0, l = s.length; l > h; h++) {
                  var f = o + "[]=" + encodeURIComponent(s[h]);n.push(f);
                } else u += "=" + encodeURIComponent(s), n.push(u);
              }
            }return 0 === n.length ? "" : "?" + n.join("&");
          }, parseQueryString: function parseQueryString(t) {
            for (var e = t.split("&"), n = {}, r = 0; r < e.length; r++) {
              var o,
                  i = e[r].split("="),
                  a = b(i[0]),
                  s = a.length,
                  u = !1;1 === i.length ? o = "true" : (s > 2 && "[]" === a.slice(s - 2) && (u = !0, a = a.slice(0, s - 2), n[a] || (n[a] = [])), o = i[1] ? b(i[1]) : ""), u ? n[a].push(o) : n[a] = o;
            }return n;
          }, recognize: function recognize(t) {
            var e,
                n,
                r,
                o,
                i = [this.rootState],
                a = {},
                s = !1;if (o = t.indexOf("?"), -1 !== o) {
              var u = t.substr(o + 1, t.length);t = t.substr(0, o), a = this.parseQueryString(u);
            }for (t = decodeURI(t), "/" !== t.charAt(0) && (t = "/" + t), e = t.length, e > 1 && "/" === t.charAt(e - 1) && (t = t.substr(0, e - 1), s = !0), n = 0, r = t.length; r > n && (i = y(i, t.charAt(n)), i.length); n++) {}var c = [];for (n = 0, r = i.length; r > n; n++) {
              i[n].handlers && c.push(i[n]);
            }i = g(c);var h = c[0];return h && h.handlers ? (s && "(.+)$" === h.regex.source.slice(-5) && (t += "/"), _(h, t, a)) : void 0;
          } }, E.prototype.map = x, E.VERSION = "0.1.9";var A = E;n(6).amd ? (r = function () {
          return A;
        }.call(e, n, e, t), !(void 0 !== r && (t.exports = r))) : "undefined" != typeof t && t.exports ? t.exports = A : "undefined" != typeof this && (this.RouteRecognizer = A);
      }).call(this);
    }).call(e, n(5)(t));
  }, function (t, e) {
    t.exports = function (t) {
      return t.webpackPolyfill || (t.deprecate = function () {}, t.paths = [], t.children = [], t.webpackPolyfill = 1), t;
    };
  }, function (t, e) {
    t.exports = function () {
      throw new Error("define cannot be used indirect");
    };
  }, function (t, e) {
    "use strict";
    e.__esModule = !0, e["default"] = function (t) {
      var e = t.util,
          n = t.prototype._init;t.prototype._init = function (t) {
        var r = t._parent || t.parent || this,
            o = r.$route;o && (o.router._children.push(this), this.$route || (this._defineMeta ? this._defineMeta("$route", o) : e.defineReactive(this, "$route", o))), n.call(this, t);
      };var r = t.prototype._destroy;t.prototype._destroy = function () {
        if (!this._isBeingDestroyed) {
          var t = this.$root.$route;t && t.router._children.$remove(this), r.apply(this, arguments);
        }
      };var o = t.config.optionMergeStrategies,
          i = /^(data|activate|deactivate)$/;o && (o.route = function (t, n) {
        if (!n) return t;if (!t) return n;var r = {};e.extend(r, t);for (var o in n) {
          var a = r[o],
              s = n[o];a && i.test(o) ? r[o] = (e.isArray(a) ? a : [a]).concat(s) : r[o] = s;
        }return r;
      });
    }, t.exports = e["default"];
  }, function (t, e, n) {
    "use strict";
    var r = n(1)["default"],
        o = n(9)["default"];e.__esModule = !0;var i = /^(component|subRoutes)$/,
        a = function s(t, e) {
      var n = this;r(this, s);var a = e._recognizer.recognize(t);a && ([].forEach.call(a, function (t) {
        for (var e in t.handler) {
          i.test(e) || (n[e] = t.handler[e]);
        }
      }), this.query = a.queryParams, this.params = [].reduce.call(a, function (t, e) {
        if (e.params) for (var n in e.params) {
          t[n] = e.params[n];
        }return t;
      }, {})), this.path = t, this.router = e, this.matched = a || e._notFoundHandler, o(this);
    };e["default"] = a, t.exports = e["default"];
  }, function (t, e, n) {
    t.exports = { "default": n(10), __esModule: !0 };
  }, function (t, e, n) {
    n(11), t.exports = n(16).Object.freeze;
  }, function (t, e, n) {
    var r = n(12);n(13)("freeze", function (t) {
      return function (e) {
        return t && r(e) ? t(e) : e;
      };
    });
  }, function (t, e) {
    t.exports = function (t) {
      return null !== t && ("object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) || "function" == typeof t);
    };
  }, function (t, e, n) {
    t.exports = function (t, e) {
      var r = n(14),
          o = (n(16).Object || {})[t] || Object[t],
          i = {};i[t] = e(o), r(r.S + r.F * n(17)(function () {
        o(1);
      }), "Object", i);
    };
  }, function (t, e, n) {
    var r = n(15),
        o = n(16),
        i = "prototype",
        a = function a(t, e) {
      return function () {
        return t.apply(e, arguments);
      };
    },
        s = function s(t, e, n) {
      var u,
          c,
          h,
          l,
          f = t & s.G,
          p = t & s.P,
          d = f ? r : t & s.S ? r[e] : (r[e] || {})[i],
          v = f ? o : o[e] || (o[e] = {});f && (n = e);for (u in n) {
        c = !(t & s.F) && d && u in d, c && u in v || (h = c ? d[u] : n[u], f && "function" != typeof d[u] ? l = n[u] : t & s.B && c ? l = a(h, r) : t & s.W && d[u] == h ? !function (t) {
          l = function l(e) {
            return this instanceof t ? new t(e) : t(e);
          }, l[i] = t[i];
        }(h) : l = p && "function" == typeof h ? a(Function.call, h) : h, v[u] = l, p && ((v[i] || (v[i] = {}))[u] = h));
      }
    };s.F = 1, s.G = 2, s.S = 4, s.P = 8, s.B = 16, s.W = 32, t.exports = s;
  }, function (t, e) {
    var n = "undefined",
        r = t.exports = (typeof window === "undefined" ? "undefined" : _typeof(window)) != n && window.Math == Math ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) != n && self.Math == Math ? self : Function("return this")();"number" == typeof __g && (__g = r);
  }, function (t, e) {
    var n = t.exports = {};"number" == typeof __e && (__e = n);
  }, function (t, e) {
    t.exports = function (t) {
      try {
        return !!t();
      } catch (e) {
        return !0;
      }
    };
  }, function (t, e, n) {
    "use strict";
    function r(t) {
      return "[object Object]" === Object.prototype.toString.call(t);
    }var o = n(1)["default"];e.__esModule = !0;var i = n(3),
        a = n(19),
        s = function () {
      function t(e, n, r) {
        o(this, t), this.router = e, this.to = n, this.from = r, this.next = null, this.aborted = !1, this.done = !1, this.deactivateQueue = e._views;var i = n.matched ? Array.prototype.slice.call(n.matched) : [];this.activateQueue = i.map(function (t) {
          return t.handler;
        });
      }return t.prototype.abort = function () {
        if (!this.aborted) {
          this.aborted = !0;var t = !this.from.path && "/" === this.to.path;t || this.router.replace(this.from.path || "/");
        }
      }, t.prototype.redirect = function (t) {
        this.aborted || (this.aborted = !0, "string" == typeof t ? t = i.mapParams(t, this.to.params, this.to.query) : (t.params = this.to.params, t.query = this.to.query), this.router.replace(t));
      }, t.prototype.start = function (t) {
        var e = this,
            n = this.deactivateQueue,
            r = this.activateQueue,
            o = n.slice().reverse(),
            i = void 0,
            s = void 0;for (s = 0; s < o.length && a.canReuse(o[s], r[s], e); s++) {}s > 0 && (i = o.slice(0, s), n = o.slice(s).reverse(), r = r.slice(s)), e.runQueue(n, a.canDeactivate, function () {
          e.runQueue(r, a.canActivate, function () {
            e.runQueue(n, a.deactivate, function () {
              if (e.router._onTransitionValidated(e), i && i.forEach(function (t) {
                a.reuse(t, e);
              }), n.length) {
                var r = n[n.length - 1],
                    o = i ? i.length : 0;a.activate(r, e, o, t);
              } else t();
            });
          });
        });
      }, t.prototype.runQueue = function (t, e, n) {
        function r(i) {
          i >= t.length ? n() : e(t[i], o, function () {
            r(i + 1);
          });
        }var o = this;r(0);
      }, t.prototype.callHook = function (t, e, n) {
        var o = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3],
            a = o.expectBoolean,
            s = void 0 === a ? !1 : a,
            u = o.expectData,
            c = void 0 === u ? !1 : u,
            h = o.cleanup,
            l = this,
            f = !1,
            p = function p() {
          h && h(), l.abort();
        },
            d = function d(t) {
          if (h ? v() : p(), t && !l.router._suppress) throw i.warn("Uncaught error during transition: "), t instanceof Error ? t : new Error(t);
        },
            v = function v(t) {
          return f ? void i.warn("transition.next() should be called only once.") : (f = !0, l.aborted ? void (h && h()) : void (n && n(t, d)));
        },
            g = { to: l.to, from: l.from, abort: p, next: v, redirect: function redirect() {
            l.redirect.apply(l, arguments);
          } },
            y = void 0;try {
          y = t.call(e, g);
        } catch (m) {
          return d(m);
        }var _ = i.isPromise(y);s ? "boolean" == typeof y ? y ? v() : p() : _ ? y.then(function (t) {
          t ? v() : p();
        }, d) : t.length || v(y) : _ ? y.then(v, d) : (c && r(y) || !t.length) && v(y);
      }, t.prototype.callHooks = function (t, e, n, r) {
        var o = this;Array.isArray(t) ? !function () {
          var i = [];i._needMerge = !0;var a = void 0;o.runQueue(t, function (t, n, a) {
            o.aborted || o.callHook(t, e, function (t, e) {
              t && i.push(t), e = e, a();
            }, r);
          }, function () {
            n(i, a);
          });
        }() : this.callHook(t, e, n, r);
      }, t;
    }();e["default"] = s, t.exports = e["default"];
  }, function (t, e, n) {
    "use strict";
    function r(t, e, n) {
      var r = t.childVM;if (!r || !e) return !1;if (t.Component !== e.component) return !1;var o = p.getRouteConfig(r, "canReuse");return "boolean" == typeof o ? o : o ? o.call(r, { to: n.to, from: n.from }) : !0;
    }function o(t, e, n) {
      var r = t.childVM,
          o = p.getRouteConfig(r, "canDeactivate");o ? e.callHook(o, r, n, { expectBoolean: !0 }) : n();
    }function i(t, e, n) {
      p.resolveAsyncComponent(t, function (t) {
        if (!e.aborted) {
          var r = p.getRouteConfig(t, "canActivate");r ? e.callHook(r, null, n, { expectBoolean: !0 }) : n();
        }
      });
    }function a(t, e, n) {
      var r = t.childVM,
          o = p.getRouteConfig(r, "deactivate");o ? e.callHooks(o, r, n) : n();
    }function s(t, e, n, r, o) {
      var i = e.activateQueue[n];if (!i) return t._bound && t.setComponent(null), void (r && r());var a = t.Component = i.component,
          u = p.getRouteConfig(a, "activate"),
          h = p.getRouteConfig(a, "data"),
          l = p.getRouteConfig(a, "waitForData");t.depth = n, t.activated = !1;var f = void 0,
          d = !(!h || l);if (o = o && t.childVM && t.childVM.constructor === a) f = t.childVM, f.$loadingRouteData = d;else {
        if (t.unbuild(!0), t.keepAlive) {
          var v = e.router._views,
              g = v.indexOf(t);g > 0 && (e.router._views = v.slice(g), t.childVM && (t.childVM._routerViews = v.slice(0, g)));
        }if (f = t.build({ _meta: { $loadingRouteData: d } }), t.keepAlive) {
          f.$loadingRouteData = d;var y = f._routerViews;y && (e.router._views = y.concat(e.router._views), t.childView = y[y.length - 1], f._routerViews = null);
        }
      }var m = function m() {
        f.$destroy();
      },
          _ = function _() {
        if (o) return void (r && r());var n = e.router;n._rendered || n._transitionOnLoad ? t.transition(f) : (t.setCurrent ? t.setCurrent(f) : t.childVM = f, f.$before(t.anchor, null, !1)), r && r();
      },
          w = function w() {
        t.activated = !0, t.childView && s(t.childView, e, n + 1, null, o || t.keepAlive), h && l ? c(f, e, h, _, m) : (h && c(f, e, h), _());
      };u ? e.callHooks(u, f, w, { cleanup: m }) : w();
    }function u(t, e) {
      var n = t.childVM,
          r = p.getRouteConfig(n, "data");r && c(n, e, r);
    }function c(t, e, n, r, o) {
      t.$loadingRouteData = !0, e.callHooks(n, t, function (e, n) {
        Array.isArray(e) && e._needMerge && (e = e.reduce(function (t, e) {
          return h(e) && l(e).forEach(function (n) {
            t[n] = e[n];
          }), t;
        }, f(null)));var o = [];h(e) && l(e).forEach(function (n) {
          var r = e[n];p.isPromise(r) ? o.push(r.then(function (e) {
            t.$set(n, e);
          })) : t.$set(n, r);
        }), o.length ? o[0].constructor.all(o).then(function (e) {
          t.$loadingRouteData = !1, r && r();
        }, n) : (t.$loadingRouteData = !1, r && r());
      }, { cleanup: o, expectData: !0 });
    }function h(t) {
      return "[object Object]" === Object.prototype.toString.call(t);
    }var l = n(20)["default"],
        f = n(25)["default"];e.__esModule = !0, e.canReuse = r, e.canDeactivate = o, e.canActivate = i, e.deactivate = a, e.activate = s, e.reuse = u;var p = n(3);
  }, function (t, e, n) {
    t.exports = { "default": n(21), __esModule: !0 };
  }, function (t, e, n) {
    n(22), t.exports = n(16).Object.keys;
  }, function (t, e, n) {
    var r = n(23);n(13)("keys", function (t) {
      return function (e) {
        return t(r(e));
      };
    });
  }, function (t, e, n) {
    var r = n(24);t.exports = function (t) {
      return Object(r(t));
    };
  }, function (t, e) {
    t.exports = function (t) {
      if (void 0 == t) throw TypeError("Can't call method on  " + t);return t;
    };
  }, function (t, e, n) {
    t.exports = { "default": n(26), __esModule: !0 };
  }, function (t, e, n) {
    var r = n(27);t.exports = function (t, e) {
      return r.create(t, e);
    };
  }, function (t, e) {
    var n = Object;t.exports = { create: n.create, getProto: n.getPrototypeOf, isEnum: {}.propertyIsEnumerable, getDesc: n.getOwnPropertyDescriptor, setDesc: n.defineProperty, setDescs: n.defineProperties, getKeys: n.keys, getNames: n.getOwnPropertyNames, getSymbols: n.getOwnPropertySymbols, each: [].forEach };
  }, function (t, e, n) {
    "use strict";
    e.__esModule = !0;var r = n(3),
        o = n(19);e["default"] = function (t) {
      var e = t.util,
          n = t.directive("_component") || t.internalDirectives.component,
          i = e.extend({}, n);e.extend(i, { _isRouterView: !0, bind: function bind() {
          var t = this.vm.$route;if (!t) return void r.warn("<router-view> can only be used inside a router-enabled app.");this._isDynamicLiteral = !0, n.bind.call(this);var e = this.router = t.router;e._views.unshift(this);var i = e._views[1];i && (i.childView = this);var a = t.router._currentTransition;if (!i && a.done || i && i.activated) {
            var s = i ? i.depth + 1 : 0;o.activate(this, a, s);
          }
        }, unbind: function unbind() {
          this.router._views.$remove(this), n.unbind.call(this);
        } }), t.elementDirective("router-view", i);
    }, t.exports = e["default"];
  }, function (t, e, n) {
    "use strict";
    e.__esModule = !0;var r = n(3),
        o = /\/$/,
        i = /[-.*+?^${}()|[\]\/\\]/g;e["default"] = function (t) {
      function e(t) {
        return t.protocol === location.protocol && t.hostname === location.hostname && t.port === location.port;
      }var n = t.util;t.directive("link", { bind: function bind() {
          var t = this,
              o = this.vm;if (!o.$route) return void r.warn("v-link can only be used inside a router-enabled app.");var i = o.$route.router;this.handler = function (n) {
            if (!(n.metaKey || n.ctrlKey || n.shiftKey || n.defaultPrevented || 0 !== n.button)) {
              var r = t.target,
                  o = function o(t) {
                n.preventDefault(), null != t && i.go(t);
              };if ("A" === t.el.tagName || n.target === t.el) o(r);else {
                for (var a = n.target; a && "A" !== a.tagName && a !== t.el;) {
                  a = a.parentNode;
                }if (!a) return;"A" === a.tagName && a.href ? e(a) && o({ path: a.pathname, replace: r && r.replace, append: r && r.append }) : o(r);
              }
            }
          }, this.el.addEventListener("click", this.handler), this.unwatch = o.$watch("$route.path", n.bind(this.updateClasses, this));
        }, update: function update(t) {
          var e = this.vm.$route.router,
              r = void 0;this.target = t, n.isObject(t) && (r = t.append, this.exact = t.exact, this.prevActiveClass = this.activeClass, this.activeClass = t.activeClass), t = this.path = e._stringifyPath(t), this.activeRE = t && !this.exact ? new RegExp("^" + t.replace(/\/$/, "").replace(i, "\\$&") + "(\\/|$)") : null, this.updateClasses(this.vm.$route.path);var o = "/" === t.charAt(0),
              a = t && ("hash" === e.mode || o) ? e.history.formatPath(t, r) : t;"A" === this.el.tagName && (a ? this.el.href = a : this.el.removeAttribute("href"));
        }, updateClasses: function updateClasses(t) {
          var e = this.el,
              r = this.path,
              i = this.vm.$route.router,
              a = this.activeClass || i._linkActiveClass;this.prevActiveClass !== a && n.removeClass(e, this.prevActiveClass), this.exact ? r === t || "/" !== r.charAt(r.length - 1) && r === t.replace(o, "") ? n.addClass(e, a) : n.removeClass(e, a) : this.activeRE && this.activeRE.test(t) ? n.addClass(e, a) : n.removeClass(e, a);
        }, unbind: function unbind() {
          this.el.removeEventListener("click", this.handler), this.unwatch && this.unwatch();
        } });
    }, t.exports = e["default"];
  }, function (t, e, n) {
    "use strict";
    var r = n(1)["default"];e.__esModule = !0;var o = n(3),
        i = function () {
      function t(e) {
        var n = e.onChange;r(this, t), this.onChange = n, this.currentPath = "/";
      }return t.prototype.start = function () {
        this.onChange("/");
      }, t.prototype.stop = function () {}, t.prototype.go = function (t, e, n) {
        t = this.currentPath = this.formatPath(t, n), this.onChange(t);
      }, t.prototype.formatPath = function (t, e) {
        return "/" === t.charAt(0) ? t : o.resolvePath(this.currentPath, t, e);
      }, t;
    }();e["default"] = i, t.exports = e["default"];
  }, function (t, e, n) {
    "use strict";
    var r = n(1)["default"];e.__esModule = !0;var o = n(3),
        i = function () {
      function t(e) {
        var n = e.hashbang,
            o = e.onChange;r(this, t), this.hashbang = n, this.onChange = o;
      }return t.prototype.start = function () {
        var t = this;this.listener = function () {
          var e = location.hash,
              n = e.replace(/^#!?/, "");"/" !== n.charAt(0) && (n = "/" + n);var r = t.formatPath(n);if (r !== e) return void location.replace(r);var o = decodeURI(e.replace(/^#!?/, "") + location.search);t.onChange(o);
        }, window.addEventListener("hashchange", this.listener), this.listener();
      }, t.prototype.stop = function () {
        window.removeEventListener("hashchange", this.listener);
      }, t.prototype.go = function (t, e, n) {
        t = this.formatPath(t, n), e ? location.replace(t) : location.hash = t;
      }, t.prototype.formatPath = function (t, e) {
        var n = "/" === t.charAt(0),
            r = "#" + (this.hashbang ? "!" : "");return n ? r + t : r + o.resolvePath(location.hash.replace(/^#!?/, ""), t, e);
      }, t;
    }();e["default"] = i, t.exports = e["default"];
  }, function (t, e, n) {
    "use strict";
    var r = n(1)["default"];e.__esModule = !0;var o = n(3),
        i = /#.*$/,
        a = function () {
      function t(e) {
        var n = e.root,
            o = e.onChange;r(this, t), n ? ("/" !== n.charAt(0) && (n = "/" + n), this.root = n.replace(/\/$/, ""), this.rootRE = new RegExp("^\\" + this.root)) : this.root = null, this.onChange = o;var i = document.querySelector("base");this.base = i && i.getAttribute("href");
      }return t.prototype.start = function () {
        var t = this;this.listener = function (e) {
          var n = decodeURI(location.pathname + location.search);t.root && (n = n.replace(t.rootRE, "")), t.onChange(n, e && e.state, location.hash);
        }, window.addEventListener("popstate", this.listener), this.listener();
      }, t.prototype.stop = function () {
        window.removeEventListener("popstate", this.listener);
      }, t.prototype.go = function (t, e, n) {
        var r = this.formatPath(t, n);e ? history.replaceState({}, "", r) : (history.replaceState({ pos: { x: window.pageXOffset, y: window.pageYOffset } }, ""), history.pushState({}, "", r));var o = t.match(i),
            a = o && o[0];t = r.replace(i, "").replace(this.rootRE, ""), this.onChange(t, null, a);
      }, t.prototype.formatPath = function (t, e) {
        return "/" === t.charAt(0) ? this.root ? this.root + "/" + t.replace(/^\//, "") : t : o.resolvePath(this.base || location.pathname, t, e);
      }, t;
    }();e["default"] = a, t.exports = e["default"];
  }]);
});

},{}],"/var/www/github/vue-mini-shop/assets/js/libs/vue-simple-store.js":[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

/*! Copyright (c) 2016 Naufal Rabbani (http://github.com/BosNaufal)
* Licensed Under MIT (http://opensource.org/licenses/MIT)
*
* Vue Simple Store - version@1.0.0
*
*/

(function () {

  var VueSimpleStore = {

    install: function install(Vue, opt) {

      var plugin = this;

      if (opt.debug) console.info('[Vue Simple Store]: In Debug Mode');

      var theStores = {};
      var theState = {};

      for (var i = 0; i < opt.stores.length; i++) {

        if (opt.stores[i].name === undefined) console.warn("[Vue Simple Store]: Please add a Store Name", opt.stores[i]);

        // Make a global Stores
        theStores[opt.stores[i].name] = opt.stores[i];

        // Make a global state
        if (opt.stores[i].state !== undefined) theState[opt.stores[i].name] = opt.stores[i].state;

        // Remove the name
        delete theStores[opt.stores[i].name].name;
      }

      plugin.mixin = {};

      plugin.mixin.init = function () {
        Vue.util.defineReactive(this, 'state', theState);
        Vue.util.defineReactive(this, '$action', function (eventName, val) {

          var theColon = eventName.search(':');
          var storeName = eventName.substr(0, theColon);
          var theEvent = eventName.substr(theColon + 1, eventName.length);

          if (theStores[storeName] === undefined) return console.warn("[Vue Simple Store]: the " + storeName + " store doesn't exist");

          // Trigger the store
          theStores[storeName][theEvent](val);

          if (opt.debug) {
            if (val === undefined) console.info(eventName);else console.info(eventName, val);
          }
        });
      };

      // Merge mixin to VM via vue options
      Vue.options = Vue.util.mergeOptions(Vue.options, plugin.mixin);
    }

  };

  // If support node / ES6 module
  if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
    module.exports = VueSimpleStore;
  }
  // if using require js
  else if (typeof define === 'function' && define.amd) {
      define(function () {
        return VueSimpleStore;
      });
    }
    // if script loaded by script tag in HTML file
    else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefined) {
        return window.VueSimpleStore = VueSimpleStore;
      }
})();

},{}],"/var/www/github/vue-mini-shop/assets/js/libs/vue.js":[function(require,module,exports){
(function (global){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol?"symbol":typeof obj;}; /*!
 * Vue.js v1.0.18
 * (c) 2016 Evan You
 * Released under the MIT License.
 */(function(global,factory){(typeof exports==='undefined'?'undefined':_typeof(exports))==='object'&&typeof module!=='undefined'?module.exports=factory():typeof define==='function'&&define.amd?define(factory):global.Vue=factory();})(undefined,function(){'use strict';function set(obj,key,val){if(hasOwn(obj,key)){obj[key]=val;return;}if(obj._isVue){set(obj._data,key,val);return;}var ob=obj.__ob__;if(!ob){obj[key]=val;return;}ob.convert(key,val);ob.dep.notify();if(ob.vms){var i=ob.vms.length;while(i--){var vm=ob.vms[i];vm._proxy(key);vm._digest();}}return val;} /**
   * Delete a property and trigger change if necessary.
   *
   * @param {Object} obj
   * @param {String} key
   */function del(obj,key){if(!hasOwn(obj,key)){return;}delete obj[key];var ob=obj.__ob__;if(!ob){return;}ob.dep.notify();if(ob.vms){var i=ob.vms.length;while(i--){var vm=ob.vms[i];vm._unproxy(key);vm._digest();}}}var hasOwnProperty=Object.prototype.hasOwnProperty; /**
   * Check whether the object has the property.
   *
   * @param {Object} obj
   * @param {String} key
   * @return {Boolean}
   */function hasOwn(obj,key){return hasOwnProperty.call(obj,key);} /**
   * Check if an expression is a literal value.
   *
   * @param {String} exp
   * @return {Boolean}
   */var literalValueRE=/^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;function isLiteral(exp){return literalValueRE.test(exp);} /**
   * Check if a string starts with $ or _
   *
   * @param {String} str
   * @return {Boolean}
   */function isReserved(str){var c=(str+'').charCodeAt(0);return c===0x24||c===0x5F;} /**
   * Guard text output, make sure undefined outputs
   * empty string
   *
   * @param {*} value
   * @return {String}
   */function _toString(value){return value==null?'':value.toString();} /**
   * Check and convert possible numeric strings to numbers
   * before setting back to data
   *
   * @param {*} value
   * @return {*|Number}
   */function toNumber(value){if(typeof value!=='string'){return value;}else {var parsed=Number(value);return isNaN(parsed)?value:parsed;}} /**
   * Convert string boolean literals into real booleans.
   *
   * @param {*} value
   * @return {*|Boolean}
   */function toBoolean(value){return value==='true'?true:value==='false'?false:value;} /**
   * Strip quotes from a string
   *
   * @param {String} str
   * @return {String | false}
   */function stripQuotes(str){var a=str.charCodeAt(0);var b=str.charCodeAt(str.length-1);return a===b&&(a===0x22||a===0x27)?str.slice(1,-1):str;} /**
   * Camelize a hyphen-delmited string.
   *
   * @param {String} str
   * @return {String}
   */var camelizeRE=/-(\w)/g;function camelize(str){return str.replace(camelizeRE,toUpper);}function toUpper(_,c){return c?c.toUpperCase():'';} /**
   * Hyphenate a camelCase string.
   *
   * @param {String} str
   * @return {String}
   */var hyphenateRE=/([a-z\d])([A-Z])/g;function hyphenate(str){return str.replace(hyphenateRE,'$1-$2').toLowerCase();} /**
   * Converts hyphen/underscore/slash delimitered names into
   * camelized classNames.
   *
   * e.g. my-component => MyComponent
   *      some_else    => SomeElse
   *      some/comp    => SomeComp
   *
   * @param {String} str
   * @return {String}
   */var classifyRE=/(?:^|[-_\/])(\w)/g;function classify(str){return str.replace(classifyRE,toUpper);} /**
   * Simple bind, faster than native
   *
   * @param {Function} fn
   * @param {Object} ctx
   * @return {Function}
   */function bind(fn,ctx){return function(a){var l=arguments.length;return l?l>1?fn.apply(ctx,arguments):fn.call(ctx,a):fn.call(ctx);};} /**
   * Convert an Array-like object to a real Array.
   *
   * @param {Array-like} list
   * @param {Number} [start] - start index
   * @return {Array}
   */function toArray(list,start){start=start||0;var i=list.length-start;var ret=new Array(i);while(i--){ret[i]=list[i+start];}return ret;} /**
   * Mix properties into target object.
   *
   * @param {Object} to
   * @param {Object} from
   */function extend(to,from){var keys=Object.keys(from);var i=keys.length;while(i--){to[keys[i]]=from[keys[i]];}return to;} /**
   * Quick object check - this is primarily used to tell
   * Objects from primitive values when we know the value
   * is a JSON-compliant type.
   *
   * @param {*} obj
   * @return {Boolean}
   */function isObject(obj){return obj!==null&&(typeof obj==='undefined'?'undefined':_typeof(obj))==='object';} /**
   * Strict object type check. Only returns true
   * for plain JavaScript objects.
   *
   * @param {*} obj
   * @return {Boolean}
   */var toString=Object.prototype.toString;var OBJECT_STRING='[object Object]';function isPlainObject(obj){return toString.call(obj)===OBJECT_STRING;} /**
   * Array type check.
   *
   * @param {*} obj
   * @return {Boolean}
   */var isArray=Array.isArray; /**
   * Define a property.
   *
   * @param {Object} obj
   * @param {String} key
   * @param {*} val
   * @param {Boolean} [enumerable]
   */function def(obj,key,val,enumerable){Object.defineProperty(obj,key,{value:val,enumerable:!!enumerable,writable:true,configurable:true});} /**
   * Debounce a function so it only gets called after the
   * input stops arriving after the given wait period.
   *
   * @param {Function} func
   * @param {Number} wait
   * @return {Function} - the debounced function
   */function _debounce(func,wait){var timeout,args,context,timestamp,result;var later=function later(){var last=Date.now()-timestamp;if(last<wait&&last>=0){timeout=setTimeout(later,wait-last);}else {timeout=null;result=func.apply(context,args);if(!timeout)context=args=null;}};return function(){context=this;args=arguments;timestamp=Date.now();if(!timeout){timeout=setTimeout(later,wait);}return result;};} /**
   * Manual indexOf because it's slightly faster than
   * native.
   *
   * @param {Array} arr
   * @param {*} obj
   */function indexOf(arr,obj){var i=arr.length;while(i--){if(arr[i]===obj)return i;}return -1;} /**
   * Make a cancellable version of an async callback.
   *
   * @param {Function} fn
   * @return {Function}
   */function cancellable(fn){var cb=function cb(){if(!cb.cancelled){return fn.apply(this,arguments);}};cb.cancel=function(){cb.cancelled=true;};return cb;} /**
   * Check if two values are loosely equal - that is,
   * if they are plain objects, do they have the same shape?
   *
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   */function looseEqual(a,b){ /* eslint-disable eqeqeq */return a==b||(isObject(a)&&isObject(b)?JSON.stringify(a)===JSON.stringify(b):false); /* eslint-enable eqeqeq */}var hasProto='__proto__' in {}; // Browser environment sniffing
var inBrowser=typeof window!=='undefined'&&Object.prototype.toString.call(window)!=='[object Object]'; // detect devtools
var devtools=inBrowser&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__; // UA sniffing for working around browser-specific quirks
var UA=inBrowser&&window.navigator.userAgent.toLowerCase();var isIE9=UA&&UA.indexOf('msie 9.0')>0;var isAndroid=UA&&UA.indexOf('android')>0;var transitionProp=undefined;var transitionEndEvent=undefined;var animationProp=undefined;var animationEndEvent=undefined; // Transition property/event sniffing
if(inBrowser&&!isIE9){var isWebkitTrans=window.ontransitionend===undefined&&window.onwebkittransitionend!==undefined;var isWebkitAnim=window.onanimationend===undefined&&window.onwebkitanimationend!==undefined;transitionProp=isWebkitTrans?'WebkitTransition':'transition';transitionEndEvent=isWebkitTrans?'webkitTransitionEnd':'transitionend';animationProp=isWebkitAnim?'WebkitAnimation':'animation';animationEndEvent=isWebkitAnim?'webkitAnimationEnd':'animationend';} /**
   * Defer a task to execute it asynchronously. Ideally this
   * should be executed as a microtask, so we leverage
   * MutationObserver if it's available, and fallback to
   * setTimeout(0).
   *
   * @param {Function} cb
   * @param {Object} ctx
   */var nextTick=function(){var callbacks=[];var pending=false;var timerFunc;function nextTickHandler(){pending=false;var copies=callbacks.slice(0);callbacks=[];for(var i=0;i<copies.length;i++){copies[i]();}} /* istanbul ignore if */if(typeof MutationObserver!=='undefined'){var counter=1;var observer=new MutationObserver(nextTickHandler);var textNode=document.createTextNode(counter);observer.observe(textNode,{characterData:true});timerFunc=function timerFunc(){counter=(counter+1)%2;textNode.data=counter;};}else { // webpack attempts to inject a shim for setImmediate
// if it is used as a global, so we have to work around that to
// avoid bundling unnecessary code.
var context=inBrowser?window:typeof global!=='undefined'?global:{};timerFunc=context.setImmediate||setTimeout;}return function(cb,ctx){var func=ctx?function(){cb.call(ctx);}:cb;callbacks.push(func);if(pending)return;pending=true;timerFunc(nextTickHandler,0);};}();function Cache(limit){this.size=0;this.limit=limit;this.head=this.tail=undefined;this._keymap=Object.create(null);}var p=Cache.prototype; /**
   * Put <value> into the cache associated with <key>.
   * Returns the entry which was removed to make room for
   * the new entry. Otherwise undefined is returned.
   * (i.e. if there was enough room already).
   *
   * @param {String} key
   * @param {*} value
   * @return {Entry|undefined}
   */p.put=function(key,value){var removed;if(this.size===this.limit){removed=this.shift();}var entry=this.get(key,true);if(!entry){entry={key:key};this._keymap[key]=entry;if(this.tail){this.tail.newer=entry;entry.older=this.tail;}else {this.head=entry;}this.tail=entry;this.size++;}entry.value=value;return removed;}; /**
   * Purge the least recently used (oldest) entry from the
   * cache. Returns the removed entry or undefined if the
   * cache was empty.
   */p.shift=function(){var entry=this.head;if(entry){this.head=this.head.newer;this.head.older=undefined;entry.newer=entry.older=undefined;this._keymap[entry.key]=undefined;this.size--;}return entry;}; /**
   * Get and register recent use of <key>. Returns the value
   * associated with <key> or undefined if not in cache.
   *
   * @param {String} key
   * @param {Boolean} returnEntry
   * @return {Entry|*}
   */p.get=function(key,returnEntry){var entry=this._keymap[key];if(entry===undefined)return;if(entry===this.tail){return returnEntry?entry:entry.value;} // HEAD--------------TAIL
//   <.older   .newer>
//  <--- add direction --
//   A  B  C  <D>  E
if(entry.newer){if(entry===this.head){this.head=entry.newer;}entry.newer.older=entry.older; // C <-- E.
}if(entry.older){entry.older.newer=entry.newer; // C. --> E
}entry.newer=undefined; // D --x
entry.older=this.tail; // D. --> E
if(this.tail){this.tail.newer=entry; // E. <-- D
}this.tail=entry;return returnEntry?entry:entry.value;};var cache$1=new Cache(1000);var filterTokenRE=/[^\s'"]+|'[^']*'|"[^"]*"/g;var reservedArgRE=/^in$|^-?\d+/; /**
   * Parser state
   */var str;var dir;var c;var prev;var i;var l;var lastFilterIndex;var inSingle;var inDouble;var curly;var square;var paren; /**
   * Push a filter to the current directive object
   */function pushFilter(){var exp=str.slice(lastFilterIndex,i).trim();var filter;if(exp){filter={};var tokens=exp.match(filterTokenRE);filter.name=tokens[0];if(tokens.length>1){filter.args=tokens.slice(1).map(processFilterArg);}}if(filter){(dir.filters=dir.filters||[]).push(filter);}lastFilterIndex=i+1;} /**
   * Check if an argument is dynamic and strip quotes.
   *
   * @param {String} arg
   * @return {Object}
   */function processFilterArg(arg){if(reservedArgRE.test(arg)){return {value:toNumber(arg),dynamic:false};}else {var stripped=stripQuotes(arg);var dynamic=stripped===arg;return {value:dynamic?arg:stripped,dynamic:dynamic};}} /**
   * Parse a directive value and extract the expression
   * and its filters into a descriptor.
   *
   * Example:
   *
   * "a + 1 | uppercase" will yield:
   * {
   *   expression: 'a + 1',
   *   filters: [
   *     { name: 'uppercase', args: null }
   *   ]
   * }
   *
   * @param {String} str
   * @return {Object}
   */function parseDirective(s){var hit=cache$1.get(s);if(hit){return hit;} // reset parser state
str=s;inSingle=inDouble=false;curly=square=paren=0;lastFilterIndex=0;dir={};for(i=0,l=str.length;i<l;i++){prev=c;c=str.charCodeAt(i);if(inSingle){ // check single quote
if(c===0x27&&prev!==0x5C)inSingle=!inSingle;}else if(inDouble){ // check double quote
if(c===0x22&&prev!==0x5C)inDouble=!inDouble;}else if(c===0x7C&& // pipe
str.charCodeAt(i+1)!==0x7C&&str.charCodeAt(i-1)!==0x7C){if(dir.expression==null){ // first filter, end of expression
lastFilterIndex=i+1;dir.expression=str.slice(0,i).trim();}else { // already has filter
pushFilter();}}else {switch(c){case 0x22:inDouble=true;break; // "
case 0x27:inSingle=true;break; // '
case 0x28:paren++;break; // (
case 0x29:paren--;break; // )
case 0x5B:square++;break; // [
case 0x5D:square--;break; // ]
case 0x7B:curly++;break; // {
case 0x7D:curly--;break; // }
}}}if(dir.expression==null){dir.expression=str.slice(0,i).trim();}else if(lastFilterIndex!==0){pushFilter();}cache$1.put(s,dir);return dir;}var directive=Object.freeze({parseDirective:parseDirective});var regexEscapeRE=/[-.*+?^${}()|[\]\/\\]/g;var cache=undefined;var tagRE=undefined;var htmlRE=undefined; /**
   * Escape a string so it can be used in a RegExp
   * constructor.
   *
   * @param {String} str
   */function escapeRegex(str){return str.replace(regexEscapeRE,'\\$&');}function compileRegex(){var open=escapeRegex(config.delimiters[0]);var close=escapeRegex(config.delimiters[1]);var unsafeOpen=escapeRegex(config.unsafeDelimiters[0]);var unsafeClose=escapeRegex(config.unsafeDelimiters[1]);tagRE=new RegExp(unsafeOpen+'(.+?)'+unsafeClose+'|'+open+'(.+?)'+close,'g');htmlRE=new RegExp('^'+unsafeOpen+'.*'+unsafeClose+'$'); // reset cache
cache=new Cache(1000);} /**
   * Parse a template text string into an array of tokens.
   *
   * @param {String} text
   * @return {Array<Object> | null}
   *               - {String} type
   *               - {String} value
   *               - {Boolean} [html]
   *               - {Boolean} [oneTime]
   */function parseText(text){if(!cache){compileRegex();}var hit=cache.get(text);if(hit){return hit;}text=text.replace(/\n/g,'');if(!tagRE.test(text)){return null;}var tokens=[];var lastIndex=tagRE.lastIndex=0;var match,index,html,value,first,oneTime; /* eslint-disable no-cond-assign */while(match=tagRE.exec(text)){ /* eslint-enable no-cond-assign */index=match.index; // push text token
if(index>lastIndex){tokens.push({value:text.slice(lastIndex,index)});} // tag token
html=htmlRE.test(match[0]);value=html?match[1]:match[2];first=value.charCodeAt(0);oneTime=first===42; // *
value=oneTime?value.slice(1):value;tokens.push({tag:true,value:value.trim(),html:html,oneTime:oneTime});lastIndex=index+match[0].length;}if(lastIndex<text.length){tokens.push({value:text.slice(lastIndex)});}cache.put(text,tokens);return tokens;} /**
   * Format a list of tokens into an expression.
   * e.g. tokens parsed from 'a {{b}} c' can be serialized
   * into one single expression as '"a " + b + " c"'.
   *
   * @param {Array} tokens
   * @param {Vue} [vm]
   * @return {String}
   */function tokensToExp(tokens,vm){if(tokens.length>1){return tokens.map(function(token){return formatToken(token,vm);}).join('+');}else {return formatToken(tokens[0],vm,true);}} /**
   * Format a single token.
   *
   * @param {Object} token
   * @param {Vue} [vm]
   * @param {Boolean} [single]
   * @return {String}
   */function formatToken(token,vm,single){return token.tag?token.oneTime&&vm?'"'+vm.$eval(token.value)+'"':inlineFilters(token.value,single):'"'+token.value+'"';} /**
   * For an attribute with multiple interpolation tags,
   * e.g. attr="some-{{thing | filter}}", in order to combine
   * the whole thing into a single watchable expression, we
   * have to inline those filters. This function does exactly
   * that. This is a bit hacky but it avoids heavy changes
   * to directive parser and watcher mechanism.
   *
   * @param {String} exp
   * @param {Boolean} single
   * @return {String}
   */var filterRE=/[^|]\|[^|]/;function inlineFilters(exp,single){if(!filterRE.test(exp)){return single?exp:'('+exp+')';}else {var dir=parseDirective(exp);if(!dir.filters){return '('+exp+')';}else {return 'this._applyFilters('+dir.expression+ // value
',null,'+ // oldValue (null for read)
JSON.stringify(dir.filters)+ // filter descriptors
',false)'; // write?
}}}var text=Object.freeze({compileRegex:compileRegex,parseText:parseText,tokensToExp:tokensToExp});var delimiters=['{{','}}'];var unsafeDelimiters=['{{{','}}}'];var config=Object.defineProperties({ /**
     * Whether to print debug messages.
     * Also enables stack trace for warnings.
     *
     * @type {Boolean}
     */debug:false, /**
     * Whether to suppress warnings.
     *
     * @type {Boolean}
     */silent:false, /**
     * Whether to use async rendering.
     */async:true, /**
     * Whether to warn against errors caught when evaluating
     * expressions.
     */warnExpressionErrors:true, /**
     * Whether to allow devtools inspection.
     * Disabled by default in production builds.
     */devtools:'development'!=='production', /**
     * Internal flag to indicate the delimiters have been
     * changed.
     *
     * @type {Boolean}
     */_delimitersChanged:true, /**
     * List of asset types that a component can own.
     *
     * @type {Array}
     */_assetTypes:['component','directive','elementDirective','filter','transition','partial'], /**
     * prop binding modes
     */_propBindingModes:{ONE_WAY:0,TWO_WAY:1,ONE_TIME:2}, /**
     * Max circular updates allowed in a batcher flush cycle.
     */_maxUpdateCount:100},{delimiters:{ /**
                   * Interpolation delimiters. Changing these would trigger
                   * the text parser to re-compile the regular expressions.
                   *
                   * @type {Array<String>}
                   */get:function get(){return delimiters;},set:function set(val){delimiters=val;compileRegex();},configurable:true,enumerable:true},unsafeDelimiters:{get:function get(){return unsafeDelimiters;},set:function set(val){unsafeDelimiters=val;compileRegex();},configurable:true,enumerable:true}});var warn=undefined;if('development'!=='production'){(function(){var hasConsole=typeof console!=='undefined';warn=function warn(msg,e){if(hasConsole&&(!config.silent||config.debug)){console.warn('[Vue warn]: '+msg); /* istanbul ignore if */if(config.debug){if(e){throw e;}else {console.warn(new Error('Warning Stack Trace').stack);}}}};})();} /**
   * Append with transition.
   *
   * @param {Element} el
   * @param {Element} target
   * @param {Vue} vm
   * @param {Function} [cb]
   */function appendWithTransition(el,target,vm,cb){applyTransition(el,1,function(){target.appendChild(el);},vm,cb);} /**
   * InsertBefore with transition.
   *
   * @param {Element} el
   * @param {Element} target
   * @param {Vue} vm
   * @param {Function} [cb]
   */function beforeWithTransition(el,target,vm,cb){applyTransition(el,1,function(){before(el,target);},vm,cb);} /**
   * Remove with transition.
   *
   * @param {Element} el
   * @param {Vue} vm
   * @param {Function} [cb]
   */function removeWithTransition(el,vm,cb){applyTransition(el,-1,function(){remove(el);},vm,cb);} /**
   * Apply transitions with an operation callback.
   *
   * @param {Element} el
   * @param {Number} direction
   *                  1: enter
   *                 -1: leave
   * @param {Function} op - the actual DOM operation
   * @param {Vue} vm
   * @param {Function} [cb]
   */function applyTransition(el,direction,op,vm,cb){var transition=el.__v_trans;if(!transition|| // skip if there are no js hooks and CSS transition is
// not supported
!transition.hooks&&!transitionEndEvent|| // skip transitions for initial compile
!vm._isCompiled|| // if the vm is being manipulated by a parent directive
// during the parent's compilation phase, skip the
// animation.
vm.$parent&&!vm.$parent._isCompiled){op();if(cb)cb();return;}var action=direction>0?'enter':'leave';transition[action](op,cb);}var transition=Object.freeze({appendWithTransition:appendWithTransition,beforeWithTransition:beforeWithTransition,removeWithTransition:removeWithTransition,applyTransition:applyTransition}); /**
   * Query an element selector if it's not an element already.
   *
   * @param {String|Element} el
   * @return {Element}
   */function query(el){if(typeof el==='string'){var selector=el;el=document.querySelector(el);if(!el){'development'!=='production'&&warn('Cannot find element: '+selector);}}return el;} /**
   * Check if a node is in the document.
   * Note: document.documentElement.contains should work here
   * but always returns false for comment nodes in phantomjs,
   * making unit tests difficult. This is fixed by doing the
   * contains() check on the node's parentNode instead of
   * the node itself.
   *
   * @param {Node} node
   * @return {Boolean}
   */function inDoc(node){var doc=document.documentElement;var parent=node&&node.parentNode;return doc===node||doc===parent||!!(parent&&parent.nodeType===1&&doc.contains(parent));} /**
   * Get and remove an attribute from a node.
   *
   * @param {Node} node
   * @param {String} _attr
   */function getAttr(node,_attr){var val=node.getAttribute(_attr);if(val!==null){node.removeAttribute(_attr);}return val;} /**
   * Get an attribute with colon or v-bind: prefix.
   *
   * @param {Node} node
   * @param {String} name
   * @return {String|null}
   */function getBindAttr(node,name){var val=getAttr(node,':'+name);if(val===null){val=getAttr(node,'v-bind:'+name);}return val;} /**
   * Check the presence of a bind attribute.
   *
   * @param {Node} node
   * @param {String} name
   * @return {Boolean}
   */function hasBindAttr(node,name){return node.hasAttribute(name)||node.hasAttribute(':'+name)||node.hasAttribute('v-bind:'+name);} /**
   * Insert el before target
   *
   * @param {Element} el
   * @param {Element} target
   */function before(el,target){target.parentNode.insertBefore(el,target);} /**
   * Insert el after target
   *
   * @param {Element} el
   * @param {Element} target
   */function after(el,target){if(target.nextSibling){before(el,target.nextSibling);}else {target.parentNode.appendChild(el);}} /**
   * Remove el from DOM
   *
   * @param {Element} el
   */function remove(el){el.parentNode.removeChild(el);} /**
   * Prepend el to target
   *
   * @param {Element} el
   * @param {Element} target
   */function prepend(el,target){if(target.firstChild){before(el,target.firstChild);}else {target.appendChild(el);}} /**
   * Replace target with el
   *
   * @param {Element} target
   * @param {Element} el
   */function replace(target,el){var parent=target.parentNode;if(parent){parent.replaceChild(el,target);}} /**
   * Add event listener shorthand.
   *
   * @param {Element} el
   * @param {String} event
   * @param {Function} cb
   * @param {Boolean} [useCapture]
   */function on(el,event,cb,useCapture){el.addEventListener(event,cb,useCapture);} /**
   * Remove event listener shorthand.
   *
   * @param {Element} el
   * @param {String} event
   * @param {Function} cb
   */function off(el,event,cb){el.removeEventListener(event,cb);} /**
   * In IE9, setAttribute('class') will result in empty class
   * if the element also has the :class attribute; However in
   * PhantomJS, setting `className` does not work on SVG elements...
   * So we have to do a conditional check here.
   *
   * @param {Element} el
   * @param {String} cls
   */function setClass(el,cls){ /* istanbul ignore if */if(isIE9&&!/svg$/.test(el.namespaceURI)){el.className=cls;}else {el.setAttribute('class',cls);}} /**
   * Add class with compatibility for IE & SVG
   *
   * @param {Element} el
   * @param {String} cls
   */function addClass(el,cls){if(el.classList){el.classList.add(cls);}else {var cur=' '+(el.getAttribute('class')||'')+' ';if(cur.indexOf(' '+cls+' ')<0){setClass(el,(cur+cls).trim());}}} /**
   * Remove class with compatibility for IE & SVG
   *
   * @param {Element} el
   * @param {String} cls
   */function removeClass(el,cls){if(el.classList){el.classList.remove(cls);}else {var cur=' '+(el.getAttribute('class')||'')+' ';var tar=' '+cls+' ';while(cur.indexOf(tar)>=0){cur=cur.replace(tar,' ');}setClass(el,cur.trim());}if(!el.className){el.removeAttribute('class');}} /**
   * Extract raw content inside an element into a temporary
   * container div
   *
   * @param {Element} el
   * @param {Boolean} asFragment
   * @return {Element|DocumentFragment}
   */function extractContent(el,asFragment){var child;var rawContent; /* istanbul ignore if */if(isTemplate(el)&&isFragment(el.content)){el=el.content;}if(el.hasChildNodes()){trimNode(el);rawContent=asFragment?document.createDocumentFragment():document.createElement('div'); /* eslint-disable no-cond-assign */while(child=el.firstChild){ /* eslint-enable no-cond-assign */rawContent.appendChild(child);}}return rawContent;} /**
   * Trim possible empty head/tail text and comment
   * nodes inside a parent.
   *
   * @param {Node} node
   */function trimNode(node){var child; /* eslint-disable no-sequences */while(child=node.firstChild,isTrimmable(child)){node.removeChild(child);}while(child=node.lastChild,isTrimmable(child)){node.removeChild(child);} /* eslint-enable no-sequences */}function isTrimmable(node){return node&&(node.nodeType===3&&!node.data.trim()||node.nodeType===8);} /**
   * Check if an element is a template tag.
   * Note if the template appears inside an SVG its tagName
   * will be in lowercase.
   *
   * @param {Element} el
   */function isTemplate(el){return el.tagName&&el.tagName.toLowerCase()==='template';} /**
   * Create an "anchor" for performing dom insertion/removals.
   * This is used in a number of scenarios:
   * - fragment instance
   * - v-html
   * - v-if
   * - v-for
   * - component
   *
   * @param {String} content
   * @param {Boolean} persist - IE trashes empty textNodes on
   *                            cloneNode(true), so in certain
   *                            cases the anchor needs to be
   *                            non-empty to be persisted in
   *                            templates.
   * @return {Comment|Text}
   */function createAnchor(content,persist){var anchor=config.debug?document.createComment(content):document.createTextNode(persist?' ':'');anchor.__v_anchor=true;return anchor;} /**
   * Find a component ref attribute that starts with $.
   *
   * @param {Element} node
   * @return {String|undefined}
   */var refRE=/^v-ref:/;function findRef(node){if(node.hasAttributes()){var attrs=node.attributes;for(var i=0,l=attrs.length;i<l;i++){var name=attrs[i].name;if(refRE.test(name)){return camelize(name.replace(refRE,''));}}}} /**
   * Map a function to a range of nodes .
   *
   * @param {Node} node
   * @param {Node} end
   * @param {Function} op
   */function mapNodeRange(node,end,op){var next;while(node!==end){next=node.nextSibling;op(node);node=next;}op(end);} /**
   * Remove a range of nodes with transition, store
   * the nodes in a fragment with correct ordering,
   * and call callback when done.
   *
   * @param {Node} start
   * @param {Node} end
   * @param {Vue} vm
   * @param {DocumentFragment} frag
   * @param {Function} cb
   */function removeNodeRange(start,end,vm,frag,cb){var done=false;var removed=0;var nodes=[];mapNodeRange(start,end,function(node){if(node===end)done=true;nodes.push(node);removeWithTransition(node,vm,onRemoved);});function onRemoved(){removed++;if(done&&removed>=nodes.length){for(var i=0;i<nodes.length;i++){frag.appendChild(nodes[i]);}cb&&cb();}}} /**
   * Check if a node is a DocumentFragment.
   *
   * @param {Node} node
   * @return {Boolean}
   */function isFragment(node){return node&&node.nodeType===11;} /**
   * Get outerHTML of elements, taking care
   * of SVG elements in IE as well.
   *
   * @param {Element} el
   * @return {String}
   */function getOuterHTML(el){if(el.outerHTML){return el.outerHTML;}else {var container=document.createElement('div');container.appendChild(el.cloneNode(true));return container.innerHTML;}}var uid$1=0; /**
   * A dep is an observable that can have multiple
   * directives subscribing to it.
   *
   * @constructor
   */function Dep(){this.id=uid$1++;this.subs=[];} // the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target=null; /**
   * Add a directive subscriber.
   *
   * @param {Directive} sub
   */Dep.prototype.addSub=function(sub){this.subs.push(sub);}; /**
   * Remove a directive subscriber.
   *
   * @param {Directive} sub
   */Dep.prototype.removeSub=function(sub){this.subs.$remove(sub);}; /**
   * Add self as a dependency to the target watcher.
   */Dep.prototype.depend=function(){Dep.target.addDep(this);}; /**
   * Notify all subscribers of a new value.
   */Dep.prototype.notify=function(){ // stablize the subscriber list first
var subs=toArray(this.subs);for(var i=0,l=subs.length;i<l;i++){subs[i].update();}};var arrayProto=Array.prototype;var arrayMethods=Object.create(arrayProto) /**
   * Intercept mutating methods and emit events
   */;['push','pop','shift','unshift','splice','sort','reverse'].forEach(function(method){ // cache original method
var original=arrayProto[method];def(arrayMethods,method,function mutator(){ // avoid leaking arguments:
// http://jsperf.com/closure-with-arguments
var i=arguments.length;var args=new Array(i);while(i--){args[i]=arguments[i];}var result=original.apply(this,args);var ob=this.__ob__;var inserted;switch(method){case 'push':inserted=args;break;case 'unshift':inserted=args;break;case 'splice':inserted=args.slice(2);break;}if(inserted)ob.observeArray(inserted); // notify change
ob.dep.notify();return result;});}); /**
   * Swap the element at the given index with a new value
   * and emits corresponding event.
   *
   * @param {Number} index
   * @param {*} val
   * @return {*} - replaced element
   */def(arrayProto,'$set',function $set(index,val){if(index>=this.length){this.length=Number(index)+1;}return this.splice(index,1,val)[0];}); /**
   * Convenience method to remove the element at given index.
   *
   * @param {Number} index
   * @param {*} val
   */def(arrayProto,'$remove',function $remove(item){ /* istanbul ignore if */if(!this.length)return;var index=indexOf(this,item);if(index>-1){return this.splice(index,1);}});var arrayKeys=Object.getOwnPropertyNames(arrayMethods); /**
   * Observer class that are attached to each observed
   * object. Once attached, the observer converts target
   * object's property keys into getter/setters that
   * collect dependencies and dispatches updates.
   *
   * @param {Array|Object} value
   * @constructor
   */function Observer(value){this.value=value;this.dep=new Dep();def(value,'__ob__',this);if(isArray(value)){var augment=hasProto?protoAugment:copyAugment;augment(value,arrayMethods,arrayKeys);this.observeArray(value);}else {this.walk(value);}} // Instance methods
/**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   *
   * @param {Object} obj
   */Observer.prototype.walk=function(obj){var keys=Object.keys(obj);for(var i=0,l=keys.length;i<l;i++){this.convert(keys[i],obj[keys[i]]);}}; /**
   * Observe a list of Array items.
   *
   * @param {Array} items
   */Observer.prototype.observeArray=function(items){for(var i=0,l=items.length;i<l;i++){observe(items[i]);}}; /**
   * Convert a property into getter/setter so we can emit
   * the events when the property is accessed/changed.
   *
   * @param {String} key
   * @param {*} val
   */Observer.prototype.convert=function(key,val){defineReactive(this.value,key,val);}; /**
   * Add an owner vm, so that when $set/$delete mutations
   * happen we can notify owner vms to proxy the keys and
   * digest the watchers. This is only called when the object
   * is observed as an instance's root $data.
   *
   * @param {Vue} vm
   */Observer.prototype.addVm=function(vm){(this.vms||(this.vms=[])).push(vm);}; /**
   * Remove an owner vm. This is called when the object is
   * swapped out as an instance's $data object.
   *
   * @param {Vue} vm
   */Observer.prototype.removeVm=function(vm){this.vms.$remove(vm);}; // helpers
/**
   * Augment an target Object or Array by intercepting
   * the prototype chain using __proto__
   *
   * @param {Object|Array} target
   * @param {Object} proto
   */function protoAugment(target,src){ /* eslint-disable no-proto */target.__proto__=src; /* eslint-enable no-proto */} /**
   * Augment an target Object or Array by defining
   * hidden properties.
   *
   * @param {Object|Array} target
   * @param {Object} proto
   */function copyAugment(target,src,keys){for(var i=0,l=keys.length;i<l;i++){var key=keys[i];def(target,key,src[key]);}} /**
   * Attempt to create an observer instance for a value,
   * returns the new observer if successfully observed,
   * or the existing observer if the value already has one.
   *
   * @param {*} value
   * @param {Vue} [vm]
   * @return {Observer|undefined}
   * @static
   */function observe(value,vm){if(!value||(typeof value==='undefined'?'undefined':_typeof(value))!=='object'){return;}var ob;if(hasOwn(value,'__ob__')&&value.__ob__ instanceof Observer){ob=value.__ob__;}else if((isArray(value)||isPlainObject(value))&&Object.isExtensible(value)&&!value._isVue){ob=new Observer(value);}if(ob&&vm){ob.addVm(vm);}return ob;} /**
   * Define a reactive property on an Object.
   *
   * @param {Object} obj
   * @param {String} key
   * @param {*} val
   * @param {Boolean} doNotObserve
   */function defineReactive(obj,key,val,doNotObserve){var dep=new Dep();var property=Object.getOwnPropertyDescriptor(obj,key);if(property&&property.configurable===false){return;} // cater for pre-defined getter/setters
var getter=property&&property.get;var setter=property&&property.set; // if doNotObserve is true, only use the child value observer
// if it already exists, and do not attempt to create it.
// this allows freezing a large object from the root and
// avoid unnecessary observation inside v-for fragments.
var childOb=doNotObserve?isObject(val)&&val.__ob__:observe(val);Object.defineProperty(obj,key,{enumerable:true,configurable:true,get:function reactiveGetter(){var value=getter?getter.call(obj):val;if(Dep.target){dep.depend();if(childOb){childOb.dep.depend();}if(isArray(value)){for(var e,i=0,l=value.length;i<l;i++){e=value[i];e&&e.__ob__&&e.__ob__.dep.depend();}}}return value;},set:function reactiveSetter(newVal){var value=getter?getter.call(obj):val;if(newVal===value){return;}if(setter){setter.call(obj,newVal);}else {val=newVal;}childOb=doNotObserve?isObject(newVal)&&newVal.__ob__:observe(newVal);dep.notify();}});}var commonTagRE=/^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;var reservedTagRE=/^(slot|partial|component)$/i;var isUnknownElement=undefined;if('development'!=='production'){isUnknownElement=function isUnknownElement(el,tag){if(tag.indexOf('-')>-1){ // http://stackoverflow.com/a/28210364/1070244
return el.constructor===window.HTMLUnknownElement||el.constructor===window.HTMLElement;}else {return (/HTMLUnknownElement/.test(el.toString())&& // Chrome returns unknown for several HTML5 elements.
// https://code.google.com/p/chromium/issues/detail?id=540526
!/^(data|time|rtc|rb)$/.test(tag));}};} /**
   * Check if an element is a component, if yes return its
   * component id.
   *
   * @param {Element} el
   * @param {Object} options
   * @return {Object|undefined}
   */function checkComponentAttr(el,options){var tag=el.tagName.toLowerCase();var hasAttrs=el.hasAttributes();if(!commonTagRE.test(tag)&&!reservedTagRE.test(tag)){if(resolveAsset(options,'components',tag)){return {id:tag};}else {var is=hasAttrs&&getIsBinding(el);if(is){return is;}else if('development'!=='production'){var expectedTag=options._componentNameMap&&options._componentNameMap[tag];if(expectedTag){warn('Unknown custom element: <'+tag+'> - '+'did you mean <'+expectedTag+'>? '+'HTML is case-insensitive, remember to use kebab-case in templates.');}else if(isUnknownElement(el,tag)){warn('Unknown custom element: <'+tag+'> - did you '+'register the component correctly? For recursive components, '+'make sure to provide the "name" option.');}}}}else if(hasAttrs){return getIsBinding(el);}} /**
   * Get "is" binding from an element.
   *
   * @param {Element} el
   * @return {Object|undefined}
   */function getIsBinding(el){ // dynamic syntax
var exp=getAttr(el,'is');if(exp!=null){return {id:exp};}else {exp=getBindAttr(el,'is');if(exp!=null){return {id:exp,dynamic:true};}}} /**
   * Set a prop's initial value on a vm and its data object.
   *
   * @param {Vue} vm
   * @param {Object} prop
   * @param {*} value
   */function initProp(vm,prop,value){var key=prop.path;value=coerceProp(prop,value);if(value===undefined){value=getPropDefaultValue(vm,prop.options);}if(assertProp(prop,value)){defineReactive(vm,key,value,true /* doNotObserve */);}} /**
   * Get the default value of a prop.
   *
   * @param {Vue} vm
   * @param {Object} options
   * @return {*}
   */function getPropDefaultValue(vm,options){ // no default, return undefined
if(!hasOwn(options,'default')){ // absent boolean value defaults to false
return options.type===Boolean?false:undefined;}var def=options['default']; // warn against non-factory defaults for Object & Array
if(isObject(def)){'development'!=='production'&&warn('Object/Array as default prop values will be shared '+'across multiple instances. Use a factory function '+'to return the default value instead.');} // call factory function for non-Function types
return typeof def==='function'&&options.type!==Function?def.call(vm):def;} /**
   * Assert whether a prop is valid.
   *
   * @param {Object} prop
   * @param {*} value
   */function assertProp(prop,value){if(!prop.options.required&&( // non-required
prop.raw===null|| // abscent
value==null) // null or undefined
){return true;}var options=prop.options;var type=options.type;var valid=true;var expectedType;if(type){if(type===String){expectedType='string';valid=(typeof value==='undefined'?'undefined':_typeof(value))===expectedType;}else if(type===Number){expectedType='number';valid=typeof value==='number';}else if(type===Boolean){expectedType='boolean';valid=typeof value==='boolean';}else if(type===Function){expectedType='function';valid=typeof value==='function';}else if(type===Object){expectedType='object';valid=isPlainObject(value);}else if(type===Array){expectedType='array';valid=isArray(value);}else {valid=value instanceof type;}}if(!valid){'development'!=='production'&&warn('Invalid prop: type check failed for '+prop.path+'="'+prop.raw+'".'+' Expected '+formatType(expectedType)+', got '+formatValue(value)+'.');return false;}var validator=options.validator;if(validator){if(!validator(value)){'development'!=='production'&&warn('Invalid prop: custom validator check failed for '+prop.path+'="'+prop.raw+'"');return false;}}return true;} /**
   * Force parsing value with coerce option.
   *
   * @param {*} value
   * @param {Object} options
   * @return {*}
   */function coerceProp(prop,value){var coerce=prop.options.coerce;if(!coerce){return value;} // coerce is a function
return coerce(value);}function formatType(val){return val?val.charAt(0).toUpperCase()+val.slice(1):'custom type';}function formatValue(val){return Object.prototype.toString.call(val).slice(8,-1);} /**
   * Option overwriting strategies are functions that handle
   * how to merge a parent option value and a child option
   * value into the final value.
   *
   * All strategy functions follow the same signature:
   *
   * @param {*} parentVal
   * @param {*} childVal
   * @param {Vue} [vm]
   */var strats=config.optionMergeStrategies=Object.create(null); /**
   * Helper that recursively merges two data objects together.
   */function mergeData(to,from){var key,toVal,fromVal;for(key in from){toVal=to[key];fromVal=from[key];if(!hasOwn(to,key)){set(to,key,fromVal);}else if(isObject(toVal)&&isObject(fromVal)){mergeData(toVal,fromVal);}}return to;} /**
   * Data
   */strats.data=function(parentVal,childVal,vm){if(!vm){ // in a Vue.extend merge, both should be functions
if(!childVal){return parentVal;}if(typeof childVal!=='function'){'development'!=='production'&&warn('The "data" option should be a function '+'that returns a per-instance value in component '+'definitions.');return parentVal;}if(!parentVal){return childVal;} // when parentVal & childVal are both present,
// we need to return a function that returns the
// merged result of both functions... no need to
// check if parentVal is a function here because
// it has to be a function to pass previous merges.
return function mergedDataFn(){return mergeData(childVal.call(this),parentVal.call(this));};}else if(parentVal||childVal){return function mergedInstanceDataFn(){ // instance merge
var instanceData=typeof childVal==='function'?childVal.call(vm):childVal;var defaultData=typeof parentVal==='function'?parentVal.call(vm):undefined;if(instanceData){return mergeData(instanceData,defaultData);}else {return defaultData;}};}}; /**
   * El
   */strats.el=function(parentVal,childVal,vm){if(!vm&&childVal&&typeof childVal!=='function'){'development'!=='production'&&warn('The "el" option should be a function '+'that returns a per-instance value in component '+'definitions.');return;}var ret=childVal||parentVal; // invoke the element factory if this is instance merge
return vm&&typeof ret==='function'?ret.call(vm):ret;}; /**
   * Hooks and param attributes are merged as arrays.
   */strats.init=strats.created=strats.ready=strats.attached=strats.detached=strats.beforeCompile=strats.compiled=strats.beforeDestroy=strats.destroyed=strats.activate=function(parentVal,childVal){return childVal?parentVal?parentVal.concat(childVal):isArray(childVal)?childVal:[childVal]:parentVal;}; /**
   * 0.11 deprecation warning
   */strats.paramAttributes=function(){ /* istanbul ignore next */'development'!=='production'&&warn('"paramAttributes" option has been deprecated in 0.12. '+'Use "props" instead.');}; /**
   * Assets
   *
   * When a vm is present (instance creation), we need to do
   * a three-way merge between constructor options, instance
   * options and parent options.
   */function mergeAssets(parentVal,childVal){var res=Object.create(parentVal);return childVal?extend(res,guardArrayAssets(childVal)):res;}config._assetTypes.forEach(function(type){strats[type+'s']=mergeAssets;}); /**
   * Events & Watchers.
   *
   * Events & watchers hashes should not overwrite one
   * another, so we merge them as arrays.
   */strats.watch=strats.events=function(parentVal,childVal){if(!childVal)return parentVal;if(!parentVal)return childVal;var ret={};extend(ret,parentVal);for(var key in childVal){var parent=ret[key];var child=childVal[key];if(parent&&!isArray(parent)){parent=[parent];}ret[key]=parent?parent.concat(child):[child];}return ret;}; /**
   * Other object hashes.
   */strats.props=strats.methods=strats.computed=function(parentVal,childVal){if(!childVal)return parentVal;if(!parentVal)return childVal;var ret=Object.create(null);extend(ret,parentVal);extend(ret,childVal);return ret;}; /**
   * Default strategy.
   */var defaultStrat=function defaultStrat(parentVal,childVal){return childVal===undefined?parentVal:childVal;}; /**
   * Make sure component options get converted to actual
   * constructors.
   *
   * @param {Object} options
   */function guardComponents(options){if(options.components){var components=options.components=guardArrayAssets(options.components);var ids=Object.keys(components);var def;if('development'!=='production'){var map=options._componentNameMap={};}for(var i=0,l=ids.length;i<l;i++){var key=ids[i];if(commonTagRE.test(key)||reservedTagRE.test(key)){'development'!=='production'&&warn('Do not use built-in or reserved HTML elements as component '+'id: '+key);continue;} // record a all lowercase <-> kebab-case mapping for
// possible custom element case error warning
if('development'!=='production'){map[key.replace(/-/g,'').toLowerCase()]=hyphenate(key);}def=components[key];if(isPlainObject(def)){components[key]=Vue.extend(def);}}}} /**
   * Ensure all props option syntax are normalized into the
   * Object-based format.
   *
   * @param {Object} options
   */function guardProps(options){var props=options.props;var i,val;if(isArray(props)){options.props={};i=props.length;while(i--){val=props[i];if(typeof val==='string'){options.props[val]=null;}else if(val.name){options.props[val.name]=val;}}}else if(isPlainObject(props)){var keys=Object.keys(props);i=keys.length;while(i--){val=props[keys[i]];if(typeof val==='function'){props[keys[i]]={type:val};}}}} /**
   * Guard an Array-format assets option and converted it
   * into the key-value Object format.
   *
   * @param {Object|Array} assets
   * @return {Object}
   */function guardArrayAssets(assets){if(isArray(assets)){var res={};var i=assets.length;var asset;while(i--){asset=assets[i];var id=typeof asset==='function'?asset.options&&asset.options.name||asset.id:asset.name||asset.id;if(!id){'development'!=='production'&&warn('Array-syntax assets must provide a "name" or "id" field.');}else {res[id]=asset;}}return res;}return assets;} /**
   * Merge two option objects into a new one.
   * Core utility used in both instantiation and inheritance.
   *
   * @param {Object} parent
   * @param {Object} child
   * @param {Vue} [vm] - if vm is present, indicates this is
   *                     an instantiation merge.
   */function mergeOptions(parent,child,vm){guardComponents(child);guardProps(child);var options={};var key;if(child.mixins){for(var i=0,l=child.mixins.length;i<l;i++){parent=mergeOptions(parent,child.mixins[i],vm);}}for(key in parent){mergeField(key);}for(key in child){if(!hasOwn(parent,key)){mergeField(key);}}function mergeField(key){var strat=strats[key]||defaultStrat;options[key]=strat(parent[key],child[key],vm,key);}return options;} /**
   * Resolve an asset.
   * This function is used because child instances need access
   * to assets defined in its ancestor chain.
   *
   * @param {Object} options
   * @param {String} type
   * @param {String} id
   * @return {Object|Function}
   */function resolveAsset(options,type,id){ /* istanbul ignore if */if(typeof id!=='string'){return;}var assets=options[type];var camelizedId;return assets[id]|| // camelCase ID
assets[camelizedId=camelize(id)]|| // Pascal Case ID
assets[camelizedId.charAt(0).toUpperCase()+camelizedId.slice(1)];} /**
   * Assert asset exists
   */function assertAsset(val,type,id){if(!val){'development'!=='production'&&warn('Failed to resolve '+type+': '+id);}}var util=Object.freeze({defineReactive:defineReactive,set:set,del:del,hasOwn:hasOwn,isLiteral:isLiteral,isReserved:isReserved,_toString:_toString,toNumber:toNumber,toBoolean:toBoolean,stripQuotes:stripQuotes,camelize:camelize,hyphenate:hyphenate,classify:classify,bind:bind,toArray:toArray,extend:extend,isObject:isObject,isPlainObject:isPlainObject,def:def,debounce:_debounce,indexOf:indexOf,cancellable:cancellable,looseEqual:looseEqual,isArray:isArray,hasProto:hasProto,inBrowser:inBrowser,devtools:devtools,isIE9:isIE9,isAndroid:isAndroid,get transitionProp(){return transitionProp;},get transitionEndEvent(){return transitionEndEvent;},get animationProp(){return animationProp;},get animationEndEvent(){return animationEndEvent;},nextTick:nextTick,query:query,inDoc:inDoc,getAttr:getAttr,getBindAttr:getBindAttr,hasBindAttr:hasBindAttr,before:before,after:after,remove:remove,prepend:prepend,replace:replace,on:on,off:off,setClass:setClass,addClass:addClass,removeClass:removeClass,extractContent:extractContent,trimNode:trimNode,isTemplate:isTemplate,createAnchor:createAnchor,findRef:findRef,mapNodeRange:mapNodeRange,removeNodeRange:removeNodeRange,isFragment:isFragment,getOuterHTML:getOuterHTML,mergeOptions:mergeOptions,resolveAsset:resolveAsset,assertAsset:assertAsset,checkComponentAttr:checkComponentAttr,initProp:initProp,assertProp:assertProp,coerceProp:coerceProp,commonTagRE:commonTagRE,reservedTagRE:reservedTagRE,get warn(){return warn;}});var uid=0;function initMixin(Vue){ /**
     * The main init sequence. This is called for every
     * instance, including ones that are created from extended
     * constructors.
     *
     * @param {Object} options - this options object should be
     *                           the result of merging class
     *                           options and the options passed
     *                           in to the constructor.
     */Vue.prototype._init=function(options){options=options||{};this.$el=null;this.$parent=options.parent;this.$root=this.$parent?this.$parent.$root:this;this.$children=[];this.$refs={}; // child vm references
this.$els={}; // element references
this._watchers=[]; // all watchers as an array
this._directives=[]; // all directives
// a uid
this._uid=uid++; // a flag to avoid this being observed
this._isVue=true; // events bookkeeping
this._events={}; // registered callbacks
this._eventsCount={}; // for $broadcast optimization
// fragment instance properties
this._isFragment=false;this._fragment= // @type {DocumentFragment}
this._fragmentStart= // @type {Text|Comment}
this._fragmentEnd=null; // @type {Text|Comment}
// lifecycle state
this._isCompiled=this._isDestroyed=this._isReady=this._isAttached=this._isBeingDestroyed=this._vForRemoving=false;this._unlinkFn=null; // context:
// if this is a transcluded component, context
// will be the common parent vm of this instance
// and its host.
this._context=options._context||this.$parent; // scope:
// if this is inside an inline v-for, the scope
// will be the intermediate scope created for this
// repeat fragment. this is used for linking props
// and container directives.
this._scope=options._scope; // fragment:
// if this instance is compiled inside a Fragment, it
// needs to reigster itself as a child of that fragment
// for attach/detach to work properly.
this._frag=options._frag;if(this._frag){this._frag.children.push(this);} // push self into parent / transclusion host
if(this.$parent){this.$parent.$children.push(this);} // merge options.
options=this.$options=mergeOptions(this.constructor.options,options,this); // set ref
this._updateRef(); // initialize data as empty object.
// it will be filled up in _initScope().
this._data={}; // save raw constructor data before merge
// so that we know which properties are provided at
// instantiation.
this._runtimeData=options.data; // call init hook
this._callHook('init'); // initialize data observation and scope inheritance.
this._initState(); // setup event system and option events.
this._initEvents(); // call created hook
this._callHook('created'); // if `el` option is passed, start compilation.
if(options.el){this.$mount(options.el);}};}var pathCache=new Cache(1000); // actions
var APPEND=0;var PUSH=1;var INC_SUB_PATH_DEPTH=2;var PUSH_SUB_PATH=3; // states
var BEFORE_PATH=0;var IN_PATH=1;var BEFORE_IDENT=2;var IN_IDENT=3;var IN_SUB_PATH=4;var IN_SINGLE_QUOTE=5;var IN_DOUBLE_QUOTE=6;var AFTER_PATH=7;var ERROR=8;var pathStateMachine=[];pathStateMachine[BEFORE_PATH]={'ws':[BEFORE_PATH],'ident':[IN_IDENT,APPEND],'[':[IN_SUB_PATH],'eof':[AFTER_PATH]};pathStateMachine[IN_PATH]={'ws':[IN_PATH],'.':[BEFORE_IDENT],'[':[IN_SUB_PATH],'eof':[AFTER_PATH]};pathStateMachine[BEFORE_IDENT]={'ws':[BEFORE_IDENT],'ident':[IN_IDENT,APPEND]};pathStateMachine[IN_IDENT]={'ident':[IN_IDENT,APPEND],'0':[IN_IDENT,APPEND],'number':[IN_IDENT,APPEND],'ws':[IN_PATH,PUSH],'.':[BEFORE_IDENT,PUSH],'[':[IN_SUB_PATH,PUSH],'eof':[AFTER_PATH,PUSH]};pathStateMachine[IN_SUB_PATH]={"'":[IN_SINGLE_QUOTE,APPEND],'"':[IN_DOUBLE_QUOTE,APPEND],'[':[IN_SUB_PATH,INC_SUB_PATH_DEPTH],']':[IN_PATH,PUSH_SUB_PATH],'eof':ERROR,'else':[IN_SUB_PATH,APPEND]};pathStateMachine[IN_SINGLE_QUOTE]={"'":[IN_SUB_PATH,APPEND],'eof':ERROR,'else':[IN_SINGLE_QUOTE,APPEND]};pathStateMachine[IN_DOUBLE_QUOTE]={'"':[IN_SUB_PATH,APPEND],'eof':ERROR,'else':[IN_DOUBLE_QUOTE,APPEND]}; /**
   * Determine the type of a character in a keypath.
   *
   * @param {Char} ch
   * @return {String} type
   */function getPathCharType(ch){if(ch===undefined){return 'eof';}var code=ch.charCodeAt(0);switch(code){case 0x5B: // [
case 0x5D: // ]
case 0x2E: // .
case 0x22: // "
case 0x27: // '
case 0x30: // 0
return ch;case 0x5F: // _
case 0x24: // $
return 'ident';case 0x20: // Space
case 0x09: // Tab
case 0x0A: // Newline
case 0x0D: // Return
case 0xA0: // No-break space
case 0xFEFF: // Byte Order Mark
case 0x2028: // Line Separator
case 0x2029: // Paragraph Separator
return 'ws';} // a-z, A-Z
if(code>=0x61&&code<=0x7A||code>=0x41&&code<=0x5A){return 'ident';} // 1-9
if(code>=0x31&&code<=0x39){return 'number';}return 'else';} /**
   * Format a subPath, return its plain form if it is
   * a literal string or number. Otherwise prepend the
   * dynamic indicator (*).
   *
   * @param {String} path
   * @return {String}
   */function formatSubPath(path){var trimmed=path.trim(); // invalid leading 0
if(path.charAt(0)==='0'&&isNaN(path)){return false;}return isLiteral(trimmed)?stripQuotes(trimmed):'*'+trimmed;} /**
   * Parse a string path into an array of segments
   *
   * @param {String} path
   * @return {Array|undefined}
   */function parse(path){var keys=[];var index=-1;var mode=BEFORE_PATH;var subPathDepth=0;var c,newChar,key,type,transition,action,typeMap;var actions=[];actions[PUSH]=function(){if(key!==undefined){keys.push(key);key=undefined;}};actions[APPEND]=function(){if(key===undefined){key=newChar;}else {key+=newChar;}};actions[INC_SUB_PATH_DEPTH]=function(){actions[APPEND]();subPathDepth++;};actions[PUSH_SUB_PATH]=function(){if(subPathDepth>0){subPathDepth--;mode=IN_SUB_PATH;actions[APPEND]();}else {subPathDepth=0;key=formatSubPath(key);if(key===false){return false;}else {actions[PUSH]();}}};function maybeUnescapeQuote(){var nextChar=path[index+1];if(mode===IN_SINGLE_QUOTE&&nextChar==="'"||mode===IN_DOUBLE_QUOTE&&nextChar==='"'){index++;newChar='\\'+nextChar;actions[APPEND]();return true;}}while(mode!=null){index++;c=path[index];if(c==='\\'&&maybeUnescapeQuote()){continue;}type=getPathCharType(c);typeMap=pathStateMachine[mode];transition=typeMap[type]||typeMap['else']||ERROR;if(transition===ERROR){return; // parse error
}mode=transition[0];action=actions[transition[1]];if(action){newChar=transition[2];newChar=newChar===undefined?c:newChar;if(action()===false){return;}}if(mode===AFTER_PATH){keys.raw=path;return keys;}}} /**
   * External parse that check for a cache hit first
   *
   * @param {String} path
   * @return {Array|undefined}
   */function parsePath(path){var hit=pathCache.get(path);if(!hit){hit=parse(path);if(hit){pathCache.put(path,hit);}}return hit;} /**
   * Get from an object from a path string
   *
   * @param {Object} obj
   * @param {String} path
   */function getPath(obj,path){return parseExpression(path).get(obj);} /**
   * Warn against setting non-existent root path on a vm.
   */var warnNonExistent;if('development'!=='production'){warnNonExistent=function warnNonExistent(path){warn('You are setting a non-existent path "'+path.raw+'" '+'on a vm instance. Consider pre-initializing the property '+'with the "data" option for more reliable reactivity '+'and better performance.');};} /**
   * Set on an object from a path
   *
   * @param {Object} obj
   * @param {String | Array} path
   * @param {*} val
   */function setPath(obj,path,val){var original=obj;if(typeof path==='string'){path=parse(path);}if(!path||!isObject(obj)){return false;}var last,key;for(var i=0,l=path.length;i<l;i++){last=obj;key=path[i];if(key.charAt(0)==='*'){key=parseExpression(key.slice(1)).get.call(original,original);}if(i<l-1){obj=obj[key];if(!isObject(obj)){obj={};if('development'!=='production'&&last._isVue){warnNonExistent(path);}set(last,key,obj);}}else {if(isArray(obj)){obj.$set(key,val);}else if(key in obj){obj[key]=val;}else {if('development'!=='production'&&obj._isVue){warnNonExistent(path);}set(obj,key,val);}}}return true;}var path=Object.freeze({parsePath:parsePath,getPath:getPath,setPath:setPath});var expressionCache=new Cache(1000);var allowedKeywords='Math,Date,this,true,false,null,undefined,Infinity,NaN,'+'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,'+'encodeURIComponent,parseInt,parseFloat';var allowedKeywordsRE=new RegExp('^('+allowedKeywords.replace(/,/g,'\\b|')+'\\b)'); // keywords that don't make sense inside expressions
var improperKeywords='break,case,class,catch,const,continue,debugger,default,'+'delete,do,else,export,extends,finally,for,function,if,'+'import,in,instanceof,let,return,super,switch,throw,try,'+'var,while,with,yield,enum,await,implements,package,'+'protected,static,interface,private,public';var improperKeywordsRE=new RegExp('^('+improperKeywords.replace(/,/g,'\\b|')+'\\b)');var wsRE=/\s/g;var newlineRE=/\n/g;var saveRE=/[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g;var restoreRE=/"(\d+)"/g;var pathTestRE=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;var identRE=/[^\w$\.](?:[A-Za-z_$][\w$]*)/g;var booleanLiteralRE=/^(?:true|false)$/; /**
   * Save / Rewrite / Restore
   *
   * When rewriting paths found in an expression, it is
   * possible for the same letter sequences to be found in
   * strings and Object literal property keys. Therefore we
   * remove and store these parts in a temporary array, and
   * restore them after the path rewrite.
   */var saved=[]; /**
   * Save replacer
   *
   * The save regex can match two possible cases:
   * 1. An opening object literal
   * 2. A string
   * If matched as a plain string, we need to escape its
   * newlines, since the string needs to be preserved when
   * generating the function body.
   *
   * @param {String} str
   * @param {String} isString - str if matched as a string
   * @return {String} - placeholder with index
   */function save(str,isString){var i=saved.length;saved[i]=isString?str.replace(newlineRE,'\\n'):str;return '"'+i+'"';} /**
   * Path rewrite replacer
   *
   * @param {String} raw
   * @return {String}
   */function rewrite(raw){var c=raw.charAt(0);var path=raw.slice(1);if(allowedKeywordsRE.test(path)){return raw;}else {path=path.indexOf('"')>-1?path.replace(restoreRE,restore):path;return c+'scope.'+path;}} /**
   * Restore replacer
   *
   * @param {String} str
   * @param {String} i - matched save index
   * @return {String}
   */function restore(str,i){return saved[i];} /**
   * Rewrite an expression, prefixing all path accessors with
   * `scope.` and generate getter/setter functions.
   *
   * @param {String} exp
   * @return {Function}
   */function compileGetter(exp){if(improperKeywordsRE.test(exp)){'development'!=='production'&&warn('Avoid using reserved keywords in expression: '+exp);} // reset state
saved.length=0; // save strings and object literal keys
var body=exp.replace(saveRE,save).replace(wsRE,''); // rewrite all paths
// pad 1 space here becaue the regex matches 1 extra char
body=(' '+body).replace(identRE,rewrite).replace(restoreRE,restore);return makeGetterFn(body);} /**
   * Build a getter function. Requires eval.
   *
   * We isolate the try/catch so it doesn't affect the
   * optimization of the parse function when it is not called.
   *
   * @param {String} body
   * @return {Function|undefined}
   */function makeGetterFn(body){try{ /* eslint-disable no-new-func */return new Function('scope','return '+body+';'); /* eslint-enable no-new-func */}catch(e){'development'!=='production'&&warn('Invalid expression. '+'Generated function body: '+body);}} /**
   * Compile a setter function for the expression.
   *
   * @param {String} exp
   * @return {Function|undefined}
   */function compileSetter(exp){var path=parsePath(exp);if(path){return function(scope,val){setPath(scope,path,val);};}else {'development'!=='production'&&warn('Invalid setter expression: '+exp);}} /**
   * Parse an expression into re-written getter/setters.
   *
   * @param {String} exp
   * @param {Boolean} needSet
   * @return {Function}
   */function parseExpression(exp,needSet){exp=exp.trim(); // try cache
var hit=expressionCache.get(exp);if(hit){if(needSet&&!hit.set){hit.set=compileSetter(hit.exp);}return hit;}var res={exp:exp};res.get=isSimplePath(exp)&&exp.indexOf('[')<0 // optimized super simple getter
?makeGetterFn('scope.'+exp) // dynamic getter
:compileGetter(exp);if(needSet){res.set=compileSetter(exp);}expressionCache.put(exp,res);return res;} /**
   * Check if an expression is a simple path.
   *
   * @param {String} exp
   * @return {Boolean}
   */function isSimplePath(exp){return pathTestRE.test(exp)&& // don't treat true/false as paths
!booleanLiteralRE.test(exp)&& // Math constants e.g. Math.PI, Math.E etc.
exp.slice(0,5)!=='Math.';}var expression=Object.freeze({parseExpression:parseExpression,isSimplePath:isSimplePath}); // we have two separate queues: one for directive updates
// and one for user watcher registered via $watch().
// we want to guarantee directive updates to be called
// before user watchers so that when user watchers are
// triggered, the DOM would have already been in updated
// state.
var queueIndex;var queue=[];var userQueue=[];var has={};var circular={};var waiting=false;var internalQueueDepleted=false; /**
   * Reset the batcher's state.
   */function resetBatcherState(){queue=[];userQueue=[];has={};circular={};waiting=internalQueueDepleted=false;} /**
   * Flush both queues and run the watchers.
   */function flushBatcherQueue(){runBatcherQueue(queue);internalQueueDepleted=true;runBatcherQueue(userQueue); // dev tool hook
/* istanbul ignore if */if(devtools&&config.devtools){devtools.emit('flush');}resetBatcherState();} /**
   * Run the watchers in a single queue.
   *
   * @param {Array} queue
   */function runBatcherQueue(queue){ // do not cache length because more watchers might be pushed
// as we run existing watchers
for(queueIndex=0;queueIndex<queue.length;queueIndex++){var watcher=queue[queueIndex];var id=watcher.id;has[id]=null;watcher.run(); // in dev build, check and stop circular updates.
if('development'!=='production'&&has[id]!=null){circular[id]=(circular[id]||0)+1;if(circular[id]>config._maxUpdateCount){queue.splice(has[id],1);warn('You may have an infinite update loop for watcher '+'with expression: '+watcher.expression);}}}} /**
   * Push a watcher into the watcher queue.
   * Jobs with duplicate IDs will be skipped unless it's
   * pushed when the queue is being flushed.
   *
   * @param {Watcher} watcher
   *   properties:
   *   - {Number} id
   *   - {Function} run
   */function pushWatcher(watcher){var id=watcher.id;if(has[id]==null){if(internalQueueDepleted&&!watcher.user){ // an internal watcher triggered by a user watcher...
// let's run it immediately after current user watcher is done.
userQueue.splice(queueIndex+1,0,watcher);}else { // push watcher into appropriate queue
var q=watcher.user?userQueue:queue;has[id]=q.length;q.push(watcher); // queue the flush
if(!waiting){waiting=true;nextTick(flushBatcherQueue);}}}}var uid$2=0; /**
   * A watcher parses an expression, collects dependencies,
   * and fires callback when the expression value changes.
   * This is used for both the $watch() api and directives.
   *
   * @param {Vue} vm
   * @param {String} expression
   * @param {Function} cb
   * @param {Object} options
   *                 - {Array} filters
   *                 - {Boolean} twoWay
   *                 - {Boolean} deep
   *                 - {Boolean} user
   *                 - {Boolean} sync
   *                 - {Boolean} lazy
   *                 - {Function} [preProcess]
   *                 - {Function} [postProcess]
   * @constructor
   */function Watcher(vm,expOrFn,cb,options){ // mix in options
if(options){extend(this,options);}var isFn=typeof expOrFn==='function';this.vm=vm;vm._watchers.push(this);this.expression=expOrFn;this.cb=cb;this.id=++uid$2; // uid for batching
this.active=true;this.dirty=this.lazy; // for lazy watchers
this.deps=[];this.newDeps=[];this.depIds=Object.create(null);this.newDepIds=null;this.prevError=null; // for async error stacks
// parse expression for getter/setter
if(isFn){this.getter=expOrFn;this.setter=undefined;}else {var res=parseExpression(expOrFn,this.twoWay);this.getter=res.get;this.setter=res.set;}this.value=this.lazy?undefined:this.get(); // state for avoiding false triggers for deep and Array
// watchers during vm._digest()
this.queued=this.shallow=false;} /**
   * Evaluate the getter, and re-collect dependencies.
   */Watcher.prototype.get=function(){this.beforeGet();var scope=this.scope||this.vm;var value;try{value=this.getter.call(scope,scope);}catch(e){if('development'!=='production'&&config.warnExpressionErrors){warn('Error when evaluating expression "'+this.expression+'". '+(config.debug?'':'Turn on debug mode to see stack trace.'),e);}} // "touch" every property so they are all tracked as
// dependencies for deep watching
if(this.deep){traverse(value);}if(this.preProcess){value=this.preProcess(value);}if(this.filters){value=scope._applyFilters(value,null,this.filters,false);}if(this.postProcess){value=this.postProcess(value);}this.afterGet();return value;}; /**
   * Set the corresponding value with the setter.
   *
   * @param {*} value
   */Watcher.prototype.set=function(value){var scope=this.scope||this.vm;if(this.filters){value=scope._applyFilters(value,this.value,this.filters,true);}try{this.setter.call(scope,scope,value);}catch(e){if('development'!=='production'&&config.warnExpressionErrors){warn('Error when evaluating setter "'+this.expression+'"',e);}} // two-way sync for v-for alias
var forContext=scope.$forContext;if(forContext&&forContext.alias===this.expression){if(forContext.filters){'development'!=='production'&&warn('It seems you are using two-way binding on '+'a v-for alias ('+this.expression+'), and the '+'v-for has filters. This will not work properly. '+'Either remove the filters or use an array of '+'objects and bind to object properties instead.');return;}forContext._withLock(function(){if(scope.$key){ // original is an object
forContext.rawValue[scope.$key]=value;}else {forContext.rawValue.$set(scope.$index,value);}});}}; /**
   * Prepare for dependency collection.
   */Watcher.prototype.beforeGet=function(){Dep.target=this;this.newDepIds=Object.create(null);this.newDeps.length=0;}; /**
   * Add a dependency to this directive.
   *
   * @param {Dep} dep
   */Watcher.prototype.addDep=function(dep){var id=dep.id;if(!this.newDepIds[id]){this.newDepIds[id]=true;this.newDeps.push(dep);if(!this.depIds[id]){dep.addSub(this);}}}; /**
   * Clean up for dependency collection.
   */Watcher.prototype.afterGet=function(){Dep.target=null;var i=this.deps.length;while(i--){var dep=this.deps[i];if(!this.newDepIds[dep.id]){dep.removeSub(this);}}this.depIds=this.newDepIds;var tmp=this.deps;this.deps=this.newDeps;this.newDeps=tmp;}; /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   *
   * @param {Boolean} shallow
   */Watcher.prototype.update=function(shallow){if(this.lazy){this.dirty=true;}else if(this.sync||!config.async){this.run();}else { // if queued, only overwrite shallow with non-shallow,
// but not the other way around.
this.shallow=this.queued?shallow?this.shallow:false:!!shallow;this.queued=true; // record before-push error stack in debug mode
/* istanbul ignore if */if('development'!=='production'&&config.debug){this.prevError=new Error('[vue] async stack trace');}pushWatcher(this);}}; /**
   * Batcher job interface.
   * Will be called by the batcher.
   */Watcher.prototype.run=function(){if(this.active){var value=this.get();if(value!==this.value|| // Deep watchers and watchers on Object/Arrays should fire even
// when the value is the same, because the value may
// have mutated; but only do so if this is a
// non-shallow update (caused by a vm digest).
(isObject(value)||this.deep)&&!this.shallow){ // set new value
var oldValue=this.value;this.value=value; // in debug + async mode, when a watcher callbacks
// throws, we also throw the saved before-push error
// so the full cross-tick stack trace is available.
var prevError=this.prevError; /* istanbul ignore if */if('development'!=='production'&&config.debug&&prevError){this.prevError=null;try{this.cb.call(this.vm,value,oldValue);}catch(e){nextTick(function(){throw prevError;},0);throw e;}}else {this.cb.call(this.vm,value,oldValue);}}this.queued=this.shallow=false;}}; /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */Watcher.prototype.evaluate=function(){ // avoid overwriting another watcher that is being
// collected.
var current=Dep.target;this.value=this.get();this.dirty=false;Dep.target=current;}; /**
   * Depend on all deps collected by this watcher.
   */Watcher.prototype.depend=function(){var i=this.deps.length;while(i--){this.deps[i].depend();}}; /**
   * Remove self from all dependencies' subcriber list.
   */Watcher.prototype.teardown=function(){if(this.active){ // remove self from vm's watcher list
// this is a somewhat expensive operation so we skip it
// if the vm is being destroyed or is performing a v-for
// re-render (the watcher list is then filtered by v-for).
if(!this.vm._isBeingDestroyed&&!this.vm._vForRemoving){this.vm._watchers.$remove(this);}var i=this.deps.length;while(i--){this.deps[i].removeSub(this);}this.active=false;this.vm=this.cb=this.value=null;}}; /**
   * Recrusively traverse an object to evoke all converted
   * getters, so that every nested property inside the object
   * is collected as a "deep" dependency.
   *
   * @param {*} val
   */function traverse(val){var i,keys;if(isArray(val)){i=val.length;while(i--){traverse(val[i]);}}else if(isObject(val)){keys=Object.keys(val);i=keys.length;while(i--){traverse(val[keys[i]]);}}}var text$1={bind:function bind(){this.attr=this.el.nodeType===3?'data':'textContent';},update:function update(value){this.el[this.attr]=_toString(value);}};var templateCache=new Cache(1000);var idSelectorCache=new Cache(1000);var map={efault:[0,'',''],legend:[1,'<fieldset>','</fieldset>'],tr:[2,'<table><tbody>','</tbody></table>'],col:[2,'<table><tbody></tbody><colgroup>','</colgroup></table>']};map.td=map.th=[3,'<table><tbody><tr>','</tr></tbody></table>'];map.option=map.optgroup=[1,'<select multiple="multiple">','</select>'];map.thead=map.tbody=map.colgroup=map.caption=map.tfoot=[1,'<table>','</table>'];map.g=map.defs=map.symbol=map.use=map.image=map.text=map.circle=map.ellipse=map.line=map.path=map.polygon=map.polyline=map.rect=[1,'<svg '+'xmlns="http://www.w3.org/2000/svg" '+'xmlns:xlink="http://www.w3.org/1999/xlink" '+'xmlns:ev="http://www.w3.org/2001/xml-events"'+'version="1.1">','</svg>']; /**
   * Check if a node is a supported template node with a
   * DocumentFragment content.
   *
   * @param {Node} node
   * @return {Boolean}
   */function isRealTemplate(node){return isTemplate(node)&&isFragment(node.content);}var tagRE$1=/<([\w:-]+)/;var entityRE=/&#?\w+?;/; /**
   * Convert a string template to a DocumentFragment.
   * Determines correct wrapping by tag types. Wrapping
   * strategy found in jQuery & component/domify.
   *
   * @param {String} templateString
   * @param {Boolean} raw
   * @return {DocumentFragment}
   */function stringToFragment(templateString,raw){ // try a cache hit first
var cacheKey=raw?templateString:templateString.trim();var hit=templateCache.get(cacheKey);if(hit){return hit;}var frag=document.createDocumentFragment();var tagMatch=templateString.match(tagRE$1);var entityMatch=entityRE.test(templateString);if(!tagMatch&&!entityMatch){ // text only, return a single text node.
frag.appendChild(document.createTextNode(templateString));}else {var tag=tagMatch&&tagMatch[1];var wrap=map[tag]||map.efault;var depth=wrap[0];var prefix=wrap[1];var suffix=wrap[2];var node=document.createElement('div');node.innerHTML=prefix+templateString+suffix;while(depth--){node=node.lastChild;}var child; /* eslint-disable no-cond-assign */while(child=node.firstChild){ /* eslint-enable no-cond-assign */frag.appendChild(child);}}if(!raw){trimNode(frag);}templateCache.put(cacheKey,frag);return frag;} /**
   * Convert a template node to a DocumentFragment.
   *
   * @param {Node} node
   * @return {DocumentFragment}
   */function nodeToFragment(node){ // if its a template tag and the browser supports it,
// its content is already a document fragment.
if(isRealTemplate(node)){trimNode(node.content);return node.content;} // script template
if(node.tagName==='SCRIPT'){return stringToFragment(node.textContent);} // normal node, clone it to avoid mutating the original
var clonedNode=cloneNode(node);var frag=document.createDocumentFragment();var child; /* eslint-disable no-cond-assign */while(child=clonedNode.firstChild){ /* eslint-enable no-cond-assign */frag.appendChild(child);}trimNode(frag);return frag;} // Test for the presence of the Safari template cloning bug
// https://bugs.webkit.org/showug.cgi?id=137755
var hasBrokenTemplate=function(){ /* istanbul ignore else */if(inBrowser){var a=document.createElement('div');a.innerHTML='<template>1</template>';return !a.cloneNode(true).firstChild.innerHTML;}else {return false;}}(); // Test for IE10/11 textarea placeholder clone bug
var hasTextareaCloneBug=function(){ /* istanbul ignore else */if(inBrowser){var t=document.createElement('textarea');t.placeholder='t';return t.cloneNode(true).value==='t';}else {return false;}}(); /**
   * 1. Deal with Safari cloning nested <template> bug by
   *    manually cloning all template instances.
   * 2. Deal with IE10/11 textarea placeholder bug by setting
   *    the correct value after cloning.
   *
   * @param {Element|DocumentFragment} node
   * @return {Element|DocumentFragment}
   */function cloneNode(node){ /* istanbul ignore if */if(!node.querySelectorAll){return node.cloneNode();}var res=node.cloneNode(true);var i,original,cloned; /* istanbul ignore if */if(hasBrokenTemplate){var tempClone=res;if(isRealTemplate(node)){node=node.content;tempClone=res.content;}original=node.querySelectorAll('template');if(original.length){cloned=tempClone.querySelectorAll('template');i=cloned.length;while(i--){cloned[i].parentNode.replaceChild(cloneNode(original[i]),cloned[i]);}}} /* istanbul ignore if */if(hasTextareaCloneBug){if(node.tagName==='TEXTAREA'){res.value=node.value;}else {original=node.querySelectorAll('textarea');if(original.length){cloned=res.querySelectorAll('textarea');i=cloned.length;while(i--){cloned[i].value=original[i].value;}}}}return res;} /**
   * Process the template option and normalizes it into a
   * a DocumentFragment that can be used as a partial or a
   * instance template.
   *
   * @param {*} template
   *        Possible values include:
   *        - DocumentFragment object
   *        - Node object of type Template
   *        - id selector: '#some-template-id'
   *        - template string: '<div><span>{{msg}}</span></div>'
   * @param {Boolean} shouldClone
   * @param {Boolean} raw
   *        inline HTML interpolation. Do not check for id
   *        selector and keep whitespace in the string.
   * @return {DocumentFragment|undefined}
   */function parseTemplate(template,shouldClone,raw){var node,frag; // if the template is already a document fragment,
// do nothing
if(isFragment(template)){trimNode(template);return shouldClone?cloneNode(template):template;}if(typeof template==='string'){ // id selector
if(!raw&&template.charAt(0)==='#'){ // id selector can be cached too
frag=idSelectorCache.get(template);if(!frag){node=document.getElementById(template.slice(1));if(node){frag=nodeToFragment(node); // save selector to cache
idSelectorCache.put(template,frag);}}}else { // normal string template
frag=stringToFragment(template,raw);}}else if(template.nodeType){ // a direct node
frag=nodeToFragment(template);}return frag&&shouldClone?cloneNode(frag):frag;}var template=Object.freeze({cloneNode:cloneNode,parseTemplate:parseTemplate});var html={bind:function bind(){ // a comment node means this is a binding for
// {{{ inline unescaped html }}}
if(this.el.nodeType===8){ // hold nodes
this.nodes=[]; // replace the placeholder with proper anchor
this.anchor=createAnchor('v-html');replace(this.el,this.anchor);}},update:function update(value){value=_toString(value);if(this.nodes){this.swap(value);}else {this.el.innerHTML=value;}},swap:function swap(value){ // remove old nodes
var i=this.nodes.length;while(i--){remove(this.nodes[i]);} // convert new value to a fragment
// do not attempt to retrieve from id selector
var frag=parseTemplate(value,true,true); // save a reference to these nodes so we can remove later
this.nodes=toArray(frag.childNodes);before(frag,this.anchor);}}; /**
   * Abstraction for a partially-compiled fragment.
   * Can optionally compile content with a child scope.
   *
   * @param {Function} linker
   * @param {Vue} vm
   * @param {DocumentFragment} frag
   * @param {Vue} [host]
   * @param {Object} [scope]
   */function Fragment(linker,vm,frag,host,scope,parentFrag){this.children=[];this.childFrags=[];this.vm=vm;this.scope=scope;this.inserted=false;this.parentFrag=parentFrag;if(parentFrag){parentFrag.childFrags.push(this);}this.unlink=linker(vm,frag,host,scope,this);var single=this.single=frag.childNodes.length===1&& // do not go single mode if the only node is an anchor
!frag.childNodes[0].__v_anchor;if(single){this.node=frag.childNodes[0];this.before=singleBefore;this.remove=singleRemove;}else {this.node=createAnchor('fragment-start');this.end=createAnchor('fragment-end');this.frag=frag;prepend(this.node,frag);frag.appendChild(this.end);this.before=multiBefore;this.remove=multiRemove;}this.node.__v_frag=this;} /**
   * Call attach/detach for all components contained within
   * this fragment. Also do so recursively for all child
   * fragments.
   *
   * @param {Function} hook
   */Fragment.prototype.callHook=function(hook){var i,l;for(i=0,l=this.childFrags.length;i<l;i++){this.childFrags[i].callHook(hook);}for(i=0,l=this.children.length;i<l;i++){hook(this.children[i]);}}; /**
   * Insert fragment before target, single node version
   *
   * @param {Node} target
   * @param {Boolean} withTransition
   */function singleBefore(target,withTransition){this.inserted=true;var method=withTransition!==false?beforeWithTransition:before;method(this.node,target,this.vm);if(inDoc(this.node)){this.callHook(attach);}} /**
   * Remove fragment, single node version
   */function singleRemove(){this.inserted=false;var shouldCallRemove=inDoc(this.node);var self=this;this.beforeRemove();removeWithTransition(this.node,this.vm,function(){if(shouldCallRemove){self.callHook(detach);}self.destroy();});} /**
   * Insert fragment before target, multi-nodes version
   *
   * @param {Node} target
   * @param {Boolean} withTransition
   */function multiBefore(target,withTransition){this.inserted=true;var vm=this.vm;var method=withTransition!==false?beforeWithTransition:before;mapNodeRange(this.node,this.end,function(node){method(node,target,vm);});if(inDoc(this.node)){this.callHook(attach);}} /**
   * Remove fragment, multi-nodes version
   */function multiRemove(){this.inserted=false;var self=this;var shouldCallRemove=inDoc(this.node);this.beforeRemove();removeNodeRange(this.node,this.end,this.vm,this.frag,function(){if(shouldCallRemove){self.callHook(detach);}self.destroy();});} /**
   * Prepare the fragment for removal.
   */Fragment.prototype.beforeRemove=function(){var i,l;for(i=0,l=this.childFrags.length;i<l;i++){ // call the same method recursively on child
// fragments, depth-first
this.childFrags[i].beforeRemove(false);}for(i=0,l=this.children.length;i<l;i++){ // Call destroy for all contained instances,
// with remove:false and defer:true.
// Defer is necessary because we need to
// keep the children to call detach hooks
// on them.
this.children[i].$destroy(false,true);}var dirs=this.unlink.dirs;for(i=0,l=dirs.length;i<l;i++){ // disable the watchers on all the directives
// so that the rendered content stays the same
// during removal.
dirs[i]._watcher&&dirs[i]._watcher.teardown();}}; /**
   * Destroy the fragment.
   */Fragment.prototype.destroy=function(){if(this.parentFrag){this.parentFrag.childFrags.$remove(this);}this.node.__v_frag=null;this.unlink();}; /**
   * Call attach hook for a Vue instance.
   *
   * @param {Vue} child
   */function attach(child){if(!child._isAttached&&inDoc(child.$el)){child._callHook('attached');}} /**
   * Call detach hook for a Vue instance.
   *
   * @param {Vue} child
   */function detach(child){if(child._isAttached&&!inDoc(child.$el)){child._callHook('detached');}}var linkerCache=new Cache(5000); /**
   * A factory that can be used to create instances of a
   * fragment. Caches the compiled linker if possible.
   *
   * @param {Vue} vm
   * @param {Element|String} el
   */function FragmentFactory(vm,el){this.vm=vm;var template;var isString=typeof el==='string';if(isString||isTemplate(el)){template=parseTemplate(el,true);}else {template=document.createDocumentFragment();template.appendChild(el);}this.template=template; // linker can be cached, but only for components
var linker;var cid=vm.constructor.cid;if(cid>0){var cacheId=cid+(isString?el:getOuterHTML(el));linker=linkerCache.get(cacheId);if(!linker){linker=compile(template,vm.$options,true);linkerCache.put(cacheId,linker);}}else {linker=compile(template,vm.$options,true);}this.linker=linker;} /**
   * Create a fragment instance with given host and scope.
   *
   * @param {Vue} host
   * @param {Object} scope
   * @param {Fragment} parentFrag
   */FragmentFactory.prototype.create=function(host,scope,parentFrag){var frag=cloneNode(this.template);return new Fragment(this.linker,this.vm,frag,host,scope,parentFrag);};var ON=700;var MODEL=800;var BIND=850;var TRANSITION=1100;var EL=1500;var COMPONENT=1500;var PARTIAL=1750;var FOR=2000;var IF=2000;var SLOT=2100;var uid$3=0;var vFor={priority:FOR,params:['track-by','stagger','enter-stagger','leave-stagger'],bind:function bind(){ // support "item in/of items" syntax
var inMatch=this.expression.match(/(.*) (?:in|of) (.*)/);if(inMatch){var itMatch=inMatch[1].match(/\((.*),(.*)\)/);if(itMatch){this.iterator=itMatch[1].trim();this.alias=itMatch[2].trim();}else {this.alias=inMatch[1].trim();}this.expression=inMatch[2];}if(!this.alias){'development'!=='production'&&warn('Alias is required in v-for.');return;} // uid as a cache identifier
this.id='__v-for__'+ ++uid$3; // check if this is an option list,
// so that we know if we need to update the <select>'s
// v-model when the option list has changed.
// because v-model has a lower priority than v-for,
// the v-model is not bound here yet, so we have to
// retrive it in the actual updateModel() function.
var tag=this.el.tagName;this.isOption=(tag==='OPTION'||tag==='OPTGROUP')&&this.el.parentNode.tagName==='SELECT'; // setup anchor nodes
this.start=createAnchor('v-for-start');this.end=createAnchor('v-for-end');replace(this.el,this.end);before(this.start,this.end); // cache
this.cache=Object.create(null); // fragment factory
this.factory=new FragmentFactory(this.vm,this.el);},update:function update(data){this.diff(data);this.updateRef();this.updateModel();}, /**
     * Diff, based on new data and old data, determine the
     * minimum amount of DOM manipulations needed to make the
     * DOM reflect the new data Array.
     *
     * The algorithm diffs the new data Array by storing a
     * hidden reference to an owner vm instance on previously
     * seen data. This allows us to achieve O(n) which is
     * better than a levenshtein distance based algorithm,
     * which is O(m * n).
     *
     * @param {Array} data
     */diff:function diff(data){ // check if the Array was converted from an Object
var item=data[0];var convertedFromObject=this.fromObject=isObject(item)&&hasOwn(item,'$key')&&hasOwn(item,'$value');var trackByKey=this.params.trackBy;var oldFrags=this.frags;var frags=this.frags=new Array(data.length);var alias=this.alias;var iterator=this.iterator;var start=this.start;var end=this.end;var inDocument=inDoc(start);var init=!oldFrags;var i,l,frag,key,value,primitive; // First pass, go through the new Array and fill up
// the new frags array. If a piece of data has a cached
// instance for it, we reuse it. Otherwise build a new
// instance.
for(i=0,l=data.length;i<l;i++){item=data[i];key=convertedFromObject?item.$key:null;value=convertedFromObject?item.$value:item;primitive=!isObject(value);frag=!init&&this.getCachedFrag(value,i,key);if(frag){ // reusable fragment
frag.reused=true; // update $index
frag.scope.$index=i; // update $key
if(key){frag.scope.$key=key;} // update iterator
if(iterator){frag.scope[iterator]=key!==null?key:i;} // update data for track-by, object repeat &
// primitive values.
if(trackByKey||convertedFromObject||primitive){frag.scope[alias]=value;}}else { // new isntance
frag=this.create(value,alias,i,key);frag.fresh=!init;}frags[i]=frag;if(init){frag.before(end);}} // we're done for the initial render.
if(init){return;} // Second pass, go through the old fragments and
// destroy those who are not reused (and remove them
// from cache)
var removalIndex=0;var totalRemoved=oldFrags.length-frags.length; // when removing a large number of fragments, watcher removal
// turns out to be a perf bottleneck, so we batch the watcher
// removals into a single filter call!
this.vm._vForRemoving=true;for(i=0,l=oldFrags.length;i<l;i++){frag=oldFrags[i];if(!frag.reused){this.deleteCachedFrag(frag);this.remove(frag,removalIndex++,totalRemoved,inDocument);}}this.vm._vForRemoving=false;if(removalIndex){this.vm._watchers=this.vm._watchers.filter(function(w){return w.active;});} // Final pass, move/insert new fragments into the
// right place.
var targetPrev,prevEl,currentPrev;var insertionIndex=0;for(i=0,l=frags.length;i<l;i++){frag=frags[i]; // this is the frag that we should be after
targetPrev=frags[i-1];prevEl=targetPrev?targetPrev.staggerCb?targetPrev.staggerAnchor:targetPrev.end||targetPrev.node:start;if(frag.reused&&!frag.staggerCb){currentPrev=findPrevFrag(frag,start,this.id);if(currentPrev!==targetPrev&&(!currentPrev|| // optimization for moving a single item.
// thanks to suggestions by @livoras in #1807
findPrevFrag(currentPrev,start,this.id)!==targetPrev)){this.move(frag,prevEl);}}else { // new instance, or still in stagger.
// insert with updated stagger index.
this.insert(frag,insertionIndex++,prevEl,inDocument);}frag.reused=frag.fresh=false;}}, /**
     * Create a new fragment instance.
     *
     * @param {*} value
     * @param {String} alias
     * @param {Number} index
     * @param {String} [key]
     * @return {Fragment}
     */create:function create(value,alias,index,key){var host=this._host; // create iteration scope
var parentScope=this._scope||this.vm;var scope=Object.create(parentScope); // ref holder for the scope
scope.$refs=Object.create(parentScope.$refs);scope.$els=Object.create(parentScope.$els); // make sure point $parent to parent scope
scope.$parent=parentScope; // for two-way binding on alias
scope.$forContext=this; // define scope properties
defineReactive(scope,alias,value,true /* do not observe */);defineReactive(scope,'$index',index);if(key){defineReactive(scope,'$key',key);}else if(scope.$key){ // avoid accidental fallback
def(scope,'$key',null);}if(this.iterator){defineReactive(scope,this.iterator,key!==null?key:index);}var frag=this.factory.create(host,scope,this._frag);frag.forId=this.id;this.cacheFrag(value,frag,index,key);return frag;}, /**
     * Update the v-ref on owner vm.
     */updateRef:function updateRef(){var ref=this.descriptor.ref;if(!ref)return;var hash=(this._scope||this.vm).$refs;var refs;if(!this.fromObject){refs=this.frags.map(findVmFromFrag);}else {refs={};this.frags.forEach(function(frag){refs[frag.scope.$key]=findVmFromFrag(frag);});}hash[ref]=refs;}, /**
     * For option lists, update the containing v-model on
     * parent <select>.
     */updateModel:function updateModel(){if(this.isOption){var parent=this.start.parentNode;var model=parent&&parent.__v_model;if(model){model.forceUpdate();}}}, /**
     * Insert a fragment. Handles staggering.
     *
     * @param {Fragment} frag
     * @param {Number} index
     * @param {Node} prevEl
     * @param {Boolean} inDocument
     */insert:function insert(frag,index,prevEl,inDocument){if(frag.staggerCb){frag.staggerCb.cancel();frag.staggerCb=null;}var staggerAmount=this.getStagger(frag,index,null,'enter');if(inDocument&&staggerAmount){ // create an anchor and insert it synchronously,
// so that we can resolve the correct order without
// worrying about some elements not inserted yet
var anchor=frag.staggerAnchor;if(!anchor){anchor=frag.staggerAnchor=createAnchor('stagger-anchor');anchor.__v_frag=frag;}after(anchor,prevEl);var op=frag.staggerCb=cancellable(function(){frag.staggerCb=null;frag.before(anchor);remove(anchor);});setTimeout(op,staggerAmount);}else {frag.before(prevEl.nextSibling);}}, /**
     * Remove a fragment. Handles staggering.
     *
     * @param {Fragment} frag
     * @param {Number} index
     * @param {Number} total
     * @param {Boolean} inDocument
     */remove:function remove(frag,index,total,inDocument){if(frag.staggerCb){frag.staggerCb.cancel();frag.staggerCb=null; // it's not possible for the same frag to be removed
// twice, so if we have a pending stagger callback,
// it means this frag is queued for enter but removed
// before its transition started. Since it is already
// destroyed, we can just leave it in detached state.
return;}var staggerAmount=this.getStagger(frag,index,total,'leave');if(inDocument&&staggerAmount){var op=frag.staggerCb=cancellable(function(){frag.staggerCb=null;frag.remove();});setTimeout(op,staggerAmount);}else {frag.remove();}}, /**
     * Move a fragment to a new position.
     * Force no transition.
     *
     * @param {Fragment} frag
     * @param {Node} prevEl
     */move:function move(frag,prevEl){ // fix a common issue with Sortable:
// if prevEl doesn't have nextSibling, this means it's
// been dragged after the end anchor. Just re-position
// the end anchor to the end of the container.
/* istanbul ignore if */if(!prevEl.nextSibling){this.end.parentNode.appendChild(this.end);}frag.before(prevEl.nextSibling,false);}, /**
     * Cache a fragment using track-by or the object key.
     *
     * @param {*} value
     * @param {Fragment} frag
     * @param {Number} index
     * @param {String} [key]
     */cacheFrag:function cacheFrag(value,frag,index,key){var trackByKey=this.params.trackBy;var cache=this.cache;var primitive=!isObject(value);var id;if(key||trackByKey||primitive){id=trackByKey?trackByKey==='$index'?index:value[trackByKey]:key||value;if(!cache[id]){cache[id]=frag;}else if(trackByKey!=='$index'){'development'!=='production'&&this.warnDuplicate(value);}}else {id=this.id;if(hasOwn(value,id)){if(value[id]===null){value[id]=frag;}else {'development'!=='production'&&this.warnDuplicate(value);}}else {def(value,id,frag);}}frag.raw=value;}, /**
     * Get a cached fragment from the value/index/key
     *
     * @param {*} value
     * @param {Number} index
     * @param {String} key
     * @return {Fragment}
     */getCachedFrag:function getCachedFrag(value,index,key){var trackByKey=this.params.trackBy;var primitive=!isObject(value);var frag;if(key||trackByKey||primitive){var id=trackByKey?trackByKey==='$index'?index:value[trackByKey]:key||value;frag=this.cache[id];}else {frag=value[this.id];}if(frag&&(frag.reused||frag.fresh)){'development'!=='production'&&this.warnDuplicate(value);}return frag;}, /**
     * Delete a fragment from cache.
     *
     * @param {Fragment} frag
     */deleteCachedFrag:function deleteCachedFrag(frag){var value=frag.raw;var trackByKey=this.params.trackBy;var scope=frag.scope;var index=scope.$index; // fix #948: avoid accidentally fall through to
// a parent repeater which happens to have $key.
var key=hasOwn(scope,'$key')&&scope.$key;var primitive=!isObject(value);if(trackByKey||key||primitive){var id=trackByKey?trackByKey==='$index'?index:value[trackByKey]:key||value;this.cache[id]=null;}else {value[this.id]=null;frag.raw=null;}}, /**
     * Get the stagger amount for an insertion/removal.
     *
     * @param {Fragment} frag
     * @param {Number} index
     * @param {Number} total
     * @param {String} type
     */getStagger:function getStagger(frag,index,total,type){type=type+'Stagger';var trans=frag.node.__v_trans;var hooks=trans&&trans.hooks;var hook=hooks&&(hooks[type]||hooks.stagger);return hook?hook.call(frag,index,total):index*parseInt(this.params[type]||this.params.stagger,10);}, /**
     * Pre-process the value before piping it through the
     * filters. This is passed to and called by the watcher.
     */_preProcess:function _preProcess(value){ // regardless of type, store the un-filtered raw value.
this.rawValue=value;return value;}, /**
     * Post-process the value after it has been piped through
     * the filters. This is passed to and called by the watcher.
     *
     * It is necessary for this to be called during the
     * wathcer's dependency collection phase because we want
     * the v-for to update when the source Object is mutated.
     */_postProcess:function _postProcess(value){if(isArray(value)){return value;}else if(isPlainObject(value)){ // convert plain object to array.
var keys=Object.keys(value);var i=keys.length;var res=new Array(i);var key;while(i--){key=keys[i];res[i]={$key:key,$value:value[key]};}return res;}else {if(typeof value==='number'&&!isNaN(value)){value=range(value);}return value||[];}},unbind:function unbind(){if(this.descriptor.ref){(this._scope||this.vm).$refs[this.descriptor.ref]=null;}if(this.frags){var i=this.frags.length;var frag;while(i--){frag=this.frags[i];this.deleteCachedFrag(frag);frag.destroy();}}}}; /**
   * Helper to find the previous element that is a fragment
   * anchor. This is necessary because a destroyed frag's
   * element could still be lingering in the DOM before its
   * leaving transition finishes, but its inserted flag
   * should have been set to false so we can skip them.
   *
   * If this is a block repeat, we want to make sure we only
   * return frag that is bound to this v-for. (see #929)
   *
   * @param {Fragment} frag
   * @param {Comment|Text} anchor
   * @param {String} id
   * @return {Fragment}
   */function findPrevFrag(frag,anchor,id){var el=frag.node.previousSibling; /* istanbul ignore if */if(!el)return;frag=el.__v_frag;while((!frag||frag.forId!==id||!frag.inserted)&&el!==anchor){el=el.previousSibling; /* istanbul ignore if */if(!el)return;frag=el.__v_frag;}return frag;} /**
   * Find a vm from a fragment.
   *
   * @param {Fragment} frag
   * @return {Vue|undefined}
   */function findVmFromFrag(frag){var node=frag.node; // handle multi-node frag
if(frag.end){while(!node.__vue__&&node!==frag.end&&node.nextSibling){node=node.nextSibling;}}return node.__vue__;} /**
   * Create a range array from given number.
   *
   * @param {Number} n
   * @return {Array}
   */function range(n){var i=-1;var ret=new Array(Math.floor(n));while(++i<n){ret[i]=i;}return ret;}if('development'!=='production'){vFor.warnDuplicate=function(value){warn('Duplicate value found in v-for="'+this.descriptor.raw+'": '+JSON.stringify(value)+'. Use track-by="$index" if '+'you are expecting duplicate values.');};}var vIf={priority:IF,bind:function bind(){var el=this.el;if(!el.__vue__){ // check else block
var next=el.nextElementSibling;if(next&&getAttr(next,'v-else')!==null){remove(next);this.elseEl=next;} // check main block
this.anchor=createAnchor('v-if');replace(el,this.anchor);}else {'development'!=='production'&&warn('v-if="'+this.expression+'" cannot be '+'used on an instance root element.');this.invalid=true;}},update:function update(value){if(this.invalid)return;if(value){if(!this.frag){this.insert();}}else {this.remove();}},insert:function insert(){if(this.elseFrag){this.elseFrag.remove();this.elseFrag=null;} // lazy init factory
if(!this.factory){this.factory=new FragmentFactory(this.vm,this.el);}this.frag=this.factory.create(this._host,this._scope,this._frag);this.frag.before(this.anchor);},remove:function remove(){if(this.frag){this.frag.remove();this.frag=null;}if(this.elseEl&&!this.elseFrag){if(!this.elseFactory){this.elseFactory=new FragmentFactory(this.elseEl._context||this.vm,this.elseEl);}this.elseFrag=this.elseFactory.create(this._host,this._scope,this._frag);this.elseFrag.before(this.anchor);}},unbind:function unbind(){if(this.frag){this.frag.destroy();}if(this.elseFrag){this.elseFrag.destroy();}}};var show={bind:function bind(){ // check else block
var next=this.el.nextElementSibling;if(next&&getAttr(next,'v-else')!==null){this.elseEl=next;}},update:function update(value){this.apply(this.el,value);if(this.elseEl){this.apply(this.elseEl,!value);}},apply:function apply(el,value){if(inDoc(el)){applyTransition(el,value?1:-1,toggle,this.vm);}else {toggle();}function toggle(){el.style.display=value?'':'none';}}};var text$2={bind:function bind(){var self=this;var el=this.el;var isRange=el.type==='range';var lazy=this.params.lazy;var number=this.params.number;var debounce=this.params.debounce; // handle composition events.
//   http://blog.evanyou.me/2014/01/03/composition-event/
// skip this for Android because it handles composition
// events quite differently. Android doesn't trigger
// composition events for language input methods e.g.
// Chinese, but instead triggers them for spelling
// suggestions... (see Discussion/#162)
var composing=false;if(!isAndroid&&!isRange){this.on('compositionstart',function(){composing=true;});this.on('compositionend',function(){composing=false; // in IE11 the "compositionend" event fires AFTER
// the "input" event, so the input handler is blocked
// at the end... have to call it here.
//
// #1327: in lazy mode this is unecessary.
if(!lazy){self.listener();}});} // prevent messing with the input when user is typing,
// and force update on blur.
this.focused=false;if(!isRange&&!lazy){this.on('focus',function(){self.focused=true;});this.on('blur',function(){self.focused=false; // do not sync value after fragment removal (#2017)
if(!self._frag||self._frag.inserted){self.rawListener();}});} // Now attach the main listener
this.listener=this.rawListener=function(){if(composing||!self._bound){return;}var val=number||isRange?toNumber(el.value):el.value;self.set(val); // force update on next tick to avoid lock & same value
// also only update when user is not typing
nextTick(function(){if(self._bound&&!self.focused){self.update(self._watcher.value);}});}; // apply debounce
if(debounce){this.listener=_debounce(this.listener,debounce);} // Support jQuery events, since jQuery.trigger() doesn't
// trigger native events in some cases and some plugins
// rely on $.trigger()
//
// We want to make sure if a listener is attached using
// jQuery, it is also removed with jQuery, that's why
// we do the check for each directive instance and
// store that check result on itself. This also allows
// easier test coverage control by unsetting the global
// jQuery variable in tests.
this.hasjQuery=typeof jQuery==='function';if(this.hasjQuery){var method=jQuery.fn.on?'on':'bind';jQuery(el)[method]('change',this.rawListener);if(!lazy){jQuery(el)[method]('input',this.listener);}}else {this.on('change',this.rawListener);if(!lazy){this.on('input',this.listener);}} // IE9 doesn't fire input event on backspace/del/cut
if(!lazy&&isIE9){this.on('cut',function(){nextTick(self.listener);});this.on('keyup',function(e){if(e.keyCode===46||e.keyCode===8){self.listener();}});} // set initial value if present
if(el.hasAttribute('value')||el.tagName==='TEXTAREA'&&el.value.trim()){this.afterBind=this.listener;}},update:function update(value){this.el.value=_toString(value);},unbind:function unbind(){var el=this.el;if(this.hasjQuery){var method=jQuery.fn.off?'off':'unbind';jQuery(el)[method]('change',this.listener);jQuery(el)[method]('input',this.listener);}}};var radio={bind:function bind(){var self=this;var el=this.el;this.getValue=function(){ // value overwrite via v-bind:value
if(el.hasOwnProperty('_value')){return el._value;}var val=el.value;if(self.params.number){val=toNumber(val);}return val;};this.listener=function(){self.set(self.getValue());};this.on('change',this.listener);if(el.hasAttribute('checked')){this.afterBind=this.listener;}},update:function update(value){this.el.checked=looseEqual(value,this.getValue());}};var select={bind:function bind(){var self=this;var el=this.el; // method to force update DOM using latest value.
this.forceUpdate=function(){if(self._watcher){self.update(self._watcher.get());}}; // check if this is a multiple select
var multiple=this.multiple=el.hasAttribute('multiple'); // attach listener
this.listener=function(){var value=getValue(el,multiple);value=self.params.number?isArray(value)?value.map(toNumber):toNumber(value):value;self.set(value);};this.on('change',this.listener); // if has initial value, set afterBind
var initValue=getValue(el,multiple,true);if(multiple&&initValue.length||!multiple&&initValue!==null){this.afterBind=this.listener;} // All major browsers except Firefox resets
// selectedIndex with value -1 to 0 when the element
// is appended to a new parent, therefore we have to
// force a DOM update whenever that happens...
this.vm.$on('hook:attached',this.forceUpdate);},update:function update(value){var el=this.el;el.selectedIndex=-1;var multi=this.multiple&&isArray(value);var options=el.options;var i=options.length;var op,val;while(i--){op=options[i];val=op.hasOwnProperty('_value')?op._value:op.value; /* eslint-disable eqeqeq */op.selected=multi?indexOf$1(value,val)>-1:looseEqual(value,val); /* eslint-enable eqeqeq */}},unbind:function unbind(){ /* istanbul ignore next */this.vm.$off('hook:attached',this.forceUpdate);}}; /**
   * Get select value
   *
   * @param {SelectElement} el
   * @param {Boolean} multi
   * @param {Boolean} init
   * @return {Array|*}
   */function getValue(el,multi,init){var res=multi?[]:null;var op,val,selected;for(var i=0,l=el.options.length;i<l;i++){op=el.options[i];selected=init?op.hasAttribute('selected'):op.selected;if(selected){val=op.hasOwnProperty('_value')?op._value:op.value;if(multi){res.push(val);}else {return val;}}}return res;} /**
   * Native Array.indexOf uses strict equal, but in this
   * case we need to match string/numbers with custom equal.
   *
   * @param {Array} arr
   * @param {*} val
   */function indexOf$1(arr,val){var i=arr.length;while(i--){if(looseEqual(arr[i],val)){return i;}}return -1;}var checkbox={bind:function bind(){var self=this;var el=this.el;this.getValue=function(){return el.hasOwnProperty('_value')?el._value:self.params.number?toNumber(el.value):el.value;};function getBooleanValue(){var val=el.checked;if(val&&el.hasOwnProperty('_trueValue')){return el._trueValue;}if(!val&&el.hasOwnProperty('_falseValue')){return el._falseValue;}return val;}this.listener=function(){var model=self._watcher.value;if(isArray(model)){var val=self.getValue();if(el.checked){if(indexOf(model,val)<0){model.push(val);}}else {model.$remove(val);}}else {self.set(getBooleanValue());}};this.on('change',this.listener);if(el.hasAttribute('checked')){this.afterBind=this.listener;}},update:function update(value){var el=this.el;if(isArray(value)){el.checked=indexOf(value,this.getValue())>-1;}else {if(el.hasOwnProperty('_trueValue')){el.checked=looseEqual(value,el._trueValue);}else {el.checked=!!value;}}}};var handlers={text:text$2,radio:radio,select:select,checkbox:checkbox};var model={priority:MODEL,twoWay:true,handlers:handlers,params:['lazy','number','debounce'], /**
     * Possible elements:
     *   <select>
     *   <textarea>
     *   <input type="*">
     *     - text
     *     - checkbox
     *     - radio
     *     - number
     */bind:function bind(){ // friendly warning...
this.checkFilters();if(this.hasRead&&!this.hasWrite){'development'!=='production'&&warn('It seems you are using a read-only filter with '+'v-model. You might want to use a two-way filter '+'to ensure correct behavior.');}var el=this.el;var tag=el.tagName;var handler;if(tag==='INPUT'){handler=handlers[el.type]||handlers.text;}else if(tag==='SELECT'){handler=handlers.select;}else if(tag==='TEXTAREA'){handler=handlers.text;}else {'development'!=='production'&&warn('v-model does not support element type: '+tag);return;}el.__v_model=this;handler.bind.call(this);this.update=handler.update;this._unbind=handler.unbind;}, /**
     * Check read/write filter stats.
     */checkFilters:function checkFilters(){var filters=this.filters;if(!filters)return;var i=filters.length;while(i--){var filter=resolveAsset(this.vm.$options,'filters',filters[i].name);if(typeof filter==='function'||filter.read){this.hasRead=true;}if(filter.write){this.hasWrite=true;}}},unbind:function unbind(){this.el.__v_model=null;this._unbind&&this._unbind();}}; // keyCode aliases
var keyCodes={esc:27,tab:9,enter:13,space:32,'delete':[8,46],up:38,left:37,right:39,down:40};function keyFilter(handler,keys){var codes=keys.map(function(key){var charCode=key.charCodeAt(0);if(charCode>47&&charCode<58){return parseInt(key,10);}if(key.length===1){charCode=key.toUpperCase().charCodeAt(0);if(charCode>64&&charCode<91){return charCode;}}return keyCodes[key];});codes=[].concat.apply([],codes);return function keyHandler(e){if(codes.indexOf(e.keyCode)>-1){return handler.call(this,e);}};}function stopFilter(handler){return function stopHandler(e){e.stopPropagation();return handler.call(this,e);};}function preventFilter(handler){return function preventHandler(e){e.preventDefault();return handler.call(this,e);};}function selfFilter(handler){return function selfHandler(e){if(e.target===e.currentTarget){return handler.call(this,e);}};}var on$1={priority:ON,acceptStatement:true,keyCodes:keyCodes,bind:function bind(){ // deal with iframes
if(this.el.tagName==='IFRAME'&&this.arg!=='load'){var self=this;this.iframeBind=function(){on(self.el.contentWindow,self.arg,self.handler,self.modifiers.capture);};this.on('load',this.iframeBind);}},update:function update(handler){ // stub a noop for v-on with no value,
// e.g. @mousedown.prevent
if(!this.descriptor.raw){handler=function handler(){};}if(typeof handler!=='function'){'development'!=='production'&&warn('v-on:'+this.arg+'="'+this.expression+'" expects a function value, '+'got '+handler);return;} // apply modifiers
if(this.modifiers.stop){handler=stopFilter(handler);}if(this.modifiers.prevent){handler=preventFilter(handler);}if(this.modifiers.self){handler=selfFilter(handler);} // key filter
var keys=Object.keys(this.modifiers).filter(function(key){return key!=='stop'&&key!=='prevent'&&key!=='self';});if(keys.length){handler=keyFilter(handler,keys);}this.reset();this.handler=handler;if(this.iframeBind){this.iframeBind();}else {on(this.el,this.arg,this.handler,this.modifiers.capture);}},reset:function reset(){var el=this.iframeBind?this.el.contentWindow:this.el;if(this.handler){off(el,this.arg,this.handler);}},unbind:function unbind(){this.reset();}};var prefixes=['-webkit-','-moz-','-ms-'];var camelPrefixes=['Webkit','Moz','ms'];var importantRE=/!important;?$/;var propCache=Object.create(null);var testEl=null;var style={deep:true,update:function update(value){if(typeof value==='string'){this.el.style.cssText=value;}else if(isArray(value)){this.handleObject(value.reduce(extend,{}));}else {this.handleObject(value||{});}},handleObject:function handleObject(value){ // cache object styles so that only changed props
// are actually updated.
var cache=this.cache||(this.cache={});var name,val;for(name in cache){if(!(name in value)){this.handleSingle(name,null);delete cache[name];}}for(name in value){val=value[name];if(val!==cache[name]){cache[name]=val;this.handleSingle(name,val);}}},handleSingle:function handleSingle(prop,value){prop=normalize(prop);if(!prop)return; // unsupported prop
// cast possible numbers/booleans into strings
if(value!=null)value+='';if(value){var isImportant=importantRE.test(value)?'important':'';if(isImportant){value=value.replace(importantRE,'').trim();}this.el.style.setProperty(prop,value,isImportant);}else {this.el.style.removeProperty(prop);}}}; /**
   * Normalize a CSS property name.
   * - cache result
   * - auto prefix
   * - camelCase -> dash-case
   *
   * @param {String} prop
   * @return {String}
   */function normalize(prop){if(propCache[prop]){return propCache[prop];}var res=prefix(prop);propCache[prop]=propCache[res]=res;return res;} /**
   * Auto detect the appropriate prefix for a CSS property.
   * https://gist.github.com/paulirish/523692
   *
   * @param {String} prop
   * @return {String}
   */function prefix(prop){prop=hyphenate(prop);var camel=camelize(prop);var upper=camel.charAt(0).toUpperCase()+camel.slice(1);if(!testEl){testEl=document.createElement('div');}var i=prefixes.length;var prefixed;while(i--){prefixed=camelPrefixes[i]+upper;if(prefixed in testEl.style){return prefixes[i]+prop;}}if(camel in testEl.style){return prop;}} // xlink
var xlinkNS='http://www.w3.org/1999/xlink';var xlinkRE=/^xlink:/; // check for attributes that prohibit interpolations
var disallowedInterpAttrRE=/^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/; // these attributes should also set their corresponding properties
// because they only affect the initial state of the element
var attrWithPropsRE=/^(?:value|checked|selected|muted)$/; // these attributes expect enumrated values of "true" or "false"
// but are not boolean attributes
var enumeratedAttrRE=/^(?:draggable|contenteditable|spellcheck)$/; // these attributes should set a hidden property for
// binding v-model to object values
var modelProps={value:'_value','true-value':'_trueValue','false-value':'_falseValue'};var bind$1={priority:BIND,bind:function bind(){var attr=this.arg;var tag=this.el.tagName; // should be deep watch on object mode
if(!attr){this.deep=true;} // handle interpolation bindings
var descriptor=this.descriptor;var tokens=descriptor.interp;if(tokens){ // handle interpolations with one-time tokens
if(descriptor.hasOneTime){this.expression=tokensToExp(tokens,this._scope||this.vm);} // only allow binding on native attributes
if(disallowedInterpAttrRE.test(attr)||attr==='name'&&(tag==='PARTIAL'||tag==='SLOT')){'development'!=='production'&&warn(attr+'="'+descriptor.raw+'": '+'attribute interpolation is not allowed in Vue.js '+'directives and special attributes.');this.el.removeAttribute(attr);this.invalid=true;} /* istanbul ignore if */if('development'!=='production'){var raw=attr+'="'+descriptor.raw+'": '; // warn src
if(attr==='src'){warn(raw+'interpolation in "src" attribute will cause '+'a 404 request. Use v-bind:src instead.');} // warn style
if(attr==='style'){warn(raw+'interpolation in "style" attribute will cause '+'the attribute to be discarded in Internet Explorer. '+'Use v-bind:style instead.');}}}},update:function update(value){if(this.invalid){return;}var attr=this.arg;if(this.arg){this.handleSingle(attr,value);}else {this.handleObject(value||{});}}, // share object handler with v-bind:class
handleObject:style.handleObject,handleSingle:function handleSingle(attr,value){var el=this.el;var interp=this.descriptor.interp;if(this.modifiers.camel){attr=camelize(attr);}if(!interp&&attrWithPropsRE.test(attr)&&attr in el){el[attr]=attr==='value'?value==null // IE9 will set input.value to "null" for null...
?'':value:value;} // set model props
var modelProp=modelProps[attr];if(!interp&&modelProp){el[modelProp]=value; // update v-model if present
var model=el.__v_model;if(model){model.listener();}} // do not set value attribute for textarea
if(attr==='value'&&el.tagName==='TEXTAREA'){el.removeAttribute(attr);return;} // update attribute
if(enumeratedAttrRE.test(attr)){el.setAttribute(attr,value?'true':'false');}else if(value!=null&&value!==false){if(attr==='class'){ // handle edge case #1960:
// class interpolation should not overwrite Vue transition class
if(el.__v_trans){value+=' '+el.__v_trans.id+'-transition';}setClass(el,value);}else if(xlinkRE.test(attr)){el.setAttributeNS(xlinkNS,attr,value===true?'':value);}else {el.setAttribute(attr,value===true?'':value);}}else {el.removeAttribute(attr);}}};var el={priority:EL,bind:function bind(){ /* istanbul ignore if */if(!this.arg){return;}var id=this.id=camelize(this.arg);var refs=(this._scope||this.vm).$els;if(hasOwn(refs,id)){refs[id]=this.el;}else {defineReactive(refs,id,this.el);}},unbind:function unbind(){var refs=(this._scope||this.vm).$els;if(refs[this.id]===this.el){refs[this.id]=null;}}};var ref={bind:function bind(){'development'!=='production'&&warn('v-ref:'+this.arg+' must be used on a child '+'component. Found on <'+this.el.tagName.toLowerCase()+'>.');}};var cloak={bind:function bind(){var el=this.el;this.vm.$once('pre-hook:compiled',function(){el.removeAttribute('v-cloak');});}}; // must export plain object
var directives={text:text$1,html:html,'for':vFor,'if':vIf,show:show,model:model,on:on$1,bind:bind$1,el:el,ref:ref,cloak:cloak};var vClass={deep:true,update:function update(value){if(value&&typeof value==='string'){this.handleObject(stringToObject(value));}else if(isPlainObject(value)){this.handleObject(value);}else if(isArray(value)){this.handleArray(value);}else {this.cleanup();}},handleObject:function handleObject(value){this.cleanup(value);var keys=this.prevKeys=Object.keys(value);for(var i=0,l=keys.length;i<l;i++){var key=keys[i];if(value[key]){addClass(this.el,key);}else {removeClass(this.el,key);}}},handleArray:function handleArray(value){this.cleanup(value);for(var i=0,l=value.length;i<l;i++){if(value[i]){addClass(this.el,value[i]);}}this.prevKeys=value.slice();},cleanup:function cleanup(value){if(this.prevKeys){var i=this.prevKeys.length;while(i--){var key=this.prevKeys[i];if(key&&(!value||!contains(value,key))){removeClass(this.el,key);}}}}};function stringToObject(value){var res={};var keys=value.trim().split(/\s+/);var i=keys.length;while(i--){res[keys[i]]=true;}return res;}function contains(value,key){return isArray(value)?value.indexOf(key)>-1:hasOwn(value,key);}var component={priority:COMPONENT,params:['keep-alive','transition-mode','inline-template'], /**
     * Setup. Two possible usages:
     *
     * - static:
     *   <comp> or <div v-component="comp">
     *
     * - dynamic:
     *   <component :is="view">
     */bind:function bind(){if(!this.el.__vue__){ // keep-alive cache
this.keepAlive=this.params.keepAlive;if(this.keepAlive){this.cache={};} // check inline-template
if(this.params.inlineTemplate){ // extract inline template as a DocumentFragment
this.inlineTemplate=extractContent(this.el,true);} // component resolution related state
this.pendingComponentCb=this.Component=null; // transition related state
this.pendingRemovals=0;this.pendingRemovalCb=null; // create a ref anchor
this.anchor=createAnchor('v-component');replace(this.el,this.anchor); // remove is attribute.
// this is removed during compilation, but because compilation is
// cached, when the component is used elsewhere this attribute
// will remain at link time.
this.el.removeAttribute('is'); // remove ref, same as above
if(this.descriptor.ref){this.el.removeAttribute('v-ref:'+hyphenate(this.descriptor.ref));} // if static, build right now.
if(this.literal){this.setComponent(this.expression);}}else {'development'!=='production'&&warn('cannot mount component "'+this.expression+'" '+'on already mounted element: '+this.el);}}, /**
     * Public update, called by the watcher in the dynamic
     * literal scenario, e.g. <component :is="view">
     */update:function update(value){if(!this.literal){this.setComponent(value);}}, /**
     * Switch dynamic components. May resolve the component
     * asynchronously, and perform transition based on
     * specified transition mode. Accepts a few additional
     * arguments specifically for vue-router.
     *
     * The callback is called when the full transition is
     * finished.
     *
     * @param {String} value
     * @param {Function} [cb]
     */setComponent:function setComponent(value,cb){this.invalidatePending();if(!value){ // just remove current
this.unbuild(true);this.remove(this.childVM,cb);this.childVM=null;}else {var self=this;this.resolveComponent(value,function(){self.mountComponent(cb);});}}, /**
     * Resolve the component constructor to use when creating
     * the child vm.
     */resolveComponent:function resolveComponent(id,cb){var self=this;this.pendingComponentCb=cancellable(function(Component){self.ComponentName=Component.options.name||id;self.Component=Component;cb();});this.vm._resolveComponent(id,this.pendingComponentCb);}, /**
     * Create a new instance using the current constructor and
     * replace the existing instance. This method doesn't care
     * whether the new component and the old one are actually
     * the same.
     *
     * @param {Function} [cb]
     */mountComponent:function mountComponent(cb){ // actual mount
this.unbuild(true);var self=this;var activateHooks=this.Component.options.activate;var cached=this.getCached();var newComponent=this.build();if(activateHooks&&!cached){this.waitingFor=newComponent;callActivateHooks(activateHooks,newComponent,function(){if(self.waitingFor!==newComponent){return;}self.waitingFor=null;self.transition(newComponent,cb);});}else { // update ref for kept-alive component
if(cached){newComponent._updateRef();}this.transition(newComponent,cb);}}, /**
     * When the component changes or unbinds before an async
     * constructor is resolved, we need to invalidate its
     * pending callback.
     */invalidatePending:function invalidatePending(){if(this.pendingComponentCb){this.pendingComponentCb.cancel();this.pendingComponentCb=null;}}, /**
     * Instantiate/insert a new child vm.
     * If keep alive and has cached instance, insert that
     * instance; otherwise build a new one and cache it.
     *
     * @param {Object} [extraOptions]
     * @return {Vue} - the created instance
     */build:function build(extraOptions){var cached=this.getCached();if(cached){return cached;}if(this.Component){ // default options
var options={name:this.ComponentName,el:cloneNode(this.el),template:this.inlineTemplate, // make sure to add the child with correct parent
// if this is a transcluded component, its parent
// should be the transclusion host.
parent:this._host||this.vm, // if no inline-template, then the compiled
// linker can be cached for better performance.
_linkerCachable:!this.inlineTemplate,_ref:this.descriptor.ref,_asComponent:true,_isRouterView:this._isRouterView, // if this is a transcluded component, context
// will be the common parent vm of this instance
// and its host.
_context:this.vm, // if this is inside an inline v-for, the scope
// will be the intermediate scope created for this
// repeat fragment. this is used for linking props
// and container directives.
_scope:this._scope, // pass in the owner fragment of this component.
// this is necessary so that the fragment can keep
// track of its contained components in order to
// call attach/detach hooks for them.
_frag:this._frag}; // extra options
// in 1.0.0 this is used by vue-router only
/* istanbul ignore if */if(extraOptions){extend(options,extraOptions);}var child=new this.Component(options);if(this.keepAlive){this.cache[this.Component.cid]=child;} /* istanbul ignore if */if('development'!=='production'&&this.el.hasAttribute('transition')&&child._isFragment){warn('Transitions will not work on a fragment instance. '+'Template: '+child.$options.template);}return child;}}, /**
     * Try to get a cached instance of the current component.
     *
     * @return {Vue|undefined}
     */getCached:function getCached(){return this.keepAlive&&this.cache[this.Component.cid];}, /**
     * Teardown the current child, but defers cleanup so
     * that we can separate the destroy and removal steps.
     *
     * @param {Boolean} defer
     */unbuild:function unbuild(defer){if(this.waitingFor){this.waitingFor.$destroy();this.waitingFor=null;}var child=this.childVM;if(!child||this.keepAlive){if(child){ // remove ref
child._inactive=true;child._updateRef(true);}return;} // the sole purpose of `deferCleanup` is so that we can
// "deactivate" the vm right now and perform DOM removal
// later.
child.$destroy(false,defer);}, /**
     * Remove current destroyed child and manually do
     * the cleanup after removal.
     *
     * @param {Function} cb
     */remove:function remove(child,cb){var keepAlive=this.keepAlive;if(child){ // we may have a component switch when a previous
// component is still being transitioned out.
// we want to trigger only one lastest insertion cb
// when the existing transition finishes. (#1119)
this.pendingRemovals++;this.pendingRemovalCb=cb;var self=this;child.$remove(function(){self.pendingRemovals--;if(!keepAlive)child._cleanup();if(!self.pendingRemovals&&self.pendingRemovalCb){self.pendingRemovalCb();self.pendingRemovalCb=null;}});}else if(cb){cb();}}, /**
     * Actually swap the components, depending on the
     * transition mode. Defaults to simultaneous.
     *
     * @param {Vue} target
     * @param {Function} [cb]
     */transition:function transition(target,cb){var self=this;var current=this.childVM; // for devtool inspection
if(current)current._inactive=true;target._inactive=false;this.childVM=target;switch(self.params.transitionMode){case 'in-out':target.$before(self.anchor,function(){self.remove(current,cb);});break;case 'out-in':self.remove(current,function(){target.$before(self.anchor,cb);});break;default:self.remove(current);target.$before(self.anchor,cb);}}, /**
     * Unbind.
     */unbind:function unbind(){this.invalidatePending(); // Do not defer cleanup when unbinding
this.unbuild(); // destroy all keep-alive cached instances
if(this.cache){for(var key in this.cache){this.cache[key].$destroy();}this.cache=null;}}}; /**
   * Call activate hooks in order (asynchronous)
   *
   * @param {Array} hooks
   * @param {Vue} vm
   * @param {Function} cb
   */function callActivateHooks(hooks,vm,cb){var total=hooks.length;var called=0;hooks[0].call(vm,next);function next(){if(++called>=total){cb();}else {hooks[called].call(vm,next);}}}var bindingModes=config._propBindingModes;var propDef={bind:function bind(){var child=this.vm;var parent=child._context; // passed in from compiler directly
var prop=this.descriptor.prop;var childKey=prop.path;var parentKey=prop.parentPath;var twoWay=prop.mode===bindingModes.TWO_WAY;var parentWatcher=this.parentWatcher=new Watcher(parent,parentKey,function(val){val=coerceProp(prop,val);if(assertProp(prop,val)){child[childKey]=val;}},{twoWay:twoWay,filters:prop.filters, // important: props need to be observed on the
// v-for scope if present
scope:this._scope}); // set the child initial value.
initProp(child,prop,parentWatcher.value); // setup two-way binding
if(twoWay){ // important: defer the child watcher creation until
// the created hook (after data observation)
var self=this;child.$once('pre-hook:created',function(){self.childWatcher=new Watcher(child,childKey,function(val){parentWatcher.set(val);},{ // ensure sync upward before parent sync down.
// this is necessary in cases e.g. the child
// mutates a prop array, then replaces it. (#1683)
sync:true});});}},unbind:function unbind(){this.parentWatcher.teardown();if(this.childWatcher){this.childWatcher.teardown();}}};var queue$1=[];var queued=false; /**
   * Push a job into the queue.
   *
   * @param {Function} job
   */function pushJob(job){queue$1.push(job);if(!queued){queued=true;nextTick(flush);}} /**
   * Flush the queue, and do one forced reflow before
   * triggering transitions.
   */function flush(){ // Force layout
var f=document.documentElement.offsetHeight;for(var i=0;i<queue$1.length;i++){queue$1[i]();}queue$1=[];queued=false; // dummy return, so js linters don't complain about
// unused variable f
return f;}var TYPE_TRANSITION='transition';var TYPE_ANIMATION='animation';var transDurationProp=transitionProp+'Duration';var animDurationProp=animationProp+'Duration'; /**
   * A Transition object that encapsulates the state and logic
   * of the transition.
   *
   * @param {Element} el
   * @param {String} id
   * @param {Object} hooks
   * @param {Vue} vm
   */function Transition(el,id,hooks,vm){this.id=id;this.el=el;this.enterClass=hooks&&hooks.enterClass||id+'-enter';this.leaveClass=hooks&&hooks.leaveClass||id+'-leave';this.hooks=hooks;this.vm=vm; // async state
this.pendingCssEvent=this.pendingCssCb=this.cancel=this.pendingJsCb=this.op=this.cb=null;this.justEntered=false;this.entered=this.left=false;this.typeCache={}; // check css transition type
this.type=hooks&&hooks.type; /* istanbul ignore if */if('development'!=='production'){if(this.type&&this.type!==TYPE_TRANSITION&&this.type!==TYPE_ANIMATION){warn('invalid CSS transition type for transition="'+this.id+'": '+this.type);}} // bind
var self=this;['enterNextTick','enterDone','leaveNextTick','leaveDone'].forEach(function(m){self[m]=bind(self[m],self);});}var p$1=Transition.prototype; /**
   * Start an entering transition.
   *
   * 1. enter transition triggered
   * 2. call beforeEnter hook
   * 3. add enter class
   * 4. insert/show element
   * 5. call enter hook (with possible explicit js callback)
   * 6. reflow
   * 7. based on transition type:
   *    - transition:
   *        remove class now, wait for transitionend,
   *        then done if there's no explicit js callback.
   *    - animation:
   *        wait for animationend, remove class,
   *        then done if there's no explicit js callback.
   *    - no css transition:
   *        done now if there's no explicit js callback.
   * 8. wait for either done or js callback, then call
   *    afterEnter hook.
   *
   * @param {Function} op - insert/show the element
   * @param {Function} [cb]
   */p$1.enter=function(op,cb){this.cancelPending();this.callHook('beforeEnter');this.cb=cb;addClass(this.el,this.enterClass);op();this.entered=false;this.callHookWithCb('enter');if(this.entered){return; // user called done synchronously.
}this.cancel=this.hooks&&this.hooks.enterCancelled;pushJob(this.enterNextTick);}; /**
   * The "nextTick" phase of an entering transition, which is
   * to be pushed into a queue and executed after a reflow so
   * that removing the class can trigger a CSS transition.
   */p$1.enterNextTick=function(){ // Important hack:
// in Chrome, if a just-entered element is applied the
// leave class while its interpolated property still has
// a very small value (within one frame), Chrome will
// skip the leave transition entirely and not firing the
// transtionend event. Therefore we need to protected
// against such cases using a one-frame timeout.
this.justEntered=true;var self=this;setTimeout(function(){self.justEntered=false;},17);var enterDone=this.enterDone;var type=this.getCssTransitionType(this.enterClass);if(!this.pendingJsCb){if(type===TYPE_TRANSITION){ // trigger transition by removing enter class now
removeClass(this.el,this.enterClass);this.setupCssCb(transitionEndEvent,enterDone);}else if(type===TYPE_ANIMATION){this.setupCssCb(animationEndEvent,enterDone);}else {enterDone();}}else if(type===TYPE_TRANSITION){removeClass(this.el,this.enterClass);}}; /**
   * The "cleanup" phase of an entering transition.
   */p$1.enterDone=function(){this.entered=true;this.cancel=this.pendingJsCb=null;removeClass(this.el,this.enterClass);this.callHook('afterEnter');if(this.cb)this.cb();}; /**
   * Start a leaving transition.
   *
   * 1. leave transition triggered.
   * 2. call beforeLeave hook
   * 3. add leave class (trigger css transition)
   * 4. call leave hook (with possible explicit js callback)
   * 5. reflow if no explicit js callback is provided
   * 6. based on transition type:
   *    - transition or animation:
   *        wait for end event, remove class, then done if
   *        there's no explicit js callback.
   *    - no css transition:
   *        done if there's no explicit js callback.
   * 7. wait for either done or js callback, then call
   *    afterLeave hook.
   *
   * @param {Function} op - remove/hide the element
   * @param {Function} [cb]
   */p$1.leave=function(op,cb){this.cancelPending();this.callHook('beforeLeave');this.op=op;this.cb=cb;addClass(this.el,this.leaveClass);this.left=false;this.callHookWithCb('leave');if(this.left){return; // user called done synchronously.
}this.cancel=this.hooks&&this.hooks.leaveCancelled; // only need to handle leaveDone if
// 1. the transition is already done (synchronously called
//    by the user, which causes this.op set to null)
// 2. there's no explicit js callback
if(this.op&&!this.pendingJsCb){ // if a CSS transition leaves immediately after enter,
// the transitionend event never fires. therefore we
// detect such cases and end the leave immediately.
if(this.justEntered){this.leaveDone();}else {pushJob(this.leaveNextTick);}}}; /**
   * The "nextTick" phase of a leaving transition.
   */p$1.leaveNextTick=function(){var type=this.getCssTransitionType(this.leaveClass);if(type){var event=type===TYPE_TRANSITION?transitionEndEvent:animationEndEvent;this.setupCssCb(event,this.leaveDone);}else {this.leaveDone();}}; /**
   * The "cleanup" phase of a leaving transition.
   */p$1.leaveDone=function(){this.left=true;this.cancel=this.pendingJsCb=null;this.op();removeClass(this.el,this.leaveClass);this.callHook('afterLeave');if(this.cb)this.cb();this.op=null;}; /**
   * Cancel any pending callbacks from a previously running
   * but not finished transition.
   */p$1.cancelPending=function(){this.op=this.cb=null;var hasPending=false;if(this.pendingCssCb){hasPending=true;off(this.el,this.pendingCssEvent,this.pendingCssCb);this.pendingCssEvent=this.pendingCssCb=null;}if(this.pendingJsCb){hasPending=true;this.pendingJsCb.cancel();this.pendingJsCb=null;}if(hasPending){removeClass(this.el,this.enterClass);removeClass(this.el,this.leaveClass);}if(this.cancel){this.cancel.call(this.vm,this.el);this.cancel=null;}}; /**
   * Call a user-provided synchronous hook function.
   *
   * @param {String} type
   */p$1.callHook=function(type){if(this.hooks&&this.hooks[type]){this.hooks[type].call(this.vm,this.el);}}; /**
   * Call a user-provided, potentially-async hook function.
   * We check for the length of arguments to see if the hook
   * expects a `done` callback. If true, the transition's end
   * will be determined by when the user calls that callback;
   * otherwise, the end is determined by the CSS transition or
   * animation.
   *
   * @param {String} type
   */p$1.callHookWithCb=function(type){var hook=this.hooks&&this.hooks[type];if(hook){if(hook.length>1){this.pendingJsCb=cancellable(this[type+'Done']);}hook.call(this.vm,this.el,this.pendingJsCb);}}; /**
   * Get an element's transition type based on the
   * calculated styles.
   *
   * @param {String} className
   * @return {Number}
   */p$1.getCssTransitionType=function(className){ /* istanbul ignore if */if(!transitionEndEvent|| // skip CSS transitions if page is not visible -
// this solves the issue of transitionend events not
// firing until the page is visible again.
// pageVisibility API is supported in IE10+, same as
// CSS transitions.
document.hidden|| // explicit js-only transition
this.hooks&&this.hooks.css===false|| // element is hidden
isHidden(this.el)){return;}var type=this.type||this.typeCache[className];if(type)return type;var inlineStyles=this.el.style;var computedStyles=window.getComputedStyle(this.el);var transDuration=inlineStyles[transDurationProp]||computedStyles[transDurationProp];if(transDuration&&transDuration!=='0s'){type=TYPE_TRANSITION;}else {var animDuration=inlineStyles[animDurationProp]||computedStyles[animDurationProp];if(animDuration&&animDuration!=='0s'){type=TYPE_ANIMATION;}}if(type){this.typeCache[className]=type;}return type;}; /**
   * Setup a CSS transitionend/animationend callback.
   *
   * @param {String} event
   * @param {Function} cb
   */p$1.setupCssCb=function(event,cb){this.pendingCssEvent=event;var self=this;var el=this.el;var onEnd=this.pendingCssCb=function(e){if(e.target===el){off(el,event,onEnd);self.pendingCssEvent=self.pendingCssCb=null;if(!self.pendingJsCb&&cb){cb();}}};on(el,event,onEnd);}; /**
   * Check if an element is hidden - in that case we can just
   * skip the transition alltogether.
   *
   * @param {Element} el
   * @return {Boolean}
   */function isHidden(el){if(/svg$/.test(el.namespaceURI)){ // SVG elements do not have offset(Width|Height)
// so we need to check the client rect
var rect=el.getBoundingClientRect();return !(rect.width||rect.height);}else {return !(el.offsetWidth||el.offsetHeight||el.getClientRects().length);}}var transition$1={priority:TRANSITION,update:function update(id,oldId){var el=this.el; // resolve on owner vm
var hooks=resolveAsset(this.vm.$options,'transitions',id);id=id||'v';el.__v_trans=new Transition(el,id,hooks,this.vm);if(oldId){removeClass(el,oldId+'-transition');}addClass(el,id+'-transition');}};var internalDirectives={style:style,'class':vClass,component:component,prop:propDef,transition:transition$1};var propBindingModes=config._propBindingModes;var empty={}; // regexes
var identRE$1=/^[$_a-zA-Z]+[\w$]*$/;var settablePathRE=/^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/; /**
   * Compile props on a root element and return
   * a props link function.
   *
   * @param {Element|DocumentFragment} el
   * @param {Array} propOptions
   * @return {Function} propsLinkFn
   */function compileProps(el,propOptions){var props=[];var names=Object.keys(propOptions);var i=names.length;var options,name,attr,value,path,parsed,prop;while(i--){name=names[i];options=propOptions[name]||empty;if('development'!=='production'&&name==='$data'){warn('Do not use $data as prop.');continue;} // props could contain dashes, which will be
// interpreted as minus calculations by the parser
// so we need to camelize the path here
path=camelize(name);if(!identRE$1.test(path)){'development'!=='production'&&warn('Invalid prop key: "'+name+'". Prop keys '+'must be valid identifiers.');continue;}prop={name:name,path:path,options:options,mode:propBindingModes.ONE_WAY,raw:null};attr=hyphenate(name); // first check dynamic version
if((value=getBindAttr(el,attr))===null){if((value=getBindAttr(el,attr+'.sync'))!==null){prop.mode=propBindingModes.TWO_WAY;}else if((value=getBindAttr(el,attr+'.once'))!==null){prop.mode=propBindingModes.ONE_TIME;}}if(value!==null){ // has dynamic binding!
prop.raw=value;parsed=parseDirective(value);value=parsed.expression;prop.filters=parsed.filters; // check binding type
if(isLiteral(value)&&!parsed.filters){ // for expressions containing literal numbers and
// booleans, there's no need to setup a prop binding,
// so we can optimize them as a one-time set.
prop.optimizedLiteral=true;}else {prop.dynamic=true; // check non-settable path for two-way bindings
if('development'!=='production'&&prop.mode===propBindingModes.TWO_WAY&&!settablePathRE.test(value)){prop.mode=propBindingModes.ONE_WAY;warn('Cannot bind two-way prop with non-settable '+'parent path: '+value);}}prop.parentPath=value; // warn required two-way
if('development'!=='production'&&options.twoWay&&prop.mode!==propBindingModes.TWO_WAY){warn('Prop "'+name+'" expects a two-way binding type.');}}else if((value=getAttr(el,attr))!==null){ // has literal binding!
prop.raw=value;}else if('development'!=='production'){ // check possible camelCase prop usage
var lowerCaseName=path.toLowerCase();value=/[A-Z\-]/.test(name)&&(el.getAttribute(lowerCaseName)||el.getAttribute(':'+lowerCaseName)||el.getAttribute('v-bind:'+lowerCaseName)||el.getAttribute(':'+lowerCaseName+'.once')||el.getAttribute('v-bind:'+lowerCaseName+'.once')||el.getAttribute(':'+lowerCaseName+'.sync')||el.getAttribute('v-bind:'+lowerCaseName+'.sync'));if(value){warn('Possible usage error for prop `'+lowerCaseName+'` - '+'did you mean `'+attr+'`? HTML is case-insensitive, remember to use '+'kebab-case for props in templates.');}else if(options.required){ // warn missing required
warn('Missing required prop: '+name);}} // push prop
props.push(prop);}return makePropsLinkFn(props);} /**
   * Build a function that applies props to a vm.
   *
   * @param {Array} props
   * @return {Function} propsLinkFn
   */function makePropsLinkFn(props){return function propsLinkFn(vm,scope){ // store resolved props info
vm._props={};var i=props.length;var prop,path,options,value,raw;while(i--){prop=props[i];raw=prop.raw;path=prop.path;options=prop.options;vm._props[path]=prop;if(raw===null){ // initialize absent prop
initProp(vm,prop,undefined);}else if(prop.dynamic){ // dynamic prop
if(prop.mode===propBindingModes.ONE_TIME){ // one time binding
value=(scope||vm._context||vm).$get(prop.parentPath);initProp(vm,prop,value);}else {if(vm._context){ // dynamic binding
vm._bindDir({name:'prop',def:propDef,prop:prop},null,null,scope); // el, host, scope
}else { // root instance
initProp(vm,prop,vm.$get(prop.parentPath));}}}else if(prop.optimizedLiteral){ // optimized literal, cast it and just set once
var stripped=stripQuotes(raw);value=stripped===raw?toBoolean(toNumber(raw)):stripped;initProp(vm,prop,value);}else { // string literal, but we need to cater for
// Boolean props with no value
value=options.type===Boolean&&raw===''?true:raw;initProp(vm,prop,value);}}};} // special binding prefixes
var bindRE=/^v-bind:|^:/;var onRE=/^v-on:|^@/;var dirAttrRE=/^v-([^:]+)(?:$|:(.*)$)/;var modifierRE=/\.[^\.]+/g;var transitionRE=/^(v-bind:|:)?transition$/; // terminal directives
var terminalDirectives=['for','if']; // default directive priority
var DEFAULT_PRIORITY=1000; /**
   * Compile a template and return a reusable composite link
   * function, which recursively contains more link functions
   * inside. This top level compile function would normally
   * be called on instance root nodes, but can also be used
   * for partial compilation if the partial argument is true.
   *
   * The returned composite link function, when called, will
   * return an unlink function that tearsdown all directives
   * created during the linking phase.
   *
   * @param {Element|DocumentFragment} el
   * @param {Object} options
   * @param {Boolean} partial
   * @return {Function}
   */function compile(el,options,partial){ // link function for the node itself.
var nodeLinkFn=partial||!options._asComponent?compileNode(el,options):null; // link function for the childNodes
var childLinkFn=!(nodeLinkFn&&nodeLinkFn.terminal)&&el.tagName!=='SCRIPT'&&el.hasChildNodes()?compileNodeList(el.childNodes,options):null; /**
     * A composite linker function to be called on a already
     * compiled piece of DOM, which instantiates all directive
     * instances.
     *
     * @param {Vue} vm
     * @param {Element|DocumentFragment} el
     * @param {Vue} [host] - host vm of transcluded content
     * @param {Object} [scope] - v-for scope
     * @param {Fragment} [frag] - link context fragment
     * @return {Function|undefined}
     */return function compositeLinkFn(vm,el,host,scope,frag){ // cache childNodes before linking parent, fix #657
var childNodes=toArray(el.childNodes); // link
var dirs=linkAndCapture(function compositeLinkCapturer(){if(nodeLinkFn)nodeLinkFn(vm,el,host,scope,frag);if(childLinkFn)childLinkFn(vm,childNodes,host,scope,frag);},vm);return makeUnlinkFn(vm,dirs);};} /**
   * Apply a linker to a vm/element pair and capture the
   * directives created during the process.
   *
   * @param {Function} linker
   * @param {Vue} vm
   */function linkAndCapture(linker,vm){ /* istanbul ignore if */if('development'==='production'){}var originalDirCount=vm._directives.length;linker();var dirs=vm._directives.slice(originalDirCount);dirs.sort(directiveComparator);for(var i=0,l=dirs.length;i<l;i++){dirs[i]._bind();}return dirs;} /**
   * Directive priority sort comparator
   *
   * @param {Object} a
   * @param {Object} b
   */function directiveComparator(a,b){a=a.descriptor.def.priority||DEFAULT_PRIORITY;b=b.descriptor.def.priority||DEFAULT_PRIORITY;return a>b?-1:a===b?0:1;} /**
   * Linker functions return an unlink function that
   * tearsdown all directives instances generated during
   * the process.
   *
   * We create unlink functions with only the necessary
   * information to avoid retaining additional closures.
   *
   * @param {Vue} vm
   * @param {Array} dirs
   * @param {Vue} [context]
   * @param {Array} [contextDirs]
   * @return {Function}
   */function makeUnlinkFn(vm,dirs,context,contextDirs){function unlink(destroying){teardownDirs(vm,dirs,destroying);if(context&&contextDirs){teardownDirs(context,contextDirs);}} // expose linked directives
unlink.dirs=dirs;return unlink;} /**
   * Teardown partial linked directives.
   *
   * @param {Vue} vm
   * @param {Array} dirs
   * @param {Boolean} destroying
   */function teardownDirs(vm,dirs,destroying){var i=dirs.length;while(i--){dirs[i]._teardown();if('development'!=='production'&&!destroying){vm._directives.$remove(dirs[i]);}}} /**
   * Compile link props on an instance.
   *
   * @param {Vue} vm
   * @param {Element} el
   * @param {Object} props
   * @param {Object} [scope]
   * @return {Function}
   */function compileAndLinkProps(vm,el,props,scope){var propsLinkFn=compileProps(el,props);var propDirs=linkAndCapture(function(){propsLinkFn(vm,scope);},vm);return makeUnlinkFn(vm,propDirs);} /**
   * Compile the root element of an instance.
   *
   * 1. attrs on context container (context scope)
   * 2. attrs on the component template root node, if
   *    replace:true (child scope)
   *
   * If this is a fragment instance, we only need to compile 1.
   *
   * @param {Element} el
   * @param {Object} options
   * @param {Object} contextOptions
   * @return {Function}
   */function compileRoot(el,options,contextOptions){var containerAttrs=options._containerAttrs;var replacerAttrs=options._replacerAttrs;var contextLinkFn,replacerLinkFn; // only need to compile other attributes for
// non-fragment instances
if(el.nodeType!==11){ // for components, container and replacer need to be
// compiled separately and linked in different scopes.
if(options._asComponent){ // 2. container attributes
if(containerAttrs&&contextOptions){contextLinkFn=compileDirectives(containerAttrs,contextOptions);}if(replacerAttrs){ // 3. replacer attributes
replacerLinkFn=compileDirectives(replacerAttrs,options);}}else { // non-component, just compile as a normal element.
replacerLinkFn=compileDirectives(el.attributes,options);}}else if('development'!=='production'&&containerAttrs){ // warn container directives for fragment instances
var names=containerAttrs.filter(function(attr){ // allow vue-loader/vueify scoped css attributes
return attr.name.indexOf('_v-')<0&& // allow event listeners
!onRE.test(attr.name)&& // allow slots
attr.name!=='slot';}).map(function(attr){return '"'+attr.name+'"';});if(names.length){var plural=names.length>1;warn('Attribute'+(plural?'s ':' ')+names.join(', ')+(plural?' are':' is')+' ignored on component '+'<'+options.el.tagName.toLowerCase()+'> because '+'the component is a fragment instance: '+'http://vuejs.org/guide/components.html#Fragment_Instance');}}options._containerAttrs=options._replacerAttrs=null;return function rootLinkFn(vm,el,scope){ // link context scope dirs
var context=vm._context;var contextDirs;if(context&&contextLinkFn){contextDirs=linkAndCapture(function(){contextLinkFn(context,el,null,scope);},context);} // link self
var selfDirs=linkAndCapture(function(){if(replacerLinkFn)replacerLinkFn(vm,el);},vm); // return the unlink function that tearsdown context
// container directives.
return makeUnlinkFn(vm,selfDirs,context,contextDirs);};} /**
   * Compile a node and return a nodeLinkFn based on the
   * node type.
   *
   * @param {Node} node
   * @param {Object} options
   * @return {Function|null}
   */function compileNode(node,options){var type=node.nodeType;if(type===1&&node.tagName!=='SCRIPT'){return compileElement(node,options);}else if(type===3&&node.data.trim()){return compileTextNode(node,options);}else {return null;}} /**
   * Compile an element and return a nodeLinkFn.
   *
   * @param {Element} el
   * @param {Object} options
   * @return {Function|null}
   */function compileElement(el,options){ // preprocess textareas.
// textarea treats its text content as the initial value.
// just bind it as an attr directive for value.
if(el.tagName==='TEXTAREA'){var tokens=parseText(el.value);if(tokens){el.setAttribute(':value',tokensToExp(tokens));el.value='';}}var linkFn;var hasAttrs=el.hasAttributes(); // check terminal directives (for & if)
if(hasAttrs){linkFn=checkTerminalDirectives(el,options);} // check element directives
if(!linkFn){linkFn=checkElementDirectives(el,options);} // check component
if(!linkFn){linkFn=checkComponent(el,options);} // normal directives
if(!linkFn&&hasAttrs){linkFn=compileDirectives(el.attributes,options);}return linkFn;} /**
   * Compile a textNode and return a nodeLinkFn.
   *
   * @param {TextNode} node
   * @param {Object} options
   * @return {Function|null} textNodeLinkFn
   */function compileTextNode(node,options){ // skip marked text nodes
if(node._skip){return removeText;}var tokens=parseText(node.wholeText);if(!tokens){return null;} // mark adjacent text nodes as skipped,
// because we are using node.wholeText to compile
// all adjacent text nodes together. This fixes
// issues in IE where sometimes it splits up a single
// text node into multiple ones.
var next=node.nextSibling;while(next&&next.nodeType===3){next._skip=true;next=next.nextSibling;}var frag=document.createDocumentFragment();var el,token;for(var i=0,l=tokens.length;i<l;i++){token=tokens[i];el=token.tag?processTextToken(token,options):document.createTextNode(token.value);frag.appendChild(el);}return makeTextNodeLinkFn(tokens,frag,options);} /**
   * Linker for an skipped text node.
   *
   * @param {Vue} vm
   * @param {Text} node
   */function removeText(vm,node){remove(node);} /**
   * Process a single text token.
   *
   * @param {Object} token
   * @param {Object} options
   * @return {Node}
   */function processTextToken(token,options){var el;if(token.oneTime){el=document.createTextNode(token.value);}else {if(token.html){el=document.createComment('v-html');setTokenType('html');}else { // IE will clean up empty textNodes during
// frag.cloneNode(true), so we have to give it
// something here...
el=document.createTextNode(' ');setTokenType('text');}}function setTokenType(type){if(token.descriptor)return;var parsed=parseDirective(token.value);token.descriptor={name:type,def:directives[type],expression:parsed.expression,filters:parsed.filters};}return el;} /**
   * Build a function that processes a textNode.
   *
   * @param {Array<Object>} tokens
   * @param {DocumentFragment} frag
   */function makeTextNodeLinkFn(tokens,frag){return function textNodeLinkFn(vm,el,host,scope){var fragClone=frag.cloneNode(true);var childNodes=toArray(fragClone.childNodes);var token,value,node;for(var i=0,l=tokens.length;i<l;i++){token=tokens[i];value=token.value;if(token.tag){node=childNodes[i];if(token.oneTime){value=(scope||vm).$eval(value);if(token.html){replace(node,parseTemplate(value,true));}else {node.data=value;}}else {vm._bindDir(token.descriptor,node,host,scope);}}}replace(el,fragClone);};} /**
   * Compile a node list and return a childLinkFn.
   *
   * @param {NodeList} nodeList
   * @param {Object} options
   * @return {Function|undefined}
   */function compileNodeList(nodeList,options){var linkFns=[];var nodeLinkFn,childLinkFn,node;for(var i=0,l=nodeList.length;i<l;i++){node=nodeList[i];nodeLinkFn=compileNode(node,options);childLinkFn=!(nodeLinkFn&&nodeLinkFn.terminal)&&node.tagName!=='SCRIPT'&&node.hasChildNodes()?compileNodeList(node.childNodes,options):null;linkFns.push(nodeLinkFn,childLinkFn);}return linkFns.length?makeChildLinkFn(linkFns):null;} /**
   * Make a child link function for a node's childNodes.
   *
   * @param {Array<Function>} linkFns
   * @return {Function} childLinkFn
   */function makeChildLinkFn(linkFns){return function childLinkFn(vm,nodes,host,scope,frag){var node,nodeLinkFn,childrenLinkFn;for(var i=0,n=0,l=linkFns.length;i<l;n++){node=nodes[n];nodeLinkFn=linkFns[i++];childrenLinkFn=linkFns[i++]; // cache childNodes before linking parent, fix #657
var childNodes=toArray(node.childNodes);if(nodeLinkFn){nodeLinkFn(vm,node,host,scope,frag);}if(childrenLinkFn){childrenLinkFn(vm,childNodes,host,scope,frag);}}};} /**
   * Check for element directives (custom elements that should
   * be resovled as terminal directives).
   *
   * @param {Element} el
   * @param {Object} options
   */function checkElementDirectives(el,options){var tag=el.tagName.toLowerCase();if(commonTagRE.test(tag)){return;}var def=resolveAsset(options,'elementDirectives',tag);if(def){return makeTerminalNodeLinkFn(el,tag,'',options,def);}} /**
   * Check if an element is a component. If yes, return
   * a component link function.
   *
   * @param {Element} el
   * @param {Object} options
   * @return {Function|undefined}
   */function checkComponent(el,options){var component=checkComponentAttr(el,options);if(component){var ref=findRef(el);var descriptor={name:'component',ref:ref,expression:component.id,def:internalDirectives.component,modifiers:{literal:!component.dynamic}};var componentLinkFn=function componentLinkFn(vm,el,host,scope,frag){if(ref){defineReactive((scope||vm).$refs,ref,null);}vm._bindDir(descriptor,el,host,scope,frag);};componentLinkFn.terminal=true;return componentLinkFn;}} /**
   * Check an element for terminal directives in fixed order.
   * If it finds one, return a terminal link function.
   *
   * @param {Element} el
   * @param {Object} options
   * @return {Function} terminalLinkFn
   */function checkTerminalDirectives(el,options){ // skip v-pre
if(getAttr(el,'v-pre')!==null){return skip;} // skip v-else block, but only if following v-if
if(el.hasAttribute('v-else')){var prev=el.previousElementSibling;if(prev&&prev.hasAttribute('v-if')){return skip;}}var value,dirName;for(var i=0,l=terminalDirectives.length;i<l;i++){dirName=terminalDirectives[i];value=el.getAttribute('v-'+dirName);if(value!=null){return makeTerminalNodeLinkFn(el,dirName,value,options);}}}function skip(){}skip.terminal=true; /**
   * Build a node link function for a terminal directive.
   * A terminal link function terminates the current
   * compilation recursion and handles compilation of the
   * subtree in the directive.
   *
   * @param {Element} el
   * @param {String} dirName
   * @param {String} value
   * @param {Object} options
   * @param {Object} [def]
   * @return {Function} terminalLinkFn
   */function makeTerminalNodeLinkFn(el,dirName,value,options,def){var parsed=parseDirective(value);var descriptor={name:dirName,expression:parsed.expression,filters:parsed.filters,raw:value, // either an element directive, or if/for
// #2366 or custom terminal directive
def:def||resolveAsset(options,'directives',dirName)}; // check ref for v-for and router-view
if(dirName==='for'||dirName==='router-view'){descriptor.ref=findRef(el);}var fn=function terminalNodeLinkFn(vm,el,host,scope,frag){if(descriptor.ref){defineReactive((scope||vm).$refs,descriptor.ref,null);}vm._bindDir(descriptor,el,host,scope,frag);};fn.terminal=true;return fn;} /**
   * Compile the directives on an element and return a linker.
   *
   * @param {Array|NamedNodeMap} attrs
   * @param {Object} options
   * @return {Function}
   */function compileDirectives(attrs,options){var i=attrs.length;var dirs=[];var attr,name,value,rawName,rawValue,dirName,arg,modifiers,dirDef,tokens,matched;while(i--){attr=attrs[i];name=rawName=attr.name;value=rawValue=attr.value;tokens=parseText(value); // reset arg
arg=null; // check modifiers
modifiers=parseModifiers(name);name=name.replace(modifierRE,''); // attribute interpolations
if(tokens){value=tokensToExp(tokens);arg=name;pushDir('bind',directives.bind,tokens); // warn against mixing mustaches with v-bind
if('development'!=='production'){if(name==='class'&&Array.prototype.some.call(attrs,function(attr){return attr.name===':class'||attr.name==='v-bind:class';})){warn('class="'+rawValue+'": Do not mix mustache interpolation '+'and v-bind for "class" on the same element. Use one or the other.');}}}else  // special attribute: transition
if(transitionRE.test(name)){modifiers.literal=!bindRE.test(name);pushDir('transition',internalDirectives.transition);}else  // event handlers
if(onRE.test(name)){arg=name.replace(onRE,'');pushDir('on',directives.on);}else  // attribute bindings
if(bindRE.test(name)){dirName=name.replace(bindRE,'');if(dirName==='style'||dirName==='class'){pushDir(dirName,internalDirectives[dirName]);}else {arg=dirName;pushDir('bind',directives.bind);}}else  // normal directives
if(matched=name.match(dirAttrRE)){dirName=matched[1];arg=matched[2]; // skip v-else (when used with v-show)
if(dirName==='else'){continue;}dirDef=resolveAsset(options,'directives',dirName);if('development'!=='production'){assertAsset(dirDef,'directive',dirName);}if(dirDef){pushDir(dirName,dirDef);}}} /**
     * Push a directive.
     *
     * @param {String} dirName
     * @param {Object|Function} def
     * @param {Array} [interpTokens]
     */function pushDir(dirName,def,interpTokens){var hasOneTimeToken=interpTokens&&hasOneTime(interpTokens);var parsed=!hasOneTimeToken&&parseDirective(value);dirs.push({name:dirName,attr:rawName,raw:rawValue,def:def,arg:arg,modifiers:modifiers, // conversion from interpolation strings with one-time token
// to expression is differed until directive bind time so that we
// have access to the actual vm context for one-time bindings.
expression:parsed&&parsed.expression,filters:parsed&&parsed.filters,interp:interpTokens,hasOneTime:hasOneTimeToken});}if(dirs.length){return makeNodeLinkFn(dirs);}} /**
   * Parse modifiers from directive attribute name.
   *
   * @param {String} name
   * @return {Object}
   */function parseModifiers(name){var res=Object.create(null);var match=name.match(modifierRE);if(match){var i=match.length;while(i--){res[match[i].slice(1)]=true;}}return res;} /**
   * Build a link function for all directives on a single node.
   *
   * @param {Array} directives
   * @return {Function} directivesLinkFn
   */function makeNodeLinkFn(directives){return function nodeLinkFn(vm,el,host,scope,frag){ // reverse apply because it's sorted low to high
var i=directives.length;while(i--){vm._bindDir(directives[i],el,host,scope,frag);}};} /**
   * Check if an interpolation string contains one-time tokens.
   *
   * @param {Array} tokens
   * @return {Boolean}
   */function hasOneTime(tokens){var i=tokens.length;while(i--){if(tokens[i].oneTime)return true;}}var specialCharRE=/[^\w\-:\.]/; /**
   * Process an element or a DocumentFragment based on a
   * instance option object. This allows us to transclude
   * a template node/fragment before the instance is created,
   * so the processed fragment can then be cloned and reused
   * in v-for.
   *
   * @param {Element} el
   * @param {Object} options
   * @return {Element|DocumentFragment}
   */function transclude(el,options){ // extract container attributes to pass them down
// to compiler, because they need to be compiled in
// parent scope. we are mutating the options object here
// assuming the same object will be used for compile
// right after this.
if(options){options._containerAttrs=extractAttrs(el);} // for template tags, what we want is its content as
// a documentFragment (for fragment instances)
if(isTemplate(el)){el=parseTemplate(el);}if(options){if(options._asComponent&&!options.template){options.template='<slot></slot>';}if(options.template){options._content=extractContent(el);el=transcludeTemplate(el,options);}}if(isFragment(el)){ // anchors for fragment instance
// passing in `persist: true` to avoid them being
// discarded by IE during template cloning
prepend(createAnchor('v-start',true),el);el.appendChild(createAnchor('v-end',true));}return el;} /**
   * Process the template option.
   * If the replace option is true this will swap the $el.
   *
   * @param {Element} el
   * @param {Object} options
   * @return {Element|DocumentFragment}
   */function transcludeTemplate(el,options){var template=options.template;var frag=parseTemplate(template,true);if(frag){var replacer=frag.firstChild;var tag=replacer.tagName&&replacer.tagName.toLowerCase();if(options.replace){ /* istanbul ignore if */if(el===document.body){'development'!=='production'&&warn('You are mounting an instance with a template to '+'<body>. This will replace <body> entirely. You '+'should probably use `replace: false` here.');} // there are many cases where the instance must
// become a fragment instance: basically anything that
// can create more than 1 root nodes.
if( // multi-children template
frag.childNodes.length>1|| // non-element template
replacer.nodeType!==1|| // single nested component
tag==='component'||resolveAsset(options,'components',tag)||hasBindAttr(replacer,'is')|| // element directive
resolveAsset(options,'elementDirectives',tag)|| // for block
replacer.hasAttribute('v-for')|| // if block
replacer.hasAttribute('v-if')){return frag;}else {options._replacerAttrs=extractAttrs(replacer);mergeAttrs(el,replacer);return replacer;}}else {el.appendChild(frag);return el;}}else {'development'!=='production'&&warn('Invalid template option: '+template);}} /**
   * Helper to extract a component container's attributes
   * into a plain object array.
   *
   * @param {Element} el
   * @return {Array}
   */function extractAttrs(el){if(el.nodeType===1&&el.hasAttributes()){return toArray(el.attributes);}} /**
   * Merge the attributes of two elements, and make sure
   * the class names are merged properly.
   *
   * @param {Element} from
   * @param {Element} to
   */function mergeAttrs(from,to){var attrs=from.attributes;var i=attrs.length;var name,value;while(i--){name=attrs[i].name;value=attrs[i].value;if(!to.hasAttribute(name)&&!specialCharRE.test(name)){to.setAttribute(name,value);}else if(name==='class'&&!parseText(value)){value.trim().split(/\s+/).forEach(function(cls){addClass(to,cls);});}}} /**
   * Scan and determine slot content distribution.
   * We do this during transclusion instead at compile time so that
   * the distribution is decoupled from the compilation order of
   * the slots.
   *
   * @param {Element|DocumentFragment} template
   * @param {Element} content
   * @param {Vue} vm
   */function resolveSlots(vm,content){if(!content){return;}var contents=vm._slotContents=Object.create(null);var el,name;for(var i=0,l=content.children.length;i<l;i++){el=content.children[i]; /* eslint-disable no-cond-assign */if(name=el.getAttribute('slot')){(contents[name]||(contents[name]=[])).push(el);} /* eslint-enable no-cond-assign */}for(name in contents){contents[name]=extractFragment(contents[name],content);}if(content.hasChildNodes()){contents['default']=extractFragment(content.childNodes,content);}} /**
   * Extract qualified content nodes from a node list.
   *
   * @param {NodeList} nodes
   * @return {DocumentFragment}
   */function extractFragment(nodes,parent){var frag=document.createDocumentFragment();nodes=toArray(nodes);for(var i=0,l=nodes.length;i<l;i++){var node=nodes[i];if(isTemplate(node)&&!node.hasAttribute('v-if')&&!node.hasAttribute('v-for')){parent.removeChild(node);node=parseTemplate(node);}frag.appendChild(node);}return frag;}var compiler=Object.freeze({compile:compile,compileAndLinkProps:compileAndLinkProps,compileRoot:compileRoot,terminalDirectives:terminalDirectives,transclude:transclude,resolveSlots:resolveSlots});function stateMixin(Vue){ /**
     * Accessor for `$data` property, since setting $data
     * requires observing the new object and updating
     * proxied properties.
     */Object.defineProperty(Vue.prototype,'$data',{get:function get(){return this._data;},set:function set(newData){if(newData!==this._data){this._setData(newData);}}}); /**
     * Setup the scope of an instance, which contains:
     * - observed data
     * - computed properties
     * - user methods
     * - meta properties
     */Vue.prototype._initState=function(){this._initProps();this._initMeta();this._initMethods();this._initData();this._initComputed();}; /**
     * Initialize props.
     */Vue.prototype._initProps=function(){var options=this.$options;var el=options.el;var props=options.props;if(props&&!el){'development'!=='production'&&warn('Props will not be compiled if no `el` option is '+'provided at instantiation.');} // make sure to convert string selectors into element now
el=options.el=query(el);this._propsUnlinkFn=el&&el.nodeType===1&&props // props must be linked in proper scope if inside v-for
?compileAndLinkProps(this,el,props,this._scope):null;}; /**
     * Initialize the data.
     */Vue.prototype._initData=function(){var dataFn=this.$options.data;var data=this._data=dataFn?dataFn():{};var props=this._props;var runtimeData=this._runtimeData?typeof this._runtimeData==='function'?this._runtimeData():this._runtimeData:null; // proxy data on instance
var keys=Object.keys(data);var i,key;i=keys.length;while(i--){key=keys[i]; // there are two scenarios where we can proxy a data key:
// 1. it's not already defined as a prop
// 2. it's provided via a instantiation option AND there are no
//    template prop present
if(!props||!hasOwn(props,key)||runtimeData&&hasOwn(runtimeData,key)&&props[key].raw===null){this._proxy(key);}else if('development'!=='production'){warn('Data field "'+key+'" is already defined '+'as a prop. Use prop default value instead.');}} // observe data
observe(data,this);}; /**
     * Swap the instance's $data. Called in $data's setter.
     *
     * @param {Object} newData
     */Vue.prototype._setData=function(newData){newData=newData||{};var oldData=this._data;this._data=newData;var keys,key,i; // unproxy keys not present in new data
keys=Object.keys(oldData);i=keys.length;while(i--){key=keys[i];if(!(key in newData)){this._unproxy(key);}} // proxy keys not already proxied,
// and trigger change for changed values
keys=Object.keys(newData);i=keys.length;while(i--){key=keys[i];if(!hasOwn(this,key)){ // new property
this._proxy(key);}}oldData.__ob__.removeVm(this);observe(newData,this);this._digest();}; /**
     * Proxy a property, so that
     * vm.prop === vm._data.prop
     *
     * @param {String} key
     */Vue.prototype._proxy=function(key){if(!isReserved(key)){ // need to store ref to self here
// because these getter/setters might
// be called by child scopes via
// prototype inheritance.
var self=this;Object.defineProperty(self,key,{configurable:true,enumerable:true,get:function proxyGetter(){return self._data[key];},set:function proxySetter(val){self._data[key]=val;}});}}; /**
     * Unproxy a property.
     *
     * @param {String} key
     */Vue.prototype._unproxy=function(key){if(!isReserved(key)){delete this[key];}}; /**
     * Force update on every watcher in scope.
     */Vue.prototype._digest=function(){for(var i=0,l=this._watchers.length;i<l;i++){this._watchers[i].update(true); // shallow updates
}}; /**
     * Setup computed properties. They are essentially
     * special getter/setters
     */function noop(){}Vue.prototype._initComputed=function(){var computed=this.$options.computed;if(computed){for(var key in computed){var userDef=computed[key];var def={enumerable:true,configurable:true};if(typeof userDef==='function'){def.get=makeComputedGetter(userDef,this);def.set=noop;}else {def.get=userDef.get?userDef.cache!==false?makeComputedGetter(userDef.get,this):bind(userDef.get,this):noop;def.set=userDef.set?bind(userDef.set,this):noop;}Object.defineProperty(this,key,def);}}};function makeComputedGetter(getter,owner){var watcher=new Watcher(owner,getter,null,{lazy:true});return function computedGetter(){if(watcher.dirty){watcher.evaluate();}if(Dep.target){watcher.depend();}return watcher.value;};} /**
     * Setup instance methods. Methods must be bound to the
     * instance since they might be passed down as a prop to
     * child components.
     */Vue.prototype._initMethods=function(){var methods=this.$options.methods;if(methods){for(var key in methods){this[key]=bind(methods[key],this);}}}; /**
     * Initialize meta information like $index, $key & $value.
     */Vue.prototype._initMeta=function(){var metas=this.$options._meta;if(metas){for(var key in metas){defineReactive(this,key,metas[key]);}}};}var eventRE=/^v-on:|^@/;function eventsMixin(Vue){ /**
     * Setup the instance's option events & watchers.
     * If the value is a string, we pull it from the
     * instance's methods by name.
     */Vue.prototype._initEvents=function(){var options=this.$options;if(options._asComponent){registerComponentEvents(this,options.el);}registerCallbacks(this,'$on',options.events);registerCallbacks(this,'$watch',options.watch);}; /**
     * Register v-on events on a child component
     *
     * @param {Vue} vm
     * @param {Element} el
     */function registerComponentEvents(vm,el){var attrs=el.attributes;var name,handler;for(var i=0,l=attrs.length;i<l;i++){name=attrs[i].name;if(eventRE.test(name)){name=name.replace(eventRE,'');handler=(vm._scope||vm._context).$eval(attrs[i].value,true);if(typeof handler==='function'){handler._fromParent=true;vm.$on(name.replace(eventRE),handler);}else if('development'!=='production'){warn('v-on:'+name+'="'+attrs[i].value+'"'+(vm.$options.name?' on component <'+vm.$options.name+'>':'')+' expects a function value, got '+handler);}}}} /**
     * Register callbacks for option events and watchers.
     *
     * @param {Vue} vm
     * @param {String} action
     * @param {Object} hash
     */function registerCallbacks(vm,action,hash){if(!hash)return;var handlers,key,i,j;for(key in hash){handlers=hash[key];if(isArray(handlers)){for(i=0,j=handlers.length;i<j;i++){register(vm,action,key,handlers[i]);}}else {register(vm,action,key,handlers);}}} /**
     * Helper to register an event/watch callback.
     *
     * @param {Vue} vm
     * @param {String} action
     * @param {String} key
     * @param {Function|String|Object} handler
     * @param {Object} [options]
     */function register(vm,action,key,handler,options){var type=typeof handler==='undefined'?'undefined':_typeof(handler);if(type==='function'){vm[action](key,handler,options);}else if(type==='string'){var methods=vm.$options.methods;var method=methods&&methods[handler];if(method){vm[action](key,method,options);}else {'development'!=='production'&&warn('Unknown method: "'+handler+'" when '+'registering callback for '+action+': "'+key+'".');}}else if(handler&&type==='object'){register(vm,action,key,handler.handler,handler);}} /**
     * Setup recursive attached/detached calls
     */Vue.prototype._initDOMHooks=function(){this.$on('hook:attached',onAttached);this.$on('hook:detached',onDetached);}; /**
     * Callback to recursively call attached hook on children
     */function onAttached(){if(!this._isAttached){this._isAttached=true;this.$children.forEach(callAttach);}} /**
     * Iterator to call attached hook
     *
     * @param {Vue} child
     */function callAttach(child){if(!child._isAttached&&inDoc(child.$el)){child._callHook('attached');}} /**
     * Callback to recursively call detached hook on children
     */function onDetached(){if(this._isAttached){this._isAttached=false;this.$children.forEach(callDetach);}} /**
     * Iterator to call detached hook
     *
     * @param {Vue} child
     */function callDetach(child){if(child._isAttached&&!inDoc(child.$el)){child._callHook('detached');}} /**
     * Trigger all handlers for a hook
     *
     * @param {String} hook
     */Vue.prototype._callHook=function(hook){this.$emit('pre-hook:'+hook);var handlers=this.$options[hook];if(handlers){for(var i=0,j=handlers.length;i<j;i++){handlers[i].call(this);}}this.$emit('hook:'+hook);};}function noop(){} /**
   * A directive links a DOM element with a piece of data,
   * which is the result of evaluating an expression.
   * It registers a watcher with the expression and calls
   * the DOM update function when a change is triggered.
   *
   * @param {String} name
   * @param {Node} el
   * @param {Vue} vm
   * @param {Object} descriptor
   *                 - {String} name
   *                 - {Object} def
   *                 - {String} expression
   *                 - {Array<Object>} [filters]
   *                 - {Boolean} literal
   *                 - {String} attr
   *                 - {String} raw
   * @param {Object} def - directive definition object
   * @param {Vue} [host] - transclusion host component
   * @param {Object} [scope] - v-for scope
   * @param {Fragment} [frag] - owner fragment
   * @constructor
   */function Directive(descriptor,vm,el,host,scope,frag){this.vm=vm;this.el=el; // copy descriptor properties
this.descriptor=descriptor;this.name=descriptor.name;this.expression=descriptor.expression;this.arg=descriptor.arg;this.modifiers=descriptor.modifiers;this.filters=descriptor.filters;this.literal=this.modifiers&&this.modifiers.literal; // private
this._locked=false;this._bound=false;this._listeners=null; // link context
this._host=host;this._scope=scope;this._frag=frag; // store directives on node in dev mode
if('development'!=='production'&&this.el){this.el._vue_directives=this.el._vue_directives||[];this.el._vue_directives.push(this);}} /**
   * Initialize the directive, mixin definition properties,
   * setup the watcher, call definition bind() and update()
   * if present.
   *
   * @param {Object} def
   */Directive.prototype._bind=function(){var name=this.name;var descriptor=this.descriptor; // remove attribute
if((name!=='cloak'||this.vm._isCompiled)&&this.el&&this.el.removeAttribute){var attr=descriptor.attr||'v-'+name;this.el.removeAttribute(attr);} // copy def properties
var def=descriptor.def;if(typeof def==='function'){this.update=def;}else {extend(this,def);} // setup directive params
this._setupParams(); // initial bind
if(this.bind){this.bind();}this._bound=true;if(this.literal){this.update&&this.update(descriptor.raw);}else if((this.expression||this.modifiers)&&(this.update||this.twoWay)&&!this._checkStatement()){ // wrapped updater for context
var dir=this;if(this.update){this._update=function(val,oldVal){if(!dir._locked){dir.update(val,oldVal);}};}else {this._update=noop;}var preProcess=this._preProcess?bind(this._preProcess,this):null;var postProcess=this._postProcess?bind(this._postProcess,this):null;var watcher=this._watcher=new Watcher(this.vm,this.expression,this._update, // callback
{filters:this.filters,twoWay:this.twoWay,deep:this.deep,preProcess:preProcess,postProcess:postProcess,scope:this._scope}); // v-model with inital inline value need to sync back to
// model instead of update to DOM on init. They would
// set the afterBind hook to indicate that.
if(this.afterBind){this.afterBind();}else if(this.update){this.update(watcher.value);}}}; /**
   * Setup all param attributes, e.g. track-by,
   * transition-mode, etc...
   */Directive.prototype._setupParams=function(){if(!this.params){return;}var params=this.params; // swap the params array with a fresh object.
this.params=Object.create(null);var i=params.length;var key,val,mappedKey;while(i--){key=params[i];mappedKey=camelize(key);val=getBindAttr(this.el,key);if(val!=null){ // dynamic
this._setupParamWatcher(mappedKey,val);}else { // static
val=getAttr(this.el,key);if(val!=null){this.params[mappedKey]=val===''?true:val;}}}}; /**
   * Setup a watcher for a dynamic param.
   *
   * @param {String} key
   * @param {String} expression
   */Directive.prototype._setupParamWatcher=function(key,expression){var self=this;var called=false;var unwatch=(this._scope||this.vm).$watch(expression,function(val,oldVal){self.params[key]=val; // since we are in immediate mode,
// only call the param change callbacks if this is not the first update.
if(called){var cb=self.paramWatchers&&self.paramWatchers[key];if(cb){cb.call(self,val,oldVal);}}else {called=true;}},{immediate:true,user:false});(this._paramUnwatchFns||(this._paramUnwatchFns=[])).push(unwatch);}; /**
   * Check if the directive is a function caller
   * and if the expression is a callable one. If both true,
   * we wrap up the expression and use it as the event
   * handler.
   *
   * e.g. on-click="a++"
   *
   * @return {Boolean}
   */Directive.prototype._checkStatement=function(){var expression=this.expression;if(expression&&this.acceptStatement&&!isSimplePath(expression)){var fn=parseExpression(expression).get;var scope=this._scope||this.vm;var handler=function handler(e){scope.$event=e;fn.call(scope,scope);scope.$event=null;};if(this.filters){handler=scope._applyFilters(handler,null,this.filters);}this.update(handler);return true;}}; /**
   * Set the corresponding value with the setter.
   * This should only be used in two-way directives
   * e.g. v-model.
   *
   * @param {*} value
   * @public
   */Directive.prototype.set=function(value){ /* istanbul ignore else */if(this.twoWay){this._withLock(function(){this._watcher.set(value);});}else if('development'!=='production'){warn('Directive.set() can only be used inside twoWay'+'directives.');}}; /**
   * Execute a function while preventing that function from
   * triggering updates on this directive instance.
   *
   * @param {Function} fn
   */Directive.prototype._withLock=function(fn){var self=this;self._locked=true;fn.call(self);nextTick(function(){self._locked=false;});}; /**
   * Convenience method that attaches a DOM event listener
   * to the directive element and autometically tears it down
   * during unbind.
   *
   * @param {String} event
   * @param {Function} handler
   * @param {Boolean} [useCapture]
   */Directive.prototype.on=function(event,handler,useCapture){on(this.el,event,handler,useCapture);(this._listeners||(this._listeners=[])).push([event,handler]);}; /**
   * Teardown the watcher and call unbind.
   */Directive.prototype._teardown=function(){if(this._bound){this._bound=false;if(this.unbind){this.unbind();}if(this._watcher){this._watcher.teardown();}var listeners=this._listeners;var i;if(listeners){i=listeners.length;while(i--){off(this.el,listeners[i][0],listeners[i][1]);}}var unwatchFns=this._paramUnwatchFns;if(unwatchFns){i=unwatchFns.length;while(i--){unwatchFns[i]();}}if('development'!=='production'&&this.el){this.el._vue_directives.$remove(this);}this.vm=this.el=this._watcher=this._listeners=null;}};function lifecycleMixin(Vue){ /**
     * Update v-ref for component.
     *
     * @param {Boolean} remove
     */Vue.prototype._updateRef=function(remove){var ref=this.$options._ref;if(ref){var refs=(this._scope||this._context).$refs;if(remove){if(refs[ref]===this){refs[ref]=null;}}else {refs[ref]=this;}}}; /**
     * Transclude, compile and link element.
     *
     * If a pre-compiled linker is available, that means the
     * passed in element will be pre-transcluded and compiled
     * as well - all we need to do is to call the linker.
     *
     * Otherwise we need to call transclude/compile/link here.
     *
     * @param {Element} el
     */Vue.prototype._compile=function(el){var options=this.$options; // transclude and init element
// transclude can potentially replace original
// so we need to keep reference; this step also injects
// the template and caches the original attributes
// on the container node and replacer node.
var original=el;el=transclude(el,options);this._initElement(el); // handle v-pre on root node (#2026)
if(el.nodeType===1&&getAttr(el,'v-pre')!==null){return;} // root is always compiled per-instance, because
// container attrs and props can be different every time.
var contextOptions=this._context&&this._context.$options;var rootLinker=compileRoot(el,options,contextOptions); // resolve slot distribution
resolveSlots(this,options._content); // compile and link the rest
var contentLinkFn;var ctor=this.constructor; // component compilation can be cached
// as long as it's not using inline-template
if(options._linkerCachable){contentLinkFn=ctor.linker;if(!contentLinkFn){contentLinkFn=ctor.linker=compile(el,options);}} // link phase
// make sure to link root with prop scope!
var rootUnlinkFn=rootLinker(this,el,this._scope);var contentUnlinkFn=contentLinkFn?contentLinkFn(this,el):compile(el,options)(this,el); // register composite unlink function
// to be called during instance destruction
this._unlinkFn=function(){rootUnlinkFn(); // passing destroying: true to avoid searching and
// splicing the directives
contentUnlinkFn(true);}; // finally replace original
if(options.replace){replace(original,el);}this._isCompiled=true;this._callHook('compiled');}; /**
     * Initialize instance element. Called in the public
     * $mount() method.
     *
     * @param {Element} el
     */Vue.prototype._initElement=function(el){if(isFragment(el)){this._isFragment=true;this.$el=this._fragmentStart=el.firstChild;this._fragmentEnd=el.lastChild; // set persisted text anchors to empty
if(this._fragmentStart.nodeType===3){this._fragmentStart.data=this._fragmentEnd.data='';}this._fragment=el;}else {this.$el=el;}this.$el.__vue__=this;this._callHook('beforeCompile');}; /**
     * Create and bind a directive to an element.
     *
     * @param {String} name - directive name
     * @param {Node} node   - target node
     * @param {Object} desc - parsed directive descriptor
     * @param {Object} def  - directive definition object
     * @param {Vue} [host] - transclusion host component
     * @param {Object} [scope] - v-for scope
     * @param {Fragment} [frag] - owner fragment
     */Vue.prototype._bindDir=function(descriptor,node,host,scope,frag){this._directives.push(new Directive(descriptor,this,node,host,scope,frag));}; /**
     * Teardown an instance, unobserves the data, unbind all the
     * directives, turn off all the event listeners, etc.
     *
     * @param {Boolean} remove - whether to remove the DOM node.
     * @param {Boolean} deferCleanup - if true, defer cleanup to
     *                                 be called later
     */Vue.prototype._destroy=function(remove,deferCleanup){if(this._isBeingDestroyed){if(!deferCleanup){this._cleanup();}return;}var destroyReady;var pendingRemoval;var self=this; // Cleanup should be called either synchronously or asynchronoysly as
// callback of this.$remove(), or if remove and deferCleanup are false.
// In any case it should be called after all other removing, unbinding and
// turning of is done
var cleanupIfPossible=function cleanupIfPossible(){if(destroyReady&&!pendingRemoval&&!deferCleanup){self._cleanup();}}; // remove DOM element
if(remove&&this.$el){pendingRemoval=true;this.$remove(function(){pendingRemoval=false;cleanupIfPossible();});}this._callHook('beforeDestroy');this._isBeingDestroyed=true;var i; // remove self from parent. only necessary
// if parent is not being destroyed as well.
var parent=this.$parent;if(parent&&!parent._isBeingDestroyed){parent.$children.$remove(this); // unregister ref (remove: true)
this._updateRef(true);} // destroy all children.
i=this.$children.length;while(i--){this.$children[i].$destroy();} // teardown props
if(this._propsUnlinkFn){this._propsUnlinkFn();} // teardown all directives. this also tearsdown all
// directive-owned watchers.
if(this._unlinkFn){this._unlinkFn();}i=this._watchers.length;while(i--){this._watchers[i].teardown();} // remove reference to self on $el
if(this.$el){this.$el.__vue__=null;}destroyReady=true;cleanupIfPossible();}; /**
     * Clean up to ensure garbage collection.
     * This is called after the leave transition if there
     * is any.
     */Vue.prototype._cleanup=function(){if(this._isDestroyed){return;} // remove self from owner fragment
// do it in cleanup so that we can call $destroy with
// defer right when a fragment is about to be removed.
if(this._frag){this._frag.children.$remove(this);} // remove reference from data ob
// frozen object may not have observer.
if(this._data.__ob__){this._data.__ob__.removeVm(this);} // Clean up references to private properties and other
// instances. preserve reference to _data so that proxy
// accessors still work. The only potential side effect
// here is that mutating the instance after it's destroyed
// may affect the state of other components that are still
// observing the same object, but that seems to be a
// reasonable responsibility for the user rather than
// always throwing an error on them.
this.$el=this.$parent=this.$root=this.$children=this._watchers=this._context=this._scope=this._directives=null; // call the last hook...
this._isDestroyed=true;this._callHook('destroyed'); // turn off all instance listeners.
this.$off();};}function miscMixin(Vue){ /**
     * Apply a list of filter (descriptors) to a value.
     * Using plain for loops here because this will be called in
     * the getter of any watcher with filters so it is very
     * performance sensitive.
     *
     * @param {*} value
     * @param {*} [oldValue]
     * @param {Array} filters
     * @param {Boolean} write
     * @return {*}
     */Vue.prototype._applyFilters=function(value,oldValue,filters,write){var filter,fn,args,arg,offset,i,l,j,k;for(i=0,l=filters.length;i<l;i++){filter=filters[i];fn=resolveAsset(this.$options,'filters',filter.name);if('development'!=='production'){assertAsset(fn,'filter',filter.name);}if(!fn)continue;fn=write?fn.write:fn.read||fn;if(typeof fn!=='function')continue;args=write?[value,oldValue]:[value];offset=write?2:1;if(filter.args){for(j=0,k=filter.args.length;j<k;j++){arg=filter.args[j];args[j+offset]=arg.dynamic?this.$get(arg.value):arg.value;}}value=fn.apply(this,args);}return value;}; /**
     * Resolve a component, depending on whether the component
     * is defined normally or using an async factory function.
     * Resolves synchronously if already resolved, otherwise
     * resolves asynchronously and caches the resolved
     * constructor on the factory.
     *
     * @param {String} id
     * @param {Function} cb
     */Vue.prototype._resolveComponent=function(id,cb){var factory=resolveAsset(this.$options,'components',id);if('development'!=='production'){assertAsset(factory,'component',id);}if(!factory){return;} // async component factory
if(!factory.options){if(factory.resolved){ // cached
cb(factory.resolved);}else if(factory.requested){ // pool callbacks
factory.pendingCallbacks.push(cb);}else {factory.requested=true;var cbs=factory.pendingCallbacks=[cb];factory.call(this,function resolve(res){if(isPlainObject(res)){res=Vue.extend(res);} // cache resolved
factory.resolved=res; // invoke callbacks
for(var i=0,l=cbs.length;i<l;i++){cbs[i](res);}},function reject(reason){'development'!=='production'&&warn('Failed to resolve async component: '+id+'. '+(reason?'\nReason: '+reason:''));});}}else { // normal component
cb(factory);}};}var filterRE$1=/[^|]\|[^|]/;function dataAPI(Vue){ /**
     * Get the value from an expression on this vm.
     *
     * @param {String} exp
     * @param {Boolean} [asStatement]
     * @return {*}
     */Vue.prototype.$get=function(exp,asStatement){var res=parseExpression(exp);if(res){if(asStatement&&!isSimplePath(exp)){var self=this;return function statementHandler(){self.$arguments=toArray(arguments);var result=res.get.call(self,self);self.$arguments=null;return result;};}else {try{return res.get.call(this,this);}catch(e){}}}}; /**
     * Set the value from an expression on this vm.
     * The expression must be a valid left-hand
     * expression in an assignment.
     *
     * @param {String} exp
     * @param {*} val
     */Vue.prototype.$set=function(exp,val){var res=parseExpression(exp,true);if(res&&res.set){res.set.call(this,this,val);}}; /**
     * Delete a property on the VM
     *
     * @param {String} key
     */Vue.prototype.$delete=function(key){del(this._data,key);}; /**
     * Watch an expression, trigger callback when its
     * value changes.
     *
     * @param {String|Function} expOrFn
     * @param {Function} cb
     * @param {Object} [options]
     *                 - {Boolean} deep
     *                 - {Boolean} immediate
     * @return {Function} - unwatchFn
     */Vue.prototype.$watch=function(expOrFn,cb,options){var vm=this;var parsed;if(typeof expOrFn==='string'){parsed=parseDirective(expOrFn);expOrFn=parsed.expression;}var watcher=new Watcher(vm,expOrFn,cb,{deep:options&&options.deep,sync:options&&options.sync,filters:parsed&&parsed.filters,user:!options||options.user!==false});if(options&&options.immediate){cb.call(vm,watcher.value);}return function unwatchFn(){watcher.teardown();};}; /**
     * Evaluate a text directive, including filters.
     *
     * @param {String} text
     * @param {Boolean} [asStatement]
     * @return {String}
     */Vue.prototype.$eval=function(text,asStatement){ // check for filters.
if(filterRE$1.test(text)){var dir=parseDirective(text); // the filter regex check might give false positive
// for pipes inside strings, so it's possible that
// we don't get any filters here
var val=this.$get(dir.expression,asStatement);return dir.filters?this._applyFilters(val,null,dir.filters):val;}else { // no filter
return this.$get(text,asStatement);}}; /**
     * Interpolate a piece of template text.
     *
     * @param {String} text
     * @return {String}
     */Vue.prototype.$interpolate=function(text){var tokens=parseText(text);var vm=this;if(tokens){if(tokens.length===1){return vm.$eval(tokens[0].value)+'';}else {return tokens.map(function(token){return token.tag?vm.$eval(token.value):token.value;}).join('');}}else {return text;}}; /**
     * Log instance data as a plain JS object
     * so that it is easier to inspect in console.
     * This method assumes console is available.
     *
     * @param {String} [path]
     */Vue.prototype.$log=function(path){var data=path?getPath(this._data,path):this._data;if(data){data=clean(data);} // include computed fields
if(!path){var key;for(key in this.$options.computed){data[key]=clean(this[key]);}if(this._props){for(key in this._props){data[key]=clean(this[key]);}}}console.log(data);}; /**
     * "clean" a getter/setter converted object into a plain
     * object copy.
     *
     * @param {Object} - obj
     * @return {Object}
     */function clean(obj){return JSON.parse(JSON.stringify(obj));}}function domAPI(Vue){ /**
     * Convenience on-instance nextTick. The callback is
     * auto-bound to the instance, and this avoids component
     * modules having to rely on the global Vue.
     *
     * @param {Function} fn
     */Vue.prototype.$nextTick=function(fn){nextTick(fn,this);}; /**
     * Append instance to target
     *
     * @param {Node} target
     * @param {Function} [cb]
     * @param {Boolean} [withTransition] - defaults to true
     */Vue.prototype.$appendTo=function(target,cb,withTransition){return insert(this,target,cb,withTransition,append,appendWithTransition);}; /**
     * Prepend instance to target
     *
     * @param {Node} target
     * @param {Function} [cb]
     * @param {Boolean} [withTransition] - defaults to true
     */Vue.prototype.$prependTo=function(target,cb,withTransition){target=query(target);if(target.hasChildNodes()){this.$before(target.firstChild,cb,withTransition);}else {this.$appendTo(target,cb,withTransition);}return this;}; /**
     * Insert instance before target
     *
     * @param {Node} target
     * @param {Function} [cb]
     * @param {Boolean} [withTransition] - defaults to true
     */Vue.prototype.$before=function(target,cb,withTransition){return insert(this,target,cb,withTransition,beforeWithCb,beforeWithTransition);}; /**
     * Insert instance after target
     *
     * @param {Node} target
     * @param {Function} [cb]
     * @param {Boolean} [withTransition] - defaults to true
     */Vue.prototype.$after=function(target,cb,withTransition){target=query(target);if(target.nextSibling){this.$before(target.nextSibling,cb,withTransition);}else {this.$appendTo(target.parentNode,cb,withTransition);}return this;}; /**
     * Remove instance from DOM
     *
     * @param {Function} [cb]
     * @param {Boolean} [withTransition] - defaults to true
     */Vue.prototype.$remove=function(cb,withTransition){if(!this.$el.parentNode){return cb&&cb();}var inDocument=this._isAttached&&inDoc(this.$el); // if we are not in document, no need to check
// for transitions
if(!inDocument)withTransition=false;var self=this;var realCb=function realCb(){if(inDocument)self._callHook('detached');if(cb)cb();};if(this._isFragment){removeNodeRange(this._fragmentStart,this._fragmentEnd,this,this._fragment,realCb);}else {var op=withTransition===false?removeWithCb:removeWithTransition;op(this.$el,this,realCb);}return this;}; /**
     * Shared DOM insertion function.
     *
     * @param {Vue} vm
     * @param {Element} target
     * @param {Function} [cb]
     * @param {Boolean} [withTransition]
     * @param {Function} op1 - op for non-transition insert
     * @param {Function} op2 - op for transition insert
     * @return vm
     */function insert(vm,target,cb,withTransition,op1,op2){target=query(target);var targetIsDetached=!inDoc(target);var op=withTransition===false||targetIsDetached?op1:op2;var shouldCallHook=!targetIsDetached&&!vm._isAttached&&!inDoc(vm.$el);if(vm._isFragment){mapNodeRange(vm._fragmentStart,vm._fragmentEnd,function(node){op(node,target,vm);});cb&&cb();}else {op(vm.$el,target,vm,cb);}if(shouldCallHook){vm._callHook('attached');}return vm;} /**
     * Check for selectors
     *
     * @param {String|Element} el
     */function query(el){return typeof el==='string'?document.querySelector(el):el;} /**
     * Append operation that takes a callback.
     *
     * @param {Node} el
     * @param {Node} target
     * @param {Vue} vm - unused
     * @param {Function} [cb]
     */function append(el,target,vm,cb){target.appendChild(el);if(cb)cb();} /**
     * InsertBefore operation that takes a callback.
     *
     * @param {Node} el
     * @param {Node} target
     * @param {Vue} vm - unused
     * @param {Function} [cb]
     */function beforeWithCb(el,target,vm,cb){before(el,target);if(cb)cb();} /**
     * Remove operation that takes a callback.
     *
     * @param {Node} el
     * @param {Vue} vm - unused
     * @param {Function} [cb]
     */function removeWithCb(el,vm,cb){remove(el);if(cb)cb();}}function eventsAPI(Vue){ /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     */Vue.prototype.$on=function(event,fn){(this._events[event]||(this._events[event]=[])).push(fn);modifyListenerCount(this,event,1);return this;}; /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     */Vue.prototype.$once=function(event,fn){var self=this;function on(){self.$off(event,on);fn.apply(this,arguments);}on.fn=fn;this.$on(event,on);return this;}; /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     */Vue.prototype.$off=function(event,fn){var cbs; // all
if(!arguments.length){if(this.$parent){for(event in this._events){cbs=this._events[event];if(cbs){modifyListenerCount(this,event,-cbs.length);}}}this._events={};return this;} // specific event
cbs=this._events[event];if(!cbs){return this;}if(arguments.length===1){modifyListenerCount(this,event,-cbs.length);this._events[event]=null;return this;} // specific handler
var cb;var i=cbs.length;while(i--){cb=cbs[i];if(cb===fn||cb.fn===fn){modifyListenerCount(this,event,-1);cbs.splice(i,1);break;}}return this;}; /**
     * Trigger an event on self.
     *
     * @param {String|Object} event
     * @return {Boolean} shouldPropagate
     */Vue.prototype.$emit=function(event){var isSource=typeof event==='string';event=isSource?event:event.name;var cbs=this._events[event];var shouldPropagate=isSource||!cbs;if(cbs){cbs=cbs.length>1?toArray(cbs):cbs; // this is a somewhat hacky solution to the question raised
// in #2102: for an inline component listener like <comp @test="doThis">,
// the propagation handling is somewhat broken. Therefore we
// need to treat these inline callbacks differently.
var hasParentCbs=isSource&&cbs.some(function(cb){return cb._fromParent;});if(hasParentCbs){shouldPropagate=false;}var args=toArray(arguments,1);for(var i=0,l=cbs.length;i<l;i++){var cb=cbs[i];var res=cb.apply(this,args);if(res===true&&(!hasParentCbs||cb._fromParent)){shouldPropagate=true;}}}return shouldPropagate;}; /**
     * Recursively broadcast an event to all children instances.
     *
     * @param {String|Object} event
     * @param {...*} additional arguments
     */Vue.prototype.$broadcast=function(event){var isSource=typeof event==='string';event=isSource?event:event.name; // if no child has registered for this event,
// then there's no need to broadcast.
if(!this._eventsCount[event])return;var children=this.$children;var args=toArray(arguments);if(isSource){ // use object event to indicate non-source emit
// on children
args[0]={name:event,source:this};}for(var i=0,l=children.length;i<l;i++){var child=children[i];var shouldPropagate=child.$emit.apply(child,args);if(shouldPropagate){child.$broadcast.apply(child,args);}}return this;}; /**
     * Recursively propagate an event up the parent chain.
     *
     * @param {String} event
     * @param {...*} additional arguments
     */Vue.prototype.$dispatch=function(event){var shouldPropagate=this.$emit.apply(this,arguments);if(!shouldPropagate)return;var parent=this.$parent;var args=toArray(arguments); // use object event to indicate non-source emit
// on parents
args[0]={name:event,source:this};while(parent){shouldPropagate=parent.$emit.apply(parent,args);parent=shouldPropagate?parent.$parent:null;}return this;}; /**
     * Modify the listener counts on all parents.
     * This bookkeeping allows $broadcast to return early when
     * no child has listened to a certain event.
     *
     * @param {Vue} vm
     * @param {String} event
     * @param {Number} count
     */var hookRE=/^hook:/;function modifyListenerCount(vm,event,count){var parent=vm.$parent; // hooks do not get broadcasted so no need
// to do bookkeeping for them
if(!parent||!count||hookRE.test(event))return;while(parent){parent._eventsCount[event]=(parent._eventsCount[event]||0)+count;parent=parent.$parent;}}}function lifecycleAPI(Vue){ /**
     * Set instance target element and kick off the compilation
     * process. The passed in `el` can be a selector string, an
     * existing Element, or a DocumentFragment (for block
     * instances).
     *
     * @param {Element|DocumentFragment|string} el
     * @public
     */Vue.prototype.$mount=function(el){if(this._isCompiled){'development'!=='production'&&warn('$mount() should be called only once.');return;}el=query(el);if(!el){el=document.createElement('div');}this._compile(el);this._initDOMHooks();if(inDoc(this.$el)){this._callHook('attached');ready.call(this);}else {this.$once('hook:attached',ready);}return this;}; /**
     * Mark an instance as ready.
     */function ready(){this._isAttached=true;this._isReady=true;this._callHook('ready');} /**
     * Teardown the instance, simply delegate to the internal
     * _destroy.
     */Vue.prototype.$destroy=function(remove,deferCleanup){this._destroy(remove,deferCleanup);}; /**
     * Partially compile a piece of DOM and return a
     * decompile function.
     *
     * @param {Element|DocumentFragment} el
     * @param {Vue} [host]
     * @return {Function}
     */Vue.prototype.$compile=function(el,host,scope,frag){return compile(el,this.$options,true)(this,el,host,scope,frag);};} /**
   * The exposed Vue constructor.
   *
   * API conventions:
   * - public API methods/properties are prefixed with `$`
   * - internal methods/properties are prefixed with `_`
   * - non-prefixed properties are assumed to be proxied user
   *   data.
   *
   * @constructor
   * @param {Object} [options]
   * @public
   */function Vue(options){this._init(options);} // install internals
initMixin(Vue);stateMixin(Vue);eventsMixin(Vue);lifecycleMixin(Vue);miscMixin(Vue); // install instance APIs
dataAPI(Vue);domAPI(Vue);eventsAPI(Vue);lifecycleAPI(Vue);var slot={priority:SLOT,params:['name'],bind:function bind(){ // this was resolved during component transclusion
var name=this.params.name||'default';var content=this.vm._slotContents&&this.vm._slotContents[name];if(!content||!content.hasChildNodes()){this.fallback();}else {this.compile(content.cloneNode(true),this.vm._context,this.vm);}},compile:function compile(content,context,host){if(content&&context){if(this.el.hasChildNodes()&&content.childNodes.length===1&&content.childNodes[0].nodeType===1&&content.childNodes[0].hasAttribute('v-if')){ // if the inserted slot has v-if
// inject fallback content as the v-else
var elseBlock=document.createElement('template');elseBlock.setAttribute('v-else','');elseBlock.innerHTML=this.el.innerHTML; // the else block should be compiled in child scope
elseBlock._context=this.vm;content.appendChild(elseBlock);}var scope=host?host._scope:this._scope;this.unlink=context.$compile(content,host,scope,this._frag);}if(content){replace(this.el,content);}else {remove(this.el);}},fallback:function fallback(){this.compile(extractContent(this.el,true),this.vm);},unbind:function unbind(){if(this.unlink){this.unlink();}}};var partial={priority:PARTIAL,params:['name'], // watch changes to name for dynamic partials
paramWatchers:{name:function name(value){vIf.remove.call(this);if(value){this.insert(value);}}},bind:function bind(){this.anchor=createAnchor('v-partial');replace(this.el,this.anchor);this.insert(this.params.name);},insert:function insert(id){var partial=resolveAsset(this.vm.$options,'partials',id);if('development'!=='production'){assertAsset(partial,'partial',id);}if(partial){this.factory=new FragmentFactory(this.vm,partial);vIf.insert.call(this);}},unbind:function unbind(){if(this.frag){this.frag.destroy();}}};var elementDirectives={slot:slot,partial:partial};var convertArray=vFor._postProcess; /**
   * Limit filter for arrays
   *
   * @param {Number} n
   * @param {Number} offset (Decimal expected)
   */function limitBy(arr,n,offset){offset=offset?parseInt(offset,10):0;n=toNumber(n);return typeof n==='number'?arr.slice(offset,offset+n):arr;} /**
   * Filter filter for arrays
   *
   * @param {String} search
   * @param {String} [delimiter]
   * @param {String} ...dataKeys
   */function filterBy(arr,search,delimiter){arr=convertArray(arr);if(search==null){return arr;}if(typeof search==='function'){return arr.filter(search);} // cast to lowercase string
search=(''+search).toLowerCase(); // allow optional `in` delimiter
// because why not
var n=delimiter==='in'?3:2; // extract and flatten keys
var keys=toArray(arguments,n).reduce(function(prev,cur){return prev.concat(cur);},[]);var res=[];var item,key,val,j;for(var i=0,l=arr.length;i<l;i++){item=arr[i];val=item&&item.$value||item;j=keys.length;if(j){while(j--){key=keys[j];if(key==='$key'&&contains$1(item.$key,search)||contains$1(getPath(val,key),search)){res.push(item);break;}}}else if(contains$1(item,search)){res.push(item);}}return res;} /**
   * Filter filter for arrays
   *
   * @param {String} sortKey
   * @param {String} reverse
   */function orderBy(arr,sortKey,reverse){arr=convertArray(arr);if(!sortKey){return arr;}var order=reverse&&reverse<0?-1:1; // sort on a copy to avoid mutating original array
return arr.slice().sort(function(a,b){if(sortKey!=='$key'){if(isObject(a)&&'$value' in a)a=a.$value;if(isObject(b)&&'$value' in b)b=b.$value;}a=isObject(a)?getPath(a,sortKey):a;b=isObject(b)?getPath(b,sortKey):b;return a===b?0:a>b?order:-order;});} /**
   * String contain helper
   *
   * @param {*} val
   * @param {String} search
   */function contains$1(val,search){var i;if(isPlainObject(val)){var keys=Object.keys(val);i=keys.length;while(i--){if(contains$1(val[keys[i]],search)){return true;}}}else if(isArray(val)){i=val.length;while(i--){if(contains$1(val[i],search)){return true;}}}else if(val!=null){return val.toString().toLowerCase().indexOf(search)>-1;}}var digitsRE=/(\d{3})(?=\d)/g; // asset collections must be a plain object.
var filters={orderBy:orderBy,filterBy:filterBy,limitBy:limitBy, /**
     * Stringify value.
     *
     * @param {Number} indent
     */json:{read:function read(value,indent){return typeof value==='string'?value:JSON.stringify(value,null,Number(indent)||2);},write:function write(value){try{return JSON.parse(value);}catch(e){return value;}}}, /**
     * 'abc' => 'Abc'
     */capitalize:function capitalize(value){if(!value&&value!==0)return '';value=value.toString();return value.charAt(0).toUpperCase()+value.slice(1);}, /**
     * 'abc' => 'ABC'
     */uppercase:function uppercase(value){return value||value===0?value.toString().toUpperCase():'';}, /**
     * 'AbC' => 'abc'
     */lowercase:function lowercase(value){return value||value===0?value.toString().toLowerCase():'';}, /**
     * 12345 => $12,345.00
     *
     * @param {String} sign
     */currency:function currency(value,_currency){value=parseFloat(value);if(!isFinite(value)||!value&&value!==0)return '';_currency=_currency!=null?_currency:'$';var stringified=Math.abs(value).toFixed(2);var _int=stringified.slice(0,-3);var i=_int.length%3;var head=i>0?_int.slice(0,i)+(_int.length>3?',':''):'';var _float=stringified.slice(-3);var sign=value<0?'-':'';return sign+_currency+head+_int.slice(i).replace(digitsRE,'$1,')+_float;}, /**
     * 'item' => 'items'
     *
     * @params
     *  an array of strings corresponding to
     *  the single, double, triple ... forms of the word to
     *  be pluralized. When the number to be pluralized
     *  exceeds the length of the args, it will use the last
     *  entry in the array.
     *
     *  e.g. ['single', 'double', 'triple', 'multiple']
     */pluralize:function pluralize(value){var args=toArray(arguments,1);return args.length>1?args[value%10-1]||args[args.length-1]:args[0]+(value===1?'':'s');}, /**
     * Debounce a handler function.
     *
     * @param {Function} handler
     * @param {Number} delay = 300
     * @return {Function}
     */debounce:function debounce(handler,delay){if(!handler)return;if(!delay){delay=300;}return _debounce(handler,delay);}};function installGlobalAPI(Vue){ /**
     * Vue and every constructor that extends Vue has an
     * associated options object, which can be accessed during
     * compilation steps as `this.constructor.options`.
     *
     * These can be seen as the default options of every
     * Vue instance.
     */Vue.options={directives:directives,elementDirectives:elementDirectives,filters:filters,transitions:{},components:{},partials:{},replace:true}; /**
     * Expose useful internals
     */Vue.util=util;Vue.config=config;Vue.set=set;Vue['delete']=del;Vue.nextTick=nextTick; /**
     * The following are exposed for advanced usage / plugins
     */Vue.compiler=compiler;Vue.FragmentFactory=FragmentFactory;Vue.internalDirectives=internalDirectives;Vue.parsers={path:path,text:text,template:template,directive:directive,expression:expression}; /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */Vue.cid=0;var cid=1; /**
     * Class inheritance
     *
     * @param {Object} extendOptions
     */Vue.extend=function(extendOptions){extendOptions=extendOptions||{};var Super=this;var isFirstExtend=Super.cid===0;if(isFirstExtend&&extendOptions._Ctor){return extendOptions._Ctor;}var name=extendOptions.name||Super.options.name;if('development'!=='production'){if(!/^[a-zA-Z][\w-]*$/.test(name)){warn('Invalid component name: "'+name+'". Component names '+'can only contain alphanumeric characaters and the hyphen.');name=null;}}var Sub=createClass(name||'VueComponent');Sub.prototype=Object.create(Super.prototype);Sub.prototype.constructor=Sub;Sub.cid=cid++;Sub.options=mergeOptions(Super.options,extendOptions);Sub['super']=Super; // allow further extension
Sub.extend=Super.extend; // create asset registers, so extended classes
// can have their private assets too.
config._assetTypes.forEach(function(type){Sub[type]=Super[type];}); // enable recursive self-lookup
if(name){Sub.options.components[name]=Sub;} // cache constructor
if(isFirstExtend){extendOptions._Ctor=Sub;}return Sub;}; /**
     * A function that returns a sub-class constructor with the
     * given name. This gives us much nicer output when
     * logging instances in the console.
     *
     * @param {String} name
     * @return {Function}
     */function createClass(name){ /* eslint-disable no-new-func */return new Function('return function '+classify(name)+' (options) { this._init(options) }')(); /* eslint-enable no-new-func */} /**
     * Plugin system
     *
     * @param {Object} plugin
     */Vue.use=function(plugin){ /* istanbul ignore if */if(plugin.installed){return;} // additional parameters
var args=toArray(arguments,1);args.unshift(this);if(typeof plugin.install==='function'){plugin.install.apply(plugin,args);}else {plugin.apply(null,args);}plugin.installed=true;return this;}; /**
     * Apply a global mixin by merging it into the default
     * options.
     */Vue.mixin=function(mixin){Vue.options=mergeOptions(Vue.options,mixin);}; /**
     * Create asset registration methods with the following
     * signature:
     *
     * @param {String} id
     * @param {*} definition
     */config._assetTypes.forEach(function(type){Vue[type]=function(id,definition){if(!definition){return this.options[type+'s'][id];}else { /* istanbul ignore if */if('development'!=='production'){if(type==='component'&&(commonTagRE.test(id)||reservedTagRE.test(id))){warn('Do not use built-in or reserved HTML elements as component '+'id: '+id);}}if(type==='component'&&isPlainObject(definition)){definition.name=id;definition=Vue.extend(definition);}this.options[type+'s'][id]=definition;return definition;}};}); // expose internal transition API
extend(Vue.transition,transition);}installGlobalAPI(Vue);Vue.version='1.0.18'; // devtools global hook
/* istanbul ignore next */if(config.devtools){if(devtools){devtools.emit('init',Vue);}else if('development'!=='production'&&inBrowser&&/Chrome\/\d+/.test(window.navigator.userAgent)){console.log('Download the Vue Devtools for a better development experience:\n'+'https://github.com/vuejs/vue-devtools');}}return Vue;});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/var/www/github/vue-mini-shop/assets/js/main.js":[function(require,module,exports){
'use strict';

require('./stores/conf.js');

require('./router/conf.js');

},{"./router/conf.js":"/var/www/github/vue-mini-shop/assets/js/router/conf.js","./stores/conf.js":"/var/www/github/vue-mini-shop/assets/js/stores/conf.js"}],"/var/www/github/vue-mini-shop/assets/js/router/conf.js":[function(require,module,exports){
(function (global){
'use strict';

var _vue = require('../libs/vue.js');

var _vue2 = _interopRequireDefault(_vue);

var _vueRouterMin = require('../libs/vue-router.min.js');

var _vueRouterMin2 = _interopRequireDefault(_vueRouterMin);

var _app = require('../components/app.vue');

var _app2 = _interopRequireDefault(_app);

var _map = require('./map.js');

var _map2 = _interopRequireDefault(_map);

var _services = require('../stores/services.js');

var _services2 = _interopRequireDefault(_services);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
  VUE ROUTER CONFIGURATION
*/

// import map
(function () {

  // Make new VueRouter Instance
  _vue2.default.use(_vueRouterMin2.default);
  var router = new _vueRouterMin2.default();

  // Make it global
  global.router = router;

  // Register Routes
  router.map(_map2.default);

  // Handle not found routes
  router.redirect({ '*': '/' });

  // Before Routing Events
  router.beforeEach(function () {

    // Fake Loading Bar
    var curTime = 0;
    function animate() {
      var cur = parseFloat(_services2.default.state.progress);
      cur = isNaN(cur) ? 0 : cur;

      var to = 100; // The Last Unit Should Be

      var duration = 750;

      var startTime = new Date().getSeconds() + ',' + new Date().getMilliseconds();
      var start = +new Date();
      check();

      function check() {
        if (cur != to) {

          cur + to / 60 > to ? cur = to : cur += to / 60;

          _services2.default.progress_to(cur);

          // curTime += duration/60;
          var time = +new Date() - start;

          setTimeout(function () {
            check();
          }, duration / 60); // 60 FPS - Harunya 1000/60 -_-
        }
      } // check()
    }

    animate();
    document.body.scrollTop = 0;
  });

  /**
    MOUNT THE VUE
  */

  // Make a new components
  var App = _vue2.default.extend(_app2.default);

  // Mount The App
  router.start(App, '#app');
})();

// Import services


// import components

// Import Vue Router

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../components/app.vue":"/var/www/github/vue-mini-shop/assets/js/components/app.vue","../libs/vue-router.min.js":"/var/www/github/vue-mini-shop/assets/js/libs/vue-router.min.js","../libs/vue.js":"/var/www/github/vue-mini-shop/assets/js/libs/vue.js","../stores/services.js":"/var/www/github/vue-mini-shop/assets/js/stores/services.js","./map.js":"/var/www/github/vue-mini-shop/assets/js/router/map.js"}],"/var/www/github/vue-mini-shop/assets/js/router/map.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  '/': {
    component: require('../components/pages/home.vue')
  },

  '/product/:productName': {
    component: require('../components/pages/detil.vue')
  },

  '/category/:category': {
    component: require('../components/pages/category.vue')
  },

  '/search': {
    component: require('../components/pages/search.vue')
  },

  '/cart/': {
    component: require('../components/pages/cart.vue')
  }

};

},{"../components/pages/cart.vue":"/var/www/github/vue-mini-shop/assets/js/components/pages/cart.vue","../components/pages/category.vue":"/var/www/github/vue-mini-shop/assets/js/components/pages/category.vue","../components/pages/detil.vue":"/var/www/github/vue-mini-shop/assets/js/components/pages/detil.vue","../components/pages/home.vue":"/var/www/github/vue-mini-shop/assets/js/components/pages/home.vue","../components/pages/search.vue":"/var/www/github/vue-mini-shop/assets/js/components/pages/search.vue"}],"/var/www/github/vue-mini-shop/assets/js/stores/cart.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _services = require('./services.js');

var _services2 = _interopRequireDefault(_services);

var _product = require('./product.js');

var _product2 = _interopRequireDefault(_product);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

  name: 'cart',

  state: {
    all: [],
    totalItem: 0
  },

  /**
    Set the state
    @param {Object} val
  */
  set: function set(val) {
    var me = this;

    var keys = Object.keys(val);
    keys.forEach(function (key) {
      me.state[key] = val[key];
    });

    me.total_item();

    _services2.default.backup_to_local_storage();
  },


  // /**
  //   Find Item
  //   @param {Object} cart_item
  // */
  // find_item(cartItem){
  //   let me = this
  //
  //   // Find The Product
  //   let allItem = me.state.all
  //   let findItem = allItem.find(item => item.name == cartItem.name)
  //
  //   return findItem
  // },

  /**
    Add item to cart
    @param {Object} val
  */
  add_item: function add_item(val) {
    var me = this;

    // remove Vue watcher
    val = cleanUp(val);

    // Destructuring the val
    var _val = val;
    var product = _val.product;
    var color = _val.color;


    _product2.default.decrease_stock({
      product: product,
      color: color
    });

    // Prepare the format of the cart Item
    var cartItem = {
      name: product.name,
      color: color,
      price: product.price,
      amount: 1
    };

    // Prepare to Add item to the cart
    var allCartItem = me.state.all;
    var duplicated = allCartItem.find(function (item) {
      return item.name == cartItem.name && item.color == cartItem.color;
    });

    // if duplicate item, add the amount
    if (duplicated !== undefined) {
      var indexOfDuplicatedItem = allCartItem.indexOf(duplicated);
      allCartItem[indexOfDuplicatedItem].amount = duplicated.amount + 1;
    } else {
      allCartItem.push(cartItem);
    }

    me.total_item();

    _services2.default.backup_to_local_storage();
  },


  /**
    Calculate the total of the cart items
  */
  total_item: function total_item() {
    var total = 0;
    this.state.all.forEach(function (item) {
      total += item.amount;
    });
    this.state.totalItem = total;
  },


  /**
    Check out
  */
  checkout: function checkout() {
    this.state.all = [];
    this.state.totalItem = 0;
    _services2.default.backup_to_local_storage();
  }
};

},{"./product.js":"/var/www/github/vue-mini-shop/assets/js/stores/product.js","./services.js":"/var/www/github/vue-mini-shop/assets/js/stores/services.js"}],"/var/www/github/vue-mini-shop/assets/js/stores/conf.js":[function(require,module,exports){
'use strict';

var _vue = require('../libs/vue.js');

var _vue2 = _interopRequireDefault(_vue);

var _vueSimpleStore = require('../libs/vue-simple-store.js');

var _vueSimpleStore2 = _interopRequireDefault(_vueSimpleStore);

var _services = require('./services.js');

var _services2 = _interopRequireDefault(_services);

var _product = require('./product.js');

var _product2 = _interopRequireDefault(_product);

var _cart = require('./cart.js');

var _cart2 = _interopRequireDefault(_cart);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
  // Install Vue Simple Store
  _vue2.default.use(_vueSimpleStore2.default, { stores: [_services2.default, _product2.default, _cart2.default], debug: true });
})();

// Import All Store Once

// Import the library

},{"../libs/vue-simple-store.js":"/var/www/github/vue-mini-shop/assets/js/libs/vue-simple-store.js","../libs/vue.js":"/var/www/github/vue-mini-shop/assets/js/libs/vue.js","./cart.js":"/var/www/github/vue-mini-shop/assets/js/stores/cart.js","./product.js":"/var/www/github/vue-mini-shop/assets/js/stores/product.js","./services.js":"/var/www/github/vue-mini-shop/assets/js/stores/services.js"}],"/var/www/github/vue-mini-shop/assets/js/stores/product.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _services = require('./services.js');

var _services2 = _interopRequireDefault(_services);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

  name: 'product',

  state: {
    all: []
  },

  /**
    Set the state
    @param {Object} val
  */
  set: function set(val) {
    var me = this;

    var keys = Object.keys(val);
    keys.forEach(function (key) {
      me.state[key] = val[key];
    });

    me.organize(me.state.all);
    _services2.default.backup_to_local_storage();
  },


  /**
    Organize the products
    @param {Object} products
  */
  organize: function organize(products) {
    var me = this;
    products.forEach(function (product) {
      // Convert the product name to kebab-case
      product.kebabName = product.name.toLowerCase().replace(/\s/ig, '-');
    });
  },


  /**
    Find The Product
    @param {Object} product
  */
  find_product: function find_product(product) {
    var me = this;

    // Find The Product
    var allProduct = me.state.all;
    var findProduct = allProduct.find(function (item) {
      return item.name == product.name;
    });
    return findProduct;
  },


  /**
    Decrease the amount of the stock
    @param {Object} val
  */
  decrease_stock: function decrease_stock(val) {
    var me = this;

    // remove Vue watcher
    val = cleanUp(val);

    // Destructuring the val
    var _val = val;
    var product = _val.product;
    var color = _val.color;

    // decrease the stock of the product

    var theProduct = me.find_product(product);

    // Find the color then reduce the stock amount
    var allStock = theProduct.stocks;
    var findColor = allStock.find(function (stock) {
      return stock.color == color;
    });
    var indexOfColor = allStock.indexOf(findColor);
    allStock[indexOfColor].stock = findColor.stock - 1; // Finally -_-

    _services2.default.backup_to_local_storage();
  },


  /**
    Toggle Like the Product
    @param {Object} val
  */
  toggle_like: function toggle_like(val) {
    var me = this;

    // remove Vue watcher
    val = cleanUp(val);

    // Destructuring the val
    var _val2 = val;
    var product = _val2.product;


    var theProduct = me.find_product(product);

    theProduct.liked = !product.liked;

    _services2.default.backup_to_local_storage();
  },


  /**
    add a comment to the Product
    @param {Object} val
  */
  add_comment: function add_comment(val) {
    var me = this;

    // remove Vue watcher
    val = cleanUp(val);

    // Destructuring the val
    var _val3 = val;
    var product = _val3.product;
    var content = _val3.content;


    var theProduct = me.find_product(product);

    theProduct.comments.push({ content: content });

    _services2.default.backup_to_local_storage();
  },


  /**
    delete a comment to the Product
    @param {Object} val
  */
  delete_comment: function delete_comment(val) {
    var me = this;

    // remove Vue watcher
    val = cleanUp(val);

    // Destructuring the val
    var _val4 = val;
    var product = _val4.product;
    var comment = _val4.comment;


    var theProduct = me.find_product(product);

    var indexOfComment = theProduct.comments.indexOf(comment);
    theProduct.comments.splice(indexOfComment, 1);

    _services2.default.backup_to_local_storage();
  }
};

},{"./services.js":"/var/www/github/vue-mini-shop/assets/js/stores/services.js"}],"/var/www/github/vue-mini-shop/assets/js/stores/services.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _product = require('./product.js');

var _product2 = _interopRequireDefault(_product);

var _cart = require('./cart.js');

var _cart2 = _interopRequireDefault(_cart);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

  name: "services",

  state: {
    progress: 0
  },

  /**
    Set the Initial State
  */
  initial_state: function initial_state() {
    var fromLocalStorage = window.localStorage.getItem('vue-mini-shop');

    // If localStorage data is length
    if (fromLocalStorage !== null) {

      fromLocalStorage = JSON.parse(fromLocalStorage);

      // Destructuring First
      var _fromLocalStorage = fromLocalStorage;
      var product = _fromLocalStorage.product;
      var cart = _fromLocalStorage.cart;


      _product2.default.set({ all: product.all });
      _cart2.default.set({ all: cart.all });
    }
    // When data in the local Storage is null
    else {
        _product2.default.set({
          all: [{
            name: "Iphone 5 S",
            img: './assets/img/mobile.jpg',
            price: 9000000,
            stocks: [{ color: "black", stock: 30 }, { color: "silver", stock: 20 }, { color: "gold", stock: 10 }, { color: "rose gold", stock: 5 }],
            liked: false,
            detail: "<p>This is the details of the Iphone, Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.<br><br>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>",
            categories: ['phone'],
            comments: [{ content: "Waaah.. keren bingit Hpnya!" }, { content: "Barangnya Sampai dengan Selamat Gan, Makasih. Packaging-nya juga bagus! Recommended banget deh pokoknya" }]
          }, {
            name: "Smart Phone Apple",
            img: './assets/img/hi-tech-toys.jpg',
            price: 10500000,
            stocks: [{ color: "white", stock: 50 }],
            liked: false,
            detail: "<p>This is the details of the Iphone, Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.<br><br>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>",
            categories: ['phone'],
            comments: [{ content: "Pinter bingit Hpnya!" }]
          }, {
            name: "Book And Pen",
            img: './assets/img/hi-tech-toys-2.jpg',
            price: 150000,
            stocks: [{ color: "brown", stock: 150 }, { color: "silver", stock: 15 }],
            liked: false,
            detail: "<p>This is the details of the Iphone, Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.<br><br>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>",
            categories: ['accessories'],
            comments: [{ content: "Bukunya Elegan! Saya suka dengan Warnanya" }]
          }, {
            name: "Flatty Phone With Earphone",
            img: './assets/img/mobile-2.jpg',
            price: 7500000,
            stocks: [{ color: "white", stock: 20 }, { color: "black", stock: 10 }],
            liked: false,
            detail: "<p>This is the details of the Iphone, Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.<br><br>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>",
            categories: ['phone'],
            comments: [{ content: "Earphonenya Mantabs Gan!" }]
          }, {
            name: "Book And Pen",
            img: './assets/img/hi-tech-toys-2.jpg',
            price: 150000,
            stocks: [{ color: "brown", stock: 150 }, { color: "silver", stock: 15 }],
            liked: false,
            detail: "<p>This is the details of the Iphone, Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.<br><br>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>",
            categories: ['accessories'],
            comments: [{ content: "Bukunya Elegan! Saya suka dengan Warnanya" }]
          }, {
            name: "An Ipad",
            img: './assets/img/ipad.jpg',
            price: 10000000,
            stocks: [{ color: "black", stock: 10 }, { color: "silver", stock: 10 }],
            liked: false,
            detail: "<p>This is the details of the Ipad, Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.<br><br>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>",
            categories: ['pad'],
            comments: [{ content: "Sukak banget sama yang warna Merah" }, { content: "Barangnya Sampai dengan Selamat Gan, Makasih. Packaging-nya juga bagus! Recommended banget deh pokoknya" }]
          }, {
            name: "Mobile IOS",
            img: './assets/img/ios.jpg',
            price: 13000000,
            stocks: [{ color: "gold", stock: 10 }, { color: "black", stock: 10 }, { color: "silver", stock: 10 }],
            liked: false,
            detail: "<p>This is the details of the Mobile IOS, Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.<br><br>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>",
            categories: ['phone'],
            comments: []
          }]
        });
      } // else
  },
  // initial_state()

  /**
    get All state of the App
  */
  get_all: function get_all() {
    var product = _product2.default.state;
    var cart = _cart2.default.state;
    var state = { product: product, cart: cart };
    return state;
  },


  /**
    Backup All state to the Local Storage
  */
  backup_to_local_storage: function backup_to_local_storage() {
    window.localStorage.setItem('vue-mini-shop', JSON.stringify(this.get_all()));
  },


  /**
    Closing the Action
    @param {String} action_name
    @param {Object} val
  */
  close_the_action: function close_the_action(action_name, val) {
    this.backup_to_local_storage();
    console.log(action_name, val);
  },


  /**
    Set the value of the progress bar
    @param {Int} num
  */
  progress_to: function progress_to(num) {
    this.state.progress = num;
  }
};

},{"./cart.js":"/var/www/github/vue-mini-shop/assets/js/stores/cart.js","./product.js":"/var/www/github/vue-mini-shop/assets/js/stores/product.js"}]},{},["/var/www/github/vue-mini-shop/assets/js/main.js"])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaS9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanMiLCIuLi8uLi8uLi8uLi91c3IvbGliL25vZGVfbW9kdWxlcy92dWVpZnktaW5zZXJ0LWNzcy9pbmRleC5qcyIsImFzc2V0cy9qcy9jb21wb25lbnRzL2FwcC52dWUiLCJhc3NldHMvanMvY29tcG9uZW50cy9uYXYvY2F0ZWdvcmllcy52dWUiLCJhc3NldHMvanMvY29tcG9uZW50cy9uYXYvbmF2aWdhdGlvbi52dWUiLCJhc3NldHMvanMvY29tcG9uZW50cy9uYXYvc2VhcmNoLnZ1ZSIsImFzc2V0cy9qcy9jb21wb25lbnRzL290aGVyL2dyaWQudnVlIiwiYXNzZXRzL2pzL2NvbXBvbmVudHMvb3RoZXIvdnVlLWxvYWRpbmctYmFyLnZ1ZSIsImFzc2V0cy9qcy9jb21wb25lbnRzL3BhZ2VzL2NhcnQudnVlIiwiYXNzZXRzL2pzL2NvbXBvbmVudHMvcGFnZXMvY2F0ZWdvcnkudnVlIiwiYXNzZXRzL2pzL2NvbXBvbmVudHMvcGFnZXMvZGV0aWwudnVlIiwiYXNzZXRzL2pzL2NvbXBvbmVudHMvcGFnZXMvaG9tZS52dWUiLCJhc3NldHMvanMvY29tcG9uZW50cy9wYWdlcy9zZWFyY2gudnVlIiwiYXNzZXRzL2pzL2NvbXBvbmVudHMvcHJvZHVjdC9hY3Rpb25zLnZ1ZSIsImFzc2V0cy9qcy9jb21wb25lbnRzL3Byb2R1Y3QvY29sb3JzLnZ1ZSIsImFzc2V0cy9qcy9jb21wb25lbnRzL3Byb2R1Y3QvY29tbWVudC1lZGl0b3IudnVlIiwiYXNzZXRzL2pzL2NvbXBvbmVudHMvcHJvZHVjdC9jb21tZW50LnZ1ZSIsImFzc2V0cy9qcy9jb21wb25lbnRzL3Byb2R1Y3QvcHJvZHVjdC52dWUiLCJhc3NldHMvanMvbGlicy92dWUtY2xpY2stb3V0c2lkZS5qcyIsImFzc2V0cy9qcy9saWJzL3Z1ZS1yZWFkYWJsZS1udW1iZXIuanMiLCJhc3NldHMvanMvbGlicy92dWUtcm91dGVyLm1pbi5qcyIsImFzc2V0cy9qcy9saWJzL3Z1ZS1zaW1wbGUtc3RvcmUuanMiLCJhc3NldHMvanMvbGlicy92dWUuanMiLCJhc3NldHMvanMvbWFpbi5qcyIsImFzc2V0cy9qcy9yb3V0ZXIvY29uZi5qcyIsImFzc2V0cy9qcy9yb3V0ZXIvbWFwLmpzIiwiYXNzZXRzL2pzL3N0b3Jlcy9jYXJ0LmpzIiwiYXNzZXRzL2pzL3N0b3Jlcy9jb25mLmpzIiwiYXNzZXRzL2pzL3N0b3Jlcy9wcm9kdWN0LmpzIiwiYXNzZXRzL2pzL3N0b3Jlcy9zZXJ2aWNlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3QrU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIFZ1ZSAvLyBsYXRlIGJpbmRcbnZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG52YXIgc2hpbW1lZCA9IGZhbHNlXG52YXIgaXNCcm93c2VyaWZ5ID0gZmFsc2VcblxuLyoqXG4gKiBEZXRlcm1pbmUgY29tcGF0aWJpbGl0eSBhbmQgYXBwbHkgcGF0Y2guXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdnVlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJyb3dzZXJpZnlcbiAqL1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbiAodnVlLCBicm93c2VyaWZ5KSB7XG4gIGlmIChzaGltbWVkKSByZXR1cm5cbiAgc2hpbW1lZCA9IHRydWVcblxuICBWdWUgPSB2dWVcbiAgaXNCcm93c2VyaWZ5ID0gYnJvd3NlcmlmeVxuXG4gIGV4cG9ydHMuY29tcGF0aWJsZSA9ICEhVnVlLmludGVybmFsRGlyZWN0aXZlc1xuICBpZiAoIWV4cG9ydHMuY29tcGF0aWJsZSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdbSE1SXSB2dWUtbG9hZGVyIGhvdCByZWxvYWQgaXMgb25seSBjb21wYXRpYmxlIHdpdGggJyArXG4gICAgICAnVnVlLmpzIDEuMC4wKy4nXG4gICAgKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gcGF0Y2ggdmlldyBkaXJlY3RpdmVcbiAgcGF0Y2hWaWV3KFZ1ZS5pbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50KVxuICBjb25zb2xlLmxvZygnW0hNUl0gVnVlIGNvbXBvbmVudCBob3QgcmVsb2FkIHNoaW0gYXBwbGllZC4nKVxuICAvLyBzaGltIHJvdXRlci12aWV3IGlmIHByZXNlbnRcbiAgdmFyIHJvdXRlclZpZXcgPSBWdWUuZWxlbWVudERpcmVjdGl2ZSgncm91dGVyLXZpZXcnKVxuICBpZiAocm91dGVyVmlldykge1xuICAgIHBhdGNoVmlldyhyb3V0ZXJWaWV3KVxuICAgIGNvbnNvbGUubG9nKCdbSE1SXSB2dWUtcm91dGVyIDxyb3V0ZXItdmlldz4gaG90IHJlbG9hZCBzaGltIGFwcGxpZWQuJylcbiAgfVxufVxuXG4vKipcbiAqIFNoaW0gdGhlIHZpZXcgZGlyZWN0aXZlIChjb21wb25lbnQgb3Igcm91dGVyLXZpZXcpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBWaWV3XG4gKi9cblxuZnVuY3Rpb24gcGF0Y2hWaWV3IChWaWV3KSB7XG4gIHZhciB1bmJ1aWxkID0gVmlldy51bmJ1aWxkXG4gIFZpZXcudW5idWlsZCA9IGZ1bmN0aW9uIChkZWZlcikge1xuICAgIGlmICghdGhpcy5ob3RVcGRhdGluZykge1xuICAgICAgdmFyIHByZXZDb21wb25lbnQgPSB0aGlzLmNoaWxkVk0gJiYgdGhpcy5jaGlsZFZNLmNvbnN0cnVjdG9yXG4gICAgICByZW1vdmVWaWV3KHByZXZDb21wb25lbnQsIHRoaXMpXG4gICAgICAvLyBkZWZlciA9IHRydWUgbWVhbnMgd2UgYXJlIHRyYW5zaXRpb25pbmcgdG8gYSBuZXdcbiAgICAgIC8vIENvbXBvbmVudC4gUmVnaXN0ZXIgdGhpcyBuZXcgY29tcG9uZW50IHRvIHRoZSBsaXN0LlxuICAgICAgaWYgKGRlZmVyKSB7XG4gICAgICAgIGFkZFZpZXcodGhpcy5Db21wb25lbnQsIHRoaXMpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNhbGwgb3JpZ2luYWxcbiAgICByZXR1cm4gdW5idWlsZC5jYWxsKHRoaXMsIGRlZmVyKVxuICB9XG59XG5cbi8qKlxuICogQWRkIGEgY29tcG9uZW50IHZpZXcgdG8gYSBDb21wb25lbnQncyBob3QgbGlzdFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvbXBvbmVudFxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXcgLSB2aWV3IGRpcmVjdGl2ZSBpbnN0YW5jZVxuICovXG5cbmZ1bmN0aW9uIGFkZFZpZXcgKENvbXBvbmVudCwgdmlldykge1xuICB2YXIgaWQgPSBDb21wb25lbnQgJiYgQ29tcG9uZW50Lm9wdGlvbnMuaG90SURcbiAgaWYgKGlkKSB7XG4gICAgaWYgKCFtYXBbaWRdKSB7XG4gICAgICBtYXBbaWRdID0ge1xuICAgICAgICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgICAgICAgdmlld3M6IFtdLFxuICAgICAgICBpbnN0YW5jZXM6IFtdXG4gICAgICB9XG4gICAgfVxuICAgIG1hcFtpZF0udmlld3MucHVzaCh2aWV3KVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY29tcG9uZW50IHZpZXcgZnJvbSBhIENvbXBvbmVudCdzIGhvdCBsaXN0XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50XG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlldyAtIHZpZXcgZGlyZWN0aXZlIGluc3RhbmNlXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlVmlldyAoQ29tcG9uZW50LCB2aWV3KSB7XG4gIHZhciBpZCA9IENvbXBvbmVudCAmJiBDb21wb25lbnQub3B0aW9ucy5ob3RJRFxuICBpZiAoaWQpIHtcbiAgICBtYXBbaWRdLnZpZXdzLiRyZW1vdmUodmlldylcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlY29yZCBmb3IgYSBob3QgbW9kdWxlLCB3aGljaCBrZWVwcyB0cmFjayBvZiBpdHMgY29uc3RydWNvdHIsXG4gKiBpbnN0bmFjZXMgYW5kIHZpZXdzIChjb21wb25lbnQgZGlyZWN0aXZlcyBvciByb3V0ZXItdmlld3MpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5leHBvcnRzLmNyZWF0ZVJlY29yZCA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucy5vcHRpb25zXG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmVsICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0aW9ucy5kYXRhICE9PSAnb2JqZWN0Jykge1xuICAgIG1ha2VPcHRpb25zSG90KGlkLCBvcHRpb25zKVxuICAgIG1hcFtpZF0gPSB7XG4gICAgICBDb21wb25lbnQ6IG51bGwsXG4gICAgICB2aWV3czogW10sXG4gICAgICBpbnN0YW5jZXM6IFtdXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWFrZSBhIENvbXBvbmVudCBvcHRpb25zIG9iamVjdCBob3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIG1ha2VPcHRpb25zSG90IChpZCwgb3B0aW9ucykge1xuICBvcHRpb25zLmhvdElEID0gaWRcbiAgaW5qZWN0SG9vayhvcHRpb25zLCAnY3JlYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjb3JkID0gbWFwW2lkXVxuICAgIGlmICghcmVjb3JkLkNvbXBvbmVudCkge1xuICAgICAgcmVjb3JkLkNvbXBvbmVudCA9IHRoaXMuY29uc3RydWN0b3JcbiAgICB9XG4gICAgcmVjb3JkLmluc3RhbmNlcy5wdXNoKHRoaXMpXG4gIH0pXG4gIGluamVjdEhvb2sob3B0aW9ucywgJ2JlZm9yZURlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgbWFwW2lkXS5pbnN0YW5jZXMuJHJlbW92ZSh0aGlzKVxuICB9KVxufVxuXG4vKipcbiAqIEluamVjdCBhIGhvb2sgdG8gYSBob3QgcmVsb2FkYWJsZSBjb21wb25lbnQgc28gdGhhdFxuICogd2UgY2FuIGtlZXAgdHJhY2sgb2YgaXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKi9cblxuZnVuY3Rpb24gaW5qZWN0SG9vayAob3B0aW9ucywgbmFtZSwgaG9vaykge1xuICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zW25hbWVdXG4gIG9wdGlvbnNbbmFtZV0gPSBleGlzdGluZ1xuICAgID8gQXJyYXkuaXNBcnJheShleGlzdGluZylcbiAgICAgID8gZXhpc3RpbmcuY29uY2F0KGhvb2spXG4gICAgICA6IFtleGlzdGluZywgaG9va11cbiAgICA6IFtob29rXVxufVxuXG4vKipcbiAqIFVwZGF0ZSBhIGhvdCBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdHxudWxsfSBuZXdPcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBuZXdUZW1wbGF0ZVxuICovXG5cbmV4cG9ydHMudXBkYXRlID0gZnVuY3Rpb24gKGlkLCBuZXdPcHRpb25zLCBuZXdUZW1wbGF0ZSkge1xuICB2YXIgcmVjb3JkID0gbWFwW2lkXVxuICAvLyBmb3JjZSBmdWxsLXJlbG9hZCBpZiBhbiBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IGlzIGFjdGl2ZSBidXQgaXMgbm90XG4gIC8vIG1hbmFnZWQgYnkgYSB2aWV3XG4gIGlmICghcmVjb3JkIHx8IChyZWNvcmQuaW5zdGFuY2VzLmxlbmd0aCAmJiAhcmVjb3JkLnZpZXdzLmxlbmd0aCkpIHtcbiAgICBjb25zb2xlLmxvZygnW0hNUl0gUm9vdCBvciBtYW51YWxseS1tb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCBtYXkgYmUgcmVxdWlyZWQuJylcbiAgICBpZiAoIWlzQnJvd3NlcmlmeSkge1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJyb3dzZXJpZnktaG1yIHNvbWVob3cgc2VuZHMgaW5jb21wbGV0ZSBidW5kbGUgaWYgd2UgcmVsb2FkIGhlcmVcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIWlzQnJvd3NlcmlmeSkge1xuICAgIC8vIGJyb3dzZXJpZnktaG1yIGFscmVhZHkgbG9ncyB0aGlzXG4gICAgY29uc29sZS5sb2coJ1tITVJdIFVwZGF0aW5nIGNvbXBvbmVudDogJyArIGZvcm1hdChpZCkpXG4gIH1cbiAgdmFyIENvbXBvbmVudCA9IHJlY29yZC5Db21wb25lbnRcbiAgLy8gdXBkYXRlIGNvbnN0cnVjdG9yXG4gIGlmIChuZXdPcHRpb25zKSB7XG4gICAgLy8gaW4gY2FzZSB0aGUgdXNlciBleHBvcnRzIGEgY29uc3RydWN0b3JcbiAgICBDb21wb25lbnQgPSByZWNvcmQuQ29tcG9uZW50ID0gdHlwZW9mIG5ld09wdGlvbnMgPT09ICdmdW5jdGlvbidcbiAgICAgID8gbmV3T3B0aW9uc1xuICAgICAgOiBWdWUuZXh0ZW5kKG5ld09wdGlvbnMpXG4gICAgbWFrZU9wdGlvbnNIb3QoaWQsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIGlmIChuZXdUZW1wbGF0ZSkge1xuICAgIENvbXBvbmVudC5vcHRpb25zLnRlbXBsYXRlID0gbmV3VGVtcGxhdGVcbiAgfVxuICAvLyBoYW5kbGUgcmVjdXJzaXZlIGxvb2t1cFxuICBpZiAoQ29tcG9uZW50Lm9wdGlvbnMubmFtZSkge1xuICAgIENvbXBvbmVudC5vcHRpb25zLmNvbXBvbmVudHNbQ29tcG9uZW50Lm9wdGlvbnMubmFtZV0gPSBDb21wb25lbnRcbiAgfVxuICAvLyByZXNldCBjb25zdHJ1Y3RvciBjYWNoZWQgbGlua2VyXG4gIENvbXBvbmVudC5saW5rZXIgPSBudWxsXG4gIC8vIHJlbG9hZCBhbGwgdmlld3NcbiAgcmVjb3JkLnZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHtcbiAgICB1cGRhdGVWaWV3KHZpZXcsIENvbXBvbmVudClcbiAgfSlcbiAgLy8gZmx1c2ggZGV2dG9vbHNcbiAgaWYgKHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fKSB7XG4gICAgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uZW1pdCgnZmx1c2gnKVxuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIGEgY29tcG9uZW50IHZpZXcgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gdmlld1xuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50XG4gKi9cblxuZnVuY3Rpb24gdXBkYXRlVmlldyAodmlldywgQ29tcG9uZW50KSB7XG4gIGlmICghdmlldy5fYm91bmQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2aWV3LkNvbXBvbmVudCA9IENvbXBvbmVudFxuICB2aWV3LmhvdFVwZGF0aW5nID0gdHJ1ZVxuICAvLyBkaXNhYmxlIHRyYW5zaXRpb25zXG4gIHZpZXcudm0uX2lzQ29tcGlsZWQgPSBmYWxzZVxuICAvLyBzYXZlIHN0YXRlXG4gIHZhciBzdGF0ZSA9IGV4dHJhY3RTdGF0ZSh2aWV3LmNoaWxkVk0pXG4gIC8vIHJlbW91bnQsIG1ha2Ugc3VyZSB0byBkaXNhYmxlIGtlZXAtYWxpdmVcbiAgdmFyIGtlZXBBbGl2ZSA9IHZpZXcua2VlcEFsaXZlXG4gIHZpZXcua2VlcEFsaXZlID0gZmFsc2VcbiAgdmlldy5tb3VudENvbXBvbmVudCgpXG4gIHZpZXcua2VlcEFsaXZlID0ga2VlcEFsaXZlXG4gIC8vIHJlc3RvcmUgc3RhdGVcbiAgcmVzdG9yZVN0YXRlKHZpZXcuY2hpbGRWTSwgc3RhdGUsIHRydWUpXG4gIC8vIHJlLWVhbmJsZSB0cmFuc2l0aW9uc1xuICB2aWV3LnZtLl9pc0NvbXBpbGVkID0gdHJ1ZVxuICB2aWV3LmhvdFVwZGF0aW5nID0gZmFsc2Vcbn1cblxuLyoqXG4gKiBFeHRyYWN0IHN0YXRlIGZyb20gYSBWdWUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdFN0YXRlICh2bSkge1xuICByZXR1cm4ge1xuICAgIGNpZDogdm0uY29uc3RydWN0b3IuY2lkLFxuICAgIGRhdGE6IHZtLiRkYXRhLFxuICAgIGNoaWxkcmVuOiB2bS4kY2hpbGRyZW4ubWFwKGV4dHJhY3RTdGF0ZSlcbiAgfVxufVxuXG4vKipcbiAqIFJlc3RvcmUgc3RhdGUgdG8gYSByZWxvYWRlZCBWdWUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqL1xuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGUgKHZtLCBzdGF0ZSwgaXNSb290KSB7XG4gIHZhciBvbGRBc3luY0NvbmZpZ1xuICBpZiAoaXNSb290KSB7XG4gICAgLy8gc2V0IFZ1ZSBpbnRvIHN5bmMgbW9kZSBkdXJpbmcgc3RhdGUgcmVoeWRyYXRpb25cbiAgICBvbGRBc3luY0NvbmZpZyA9IFZ1ZS5jb25maWcuYXN5bmNcbiAgICBWdWUuY29uZmlnLmFzeW5jID0gZmFsc2VcbiAgfVxuICAvLyBhY3R1YWwgcmVzdG9yZVxuICBpZiAoaXNSb290IHx8ICF2bS5fcHJvcHMpIHtcbiAgICB2bS4kZGF0YSA9IHN0YXRlLmRhdGFcbiAgfSBlbHNlIHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5kYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghdm0uX3Byb3BzW2tleV0pIHtcbiAgICAgICAgLy8gZm9yIG5vbi1yb290LCBvbmx5IHJlc3RvcmUgbm9uLXByb3BzIGZpZWxkc1xuICAgICAgICB2bS4kZGF0YVtrZXldID0gc3RhdGUuZGF0YVtrZXldXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICAvLyB2ZXJpZnkgY2hpbGQgY29uc2lzdGVuY3lcbiAgdmFyIGhhc1NhbWVDaGlsZHJlbiA9IHZtLiRjaGlsZHJlbi5ldmVyeShmdW5jdGlvbiAoYywgaSkge1xuICAgIHJldHVybiBzdGF0ZS5jaGlsZHJlbltpXSAmJiBzdGF0ZS5jaGlsZHJlbltpXS5jaWQgPT09IGMuY29uc3RydWN0b3IuY2lkXG4gIH0pXG4gIGlmIChoYXNTYW1lQ2hpbGRyZW4pIHtcbiAgICAvLyByZWh5ZHJhdGUgY2hpbGRyZW5cbiAgICB2bS4kY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgcmVzdG9yZVN0YXRlKGMsIHN0YXRlLmNoaWxkcmVuW2ldKVxuICAgIH0pXG4gIH1cbiAgaWYgKGlzUm9vdCkge1xuICAgIFZ1ZS5jb25maWcuYXN5bmMgPSBvbGRBc3luY0NvbmZpZ1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdCAoaWQpIHtcbiAgcmV0dXJuIGlkLm1hdGNoKC9bXlxcL10rXFwudnVlJC8pWzBdXG59XG4iLCIvKiFcbiAqIFZ1ZS5qcyB2MS4wLjE4XG4gKiAoYykgMjAxNiBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHNldChvYmosIGtleSwgdmFsKSB7XG4gIGlmIChoYXNPd24ob2JqLCBrZXkpKSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvYmouX2lzVnVlKSB7XG4gICAgc2V0KG9iai5fZGF0YSwga2V5LCB2YWwpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2IgPSBvYmouX19vYl9fO1xuICBpZiAoIW9iKSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9iLmNvbnZlcnQoa2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIGlmIChvYi52bXMpIHtcbiAgICB2YXIgaSA9IG9iLnZtcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZtID0gb2Iudm1zW2ldO1xuICAgICAgdm0uX3Byb3h5KGtleSk7XG4gICAgICB2bS5fZGlnZXN0KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24gZGVsKG9iaiwga2V5KSB7XG4gIGlmICghaGFzT3duKG9iaiwga2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkZWxldGUgb2JqW2tleV07XG4gIHZhciBvYiA9IG9iai5fX29iX187XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xuICBpZiAob2Iudm1zKSB7XG4gICAgdmFyIGkgPSBvYi52bXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciB2bSA9IG9iLnZtc1tpXTtcbiAgICAgIHZtLl91bnByb3h5KGtleSk7XG4gICAgICB2bS5fZGlnZXN0KCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgbGl0ZXJhbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnZhciBsaXRlcmFsVmFsdWVSRSA9IC9eXFxzPyh0cnVlfGZhbHNlfC0/W1xcZFxcLl0rfCdbXiddKid8XCJbXlwiXSpcIilcXHM/JC87XG5cbmZ1bmN0aW9uIGlzTGl0ZXJhbChleHApIHtcbiAgcmV0dXJuIGxpdGVyYWxWYWx1ZVJFLnRlc3QoZXhwKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGO1xufVxuXG4vKipcbiAqIEd1YXJkIHRleHQgb3V0cHV0LCBtYWtlIHN1cmUgdW5kZWZpbmVkIG91dHB1dHNcbiAqIGVtcHR5IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBfdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogQ2hlY2sgYW5kIGNvbnZlcnQgcG9zc2libGUgbnVtZXJpYyBzdHJpbmdzIHRvIG51bWJlcnNcbiAqIGJlZm9yZSBzZXR0aW5nIGJhY2sgdG8gZGF0YVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4geyp8TnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJzZWQgPSBOdW1iZXIodmFsdWUpO1xuICAgIHJldHVybiBpc05hTihwYXJzZWQpID8gdmFsdWUgOiBwYXJzZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IHN0cmluZyBib29sZWFuIGxpdGVyYWxzIGludG8gcmVhbCBib29sZWFucy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHsqfEJvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gdG9Cb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnID8gdHJ1ZSA6IHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBTdHJpcCBxdW90ZXMgZnJvbSBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZyB8IGZhbHNlfVxuICovXG5cbmZ1bmN0aW9uIHN0cmlwUXVvdGVzKHN0cikge1xuICB2YXIgYSA9IHN0ci5jaGFyQ29kZUF0KDApO1xuICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KHN0ci5sZW5ndGggLSAxKTtcbiAgcmV0dXJuIGEgPT09IGIgJiYgKGEgPT09IDB4MjIgfHwgYSA9PT0gMHgyNykgPyBzdHIuc2xpY2UoMSwgLTEpIDogc3RyO1xufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbG1pdGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgdG9VcHBlcik7XG59XG5cbmZ1bmN0aW9uIHRvVXBwZXIoXywgYykge1xuICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnO1xufVxuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBoeXBoZW5hdGVSRSA9IC8oW2EtelxcZF0pKFtBLVpdKS9nO1xuXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBoeXBoZW4vdW5kZXJzY29yZS9zbGFzaCBkZWxpbWl0ZXJlZCBuYW1lcyBpbnRvXG4gKiBjYW1lbGl6ZWQgY2xhc3NOYW1lcy5cbiAqXG4gKiBlLmcuIG15LWNvbXBvbmVudCA9PiBNeUNvbXBvbmVudFxuICogICAgICBzb21lX2Vsc2UgICAgPT4gU29tZUVsc2VcbiAqICAgICAgc29tZS9jb21wICAgID0+IFNvbWVDb21wXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXFwvXSkoXFx3KS9nO1xuXG5mdW5jdGlvbiBjbGFzc2lmeShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIHRvVXBwZXIpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gYmluZChmbiwgY3R4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbCA/IGwgPiAxID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpIDogZm4uY2FsbChjdHgsIGEpIDogZm4uY2FsbChjdHgpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXktbGlrZX0gbGlzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydF0gLSBzdGFydCBpbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tXG4gKi9cblxuZnVuY3Rpb24gZXh0ZW5kKHRvLCBmcm9tKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0b1trZXlzW2ldXSA9IGZyb21ba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBPQkpFQ1RfU1RSSU5HID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkc7XG59XG5cbi8qKlxuICogQXJyYXkgdHlwZSBjaGVjay5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VudW1lcmFibGVdXG4gKi9cblxuZnVuY3Rpb24gZGVmKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIERlYm91bmNlIGEgZnVuY3Rpb24gc28gaXQgb25seSBnZXRzIGNhbGxlZCBhZnRlciB0aGVcbiAqIGlucHV0IHN0b3BzIGFycml2aW5nIGFmdGVyIHRoZSBnaXZlbiB3YWl0IHBlcmlvZC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0ge051bWJlcn0gd2FpdFxuICogQHJldHVybiB7RnVuY3Rpb259IC0gdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIF9kZWJvdW5jZShmdW5jLCB3YWl0KSB7XG4gIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcbiAgdmFyIGxhdGVyID0gZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xuICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogTWFudWFsIGluZGV4T2YgYmVjYXVzZSBpdCdzIHNsaWdodGx5IGZhc3RlciB0aGFuXG4gKiBuYXRpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0geyp9IG9ialxuICovXG5cbmZ1bmN0aW9uIGluZGV4T2YoYXJyLCBvYmopIHtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogTWFrZSBhIGNhbmNlbGxhYmxlIHZlcnNpb24gb2YgYW4gYXN5bmMgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNhbmNlbGxhYmxlKGZuKSB7XG4gIHZhciBjYiA9IGZ1bmN0aW9uIGNiKCkge1xuICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG4gIGNiLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYi5jYW5jZWxsZWQgPSB0cnVlO1xuICB9O1xuICByZXR1cm4gY2I7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICByZXR1cm4gYSA9PSBiIHx8IChpc09iamVjdChhKSAmJiBpc09iamVjdChiKSA/IEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKSA6IGZhbHNlKTtcbiAgLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbn1cblxudmFyIGhhc1Byb3RvID0gKCdfX3Byb3RvX18nIGluIHt9KTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cpICE9PSAnW29iamVjdCBPYmplY3RdJztcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8vIFVBIHNuaWZmaW5nIGZvciB3b3JraW5nIGFyb3VuZCBicm93c2VyLXNwZWNpZmljIHF1aXJrc1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xuXG52YXIgdHJhbnNpdGlvblByb3AgPSB1bmRlZmluZWQ7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gdW5kZWZpbmVkO1xudmFyIGFuaW1hdGlvblByb3AgPSB1bmRlZmluZWQ7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSB1bmRlZmluZWQ7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUU5KSB7XG4gIHZhciBpc1dlYmtpdFRyYW5zID0gd2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZDtcbiAgdmFyIGlzV2Via2l0QW5pbSA9IHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkO1xuICB0cmFuc2l0aW9uUHJvcCA9IGlzV2Via2l0VHJhbnMgPyAnV2Via2l0VHJhbnNpdGlvbicgOiAndHJhbnNpdGlvbic7XG4gIHRyYW5zaXRpb25FbmRFdmVudCA9IGlzV2Via2l0VHJhbnMgPyAnd2Via2l0VHJhbnNpdGlvbkVuZCcgOiAndHJhbnNpdGlvbmVuZCc7XG4gIGFuaW1hdGlvblByb3AgPSBpc1dlYmtpdEFuaW0gPyAnV2Via2l0QW5pbWF0aW9uJyA6ICdhbmltYXRpb24nO1xuICBhbmltYXRpb25FbmRFdmVudCA9IGlzV2Via2l0QW5pbSA/ICd3ZWJraXRBbmltYXRpb25FbmQnIDogJ2FuaW1hdGlvbmVuZCc7XG59XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuIElkZWFsbHkgdGhpc1xuICogc2hvdWxkIGJlIGV4ZWN1dGVkIGFzIGEgbWljcm90YXNrLCBzbyB3ZSBsZXZlcmFnZVxuICogTXV0YXRpb25PYnNlcnZlciBpZiBpdCdzIGF2YWlsYWJsZSwgYW5kIGZhbGxiYWNrIHRvXG4gKiBzZXRUaW1lb3V0KDApLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gKi9cblxudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY291bnRlcik7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBjb3VudGVyO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gd2VicGFjayBhdHRlbXB0cyB0byBpbmplY3QgYSBzaGltIGZvciBzZXRJbW1lZGlhdGVcbiAgICAvLyBpZiBpdCBpcyB1c2VkIGFzIGEgZ2xvYmFsLCBzbyB3ZSBoYXZlIHRvIHdvcmsgYXJvdW5kIHRoYXQgdG9cbiAgICAvLyBhdm9pZCBidW5kbGluZyB1bm5lY2Vzc2FyeSBjb2RlLlxuICAgIHZhciBjb250ZXh0ID0gaW5Ccm93c2VyID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB7fTtcbiAgICB0aW1lckZ1bmMgPSBjb250ZXh0LnNldEltbWVkaWF0ZSB8fCBzZXRUaW1lb3V0O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoY2IsIGN0eCkge1xuICAgIHZhciBmdW5jID0gY3R4ID8gZnVuY3Rpb24gKCkge1xuICAgICAgY2IuY2FsbChjdHgpO1xuICAgIH0gOiBjYjtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jKTtcbiAgICBpZiAocGVuZGluZykgcmV0dXJuO1xuICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgIHRpbWVyRnVuYyhuZXh0VGlja0hhbmRsZXIsIDApO1xuICB9O1xufSkoKTtcblxuZnVuY3Rpb24gQ2FjaGUobGltaXQpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX2tleW1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbnZhciBwID0gQ2FjaGUucHJvdG90eXBlO1xuXG4vKipcbiAqIFB1dCA8dmFsdWU+IGludG8gdGhlIGNhY2hlIGFzc29jaWF0ZWQgd2l0aCA8a2V5Pi5cbiAqIFJldHVybnMgdGhlIGVudHJ5IHdoaWNoIHdhcyByZW1vdmVkIHRvIG1ha2Ugcm9vbSBmb3JcbiAqIHRoZSBuZXcgZW50cnkuIE90aGVyd2lzZSB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKiAoaS5lLiBpZiB0aGVyZSB3YXMgZW5vdWdoIHJvb20gYWxyZWFkeSkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7RW50cnl8dW5kZWZpbmVkfVxuICovXG5cbnAucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdmFyIHJlbW92ZWQ7XG4gIGlmICh0aGlzLnNpemUgPT09IHRoaXMubGltaXQpIHtcbiAgICByZW1vdmVkID0gdGhpcy5zaGlmdCgpO1xuICB9XG5cbiAgdmFyIGVudHJ5ID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgaWYgKCFlbnRyeSkge1xuICAgIGVudHJ5ID0ge1xuICAgICAga2V5OiBrZXlcbiAgICB9O1xuICAgIHRoaXMuX2tleW1hcFtrZXldID0gZW50cnk7XG4gICAgaWYgKHRoaXMudGFpbCkge1xuICAgICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnk7XG4gICAgICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgfVxuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuc2l6ZSsrO1xuICB9XG4gIGVudHJ5LnZhbHVlID0gdmFsdWU7XG5cbiAgcmV0dXJuIHJlbW92ZWQ7XG59O1xuXG4vKipcbiAqIFB1cmdlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIChvbGRlc3QpIGVudHJ5IGZyb20gdGhlXG4gKiBjYWNoZS4gUmV0dXJucyB0aGUgcmVtb3ZlZCBlbnRyeSBvciB1bmRlZmluZWQgaWYgdGhlXG4gKiBjYWNoZSB3YXMgZW1wdHkuXG4gKi9cblxucC5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVudHJ5ID0gdGhpcy5oZWFkO1xuICBpZiAoZW50cnkpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV3ZXI7XG4gICAgdGhpcy5oZWFkLm9sZGVyID0gdW5kZWZpbmVkO1xuICAgIGVudHJ5Lm5ld2VyID0gZW50cnkub2xkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fa2V5bWFwW2VudHJ5LmtleV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zaXplLS07XG4gIH1cbiAgcmV0dXJuIGVudHJ5O1xufTtcblxuLyoqXG4gKiBHZXQgYW5kIHJlZ2lzdGVyIHJlY2VudCB1c2Ugb2YgPGtleT4uIFJldHVybnMgdGhlIHZhbHVlXG4gKiBhc3NvY2lhdGVkIHdpdGggPGtleT4gb3IgdW5kZWZpbmVkIGlmIG5vdCBpbiBjYWNoZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkVudHJ5XG4gKiBAcmV0dXJuIHtFbnRyeXwqfVxuICovXG5cbnAuZ2V0ID0gZnVuY3Rpb24gKGtleSwgcmV0dXJuRW50cnkpIHtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fa2V5bWFwW2tleV07XG4gIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIGlmIChlbnRyeSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuIHJldHVybkVudHJ5ID8gZW50cnkgOiBlbnRyeS52YWx1ZTtcbiAgfVxuICAvLyBIRUFELS0tLS0tLS0tLS0tLS1UQUlMXG4gIC8vICAgPC5vbGRlciAgIC5uZXdlcj5cbiAgLy8gIDwtLS0gYWRkIGRpcmVjdGlvbiAtLVxuICAvLyAgIEEgIEIgIEMgIDxEPiAgRVxuICBpZiAoZW50cnkubmV3ZXIpIHtcbiAgICBpZiAoZW50cnkgPT09IHRoaXMuaGVhZCkge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gZW50cnkub2xkZXI7IC8vIEMgPC0tIEUuXG4gIH1cbiAgaWYgKGVudHJ5Lm9sZGVyKSB7XG4gICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjsgLy8gQy4gLS0+IEVcbiAgfVxuICBlbnRyeS5uZXdlciA9IHVuZGVmaW5lZDsgLy8gRCAtLXhcbiAgZW50cnkub2xkZXIgPSB0aGlzLnRhaWw7IC8vIEQuIC0tPiBFXG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV3ZXIgPSBlbnRyeTsgLy8gRS4gPC0tIERcbiAgfVxuICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgcmV0dXJuIHJldHVybkVudHJ5ID8gZW50cnkgOiBlbnRyeS52YWx1ZTtcbn07XG5cbnZhciBjYWNoZSQxID0gbmV3IENhY2hlKDEwMDApO1xudmFyIGZpbHRlclRva2VuUkUgPSAvW15cXHMnXCJdK3wnW14nXSonfFwiW15cIl0qXCIvZztcbnZhciByZXNlcnZlZEFyZ1JFID0gL15pbiR8Xi0/XFxkKy87XG5cbi8qKlxuICogUGFyc2VyIHN0YXRlXG4gKi9cblxudmFyIHN0cjtcbnZhciBkaXI7XG52YXIgYztcbnZhciBwcmV2O1xudmFyIGk7XG52YXIgbDtcbnZhciBsYXN0RmlsdGVySW5kZXg7XG52YXIgaW5TaW5nbGU7XG52YXIgaW5Eb3VibGU7XG52YXIgY3VybHk7XG52YXIgc3F1YXJlO1xudmFyIHBhcmVuO1xuLyoqXG4gKiBQdXNoIGEgZmlsdGVyIHRvIHRoZSBjdXJyZW50IGRpcmVjdGl2ZSBvYmplY3RcbiAqL1xuXG5mdW5jdGlvbiBwdXNoRmlsdGVyKCkge1xuICB2YXIgZXhwID0gc3RyLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpO1xuICB2YXIgZmlsdGVyO1xuICBpZiAoZXhwKSB7XG4gICAgZmlsdGVyID0ge307XG4gICAgdmFyIHRva2VucyA9IGV4cC5tYXRjaChmaWx0ZXJUb2tlblJFKTtcbiAgICBmaWx0ZXIubmFtZSA9IHRva2Vuc1swXTtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZpbHRlci5hcmdzID0gdG9rZW5zLnNsaWNlKDEpLm1hcChwcm9jZXNzRmlsdGVyQXJnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlcikge1xuICAgIChkaXIuZmlsdGVycyA9IGRpci5maWx0ZXJzIHx8IFtdKS5wdXNoKGZpbHRlcik7XG4gIH1cbiAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gYXJndW1lbnQgaXMgZHluYW1pYyBhbmQgc3RyaXAgcXVvdGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhcmdcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzRmlsdGVyQXJnKGFyZykge1xuICBpZiAocmVzZXJ2ZWRBcmdSRS50ZXN0KGFyZykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHRvTnVtYmVyKGFyZyksXG4gICAgICBkeW5hbWljOiBmYWxzZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0cmlwcGVkID0gc3RyaXBRdW90ZXMoYXJnKTtcbiAgICB2YXIgZHluYW1pYyA9IHN0cmlwcGVkID09PSBhcmc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBkeW5hbWljID8gYXJnIDogc3RyaXBwZWQsXG4gICAgICBkeW5hbWljOiBkeW5hbWljXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgZGlyZWN0aXZlIHZhbHVlIGFuZCBleHRyYWN0IHRoZSBleHByZXNzaW9uXG4gKiBhbmQgaXRzIGZpbHRlcnMgaW50byBhIGRlc2NyaXB0b3IuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBcImEgKyAxIHwgdXBwZXJjYXNlXCIgd2lsbCB5aWVsZDpcbiAqIHtcbiAqICAgZXhwcmVzc2lvbjogJ2EgKyAxJyxcbiAqICAgZmlsdGVyczogW1xuICogICAgIHsgbmFtZTogJ3VwcGVyY2FzZScsIGFyZ3M6IG51bGwgfVxuICogICBdXG4gKiB9XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlRGlyZWN0aXZlKHMpIHtcbiAgdmFyIGhpdCA9IGNhY2hlJDEuZ2V0KHMpO1xuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuXG4gIC8vIHJlc2V0IHBhcnNlciBzdGF0ZVxuICBzdHIgPSBzO1xuICBpblNpbmdsZSA9IGluRG91YmxlID0gZmFsc2U7XG4gIGN1cmx5ID0gc3F1YXJlID0gcGFyZW4gPSAwO1xuICBsYXN0RmlsdGVySW5kZXggPSAwO1xuICBkaXIgPSB7fTtcblxuICBmb3IgKGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIC8vIGNoZWNrIHNpbmdsZSBxdW90ZVxuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgaW5TaW5nbGUgPSAhaW5TaW5nbGU7XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgLy8gY2hlY2sgZG91YmxlIHF1b3RlXG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSBpbkRvdWJsZSA9ICFpbkRvdWJsZTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgIHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJiBzdHIuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MpIHtcbiAgICAgIGlmIChkaXIuZXhwcmVzc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGRpci5leHByZXNzaW9uID0gc3RyLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFscmVhZHkgaGFzIGZpbHRlclxuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6XG4gICAgICAgICAgaW5Eb3VibGUgPSB0cnVlO2JyZWFrOyAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6XG4gICAgICAgICAgaW5TaW5nbGUgPSB0cnVlO2JyZWFrOyAvLyAnXG4gICAgICAgIGNhc2UgMHgyODpcbiAgICAgICAgICBwYXJlbisrO2JyZWFrOyAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTpcbiAgICAgICAgICBwYXJlbi0tO2JyZWFrOyAvLyApXG4gICAgICAgIGNhc2UgMHg1QjpcbiAgICAgICAgICBzcXVhcmUrKzticmVhazsgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6XG4gICAgICAgICAgc3F1YXJlLS07YnJlYWs7IC8vIF1cbiAgICAgICAgY2FzZSAweDdCOlxuICAgICAgICAgIGN1cmx5Kys7YnJlYWs7IC8vIHtcbiAgICAgICAgY2FzZSAweDdEOlxuICAgICAgICAgIGN1cmx5LS07YnJlYWs7IC8vIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyLmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgIGRpci5leHByZXNzaW9uID0gc3RyLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBjYWNoZSQxLnB1dChzLCBkaXIpO1xuICByZXR1cm4gZGlyO1xufVxuXG52YXIgZGlyZWN0aXZlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHBhcnNlRGlyZWN0aXZlOiBwYXJzZURpcmVjdGl2ZVxufSk7XG5cbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcbnZhciBjYWNoZSA9IHVuZGVmaW5lZDtcbnZhciB0YWdSRSA9IHVuZGVmaW5lZDtcbnZhciBodG1sUkUgPSB1bmRlZmluZWQ7XG4vKipcbiAqIEVzY2FwZSBhIHN0cmluZyBzbyBpdCBjYW4gYmUgdXNlZCBpbiBhIFJlZ0V4cFxuICogY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xufVxuXG5mdW5jdGlvbiBjb21waWxlUmVnZXgoKSB7XG4gIHZhciBvcGVuID0gZXNjYXBlUmVnZXgoY29uZmlnLmRlbGltaXRlcnNbMF0pO1xuICB2YXIgY2xvc2UgPSBlc2NhcGVSZWdleChjb25maWcuZGVsaW1pdGVyc1sxXSk7XG4gIHZhciB1bnNhZmVPcGVuID0gZXNjYXBlUmVnZXgoY29uZmlnLnVuc2FmZURlbGltaXRlcnNbMF0pO1xuICB2YXIgdW5zYWZlQ2xvc2UgPSBlc2NhcGVSZWdleChjb25maWcudW5zYWZlRGVsaW1pdGVyc1sxXSk7XG4gIHRhZ1JFID0gbmV3IFJlZ0V4cCh1bnNhZmVPcGVuICsgJyguKz8pJyArIHVuc2FmZUNsb3NlICsgJ3wnICsgb3BlbiArICcoLis/KScgKyBjbG9zZSwgJ2cnKTtcbiAgaHRtbFJFID0gbmV3IFJlZ0V4cCgnXicgKyB1bnNhZmVPcGVuICsgJy4qJyArIHVuc2FmZUNsb3NlICsgJyQnKTtcbiAgLy8gcmVzZXQgY2FjaGVcbiAgY2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG59XG5cbi8qKlxuICogUGFyc2UgYSB0ZW1wbGF0ZSB0ZXh0IHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0PiB8IG51bGx9XG4gKiAgICAgICAgICAgICAgIC0ge1N0cmluZ30gdHlwZVxuICogICAgICAgICAgICAgICAtIHtTdHJpbmd9IHZhbHVlXG4gKiAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtodG1sXVxuICogICAgICAgICAgICAgICAtIHtCb29sZWFufSBbb25lVGltZV1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVRleHQodGV4dCkge1xuICBpZiAoIWNhY2hlKSB7XG4gICAgY29tcGlsZVJlZ2V4KCk7XG4gIH1cbiAgdmFyIGhpdCA9IGNhY2hlLmdldCh0ZXh0KTtcbiAgaWYgKGhpdCkge1xuICAgIHJldHVybiBoaXQ7XG4gIH1cbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxuL2csICcnKTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleCwgaHRtbCwgdmFsdWUsIGZpcnN0LCBvbmVUaW1lO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICB3aGlsZSAobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHZhbHVlOiB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgaHRtbCA9IGh0bWxSRS50ZXN0KG1hdGNoWzBdKTtcbiAgICB2YWx1ZSA9IGh0bWwgPyBtYXRjaFsxXSA6IG1hdGNoWzJdO1xuICAgIGZpcnN0ID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICBvbmVUaW1lID0gZmlyc3QgPT09IDQyOyAvLyAqXG4gICAgdmFsdWUgPSBvbmVUaW1lID8gdmFsdWUuc2xpY2UoMSkgOiB2YWx1ZTtcbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICB0YWc6IHRydWUsXG4gICAgICB2YWx1ZTogdmFsdWUudHJpbSgpLFxuICAgICAgaHRtbDogaHRtbCxcbiAgICAgIG9uZVRpbWU6IG9uZVRpbWVcbiAgICB9KTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICB2YWx1ZTogdGV4dC5zbGljZShsYXN0SW5kZXgpXG4gICAgfSk7XG4gIH1cbiAgY2FjaGUucHV0KHRleHQsIHRva2Vucyk7XG4gIHJldHVybiB0b2tlbnM7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgbGlzdCBvZiB0b2tlbnMgaW50byBhbiBleHByZXNzaW9uLlxuICogZS5nLiB0b2tlbnMgcGFyc2VkIGZyb20gJ2Ege3tifX0gYycgY2FuIGJlIHNlcmlhbGl6ZWRcbiAqIGludG8gb25lIHNpbmdsZSBleHByZXNzaW9uIGFzICdcImEgXCIgKyBiICsgXCIgY1wiJy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0b2tlbnNcbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gdG9rZW5zVG9FeHAodG9rZW5zLCB2bSkge1xuICBpZiAodG9rZW5zLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgIHJldHVybiBmb3JtYXRUb2tlbih0b2tlbiwgdm0pO1xuICAgIH0pLmpvaW4oJysnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZm9ybWF0VG9rZW4odG9rZW5zWzBdLCB2bSwgdHJ1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBzaW5nbGUgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHBhcmFtIHtCb29sZWFufSBbc2luZ2xlXVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFRva2VuKHRva2VuLCB2bSwgc2luZ2xlKSB7XG4gIHJldHVybiB0b2tlbi50YWcgPyB0b2tlbi5vbmVUaW1lICYmIHZtID8gJ1wiJyArIHZtLiRldmFsKHRva2VuLnZhbHVlKSArICdcIicgOiBpbmxpbmVGaWx0ZXJzKHRva2VuLnZhbHVlLCBzaW5nbGUpIDogJ1wiJyArIHRva2VuLnZhbHVlICsgJ1wiJztcbn1cblxuLyoqXG4gKiBGb3IgYW4gYXR0cmlidXRlIHdpdGggbXVsdGlwbGUgaW50ZXJwb2xhdGlvbiB0YWdzLFxuICogZS5nLiBhdHRyPVwic29tZS17e3RoaW5nIHwgZmlsdGVyfX1cIiwgaW4gb3JkZXIgdG8gY29tYmluZVxuICogdGhlIHdob2xlIHRoaW5nIGludG8gYSBzaW5nbGUgd2F0Y2hhYmxlIGV4cHJlc3Npb24sIHdlXG4gKiBoYXZlIHRvIGlubGluZSB0aG9zZSBmaWx0ZXJzLiBUaGlzIGZ1bmN0aW9uIGRvZXMgZXhhY3RseVxuICogdGhhdC4gVGhpcyBpcyBhIGJpdCBoYWNreSBidXQgaXQgYXZvaWRzIGhlYXZ5IGNoYW5nZXNcbiAqIHRvIGRpcmVjdGl2ZSBwYXJzZXIgYW5kIHdhdGNoZXIgbWVjaGFuaXNtLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2luZ2xlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIGZpbHRlclJFID0gL1tefF1cXHxbXnxdLztcbmZ1bmN0aW9uIGlubGluZUZpbHRlcnMoZXhwLCBzaW5nbGUpIHtcbiAgaWYgKCFmaWx0ZXJSRS50ZXN0KGV4cCkpIHtcbiAgICByZXR1cm4gc2luZ2xlID8gZXhwIDogJygnICsgZXhwICsgJyknO1xuICB9IGVsc2Uge1xuICAgIHZhciBkaXIgPSBwYXJzZURpcmVjdGl2ZShleHApO1xuICAgIGlmICghZGlyLmZpbHRlcnMpIHtcbiAgICAgIHJldHVybiAnKCcgKyBleHAgKyAnKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAndGhpcy5fYXBwbHlGaWx0ZXJzKCcgKyBkaXIuZXhwcmVzc2lvbiArIC8vIHZhbHVlXG4gICAgICAnLG51bGwsJyArIC8vIG9sZFZhbHVlIChudWxsIGZvciByZWFkKVxuICAgICAgSlNPTi5zdHJpbmdpZnkoZGlyLmZpbHRlcnMpICsgLy8gZmlsdGVyIGRlc2NyaXB0b3JzXG4gICAgICAnLGZhbHNlKSc7IC8vIHdyaXRlP1xuICAgIH1cbiAgfVxufVxuXG52YXIgdGV4dCA9IE9iamVjdC5mcmVlemUoe1xuICBjb21waWxlUmVnZXg6IGNvbXBpbGVSZWdleCxcbiAgcGFyc2VUZXh0OiBwYXJzZVRleHQsXG4gIHRva2Vuc1RvRXhwOiB0b2tlbnNUb0V4cFxufSk7XG5cbnZhciBkZWxpbWl0ZXJzID0gWyd7eycsICd9fSddO1xudmFyIHVuc2FmZURlbGltaXRlcnMgPSBbJ3t7eycsICd9fX0nXTtcblxudmFyIGNvbmZpZyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHtcblxuICAvKipcbiAgICogV2hldGhlciB0byBwcmludCBkZWJ1ZyBtZXNzYWdlcy5cbiAgICogQWxzbyBlbmFibGVzIHN0YWNrIHRyYWNlIGZvciB3YXJuaW5ncy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIGRlYnVnOiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdXNlIGFzeW5jIHJlbmRlcmluZy5cbiAgICovXG5cbiAgYXN5bmM6IHRydWUsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gd2FybiBhZ2FpbnN0IGVycm9ycyBjYXVnaHQgd2hlbiBldmFsdWF0aW5nXG4gICAqIGV4cHJlc3Npb25zLlxuICAgKi9cblxuICB3YXJuRXhwcmVzc2lvbkVycm9yczogdHJ1ZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBhbGxvdyBkZXZ0b29scyBpbnNwZWN0aW9uLlxuICAgKiBEaXNhYmxlZCBieSBkZWZhdWx0IGluIHByb2R1Y3Rpb24gYnVpbGRzLlxuICAgKi9cblxuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogSW50ZXJuYWwgZmxhZyB0byBpbmRpY2F0ZSB0aGUgZGVsaW1pdGVycyBoYXZlIGJlZW5cbiAgICogY2hhbmdlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIF9kZWxpbWl0ZXJzQ2hhbmdlZDogdHJ1ZSxcblxuICAvKipcbiAgICogTGlzdCBvZiBhc3NldCB0eXBlcyB0aGF0IGEgY29tcG9uZW50IGNhbiBvd24uXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG5cbiAgX2Fzc2V0VHlwZXM6IFsnY29tcG9uZW50JywgJ2RpcmVjdGl2ZScsICdlbGVtZW50RGlyZWN0aXZlJywgJ2ZpbHRlcicsICd0cmFuc2l0aW9uJywgJ3BhcnRpYWwnXSxcblxuICAvKipcbiAgICogcHJvcCBiaW5kaW5nIG1vZGVzXG4gICAqL1xuXG4gIF9wcm9wQmluZGluZ01vZGVzOiB7XG4gICAgT05FX1dBWTogMCxcbiAgICBUV09fV0FZOiAxLFxuICAgIE9ORV9USU1FOiAyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1heCBjaXJjdWxhciB1cGRhdGVzIGFsbG93ZWQgaW4gYSBiYXRjaGVyIGZsdXNoIGN5Y2xlLlxuICAgKi9cblxuICBfbWF4VXBkYXRlQ291bnQ6IDEwMFxuXG59LCB7XG4gIGRlbGltaXRlcnM6IHsgLyoqXG4gICAgICAgICAgICAgICAgICogSW50ZXJwb2xhdGlvbiBkZWxpbWl0ZXJzLiBDaGFuZ2luZyB0aGVzZSB3b3VsZCB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICogdGhlIHRleHQgcGFyc2VyIHRvIHJlLWNvbXBpbGUgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXk8U3RyaW5nPn1cbiAgICAgICAgICAgICAgICAgKi9cblxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGRlbGltaXRlcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgIGRlbGltaXRlcnMgPSB2YWw7XG4gICAgICBjb21waWxlUmVnZXgoKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0sXG4gIHVuc2FmZURlbGltaXRlcnM6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB1bnNhZmVEZWxpbWl0ZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICB1bnNhZmVEZWxpbWl0ZXJzID0gdmFsO1xuICAgICAgY29tcGlsZVJlZ2V4KCk7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9XG59KTtcblxudmFyIHdhcm4gPSB1bmRlZmluZWQ7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIGUpIHtcbiAgICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCB8fCBjb25maWcuZGVidWcpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW1Z1ZSB3YXJuXTogJyArIG1zZyk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoY29uZmlnLmRlYnVnKSB7XG4gICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihuZXcgRXJyb3IoJ1dhcm5pbmcgU3RhY2sgVHJhY2UnKS5zdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbn1cblxuLyoqXG4gKiBBcHBlbmQgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiBhcHBlbmRXaXRoVHJhbnNpdGlvbihlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgYXBwbHlUcmFuc2l0aW9uKGVsLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgfSwgdm0sIGNiKTtcbn1cblxuLyoqXG4gKiBJbnNlcnRCZWZvcmUgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiBiZWZvcmVXaXRoVHJhbnNpdGlvbihlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgYXBwbHlUcmFuc2l0aW9uKGVsLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQpO1xuICB9LCB2bSwgY2IpO1xufVxuXG4vKipcbiAqIFJlbW92ZSB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlV2l0aFRyYW5zaXRpb24oZWwsIHZtLCBjYikge1xuICBhcHBseVRyYW5zaXRpb24oZWwsIC0xLCBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlKGVsKTtcbiAgfSwgdm0sIGNiKTtcbn1cblxuLyoqXG4gKiBBcHBseSB0cmFuc2l0aW9ucyB3aXRoIGFuIG9wZXJhdGlvbiBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uXG4gKiAgICAgICAgICAgICAgICAgIDE6IGVudGVyXG4gKiAgICAgICAgICAgICAgICAgLTE6IGxlYXZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHRoZSBhY3R1YWwgRE9NIG9wZXJhdGlvblxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2l0aW9uKGVsLCBkaXJlY3Rpb24sIG9wLCB2bSwgY2IpIHtcbiAgdmFyIHRyYW5zaXRpb24gPSBlbC5fX3ZfdHJhbnM7XG4gIGlmICghdHJhbnNpdGlvbiB8fFxuICAvLyBza2lwIGlmIHRoZXJlIGFyZSBubyBqcyBob29rcyBhbmQgQ1NTIHRyYW5zaXRpb24gaXNcbiAgLy8gbm90IHN1cHBvcnRlZFxuICAhdHJhbnNpdGlvbi5ob29rcyAmJiAhdHJhbnNpdGlvbkVuZEV2ZW50IHx8XG4gIC8vIHNraXAgdHJhbnNpdGlvbnMgZm9yIGluaXRpYWwgY29tcGlsZVxuICAhdm0uX2lzQ29tcGlsZWQgfHxcbiAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIG1hbmlwdWxhdGVkIGJ5IGEgcGFyZW50IGRpcmVjdGl2ZVxuICAvLyBkdXJpbmcgdGhlIHBhcmVudCdzIGNvbXBpbGF0aW9uIHBoYXNlLCBza2lwIHRoZVxuICAvLyBhbmltYXRpb24uXG4gIHZtLiRwYXJlbnQgJiYgIXZtLiRwYXJlbnQuX2lzQ29tcGlsZWQpIHtcbiAgICBvcCgpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGFjdGlvbiA9IGRpcmVjdGlvbiA+IDAgPyAnZW50ZXInIDogJ2xlYXZlJztcbiAgdHJhbnNpdGlvblthY3Rpb25dKG9wLCBjYik7XG59XG5cbnZhciB0cmFuc2l0aW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGFwcGVuZFdpdGhUcmFuc2l0aW9uOiBhcHBlbmRXaXRoVHJhbnNpdGlvbixcbiAgYmVmb3JlV2l0aFRyYW5zaXRpb246IGJlZm9yZVdpdGhUcmFuc2l0aW9uLFxuICByZW1vdmVXaXRoVHJhbnNpdGlvbjogcmVtb3ZlV2l0aFRyYW5zaXRpb24sXG4gIGFwcGx5VHJhbnNpdGlvbjogYXBwbHlUcmFuc2l0aW9uXG59KTtcblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBxdWVyeShlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RvciA9IGVsO1xuICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgc2VsZWN0b3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAqIE5vdGU6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyBzaG91bGQgd29yayBoZXJlXG4gKiBidXQgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGNvbW1lbnQgbm9kZXMgaW4gcGhhbnRvbWpzLFxuICogbWFraW5nIHVuaXQgdGVzdHMgZGlmZmljdWx0LiBUaGlzIGlzIGZpeGVkIGJ5IGRvaW5nIHRoZVxuICogY29udGFpbnMoKSBjaGVjayBvbiB0aGUgbm9kZSdzIHBhcmVudE5vZGUgaW5zdGVhZCBvZlxuICogdGhlIG5vZGUgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpbkRvYyhub2RlKSB7XG4gIHZhciBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBwYXJlbnQgPSBub2RlICYmIG5vZGUucGFyZW50Tm9kZTtcbiAgcmV0dXJuIGRvYyA9PT0gbm9kZSB8fCBkb2MgPT09IHBhcmVudCB8fCAhIShwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxICYmIGRvYy5jb250YWlucyhwYXJlbnQpKTtcbn1cblxuLyoqXG4gKiBHZXQgYW5kIHJlbW92ZSBhbiBhdHRyaWJ1dGUgZnJvbSBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gX2F0dHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRBdHRyKG5vZGUsIF9hdHRyKSB7XG4gIHZhciB2YWwgPSBub2RlLmdldEF0dHJpYnV0ZShfYXR0cik7XG4gIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShfYXR0cik7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBHZXQgYW4gYXR0cmlidXRlIHdpdGggY29sb24gb3Igdi1iaW5kOiBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cblxuZnVuY3Rpb24gZ2V0QmluZEF0dHIobm9kZSwgbmFtZSkge1xuICB2YXIgdmFsID0gZ2V0QXR0cihub2RlLCAnOicgKyBuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHZhbCA9IGdldEF0dHIobm9kZSwgJ3YtYmluZDonICsgbmFtZSk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBDaGVjayB0aGUgcHJlc2VuY2Ugb2YgYSBiaW5kIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmRBdHRyKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuaGFzQXR0cmlidXRlKG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKCc6JyArIG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2LWJpbmQ6JyArIG5hbWUpO1xufVxuXG4vKipcbiAqIEluc2VydCBlbCBiZWZvcmUgdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBiZWZvcmUoZWwsIHRhcmdldCkge1xuICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHRhcmdldCk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGVsIGFmdGVyIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gYWZ0ZXIoZWwsIHRhcmdldCkge1xuICBpZiAodGFyZ2V0Lm5leHRTaWJsaW5nKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQubmV4dFNpYmxpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBlbCBmcm9tIERPTVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmUoZWwpIHtcbiAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG59XG5cbi8qKlxuICogUHJlcGVuZCBlbCB0byB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICovXG5cbmZ1bmN0aW9uIHByZXBlbmQoZWwsIHRhcmdldCkge1xuICBpZiAodGFyZ2V0LmZpcnN0Q2hpbGQpIHtcbiAgICBiZWZvcmUoZWwsIHRhcmdldC5maXJzdENoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG59XG5cbi8qKlxuICogUmVwbGFjZSB0YXJnZXQgd2l0aCBlbFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZnVuY3Rpb24gcmVwbGFjZSh0YXJnZXQsIGVsKSB7XG4gIHZhciBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoZWwsIHRhcmdldCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXIgc2hvcnRoYW5kLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdXG4gKi9cblxuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBjYiwgdXNlQ2FwdHVyZSkge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYiwgdXNlQ2FwdHVyZSk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIHNob3J0aGFuZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZnVuY3Rpb24gb2ZmKGVsLCBldmVudCwgY2IpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2IpO1xufVxuXG4vKipcbiAqIEluIElFOSwgc2V0QXR0cmlidXRlKCdjbGFzcycpIHdpbGwgcmVzdWx0IGluIGVtcHR5IGNsYXNzXG4gKiBpZiB0aGUgZWxlbWVudCBhbHNvIGhhcyB0aGUgOmNsYXNzIGF0dHJpYnV0ZTsgSG93ZXZlciBpblxuICogUGhhbnRvbUpTLCBzZXR0aW5nIGBjbGFzc05hbWVgIGRvZXMgbm90IHdvcmsgb24gU1ZHIGVsZW1lbnRzLi4uXG4gKiBTbyB3ZSBoYXZlIHRvIGRvIGEgY29uZGl0aW9uYWwgY2hlY2sgaGVyZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gKi9cblxuZnVuY3Rpb24gc2V0Q2xhc3MoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5ICYmICEvc3ZnJC8udGVzdChlbC5uYW1lc3BhY2VVUkkpKSB7XG4gICAgZWwuY2xhc3NOYW1lID0gY2xzO1xuICB9IGVsc2Uge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gKi9cblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNscykge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSAnICcgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArICcgJztcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIHNldENsYXNzKGVsLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIElFICYgU1ZHXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICovXG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbHMpIHtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyAnICc7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIHNldENsYXNzKGVsLCBjdXIudHJpbSgpKTtcbiAgfVxuICBpZiAoIWVsLmNsYXNzTmFtZSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgcmF3IGNvbnRlbnQgaW5zaWRlIGFuIGVsZW1lbnQgaW50byBhIHRlbXBvcmFyeVxuICogY29udGFpbmVyIGRpdlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYXNGcmFnbWVudFxuICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RDb250ZW50KGVsLCBhc0ZyYWdtZW50KSB7XG4gIHZhciBjaGlsZDtcbiAgdmFyIHJhd0NvbnRlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNUZW1wbGF0ZShlbCkgJiYgaXNGcmFnbWVudChlbC5jb250ZW50KSkge1xuICAgIGVsID0gZWwuY29udGVudDtcbiAgfVxuICBpZiAoZWwuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgdHJpbU5vZGUoZWwpO1xuICAgIHJhd0NvbnRlbnQgPSBhc0ZyYWdtZW50ID8gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICB3aGlsZSAoY2hpbGQgPSBlbC5maXJzdENoaWxkKSB7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgICByYXdDb250ZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhd0NvbnRlbnQ7XG59XG5cbi8qKlxuICogVHJpbSBwb3NzaWJsZSBlbXB0eSBoZWFkL3RhaWwgdGV4dCBhbmQgY29tbWVudFxuICogbm9kZXMgaW5zaWRlIGEgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICovXG5cbmZ1bmN0aW9uIHRyaW1Ob2RlKG5vZGUpIHtcbiAgdmFyIGNoaWxkO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZXF1ZW5jZXMgKi9cbiAgd2hpbGUgKChjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCwgaXNUcmltbWFibGUoY2hpbGQpKSkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG4gIHdoaWxlICgoY2hpbGQgPSBub2RlLmxhc3RDaGlsZCwgaXNUcmltbWFibGUoY2hpbGQpKSkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tc2VxdWVuY2VzICovXG59XG5cbmZ1bmN0aW9uIGlzVHJpbW1hYmxlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IDMgJiYgIW5vZGUuZGF0YS50cmltKCkgfHwgbm9kZS5ub2RlVHlwZSA9PT0gOCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIHRlbXBsYXRlIHRhZy5cbiAqIE5vdGUgaWYgdGhlIHRlbXBsYXRlIGFwcGVhcnMgaW5zaWRlIGFuIFNWRyBpdHMgdGFnTmFtZVxuICogd2lsbCBiZSBpbiBsb3dlcmNhc2UuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmZ1bmN0aW9uIGlzVGVtcGxhdGUoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGVtcGxhdGUnO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBcImFuY2hvclwiIGZvciBwZXJmb3JtaW5nIGRvbSBpbnNlcnRpb24vcmVtb3ZhbHMuXG4gKiBUaGlzIGlzIHVzZWQgaW4gYSBudW1iZXIgb2Ygc2NlbmFyaW9zOlxuICogLSBmcmFnbWVudCBpbnN0YW5jZVxuICogLSB2LWh0bWxcbiAqIC0gdi1pZlxuICogLSB2LWZvclxuICogLSBjb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtCb29sZWFufSBwZXJzaXN0IC0gSUUgdHJhc2hlcyBlbXB0eSB0ZXh0Tm9kZXMgb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lTm9kZSh0cnVlKSwgc28gaW4gY2VydGFpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZXMgdGhlIGFuY2hvciBuZWVkcyB0byBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uLWVtcHR5IHRvIGJlIHBlcnNpc3RlZCBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLlxuICogQHJldHVybiB7Q29tbWVudHxUZXh0fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUFuY2hvcihjb250ZW50LCBwZXJzaXN0KSB7XG4gIHZhciBhbmNob3IgPSBjb25maWcuZGVidWcgPyBkb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRlbnQpIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGVyc2lzdCA/ICcgJyA6ICcnKTtcbiAgYW5jaG9yLl9fdl9hbmNob3IgPSB0cnVlO1xuICByZXR1cm4gYW5jaG9yO1xufVxuXG4vKipcbiAqIEZpbmQgYSBjb21wb25lbnQgcmVmIGF0dHJpYnV0ZSB0aGF0IHN0YXJ0cyB3aXRoICQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd8dW5kZWZpbmVkfVxuICovXG5cbnZhciByZWZSRSA9IC9edi1yZWY6LztcblxuZnVuY3Rpb24gZmluZFJlZihub2RlKSB7XG4gIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgaWYgKHJlZlJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGNhbWVsaXplKG5hbWUucmVwbGFjZShyZWZSRSwgJycpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYXAgYSBmdW5jdGlvbiB0byBhIHJhbmdlIG9mIG5vZGVzIC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcFxuICovXG5cbmZ1bmN0aW9uIG1hcE5vZGVSYW5nZShub2RlLCBlbmQsIG9wKSB7XG4gIHZhciBuZXh0O1xuICB3aGlsZSAobm9kZSAhPT0gZW5kKSB7XG4gICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgb3Aobm9kZSk7XG4gICAgbm9kZSA9IG5leHQ7XG4gIH1cbiAgb3AoZW5kKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSByYW5nZSBvZiBub2RlcyB3aXRoIHRyYW5zaXRpb24sIHN0b3JlXG4gKiB0aGUgbm9kZXMgaW4gYSBmcmFnbWVudCB3aXRoIGNvcnJlY3Qgb3JkZXJpbmcsXG4gKiBhbmQgY2FsbCBjYWxsYmFjayB3aGVuIGRvbmUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBzdGFydFxuICogQHBhcmFtIHtOb2RlfSBlbmRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBmcmFnXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGVSYW5nZShzdGFydCwgZW5kLCB2bSwgZnJhZywgY2IpIHtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdmFyIHJlbW92ZWQgPSAwO1xuICB2YXIgbm9kZXMgPSBbXTtcbiAgbWFwTm9kZVJhbmdlKHN0YXJ0LCBlbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVuZCkgZG9uZSA9IHRydWU7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgICByZW1vdmVXaXRoVHJhbnNpdGlvbihub2RlLCB2bSwgb25SZW1vdmVkKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIG9uUmVtb3ZlZCgpIHtcbiAgICByZW1vdmVkKys7XG4gICAgaWYgKGRvbmUgJiYgcmVtb3ZlZCA+PSBub2Rlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgICBjYiAmJiBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIERvY3VtZW50RnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzRnJhZ21lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAxMTtcbn1cblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldE91dGVySFRNTChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG4gIH1cbn1cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERlcCgpIHtcbiAgdGhpcy5pZCA9IHVpZCQxKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufVxuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xuXG4vKipcbiAqIEFkZCBhIGRpcmVjdGl2ZSBzdWJzY3JpYmVyLlxuICpcbiAqIEBwYXJhbSB7RGlyZWN0aXZlfSBzdWJcbiAqL1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgZGlyZWN0aXZlIHN1YnNjcmliZXIuXG4gKlxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHN1YlxuICovXG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gKHN1Yikge1xuICB0aGlzLnN1YnMuJHJlbW92ZShzdWIpO1xufTtcblxuLyoqXG4gKiBBZGQgc2VsZiBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRhcmdldCB3YXRjaGVyLlxuICovXG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbn07XG5cbi8qKlxuICogTm90aWZ5IGFsbCBzdWJzY3JpYmVycyBvZiBhIG5ldyB2YWx1ZS5cbiAqL1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gc3RhYmxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRvQXJyYXkodGhpcy5zdWJzKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90bylcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xuXG47WydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICd1bnNoaWZ0JywgJ3NwbGljZScsICdzb3J0JywgJ3JldmVyc2UnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yKCkge1xuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTtcbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aCBhIG5ldyB2YWx1ZVxuICogYW5kIGVtaXRzIGNvcnJlc3BvbmRpbmcgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Kn0gLSByZXBsYWNlZCBlbGVtZW50XG4gKi9cblxuZGVmKGFycmF5UHJvdG8sICckc2V0JywgZnVuY3Rpb24gJHNldChpbmRleCwgdmFsKSB7XG4gIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHRoaXMubGVuZ3RoID0gTnVtYmVyKGluZGV4KSArIDE7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAxLCB2YWwpWzBdO1xufSk7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBhdCBnaXZlbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuZGVmKGFycmF5UHJvdG8sICckcmVtb3ZlJywgZnVuY3Rpb24gJHJlbW92ZShpdGVtKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcywgaXRlbSk7XG4gIGlmIChpbmRleCA+IC0xKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufSk7XG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBPYnNlcnZlcih2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90byA/IHByb3RvQXVnbWVudCA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufVxuXG4vLyBJbnN0YW5jZSBtZXRob2RzXG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5jb252ZXJ0KGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhIHByb3BlcnR5IGludG8gZ2V0dGVyL3NldHRlciBzbyB3ZSBjYW4gZW1pdFxuICogdGhlIGV2ZW50cyB3aGVuIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZC9jaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgZGVmaW5lUmVhY3RpdmUodGhpcy52YWx1ZSwga2V5LCB2YWwpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gb3duZXIgdm0sIHNvIHRoYXQgd2hlbiAkc2V0LyRkZWxldGUgbXV0YXRpb25zXG4gKiBoYXBwZW4gd2UgY2FuIG5vdGlmeSBvd25lciB2bXMgdG8gcHJveHkgdGhlIGtleXMgYW5kXG4gKiBkaWdlc3QgdGhlIHdhdGNoZXJzLiBUaGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdGhlIG9iamVjdFxuICogaXMgb2JzZXJ2ZWQgYXMgYW4gaW5zdGFuY2UncyByb290ICRkYXRhLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5hZGRWbSA9IGZ1bmN0aW9uICh2bSkge1xuICAodGhpcy52bXMgfHwgKHRoaXMudm1zID0gW10pKS5wdXNoKHZtKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIG93bmVyIHZtLiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBvYmplY3QgaXNcbiAqIHN3YXBwZWQgb3V0IGFzIGFuIGluc3RhbmNlJ3MgJGRhdGEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5yZW1vdmVWbSA9IGZ1bmN0aW9uICh2bSkge1xuICB0aGlzLnZtcy4kcmVtb3ZlKHZtKTtcbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1xuICovXG5cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG9cbiAqL1xuXG5mdW5jdGlvbiBjb3B5QXVnbWVudCh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHJldHVybiB7T2JzZXJ2ZXJ8dW5kZWZpbmVkfVxuICogQHN0YXRpY1xuICovXG5cbmZ1bmN0aW9uIG9ic2VydmUodmFsdWUsIHZtKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKChpc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiYgIXZhbHVlLl9pc1Z1ZSkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAob2IgJiYgdm0pIHtcbiAgICBvYi5hZGRWbSh2bSk7XG4gIH1cbiAgcmV0dXJuIG9iO1xufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHtCb29sZWFufSBkb05vdE9ic2VydmVcbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZShvYmosIGtleSwgdmFsLCBkb05vdE9ic2VydmUpIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICAvLyBpZiBkb05vdE9ic2VydmUgaXMgdHJ1ZSwgb25seSB1c2UgdGhlIGNoaWxkIHZhbHVlIG9ic2VydmVyXG4gIC8vIGlmIGl0IGFscmVhZHkgZXhpc3RzLCBhbmQgZG8gbm90IGF0dGVtcHQgdG8gY3JlYXRlIGl0LlxuICAvLyB0aGlzIGFsbG93cyBmcmVlemluZyBhIGxhcmdlIG9iamVjdCBmcm9tIHRoZSByb290IGFuZFxuICAvLyBhdm9pZCB1bm5lY2Vzc2FyeSBvYnNlcnZhdGlvbiBpbnNpZGUgdi1mb3IgZnJhZ21lbnRzLlxuICB2YXIgY2hpbGRPYiA9IGRvTm90T2JzZXJ2ZSA/IGlzT2JqZWN0KHZhbCkgJiYgdmFsLl9fb2JfXyA6IG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlcigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yICh2YXIgZSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGUgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlcihuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSBkb05vdE9ic2VydmUgPyBpc09iamVjdChuZXdWYWwpICYmIG5ld1ZhbC5fX29iX18gOiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGNvbW1vblRhZ1JFID0gL14oZGl2fHB8c3BhbnxpbWd8YXxifGl8YnJ8dWx8b2x8bGl8aDF8aDJ8aDN8aDR8aDV8aDZ8Y29kZXxwcmV8dGFibGV8dGh8dGR8dHJ8Zm9ybXxsYWJlbHxpbnB1dHxzZWxlY3R8b3B0aW9ufG5hdnxhcnRpY2xlfHNlY3Rpb258aGVhZGVyfGZvb3RlcikkL2k7XG52YXIgcmVzZXJ2ZWRUYWdSRSA9IC9eKHNsb3R8cGFydGlhbHxjb21wb25lbnQpJC9pO1xuXG52YXIgaXNVbmtub3duRWxlbWVudCA9IHVuZGVmaW5lZDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlzVW5rbm93bkVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIHRhZykge1xuICAgIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICAgIHJldHVybiBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fCBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkgJiZcbiAgICAgICAgLy8gQ2hyb21lIHJldHVybnMgdW5rbm93biBmb3Igc2V2ZXJhbCBIVE1MNSBlbGVtZW50cy5cbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU0MDUyNlxuICAgICAgICAhL14oZGF0YXx0aW1lfHJ0Y3xyYikkLy50ZXN0KHRhZylcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSBjb21wb25lbnQsIGlmIHllcyByZXR1cm4gaXRzXG4gKiBjb21wb25lbnQgaWQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRBdHRyKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBoYXNBdHRycyA9IGVsLmhhc0F0dHJpYnV0ZXMoKTtcbiAgaWYgKCFjb21tb25UYWdSRS50ZXN0KHRhZykgJiYgIXJlc2VydmVkVGFnUkUudGVzdCh0YWcpKSB7XG4gICAgaWYgKHJlc29sdmVBc3NldChvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpIHtcbiAgICAgIHJldHVybiB7IGlkOiB0YWcgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzID0gaGFzQXR0cnMgJiYgZ2V0SXNCaW5kaW5nKGVsKTtcbiAgICAgIGlmIChpcykge1xuICAgICAgICByZXR1cm4gaXM7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkVGFnID0gb3B0aW9ucy5fY29tcG9uZW50TmFtZU1hcCAmJiBvcHRpb25zLl9jb21wb25lbnROYW1lTWFwW3RhZ107XG4gICAgICAgIGlmIChleHBlY3RlZFRhZykge1xuICAgICAgICAgIHdhcm4oJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSAnICsgJ2RpZCB5b3UgbWVhbiA8JyArIGV4cGVjdGVkVGFnICsgJz4/ICcgKyAnSFRNTCBpcyBjYXNlLWluc2Vuc2l0aXZlLCByZW1lbWJlciB0byB1c2Uga2ViYWItY2FzZSBpbiB0ZW1wbGF0ZXMuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNVbmtub3duRWxlbWVudChlbCwgdGFnKSkge1xuICAgICAgICAgIHdhcm4oJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgKyAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGhhc0F0dHJzKSB7XG4gICAgcmV0dXJuIGdldElzQmluZGluZyhlbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgXCJpc1wiIGJpbmRpbmcgZnJvbSBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gZ2V0SXNCaW5kaW5nKGVsKSB7XG4gIC8vIGR5bmFtaWMgc3ludGF4XG4gIHZhciBleHAgPSBnZXRBdHRyKGVsLCAnaXMnKTtcbiAgaWYgKGV4cCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHsgaWQ6IGV4cCB9O1xuICB9IGVsc2Uge1xuICAgIGV4cCA9IGdldEJpbmRBdHRyKGVsLCAnaXMnKTtcbiAgICBpZiAoZXhwICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGlkOiBleHAsIGR5bmFtaWM6IHRydWUgfTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wJ3MgaW5pdGlhbCB2YWx1ZSBvbiBhIHZtIGFuZCBpdHMgZGF0YSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSkge1xuICB2YXIga2V5ID0gcHJvcC5wYXRoO1xuICB2YWx1ZSA9IGNvZXJjZVByb3AocHJvcCwgdmFsdWUpO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcC5vcHRpb25zKTtcbiAgfVxuICBpZiAoYXNzZXJ0UHJvcChwcm9wLCB2YWx1ZSkpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCB2YWx1ZSwgdHJ1ZSAvKiBkb05vdE9ic2VydmUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUodm0sIG9wdGlvbnMpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihvcHRpb25zLCAnZGVmYXVsdCcpKSB7XG4gICAgLy8gYWJzZW50IGJvb2xlYW4gdmFsdWUgZGVmYXVsdHMgdG8gZmFsc2VcbiAgICByZXR1cm4gb3B0aW9ucy50eXBlID09PSBCb29sZWFuID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGRlZiA9IG9wdGlvbnNbJ2RlZmF1bHQnXTtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAoaXNPYmplY3QoZGVmKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignT2JqZWN0L0FycmF5IGFzIGRlZmF1bHQgcHJvcCB2YWx1ZXMgd2lsbCBiZSBzaGFyZWQgJyArICdhY3Jvc3MgbXVsdGlwbGUgaW5zdGFuY2VzLiBVc2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgKyAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlIGluc3RlYWQuJyk7XG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy50eXBlICE9PSBGdW5jdGlvbiA/IGRlZi5jYWxsKHZtKSA6IGRlZjtcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRQcm9wKHByb3AsIHZhbHVlKSB7XG4gIGlmICghcHJvcC5vcHRpb25zLnJlcXVpcmVkICYmICggLy8gbm9uLXJlcXVpcmVkXG4gIHByb3AucmF3ID09PSBudWxsIHx8IC8vIGFic2NlbnRcbiAgdmFsdWUgPT0gbnVsbCkgLy8gbnVsbCBvciB1bmRlZmluZWRcbiAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIHZhciBvcHRpb25zID0gcHJvcC5vcHRpb25zO1xuICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gU3RyaW5nKSB7XG4gICAgICBleHBlY3RlZFR5cGUgPSAnc3RyaW5nJztcbiAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBOdW1iZXIpIHtcbiAgICAgIGV4cGVjdGVkVHlwZSA9ICdudW1iZXInO1xuICAgICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQm9vbGVhbikge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nO1xuICAgICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEZ1bmN0aW9uKSB7XG4gICAgICBleHBlY3RlZFR5cGUgPSAnZnVuY3Rpb24nO1xuICAgICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBPYmplY3QpIHtcbiAgICAgIGV4cGVjdGVkVHlwZSA9ICdvYmplY3QnO1xuICAgICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEFycmF5KSB7XG4gICAgICBleHBlY3RlZFR5cGUgPSAnYXJyYXknO1xuICAgICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yICcgKyBwcm9wLnBhdGggKyAnPVwiJyArIHByb3AucmF3ICsgJ1wiLicgKyAnIEV4cGVjdGVkICcgKyBmb3JtYXRUeXBlKGV4cGVjdGVkVHlwZSkgKyAnLCBnb3QgJyArIGZvcm1hdFZhbHVlKHZhbHVlKSArICcuJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBvcHRpb25zLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciAnICsgcHJvcC5wYXRoICsgJz1cIicgKyBwcm9wLnJhdyArICdcIicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBGb3JjZSBwYXJzaW5nIHZhbHVlIHdpdGggY29lcmNlIG9wdGlvbi5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2VQcm9wKHByb3AsIHZhbHVlKSB7XG4gIHZhciBjb2VyY2UgPSBwcm9wLm9wdGlvbnMuY29lcmNlO1xuICBpZiAoIWNvZXJjZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvLyBjb2VyY2UgaXMgYSBmdW5jdGlvblxuICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VHlwZSh2YWwpIHtcbiAgcmV0dXJuIHZhbCA/IHZhbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbC5zbGljZSgxKSA6ICdjdXN0b20gdHlwZSc7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpO1xufVxuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqXG4gKiBBbGwgc3RyYXRlZ3kgZnVuY3Rpb25zIGZvbGxvdyB0aGUgc2FtZSBzaWduYXR1cmU6XG4gKlxuICogQHBhcmFtIHsqfSBwYXJlbnRWYWxcbiAqIEBwYXJhbSB7Kn0gY2hpbGRWYWxcbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKi9cblxudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlRGF0YSh0bywgZnJvbSkge1xuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgZm9yIChrZXkgaW4gZnJvbSkge1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh0b1ZhbCkgJiYgaXNPYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICsgJ2RlZmluaXRpb25zLicpO1xuICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKGNoaWxkVmFsLmNhbGwodGhpcyksIHBhcmVudFZhbC5jYWxsKHRoaXMpKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbigpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh2bSkgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh2bSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbFxuICovXG5cbnN0cmF0cy5lbCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICBpZiAoIXZtICYmIGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignVGhlIFwiZWxcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgKyAnZGVmaW5pdGlvbnMuJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZXQgPSBjaGlsZFZhbCB8fCBwYXJlbnRWYWw7XG4gIC8vIGludm9rZSB0aGUgZWxlbWVudCBmYWN0b3J5IGlmIHRoaXMgaXMgaW5zdGFuY2UgbWVyZ2VcbiAgcmV0dXJuIHZtICYmIHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgPyByZXQuY2FsbCh2bSkgOiByZXQ7XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwYXJhbSBhdHRyaWJ1dGVzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5cbnN0cmF0cy5pbml0ID0gc3RyYXRzLmNyZWF0ZWQgPSBzdHJhdHMucmVhZHkgPSBzdHJhdHMuYXR0YWNoZWQgPSBzdHJhdHMuZGV0YWNoZWQgPSBzdHJhdHMuYmVmb3JlQ29tcGlsZSA9IHN0cmF0cy5jb21waWxlZCA9IHN0cmF0cy5iZWZvcmVEZXN0cm95ID0gc3RyYXRzLmRlc3Ryb3llZCA9IHN0cmF0cy5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA/IHBhcmVudFZhbCA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpIDogaXNBcnJheShjaGlsZFZhbCkgPyBjaGlsZFZhbCA6IFtjaGlsZFZhbF0gOiBwYXJlbnRWYWw7XG59O1xuXG4vKipcbiAqIDAuMTEgZGVwcmVjYXRpb24gd2FybmluZ1xuICovXG5cbnN0cmF0cy5wYXJhbUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignXCJwYXJhbUF0dHJpYnV0ZXNcIiBvcHRpb24gaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiAwLjEyLiAnICsgJ1VzZSBcInByb3BzXCIgaW5zdGVhZC4nKTtcbn07XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VBc3NldHMocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwpO1xuICByZXR1cm4gY2hpbGRWYWwgPyBleHRlbmQocmVzLCBndWFyZEFycmF5QXNzZXRzKGNoaWxkVmFsKSkgOiByZXM7XG59XG5cbmNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogRXZlbnRzICYgV2F0Y2hlcnMuXG4gKlxuICogRXZlbnRzICYgd2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cblxuc3RyYXRzLndhdGNoID0gc3RyYXRzLmV2ZW50cyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWw7XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnQgPyBwYXJlbnQuY29uY2F0KGNoaWxkKSA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuXG5zdHJhdHMucHJvcHMgPSBzdHJhdHMubWV0aG9kcyA9IHN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWw7XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cblxudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIGRlZmF1bHRTdHJhdChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkID8gcGFyZW50VmFsIDogY2hpbGRWYWw7XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSBjb21wb25lbnQgb3B0aW9ucyBnZXQgY29udmVydGVkIHRvIGFjdHVhbFxuICogY29uc3RydWN0b3JzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRDb21wb25lbnRzKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBjb21wb25lbnRzID0gb3B0aW9ucy5jb21wb25lbnRzID0gZ3VhcmRBcnJheUFzc2V0cyhvcHRpb25zLmNvbXBvbmVudHMpO1xuICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyhjb21wb25lbnRzKTtcbiAgICB2YXIgZGVmO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFwID0gb3B0aW9ucy5fY29tcG9uZW50TmFtZU1hcCA9IHt9O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGlkcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBpZHNbaV07XG4gICAgICBpZiAoY29tbW9uVGFnUkUudGVzdChrZXkpIHx8IHJlc2VydmVkVGFnUkUudGVzdChrZXkpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICsgJ2lkOiAnICsga2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyByZWNvcmQgYSBhbGwgbG93ZXJjYXNlIDwtPiBrZWJhYi1jYXNlIG1hcHBpbmcgZm9yXG4gICAgICAvLyBwb3NzaWJsZSBjdXN0b20gZWxlbWVudCBjYXNlIGVycm9yIHdhcm5pbmdcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG1hcFtrZXkucmVwbGFjZSgvLS9nLCAnJykudG9Mb3dlckNhc2UoKV0gPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIGRlZiA9IGNvbXBvbmVudHNba2V5XTtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KGRlZikpIHtcbiAgICAgICAgY29tcG9uZW50c1trZXldID0gVnVlLmV4dGVuZChkZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGd1YXJkUHJvcHMob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICB2YXIgaSwgdmFsO1xuICBpZiAoaXNBcnJheShwcm9wcykpIHtcbiAgICBvcHRpb25zLnByb3BzID0ge307XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zLnByb3BzW3ZhbF0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh2YWwubmFtZSkge1xuICAgICAgICBvcHRpb25zLnByb3BzW3ZhbC5uYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNba2V5c1tpXV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wc1trZXlzW2ldXSA9IHsgdHlwZTogdmFsIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR3VhcmQgYW4gQXJyYXktZm9ybWF0IGFzc2V0cyBvcHRpb24gYW5kIGNvbnZlcnRlZCBpdFxuICogaW50byB0aGUga2V5LXZhbHVlIE9iamVjdCBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGFzc2V0c1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGd1YXJkQXJyYXlBc3NldHMoYXNzZXRzKSB7XG4gIGlmIChpc0FycmF5KGFzc2V0cykpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGkgPSBhc3NldHMubGVuZ3RoO1xuICAgIHZhciBhc3NldDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhc3NldCA9IGFzc2V0c1tpXTtcbiAgICAgIHZhciBpZCA9IHR5cGVvZiBhc3NldCA9PT0gJ2Z1bmN0aW9uJyA/IGFzc2V0Lm9wdGlvbnMgJiYgYXNzZXQub3B0aW9ucy5uYW1lIHx8IGFzc2V0LmlkIDogYXNzZXQubmFtZSB8fCBhc3NldC5pZDtcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdBcnJheS1zeW50YXggYXNzZXRzIG11c3QgcHJvdmlkZSBhIFwibmFtZVwiIG9yIFwiaWRcIiBmaWVsZC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1tpZF0gPSBhc3NldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXR1cm4gYXNzZXRzO1xufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtIHtPYmplY3R9IGNoaWxkXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXSAtIGlmIHZtIGlzIHByZXNlbnQsIGluZGljYXRlcyB0aGlzIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgIGFuIGluc3RhbnRpYXRpb24gbWVyZ2UuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQsIHZtKSB7XG4gIGd1YXJkQ29tcG9uZW50cyhjaGlsZCk7XG4gIGd1YXJkUHJvcHMoY2hpbGQpO1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEByZXR1cm4ge09iamVjdHxGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQob3B0aW9ucywgdHlwZSwgaWQpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICB2YXIgY2FtZWxpemVkSWQ7XG4gIHJldHVybiBhc3NldHNbaWRdIHx8XG4gIC8vIGNhbWVsQ2FzZSBJRFxuICBhc3NldHNbY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCldIHx8XG4gIC8vIFBhc2NhbCBDYXNlIElEXG4gIGFzc2V0c1tjYW1lbGl6ZWRJZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsaXplZElkLnNsaWNlKDEpXTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgYXNzZXQgZXhpc3RzXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0QXNzZXQodmFsLCB0eXBlLCBpZCkge1xuICBpZiAoIXZhbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUgKyAnOiAnICsgaWQpO1xuICB9XG59XG5cblxuXG52YXIgdXRpbCA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUsXG5cdHNldDogc2V0LFxuXHRkZWw6IGRlbCxcblx0aGFzT3duOiBoYXNPd24sXG5cdGlzTGl0ZXJhbDogaXNMaXRlcmFsLFxuXHRpc1Jlc2VydmVkOiBpc1Jlc2VydmVkLFxuXHRfdG9TdHJpbmc6IF90b1N0cmluZyxcblx0dG9OdW1iZXI6IHRvTnVtYmVyLFxuXHR0b0Jvb2xlYW46IHRvQm9vbGVhbixcblx0c3RyaXBRdW90ZXM6IHN0cmlwUXVvdGVzLFxuXHRjYW1lbGl6ZTogY2FtZWxpemUsXG5cdGh5cGhlbmF0ZTogaHlwaGVuYXRlLFxuXHRjbGFzc2lmeTogY2xhc3NpZnksXG5cdGJpbmQ6IGJpbmQsXG5cdHRvQXJyYXk6IHRvQXJyYXksXG5cdGV4dGVuZDogZXh0ZW5kLFxuXHRpc09iamVjdDogaXNPYmplY3QsXG5cdGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG5cdGRlZjogZGVmLFxuXHRkZWJvdW5jZTogX2RlYm91bmNlLFxuXHRpbmRleE9mOiBpbmRleE9mLFxuXHRjYW5jZWxsYWJsZTogY2FuY2VsbGFibGUsXG5cdGxvb3NlRXF1YWw6IGxvb3NlRXF1YWwsXG5cdGlzQXJyYXk6IGlzQXJyYXksXG5cdGhhc1Byb3RvOiBoYXNQcm90byxcblx0aW5Ccm93c2VyOiBpbkJyb3dzZXIsXG5cdGRldnRvb2xzOiBkZXZ0b29scyxcblx0aXNJRTk6IGlzSUU5LFxuXHRpc0FuZHJvaWQ6IGlzQW5kcm9pZCxcblx0Z2V0IHRyYW5zaXRpb25Qcm9wICgpIHsgcmV0dXJuIHRyYW5zaXRpb25Qcm9wOyB9LFxuXHRnZXQgdHJhbnNpdGlvbkVuZEV2ZW50ICgpIHsgcmV0dXJuIHRyYW5zaXRpb25FbmRFdmVudDsgfSxcblx0Z2V0IGFuaW1hdGlvblByb3AgKCkgeyByZXR1cm4gYW5pbWF0aW9uUHJvcDsgfSxcblx0Z2V0IGFuaW1hdGlvbkVuZEV2ZW50ICgpIHsgcmV0dXJuIGFuaW1hdGlvbkVuZEV2ZW50OyB9LFxuXHRuZXh0VGljazogbmV4dFRpY2ssXG5cdHF1ZXJ5OiBxdWVyeSxcblx0aW5Eb2M6IGluRG9jLFxuXHRnZXRBdHRyOiBnZXRBdHRyLFxuXHRnZXRCaW5kQXR0cjogZ2V0QmluZEF0dHIsXG5cdGhhc0JpbmRBdHRyOiBoYXNCaW5kQXR0cixcblx0YmVmb3JlOiBiZWZvcmUsXG5cdGFmdGVyOiBhZnRlcixcblx0cmVtb3ZlOiByZW1vdmUsXG5cdHByZXBlbmQ6IHByZXBlbmQsXG5cdHJlcGxhY2U6IHJlcGxhY2UsXG5cdG9uOiBvbixcblx0b2ZmOiBvZmYsXG5cdHNldENsYXNzOiBzZXRDbGFzcyxcblx0YWRkQ2xhc3M6IGFkZENsYXNzLFxuXHRyZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG5cdGV4dHJhY3RDb250ZW50OiBleHRyYWN0Q29udGVudCxcblx0dHJpbU5vZGU6IHRyaW1Ob2RlLFxuXHRpc1RlbXBsYXRlOiBpc1RlbXBsYXRlLFxuXHRjcmVhdGVBbmNob3I6IGNyZWF0ZUFuY2hvcixcblx0ZmluZFJlZjogZmluZFJlZixcblx0bWFwTm9kZVJhbmdlOiBtYXBOb2RlUmFuZ2UsXG5cdHJlbW92ZU5vZGVSYW5nZTogcmVtb3ZlTm9kZVJhbmdlLFxuXHRpc0ZyYWdtZW50OiBpc0ZyYWdtZW50LFxuXHRnZXRPdXRlckhUTUw6IGdldE91dGVySFRNTCxcblx0bWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG5cdHJlc29sdmVBc3NldDogcmVzb2x2ZUFzc2V0LFxuXHRhc3NlcnRBc3NldDogYXNzZXJ0QXNzZXQsXG5cdGNoZWNrQ29tcG9uZW50QXR0cjogY2hlY2tDb21wb25lbnRBdHRyLFxuXHRpbml0UHJvcDogaW5pdFByb3AsXG5cdGFzc2VydFByb3A6IGFzc2VydFByb3AsXG5cdGNvZXJjZVByb3A6IGNvZXJjZVByb3AsXG5cdGNvbW1vblRhZ1JFOiBjb21tb25UYWdSRSxcblx0cmVzZXJ2ZWRUYWdSRTogcmVzZXJ2ZWRUYWdSRSxcblx0Z2V0IHdhcm4gKCkgeyByZXR1cm4gd2FybjsgfVxufSk7XG5cbnZhciB1aWQgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogVGhlIG1haW4gaW5pdCBzZXF1ZW5jZS4gVGhpcyBpcyBjYWxsZWQgZm9yIGV2ZXJ5XG4gICAqIGluc3RhbmNlLCBpbmNsdWRpbmcgb25lcyB0aGF0IGFyZSBjcmVhdGVkIGZyb20gZXh0ZW5kZWRcbiAgICogY29uc3RydWN0b3JzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoaXMgb3B0aW9ucyBvYmplY3Qgc2hvdWxkIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlc3VsdCBvZiBtZXJnaW5nIGNsYXNzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyBhbmQgdGhlIG9wdGlvbnMgcGFzc2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICB0aGlzLiRwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICB0aGlzLiRyb290ID0gdGhpcy4kcGFyZW50ID8gdGhpcy4kcGFyZW50LiRyb290IDogdGhpcztcbiAgICB0aGlzLiRjaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuJHJlZnMgPSB7fTsgLy8gY2hpbGQgdm0gcmVmZXJlbmNlc1xuICAgIHRoaXMuJGVscyA9IHt9OyAvLyBlbGVtZW50IHJlZmVyZW5jZXNcbiAgICB0aGlzLl93YXRjaGVycyA9IFtdOyAvLyBhbGwgd2F0Y2hlcnMgYXMgYW4gYXJyYXlcbiAgICB0aGlzLl9kaXJlY3RpdmVzID0gW107IC8vIGFsbCBkaXJlY3RpdmVzXG5cbiAgICAvLyBhIHVpZFxuICAgIHRoaXMuX3VpZCA9IHVpZCsrO1xuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB0aGlzLl9pc1Z1ZSA9IHRydWU7XG5cbiAgICAvLyBldmVudHMgYm9va2tlZXBpbmdcbiAgICB0aGlzLl9ldmVudHMgPSB7fTsgLy8gcmVnaXN0ZXJlZCBjYWxsYmFja3NcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IHt9OyAvLyBmb3IgJGJyb2FkY2FzdCBvcHRpbWl6YXRpb25cblxuICAgIC8vIGZyYWdtZW50IGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICB0aGlzLl9pc0ZyYWdtZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fZnJhZ21lbnQgPSAvLyBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICB0aGlzLl9mcmFnbWVudFN0YXJ0ID0gLy8gQHR5cGUge1RleHR8Q29tbWVudH1cbiAgICB0aGlzLl9mcmFnbWVudEVuZCA9IG51bGw7IC8vIEB0eXBlIHtUZXh0fENvbW1lbnR9XG5cbiAgICAvLyBsaWZlY3ljbGUgc3RhdGVcbiAgICB0aGlzLl9pc0NvbXBpbGVkID0gdGhpcy5faXNEZXN0cm95ZWQgPSB0aGlzLl9pc1JlYWR5ID0gdGhpcy5faXNBdHRhY2hlZCA9IHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgPSB0aGlzLl92Rm9yUmVtb3ZpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl91bmxpbmtGbiA9IG51bGw7XG5cbiAgICAvLyBjb250ZXh0OlxuICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGNvbnRleHRcbiAgICAvLyB3aWxsIGJlIHRoZSBjb21tb24gcGFyZW50IHZtIG9mIHRoaXMgaW5zdGFuY2VcbiAgICAvLyBhbmQgaXRzIGhvc3QuXG4gICAgdGhpcy5fY29udGV4dCA9IG9wdGlvbnMuX2NvbnRleHQgfHwgdGhpcy4kcGFyZW50O1xuXG4gICAgLy8gc2NvcGU6XG4gICAgLy8gaWYgdGhpcyBpcyBpbnNpZGUgYW4gaW5saW5lIHYtZm9yLCB0aGUgc2NvcGVcbiAgICAvLyB3aWxsIGJlIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgY3JlYXRlZCBmb3IgdGhpc1xuICAgIC8vIHJlcGVhdCBmcmFnbWVudC4gdGhpcyBpcyB1c2VkIGZvciBsaW5raW5nIHByb3BzXG4gICAgLy8gYW5kIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgIHRoaXMuX3Njb3BlID0gb3B0aW9ucy5fc2NvcGU7XG5cbiAgICAvLyBmcmFnbWVudDpcbiAgICAvLyBpZiB0aGlzIGluc3RhbmNlIGlzIGNvbXBpbGVkIGluc2lkZSBhIEZyYWdtZW50LCBpdFxuICAgIC8vIG5lZWRzIHRvIHJlaWdzdGVyIGl0c2VsZiBhcyBhIGNoaWxkIG9mIHRoYXQgZnJhZ21lbnRcbiAgICAvLyBmb3IgYXR0YWNoL2RldGFjaCB0byB3b3JrIHByb3Blcmx5LlxuICAgIHRoaXMuX2ZyYWcgPSBvcHRpb25zLl9mcmFnO1xuICAgIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgICB0aGlzLl9mcmFnLmNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgLy8gcHVzaCBzZWxmIGludG8gcGFyZW50IC8gdHJhbnNjbHVzaW9uIGhvc3RcbiAgICBpZiAodGhpcy4kcGFyZW50KSB7XG4gICAgICB0aGlzLiRwYXJlbnQuJGNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgLy8gbWVyZ2Ugb3B0aW9ucy5cbiAgICBvcHRpb25zID0gdGhpcy4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnMsIG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgLy8gc2V0IHJlZlxuICAgIHRoaXMuX3VwZGF0ZVJlZigpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBkYXRhIGFzIGVtcHR5IG9iamVjdC5cbiAgICAvLyBpdCB3aWxsIGJlIGZpbGxlZCB1cCBpbiBfaW5pdFNjb3BlKCkuXG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgLy8gc2F2ZSByYXcgY29uc3RydWN0b3IgZGF0YSBiZWZvcmUgbWVyZ2VcbiAgICAvLyBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcGVydGllcyBhcmUgcHJvdmlkZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uLlxuICAgIHRoaXMuX3J1bnRpbWVEYXRhID0gb3B0aW9ucy5kYXRhO1xuXG4gICAgLy8gY2FsbCBpbml0IGhvb2tcbiAgICB0aGlzLl9jYWxsSG9vaygnaW5pdCcpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBkYXRhIG9ic2VydmF0aW9uIGFuZCBzY29wZSBpbmhlcml0YW5jZS5cbiAgICB0aGlzLl9pbml0U3RhdGUoKTtcblxuICAgIC8vIHNldHVwIGV2ZW50IHN5c3RlbSBhbmQgb3B0aW9uIGV2ZW50cy5cbiAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG5cbiAgICAvLyBjYWxsIGNyZWF0ZWQgaG9va1xuICAgIHRoaXMuX2NhbGxIb29rKCdjcmVhdGVkJyk7XG5cbiAgICAvLyBpZiBgZWxgIG9wdGlvbiBpcyBwYXNzZWQsIHN0YXJ0IGNvbXBpbGF0aW9uLlxuICAgIGlmIChvcHRpb25zLmVsKSB7XG4gICAgICB0aGlzLiRtb3VudChvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBwYXRoQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG5cbi8vIGFjdGlvbnNcbnZhciBBUFBFTkQgPSAwO1xudmFyIFBVU0ggPSAxO1xudmFyIElOQ19TVUJfUEFUSF9ERVBUSCA9IDI7XG52YXIgUFVTSF9TVUJfUEFUSCA9IDM7XG5cbi8vIHN0YXRlc1xudmFyIEJFRk9SRV9QQVRIID0gMDtcbnZhciBJTl9QQVRIID0gMTtcbnZhciBCRUZPUkVfSURFTlQgPSAyO1xudmFyIElOX0lERU5UID0gMztcbnZhciBJTl9TVUJfUEFUSCA9IDQ7XG52YXIgSU5fU0lOR0xFX1FVT1RFID0gNTtcbnZhciBJTl9ET1VCTEVfUVVPVEUgPSA2O1xudmFyIEFGVEVSX1BBVEggPSA3O1xudmFyIEVSUk9SID0gODtcblxudmFyIHBhdGhTdGF0ZU1hY2hpbmUgPSBbXTtcblxucGF0aFN0YXRlTWFjaGluZVtCRUZPUkVfUEFUSF0gPSB7XG4gICd3cyc6IFtCRUZPUkVfUEFUSF0sXG4gICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEhdLFxuICAnZW9mJzogW0FGVEVSX1BBVEhdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1BBVEhdID0ge1xuICAnd3MnOiBbSU5fUEFUSF0sXG4gICcuJzogW0JFRk9SRV9JREVOVF0sXG4gICdbJzogW0lOX1NVQl9QQVRIXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRIXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtCRUZPUkVfSURFTlRdID0ge1xuICAnd3MnOiBbQkVGT1JFX0lERU5UXSxcbiAgJ2lkZW50JzogW0lOX0lERU5ULCBBUFBFTkRdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX0lERU5UXSA9IHtcbiAgJ2lkZW50JzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAnMCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJ251bWJlcic6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJ3dzJzogW0lOX1BBVEgsIFBVU0hdLFxuICAnLic6IFtCRUZPUkVfSURFTlQsIFBVU0hdLFxuICAnWyc6IFtJTl9TVUJfUEFUSCwgUFVTSF0sXG4gICdlb2YnOiBbQUZURVJfUEFUSCwgUFVTSF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fU1VCX1BBVEhdID0ge1xuICBcIidcIjogW0lOX1NJTkdMRV9RVU9URSwgQVBQRU5EXSxcbiAgJ1wiJzogW0lOX0RPVUJMRV9RVU9URSwgQVBQRU5EXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEgsIElOQ19TVUJfUEFUSF9ERVBUSF0sXG4gICddJzogW0lOX1BBVEgsIFBVU0hfU1VCX1BBVEhdLFxuICAnZW9mJzogRVJST1IsXG4gICdlbHNlJzogW0lOX1NVQl9QQVRILCBBUFBFTkRdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1NJTkdMRV9RVU9URV0gPSB7XG4gIFwiJ1wiOiBbSU5fU1VCX1BBVEgsIEFQUEVORF0sXG4gICdlb2YnOiBFUlJPUixcbiAgJ2Vsc2UnOiBbSU5fU0lOR0xFX1FVT1RFLCBBUFBFTkRdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX0RPVUJMRV9RVU9URV0gPSB7XG4gICdcIic6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXSxcbiAgJ2VvZic6IEVSUk9SLFxuICAnZWxzZSc6IFtJTl9ET1VCTEVfUVVPVEUsIEFQUEVORF1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgY2hhcmFjdGVyIGluIGEga2V5cGF0aC5cbiAqXG4gKiBAcGFyYW0ge0NoYXJ9IGNoXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoQ2hhclR5cGUoY2gpIHtcbiAgaWYgKGNoID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ2VvZic7XG4gIH1cblxuICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG5cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDVCOiAvLyBbXG4gICAgY2FzZSAweDVEOiAvLyBdXG4gICAgY2FzZSAweDJFOiAvLyAuXG4gICAgY2FzZSAweDIyOiAvLyBcIlxuICAgIGNhc2UgMHgyNzogLy8gJ1xuICAgIGNhc2UgMHgzMDpcbiAgICAgIC8vIDBcbiAgICAgIHJldHVybiBjaDtcblxuICAgIGNhc2UgMHg1RjogLy8gX1xuICAgIGNhc2UgMHgyNDpcbiAgICAgIC8vICRcbiAgICAgIHJldHVybiAnaWRlbnQnO1xuXG4gICAgY2FzZSAweDIwOiAvLyBTcGFjZVxuICAgIGNhc2UgMHgwOTogLy8gVGFiXG4gICAgY2FzZSAweDBBOiAvLyBOZXdsaW5lXG4gICAgY2FzZSAweDBEOiAvLyBSZXR1cm5cbiAgICBjYXNlIDB4QTA6IC8vIE5vLWJyZWFrIHNwYWNlXG4gICAgY2FzZSAweEZFRkY6IC8vIEJ5dGUgT3JkZXIgTWFya1xuICAgIGNhc2UgMHgyMDI4OiAvLyBMaW5lIFNlcGFyYXRvclxuICAgIGNhc2UgMHgyMDI5OlxuICAgICAgLy8gUGFyYWdyYXBoIFNlcGFyYXRvclxuICAgICAgcmV0dXJuICd3cyc7XG4gIH1cblxuICAvLyBhLXosIEEtWlxuICBpZiAoY29kZSA+PSAweDYxICYmIGNvZGUgPD0gMHg3QSB8fCBjb2RlID49IDB4NDEgJiYgY29kZSA8PSAweDVBKSB7XG4gICAgcmV0dXJuICdpZGVudCc7XG4gIH1cblxuICAvLyAxLTlcbiAgaWYgKGNvZGUgPj0gMHgzMSAmJiBjb2RlIDw9IDB4MzkpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH1cblxuICByZXR1cm4gJ2Vsc2UnO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIHN1YlBhdGgsIHJldHVybiBpdHMgcGxhaW4gZm9ybSBpZiBpdCBpc1xuICogYSBsaXRlcmFsIHN0cmluZyBvciBudW1iZXIuIE90aGVyd2lzZSBwcmVwZW5kIHRoZVxuICogZHluYW1pYyBpbmRpY2F0b3IgKCopLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0U3ViUGF0aChwYXRoKSB7XG4gIHZhciB0cmltbWVkID0gcGF0aC50cmltKCk7XG4gIC8vIGludmFsaWQgbGVhZGluZyAwXG4gIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJzAnICYmIGlzTmFOKHBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0xpdGVyYWwodHJpbW1lZCkgPyBzdHJpcFF1b3Rlcyh0cmltbWVkKSA6ICcqJyArIHRyaW1tZWQ7XG59XG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgcGF0aCBpbnRvIGFuIGFycmF5IG9mIHNlZ21lbnRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gIHZhciBrZXlzID0gW107XG4gIHZhciBpbmRleCA9IC0xO1xuICB2YXIgbW9kZSA9IEJFRk9SRV9QQVRIO1xuICB2YXIgc3ViUGF0aERlcHRoID0gMDtcbiAgdmFyIGMsIG5ld0NoYXIsIGtleSwgdHlwZSwgdHJhbnNpdGlvbiwgYWN0aW9uLCB0eXBlTWFwO1xuXG4gIHZhciBhY3Rpb25zID0gW107XG5cbiAgYWN0aW9uc1tQVVNIXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICBhY3Rpb25zW0FQUEVORF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSBuZXdDaGFyO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgKz0gbmV3Q2hhcjtcbiAgICB9XG4gIH07XG5cbiAgYWN0aW9uc1tJTkNfU1VCX1BBVEhfREVQVEhdID0gZnVuY3Rpb24gKCkge1xuICAgIGFjdGlvbnNbQVBQRU5EXSgpO1xuICAgIHN1YlBhdGhEZXB0aCsrO1xuICB9O1xuXG4gIGFjdGlvbnNbUFVTSF9TVUJfUEFUSF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN1YlBhdGhEZXB0aCA+IDApIHtcbiAgICAgIHN1YlBhdGhEZXB0aC0tO1xuICAgICAgbW9kZSA9IElOX1NVQl9QQVRIO1xuICAgICAgYWN0aW9uc1tBUFBFTkRdKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YlBhdGhEZXB0aCA9IDA7XG4gICAgICBrZXkgPSBmb3JtYXRTdWJQYXRoKGtleSk7XG4gICAgICBpZiAoa2V5ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3Rpb25zW1BVU0hdKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1heWJlVW5lc2NhcGVRdW90ZSgpIHtcbiAgICB2YXIgbmV4dENoYXIgPSBwYXRoW2luZGV4ICsgMV07XG4gICAgaWYgKG1vZGUgPT09IElOX1NJTkdMRV9RVU9URSAmJiBuZXh0Q2hhciA9PT0gXCInXCIgfHwgbW9kZSA9PT0gSU5fRE9VQkxFX1FVT1RFICYmIG5leHRDaGFyID09PSAnXCInKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgbmV3Q2hhciA9ICdcXFxcJyArIG5leHRDaGFyO1xuICAgICAgYWN0aW9uc1tBUFBFTkRdKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAobW9kZSAhPSBudWxsKSB7XG4gICAgaW5kZXgrKztcbiAgICBjID0gcGF0aFtpbmRleF07XG5cbiAgICBpZiAoYyA9PT0gJ1xcXFwnICYmIG1heWJlVW5lc2NhcGVRdW90ZSgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0eXBlID0gZ2V0UGF0aENoYXJUeXBlKGMpO1xuICAgIHR5cGVNYXAgPSBwYXRoU3RhdGVNYWNoaW5lW21vZGVdO1xuICAgIHRyYW5zaXRpb24gPSB0eXBlTWFwW3R5cGVdIHx8IHR5cGVNYXBbJ2Vsc2UnXSB8fCBFUlJPUjtcblxuICAgIGlmICh0cmFuc2l0aW9uID09PSBFUlJPUikge1xuICAgICAgcmV0dXJuOyAvLyBwYXJzZSBlcnJvclxuICAgIH1cblxuICAgIG1vZGUgPSB0cmFuc2l0aW9uWzBdO1xuICAgIGFjdGlvbiA9IGFjdGlvbnNbdHJhbnNpdGlvblsxXV07XG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgbmV3Q2hhciA9IHRyYW5zaXRpb25bMl07XG4gICAgICBuZXdDaGFyID0gbmV3Q2hhciA9PT0gdW5kZWZpbmVkID8gYyA6IG5ld0NoYXI7XG4gICAgICBpZiAoYWN0aW9uKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kZSA9PT0gQUZURVJfUEFUSCkge1xuICAgICAga2V5cy5yYXcgPSBwYXRoO1xuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXh0ZXJuYWwgcGFyc2UgdGhhdCBjaGVjayBmb3IgYSBjYWNoZSBoaXQgZmlyc3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBoaXQgPSBwYXRoQ2FjaGUuZ2V0KHBhdGgpO1xuICBpZiAoIWhpdCkge1xuICAgIGhpdCA9IHBhcnNlKHBhdGgpO1xuICAgIGlmIChoaXQpIHtcbiAgICAgIHBhdGhDYWNoZS5wdXQocGF0aCwgaGl0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhpdDtcbn1cblxuLyoqXG4gKiBHZXQgZnJvbSBhbiBvYmplY3QgZnJvbSBhIHBhdGggc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoKG9iaiwgcGF0aCkge1xuICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKHBhdGgpLmdldChvYmopO1xufVxuXG4vKipcbiAqIFdhcm4gYWdhaW5zdCBzZXR0aW5nIG5vbi1leGlzdGVudCByb290IHBhdGggb24gYSB2bS5cbiAqL1xuXG52YXIgd2Fybk5vbkV4aXN0ZW50O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2Fybk5vbkV4aXN0ZW50ID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB3YXJuKCdZb3UgYXJlIHNldHRpbmcgYSBub24tZXhpc3RlbnQgcGF0aCBcIicgKyBwYXRoLnJhdyArICdcIiAnICsgJ29uIGEgdm0gaW5zdGFuY2UuIENvbnNpZGVyIHByZS1pbml0aWFsaXppbmcgdGhlIHByb3BlcnR5ICcgKyAnd2l0aCB0aGUgXCJkYXRhXCIgb3B0aW9uIGZvciBtb3JlIHJlbGlhYmxlIHJlYWN0aXZpdHkgJyArICdhbmQgYmV0dGVyIHBlcmZvcm1hbmNlLicpO1xuICB9O1xufVxuXG4vKipcbiAqIFNldCBvbiBhbiBvYmplY3QgZnJvbSBhIHBhdGhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBwYXRoXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHNldFBhdGgob2JqLCBwYXRoLCB2YWwpIHtcbiAgdmFyIG9yaWdpbmFsID0gb2JqO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IHBhcnNlKHBhdGgpO1xuICB9XG4gIGlmICghcGF0aCB8fCAhaXNPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdCwga2V5O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGgubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGFzdCA9IG9iajtcbiAgICBrZXkgPSBwYXRoW2ldO1xuICAgIGlmIChrZXkuY2hhckF0KDApID09PSAnKicpIHtcbiAgICAgIGtleSA9IHBhcnNlRXhwcmVzc2lvbihrZXkuc2xpY2UoMSkpLmdldC5jYWxsKG9yaWdpbmFsLCBvcmlnaW5hbCk7XG4gICAgfVxuICAgIGlmIChpIDwgbCAtIDEpIHtcbiAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgICAgIG9iaiA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBsYXN0Ll9pc1Z1ZSkge1xuICAgICAgICAgIHdhcm5Ob25FeGlzdGVudChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXQobGFzdCwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIG9iai4kc2V0KGtleSwgdmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9iai5faXNWdWUpIHtcbiAgICAgICAgICB3YXJuTm9uRXhpc3RlbnQocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KG9iaiwga2V5LCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIHBhdGggPSBPYmplY3QuZnJlZXplKHtcbiAgcGFyc2VQYXRoOiBwYXJzZVBhdGgsXG4gIGdldFBhdGg6IGdldFBhdGgsXG4gIHNldFBhdGg6IHNldFBhdGhcbn0pO1xuXG52YXIgZXhwcmVzc2lvbkNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG52YXIgYWxsb3dlZEtleXdvcmRzID0gJ01hdGgsRGF0ZSx0aGlzLHRydWUsZmFsc2UsbnVsbCx1bmRlZmluZWQsSW5maW5pdHksTmFOLCcgKyAnaXNOYU4saXNGaW5pdGUsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksJyArICdlbmNvZGVVUklDb21wb25lbnQscGFyc2VJbnQscGFyc2VGbG9hdCc7XG52YXIgYWxsb3dlZEtleXdvcmRzUkUgPSBuZXcgUmVnRXhwKCdeKCcgKyBhbGxvd2VkS2V5d29yZHMucmVwbGFjZSgvLC9nLCAnXFxcXGJ8JykgKyAnXFxcXGIpJyk7XG5cbi8vIGtleXdvcmRzIHRoYXQgZG9uJ3QgbWFrZSBzZW5zZSBpbnNpZGUgZXhwcmVzc2lvbnNcbnZhciBpbXByb3BlcktleXdvcmRzID0gJ2JyZWFrLGNhc2UsY2xhc3MsY2F0Y2gsY29uc3QsY29udGludWUsZGVidWdnZXIsZGVmYXVsdCwnICsgJ2RlbGV0ZSxkbyxlbHNlLGV4cG9ydCxleHRlbmRzLGZpbmFsbHksZm9yLGZ1bmN0aW9uLGlmLCcgKyAnaW1wb3J0LGluLGluc3RhbmNlb2YsbGV0LHJldHVybixzdXBlcixzd2l0Y2gsdGhyb3csdHJ5LCcgKyAndmFyLHdoaWxlLHdpdGgseWllbGQsZW51bSxhd2FpdCxpbXBsZW1lbnRzLHBhY2thZ2UsJyArICdwcm90ZWN0ZWQsc3RhdGljLGludGVyZmFjZSxwcml2YXRlLHB1YmxpYyc7XG52YXIgaW1wcm9wZXJLZXl3b3Jkc1JFID0gbmV3IFJlZ0V4cCgnXignICsgaW1wcm9wZXJLZXl3b3Jkcy5yZXBsYWNlKC8sL2csICdcXFxcYnwnKSArICdcXFxcYiknKTtcblxudmFyIHdzUkUgPSAvXFxzL2c7XG52YXIgbmV3bGluZVJFID0gL1xcbi9nO1xudmFyIHNhdmVSRSA9IC9bXFx7LF1cXHMqW1xcd1xcJF9dK1xccyo6fCgnKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYCl8bmV3IHx0eXBlb2YgfHZvaWQgL2c7XG52YXIgcmVzdG9yZVJFID0gL1wiKFxcZCspXCIvZztcbnZhciBwYXRoVGVzdFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXFxdfFxcW1wiLio/XCJcXF18XFxbXFxkK1xcXXxcXFtbQS1aYS16XyRdW1xcdyRdKlxcXSkqJC87XG52YXIgaWRlbnRSRSA9IC9bXlxcdyRcXC5dKD86W0EtWmEtel8kXVtcXHckXSopL2c7XG52YXIgYm9vbGVhbkxpdGVyYWxSRSA9IC9eKD86dHJ1ZXxmYWxzZSkkLztcblxuLyoqXG4gKiBTYXZlIC8gUmV3cml0ZSAvIFJlc3RvcmVcbiAqXG4gKiBXaGVuIHJld3JpdGluZyBwYXRocyBmb3VuZCBpbiBhbiBleHByZXNzaW9uLCBpdCBpc1xuICogcG9zc2libGUgZm9yIHRoZSBzYW1lIGxldHRlciBzZXF1ZW5jZXMgdG8gYmUgZm91bmQgaW5cbiAqIHN0cmluZ3MgYW5kIE9iamVjdCBsaXRlcmFsIHByb3BlcnR5IGtleXMuIFRoZXJlZm9yZSB3ZVxuICogcmVtb3ZlIGFuZCBzdG9yZSB0aGVzZSBwYXJ0cyBpbiBhIHRlbXBvcmFyeSBhcnJheSwgYW5kXG4gKiByZXN0b3JlIHRoZW0gYWZ0ZXIgdGhlIHBhdGggcmV3cml0ZS5cbiAqL1xuXG52YXIgc2F2ZWQgPSBbXTtcblxuLyoqXG4gKiBTYXZlIHJlcGxhY2VyXG4gKlxuICogVGhlIHNhdmUgcmVnZXggY2FuIG1hdGNoIHR3byBwb3NzaWJsZSBjYXNlczpcbiAqIDEuIEFuIG9wZW5pbmcgb2JqZWN0IGxpdGVyYWxcbiAqIDIuIEEgc3RyaW5nXG4gKiBJZiBtYXRjaGVkIGFzIGEgcGxhaW4gc3RyaW5nLCB3ZSBuZWVkIHRvIGVzY2FwZSBpdHNcbiAqIG5ld2xpbmVzLCBzaW5jZSB0aGUgc3RyaW5nIG5lZWRzIHRvIGJlIHByZXNlcnZlZCB3aGVuXG4gKiBnZW5lcmF0aW5nIHRoZSBmdW5jdGlvbiBib2R5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpc1N0cmluZyAtIHN0ciBpZiBtYXRjaGVkIGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IC0gcGxhY2Vob2xkZXIgd2l0aCBpbmRleFxuICovXG5cbmZ1bmN0aW9uIHNhdmUoc3RyLCBpc1N0cmluZykge1xuICB2YXIgaSA9IHNhdmVkLmxlbmd0aDtcbiAgc2F2ZWRbaV0gPSBpc1N0cmluZyA/IHN0ci5yZXBsYWNlKG5ld2xpbmVSRSwgJ1xcXFxuJykgOiBzdHI7XG4gIHJldHVybiAnXCInICsgaSArICdcIic7XG59XG5cbi8qKlxuICogUGF0aCByZXdyaXRlIHJlcGxhY2VyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHJld3JpdGUocmF3KSB7XG4gIHZhciBjID0gcmF3LmNoYXJBdCgwKTtcbiAgdmFyIHBhdGggPSByYXcuc2xpY2UoMSk7XG4gIGlmIChhbGxvd2VkS2V5d29yZHNSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuIHJhdztcbiAgfSBlbHNlIHtcbiAgICBwYXRoID0gcGF0aC5pbmRleE9mKCdcIicpID4gLTEgPyBwYXRoLnJlcGxhY2UocmVzdG9yZVJFLCByZXN0b3JlKSA6IHBhdGg7XG4gICAgcmV0dXJuIGMgKyAnc2NvcGUuJyArIHBhdGg7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXN0b3JlIHJlcGxhY2VyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGkgLSBtYXRjaGVkIHNhdmUgaW5kZXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiByZXN0b3JlKHN0ciwgaSkge1xuICByZXR1cm4gc2F2ZWRbaV07XG59XG5cbi8qKlxuICogUmV3cml0ZSBhbiBleHByZXNzaW9uLCBwcmVmaXhpbmcgYWxsIHBhdGggYWNjZXNzb3JzIHdpdGhcbiAqIGBzY29wZS5gIGFuZCBnZW5lcmF0ZSBnZXR0ZXIvc2V0dGVyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlR2V0dGVyKGV4cCkge1xuICBpZiAoaW1wcm9wZXJLZXl3b3Jkc1JFLnRlc3QoZXhwKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignQXZvaWQgdXNpbmcgcmVzZXJ2ZWQga2V5d29yZHMgaW4gZXhwcmVzc2lvbjogJyArIGV4cCk7XG4gIH1cbiAgLy8gcmVzZXQgc3RhdGVcbiAgc2F2ZWQubGVuZ3RoID0gMDtcbiAgLy8gc2F2ZSBzdHJpbmdzIGFuZCBvYmplY3QgbGl0ZXJhbCBrZXlzXG4gIHZhciBib2R5ID0gZXhwLnJlcGxhY2Uoc2F2ZVJFLCBzYXZlKS5yZXBsYWNlKHdzUkUsICcnKTtcbiAgLy8gcmV3cml0ZSBhbGwgcGF0aHNcbiAgLy8gcGFkIDEgc3BhY2UgaGVyZSBiZWNhdWUgdGhlIHJlZ2V4IG1hdGNoZXMgMSBleHRyYSBjaGFyXG4gIGJvZHkgPSAoJyAnICsgYm9keSkucmVwbGFjZShpZGVudFJFLCByZXdyaXRlKS5yZXBsYWNlKHJlc3RvcmVSRSwgcmVzdG9yZSk7XG4gIHJldHVybiBtYWtlR2V0dGVyRm4oYm9keSk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBnZXR0ZXIgZnVuY3Rpb24uIFJlcXVpcmVzIGV2YWwuXG4gKlxuICogV2UgaXNvbGF0ZSB0aGUgdHJ5L2NhdGNoIHNvIGl0IGRvZXNuJ3QgYWZmZWN0IHRoZVxuICogb3B0aW1pemF0aW9uIG9mIHRoZSBwYXJzZSBmdW5jdGlvbiB3aGVuIGl0IGlzIG5vdCBjYWxsZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJvZHlcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlR2V0dGVyRm4oYm9keSkge1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jICovXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbignc2NvcGUnLCAncmV0dXJuICcgKyBib2R5ICsgJzsnKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldy1mdW5jICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgZXhwcmVzc2lvbi4gJyArICdHZW5lcmF0ZWQgZnVuY3Rpb24gYm9keTogJyArIGJvZHkpO1xuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHNldHRlciBmdW5jdGlvbiBmb3IgdGhlIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVTZXR0ZXIoZXhwKSB7XG4gIHZhciBwYXRoID0gcGFyc2VQYXRoKGV4cCk7XG4gIGlmIChwYXRoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgdmFsKSB7XG4gICAgICBzZXRQYXRoKHNjb3BlLCBwYXRoLCB2YWwpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHNldHRlciBleHByZXNzaW9uOiAnICsgZXhwKTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gaW50byByZS13cml0dGVuIGdldHRlci9zZXR0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVlZFNldFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGV4cCwgbmVlZFNldCkge1xuICBleHAgPSBleHAudHJpbSgpO1xuICAvLyB0cnkgY2FjaGVcbiAgdmFyIGhpdCA9IGV4cHJlc3Npb25DYWNoZS5nZXQoZXhwKTtcbiAgaWYgKGhpdCkge1xuICAgIGlmIChuZWVkU2V0ICYmICFoaXQuc2V0KSB7XG4gICAgICBoaXQuc2V0ID0gY29tcGlsZVNldHRlcihoaXQuZXhwKTtcbiAgICB9XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuICB2YXIgcmVzID0geyBleHA6IGV4cCB9O1xuICByZXMuZ2V0ID0gaXNTaW1wbGVQYXRoKGV4cCkgJiYgZXhwLmluZGV4T2YoJ1snKSA8IDBcbiAgLy8gb3B0aW1pemVkIHN1cGVyIHNpbXBsZSBnZXR0ZXJcbiAgPyBtYWtlR2V0dGVyRm4oJ3Njb3BlLicgKyBleHApXG4gIC8vIGR5bmFtaWMgZ2V0dGVyXG4gIDogY29tcGlsZUdldHRlcihleHApO1xuICBpZiAobmVlZFNldCkge1xuICAgIHJlcy5zZXQgPSBjb21waWxlU2V0dGVyKGV4cCk7XG4gIH1cbiAgZXhwcmVzc2lvbkNhY2hlLnB1dChleHAsIHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZXhwcmVzc2lvbiBpcyBhIHNpbXBsZSBwYXRoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNTaW1wbGVQYXRoKGV4cCkge1xuICByZXR1cm4gcGF0aFRlc3RSRS50ZXN0KGV4cCkgJiZcbiAgLy8gZG9uJ3QgdHJlYXQgdHJ1ZS9mYWxzZSBhcyBwYXRoc1xuICAhYm9vbGVhbkxpdGVyYWxSRS50ZXN0KGV4cCkgJiZcbiAgLy8gTWF0aCBjb25zdGFudHMgZS5nLiBNYXRoLlBJLCBNYXRoLkUgZXRjLlxuICBleHAuc2xpY2UoMCwgNSkgIT09ICdNYXRoLic7XG59XG5cbnZhciBleHByZXNzaW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHBhcnNlRXhwcmVzc2lvbjogcGFyc2VFeHByZXNzaW9uLFxuICBpc1NpbXBsZVBhdGg6IGlzU2ltcGxlUGF0aFxufSk7XG5cbi8vIHdlIGhhdmUgdHdvIHNlcGFyYXRlIHF1ZXVlczogb25lIGZvciBkaXJlY3RpdmUgdXBkYXRlc1xuLy8gYW5kIG9uZSBmb3IgdXNlciB3YXRjaGVyIHJlZ2lzdGVyZWQgdmlhICR3YXRjaCgpLlxuLy8gd2Ugd2FudCB0byBndWFyYW50ZWUgZGlyZWN0aXZlIHVwZGF0ZXMgdG8gYmUgY2FsbGVkXG4vLyBiZWZvcmUgdXNlciB3YXRjaGVycyBzbyB0aGF0IHdoZW4gdXNlciB3YXRjaGVycyBhcmVcbi8vIHRyaWdnZXJlZCwgdGhlIERPTSB3b3VsZCBoYXZlIGFscmVhZHkgYmVlbiBpbiB1cGRhdGVkXG4vLyBzdGF0ZS5cblxudmFyIHF1ZXVlSW5kZXg7XG52YXIgcXVldWUgPSBbXTtcbnZhciB1c2VyUXVldWUgPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXNldCB0aGUgYmF0Y2hlcidzIHN0YXRlLlxuICovXG5cbmZ1bmN0aW9uIHJlc2V0QmF0Y2hlclN0YXRlKCkge1xuICBxdWV1ZSA9IFtdO1xuICB1c2VyUXVldWUgPSBbXTtcbiAgaGFzID0ge307XG4gIGNpcmN1bGFyID0ge307XG4gIHdhaXRpbmcgPSBpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuXG5mdW5jdGlvbiBmbHVzaEJhdGNoZXJRdWV1ZSgpIHtcbiAgcnVuQmF0Y2hlclF1ZXVlKHF1ZXVlKTtcbiAgaW50ZXJuYWxRdWV1ZURlcGxldGVkID0gdHJ1ZTtcbiAgcnVuQmF0Y2hlclF1ZXVlKHVzZXJRdWV1ZSk7XG4gIC8vIGRldiB0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG4gIHJlc2V0QmF0Y2hlclN0YXRlKCk7XG59XG5cbi8qKlxuICogUnVuIHRoZSB3YXRjaGVycyBpbiBhIHNpbmdsZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBxdWV1ZVxuICovXG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZXJRdWV1ZShxdWV1ZSkge1xuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAocXVldWVJbmRleCA9IDA7IHF1ZXVlSW5kZXggPCBxdWV1ZS5sZW5ndGg7IHF1ZXVlSW5kZXgrKykge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbcXVldWVJbmRleF07XG4gICAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IGNvbmZpZy5fbWF4VXBkYXRlQ291bnQpIHtcbiAgICAgICAgcXVldWUuc3BsaWNlKGhhc1tpZF0sIDEpO1xuICAgICAgICB3YXJuKCdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgZm9yIHdhdGNoZXIgJyArICd3aXRoIGV4cHJlc3Npb246ICcgKyB3YXRjaGVyLmV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICpcbiAqIEBwYXJhbSB7V2F0Y2hlcn0gd2F0Y2hlclxuICogICBwcm9wZXJ0aWVzOlxuICogICAtIHtOdW1iZXJ9IGlkXG4gKiAgIC0ge0Z1bmN0aW9ufSBydW5cbiAqL1xuXG5mdW5jdGlvbiBwdXNoV2F0Y2hlcih3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBpZiAoaW50ZXJuYWxRdWV1ZURlcGxldGVkICYmICF3YXRjaGVyLnVzZXIpIHtcbiAgICAgIC8vIGFuIGludGVybmFsIHdhdGNoZXIgdHJpZ2dlcmVkIGJ5IGEgdXNlciB3YXRjaGVyLi4uXG4gICAgICAvLyBsZXQncyBydW4gaXQgaW1tZWRpYXRlbHkgYWZ0ZXIgY3VycmVudCB1c2VyIHdhdGNoZXIgaXMgZG9uZS5cbiAgICAgIHVzZXJRdWV1ZS5zcGxpY2UocXVldWVJbmRleCArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwdXNoIHdhdGNoZXIgaW50byBhcHByb3ByaWF0ZSBxdWV1ZVxuICAgICAgdmFyIHEgPSB3YXRjaGVyLnVzZXIgPyB1c2VyUXVldWUgOiBxdWV1ZTtcbiAgICAgIGhhc1tpZF0gPSBxLmxlbmd0aDtcbiAgICAgIHEucHVzaCh3YXRjaGVyKTtcbiAgICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgICBuZXh0VGljayhmbHVzaEJhdGNoZXJRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXl9IGZpbHRlcnNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB0d29XYXlcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBkZWVwXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gdXNlclxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHN5bmNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBsYXp5XG4gKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtwcmVQcm9jZXNzXVxuICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbcG9zdFByb2Nlc3NdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgLy8gbWl4IGluIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBleHRlbmQodGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgdmFyIGlzRm4gPSB0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJztcbiAgdGhpcy52bSA9IHZtO1xuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbjtcbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLm5ld0RlcElkcyA9IG51bGw7XG4gIHRoaXMucHJldkVycm9yID0gbnVsbDsgLy8gZm9yIGFzeW5jIGVycm9yIHN0YWNrc1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXIvc2V0dGVyXG4gIGlmIChpc0ZuKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgIHRoaXMuc2V0dGVyID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXMgPSBwYXJzZUV4cHJlc3Npb24oZXhwT3JGbiwgdGhpcy50d29XYXkpO1xuICAgIHRoaXMuZ2V0dGVyID0gcmVzLmdldDtcbiAgICB0aGlzLnNldHRlciA9IHJlcy5zZXQ7XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eSA/IHVuZGVmaW5lZCA6IHRoaXMuZ2V0KCk7XG4gIC8vIHN0YXRlIGZvciBhdm9pZGluZyBmYWxzZSB0cmlnZ2VycyBmb3IgZGVlcCBhbmQgQXJyYXlcbiAgLy8gd2F0Y2hlcnMgZHVyaW5nIHZtLl9kaWdlc3QoKVxuICB0aGlzLnF1ZXVlZCA9IHRoaXMuc2hhbGxvdyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYmVmb3JlR2V0KCk7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bTtcbiAgdmFyIHZhbHVlO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbChzY29wZSwgc2NvcGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLndhcm5FeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICB3YXJuKCdFcnJvciB3aGVuIGV2YWx1YXRpbmcgZXhwcmVzc2lvbiBcIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCIuICcgKyAoY29uZmlnLmRlYnVnID8gJycgOiAnVHVybiBvbiBkZWJ1ZyBtb2RlIHRvIHNlZSBzdGFjayB0cmFjZS4nKSwgZSk7XG4gICAgfVxuICB9XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBpZiAodGhpcy5wcmVQcm9jZXNzKSB7XG4gICAgdmFsdWUgPSB0aGlzLnByZVByb2Nlc3ModmFsdWUpO1xuICB9XG4gIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICB2YWx1ZSA9IHNjb3BlLl9hcHBseUZpbHRlcnModmFsdWUsIG51bGwsIHRoaXMuZmlsdGVycywgZmFsc2UpO1xuICB9XG4gIGlmICh0aGlzLnBvc3RQcm9jZXNzKSB7XG4gICAgdmFsdWUgPSB0aGlzLnBvc3RQcm9jZXNzKHZhbHVlKTtcbiAgfVxuICB0aGlzLmFmdGVyR2V0KCk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHdpdGggdGhlIHNldHRlci5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bTtcbiAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgIHZhbHVlID0gc2NvcGUuX2FwcGx5RmlsdGVycyh2YWx1ZSwgdGhpcy52YWx1ZSwgdGhpcy5maWx0ZXJzLCB0cnVlKTtcbiAgfVxuICB0cnkge1xuICAgIHRoaXMuc2V0dGVyLmNhbGwoc2NvcGUsIHNjb3BlLCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcud2FybkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHdhcm4oJ0Vycm9yIHdoZW4gZXZhbHVhdGluZyBzZXR0ZXIgXCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiJywgZSk7XG4gICAgfVxuICB9XG4gIC8vIHR3by13YXkgc3luYyBmb3Igdi1mb3IgYWxpYXNcbiAgdmFyIGZvckNvbnRleHQgPSBzY29wZS4kZm9yQ29udGV4dDtcbiAgaWYgKGZvckNvbnRleHQgJiYgZm9yQ29udGV4dC5hbGlhcyA9PT0gdGhpcy5leHByZXNzaW9uKSB7XG4gICAgaWYgKGZvckNvbnRleHQuZmlsdGVycykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHR3by13YXkgYmluZGluZyBvbiAnICsgJ2Egdi1mb3IgYWxpYXMgKCcgKyB0aGlzLmV4cHJlc3Npb24gKyAnKSwgYW5kIHRoZSAnICsgJ3YtZm9yIGhhcyBmaWx0ZXJzLiBUaGlzIHdpbGwgbm90IHdvcmsgcHJvcGVybHkuICcgKyAnRWl0aGVyIHJlbW92ZSB0aGUgZmlsdGVycyBvciB1c2UgYW4gYXJyYXkgb2YgJyArICdvYmplY3RzIGFuZCBiaW5kIHRvIG9iamVjdCBwcm9wZXJ0aWVzIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvckNvbnRleHQuX3dpdGhMb2NrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzY29wZS4ka2V5KSB7XG4gICAgICAgIC8vIG9yaWdpbmFsIGlzIGFuIG9iamVjdFxuICAgICAgICBmb3JDb250ZXh0LnJhd1ZhbHVlW3Njb3BlLiRrZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JDb250ZXh0LnJhd1ZhbHVlLiRzZXQoc2NvcGUuJGluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJlcGFyZSBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmJlZm9yZUdldCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldCA9IHRoaXM7XG4gIHRoaXMubmV3RGVwSWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtEZXB9IGRlcFxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzW2lkXSkge1xuICAgIHRoaXMubmV3RGVwSWRzW2lkXSA9IHRydWU7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzW2lkXSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZnRlckdldCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldCA9IG51bGw7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkc1tkZXAuaWRdKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB2YXIgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hhbGxvd1xuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzaGFsbG93KSB7XG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMgfHwgIWNvbmZpZy5hc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgcXVldWVkLCBvbmx5IG92ZXJ3cml0ZSBzaGFsbG93IHdpdGggbm9uLXNoYWxsb3csXG4gICAgLy8gYnV0IG5vdCB0aGUgb3RoZXIgd2F5IGFyb3VuZC5cbiAgICB0aGlzLnNoYWxsb3cgPSB0aGlzLnF1ZXVlZCA/IHNoYWxsb3cgPyB0aGlzLnNoYWxsb3cgOiBmYWxzZSA6ICEhc2hhbGxvdztcbiAgICB0aGlzLnF1ZXVlZCA9IHRydWU7XG4gICAgLy8gcmVjb3JkIGJlZm9yZS1wdXNoIGVycm9yIHN0YWNrIGluIGRlYnVnIG1vZGVcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcuZGVidWcpIHtcbiAgICAgIHRoaXMucHJldkVycm9yID0gbmV3IEVycm9yKCdbdnVlXSBhc3luYyBzdGFjayB0cmFjZScpO1xuICAgIH1cbiAgICBwdXNoV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXRjaGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgYmF0Y2hlci5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgIC8vIGhhdmUgbXV0YXRlZDsgYnV0IG9ubHkgZG8gc28gaWYgdGhpcyBpcyBhXG4gICAgLy8gbm9uLXNoYWxsb3cgdXBkYXRlIChjYXVzZWQgYnkgYSB2bSBkaWdlc3QpLlxuICAgIChpc09iamVjdCh2YWx1ZSkgfHwgdGhpcy5kZWVwKSAmJiAhdGhpcy5zaGFsbG93KSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgLy8gaW4gZGVidWcgKyBhc3luYyBtb2RlLCB3aGVuIGEgd2F0Y2hlciBjYWxsYmFja3NcbiAgICAgIC8vIHRocm93cywgd2UgYWxzbyB0aHJvdyB0aGUgc2F2ZWQgYmVmb3JlLXB1c2ggZXJyb3JcbiAgICAgIC8vIHNvIHRoZSBmdWxsIGNyb3NzLXRpY2sgc3RhY2sgdHJhY2UgaXMgYXZhaWxhYmxlLlxuICAgICAgdmFyIHByZXZFcnJvciA9IHRoaXMucHJldkVycm9yO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcuZGVidWcgJiYgcHJldkVycm9yKSB7XG4gICAgICAgIHRoaXMucHJldkVycm9yID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHByZXZFcnJvcjtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5xdWV1ZWQgPSB0aGlzLnNoYWxsb3cgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGF2b2lkIG92ZXJ3cml0aW5nIGFub3RoZXIgd2F0Y2hlciB0aGF0IGlzIGJlaW5nXG4gIC8vIGNvbGxlY3RlZC5cbiAgdmFyIGN1cnJlbnQgPSBEZXAudGFyZ2V0O1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBEZXAudGFyZ2V0ID0gY3VycmVudDtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJjcmliZXIgbGlzdC5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkIG9yIGlzIHBlcmZvcm1pbmcgYSB2LWZvclxuICAgIC8vIHJlLXJlbmRlciAodGhlIHdhdGNoZXIgbGlzdCBpcyB0aGVuIGZpbHRlcmVkIGJ5IHYtZm9yKS5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXRoaXMudm0uX3ZGb3JSZW1vdmluZykge1xuICAgICAgdGhpcy52bS5fd2F0Y2hlcnMuJHJlbW92ZSh0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy52bSA9IHRoaXMuY2IgPSB0aGlzLnZhbHVlID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWNydXNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKlxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWwpIHtcbiAgdmFyIGksIGtleXM7XG4gIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB0cmF2ZXJzZSh2YWxbaV0pO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2tleXNbaV1dKTtcbiAgfVxufVxuXG52YXIgdGV4dCQxID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdGhpcy5hdHRyID0gdGhpcy5lbC5ub2RlVHlwZSA9PT0gMyA/ICdkYXRhJyA6ICd0ZXh0Q29udGVudCc7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmVsW3RoaXMuYXR0cl0gPSBfdG9TdHJpbmcodmFsdWUpO1xuICB9XG59O1xuXG52YXIgdGVtcGxhdGVDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcbnZhciBpZFNlbGVjdG9yQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG5cbnZhciBtYXAgPSB7XG4gIGVmYXVsdDogWzAsICcnLCAnJ10sXG4gIGxlZ2VuZDogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gIHRyOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcbiAgY29sOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXVxufTtcblxubWFwLnRkID0gbWFwLnRoID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbm1hcC5vcHRpb24gPSBtYXAub3B0Z3JvdXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPicsICc8L3NlbGVjdD4nXTtcblxubWFwLnRoZWFkID0gbWFwLnRib2R5ID0gbWFwLmNvbGdyb3VwID0gbWFwLmNhcHRpb24gPSBtYXAudGZvb3QgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcblxubWFwLmcgPSBtYXAuZGVmcyA9IG1hcC5zeW1ib2wgPSBtYXAudXNlID0gbWFwLmltYWdlID0gbWFwLnRleHQgPSBtYXAuY2lyY2xlID0gbWFwLmVsbGlwc2UgPSBtYXAubGluZSA9IG1hcC5wYXRoID0gbWFwLnBvbHlnb24gPSBtYXAucG9seWxpbmUgPSBtYXAucmVjdCA9IFsxLCAnPHN2ZyAnICsgJ3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnICsgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiICcgKyAneG1sbnM6ZXY9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHNcIicgKyAndmVyc2lvbj1cIjEuMVwiPicsICc8L3N2Zz4nXTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIG5vZGUgaXMgYSBzdXBwb3J0ZWQgdGVtcGxhdGUgbm9kZSB3aXRoIGFcbiAqIERvY3VtZW50RnJhZ21lbnQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNSZWFsVGVtcGxhdGUobm9kZSkge1xuICByZXR1cm4gaXNUZW1wbGF0ZShub2RlKSAmJiBpc0ZyYWdtZW50KG5vZGUuY29udGVudCk7XG59XG5cbnZhciB0YWdSRSQxID0gLzwoW1xcdzotXSspLztcbnZhciBlbnRpdHlSRSA9IC8mIz9cXHcrPzsvO1xuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgdGVtcGxhdGUgdG8gYSBEb2N1bWVudEZyYWdtZW50LlxuICogRGV0ZXJtaW5lcyBjb3JyZWN0IHdyYXBwaW5nIGJ5IHRhZyB0eXBlcy4gV3JhcHBpbmdcbiAqIHN0cmF0ZWd5IGZvdW5kIGluIGpRdWVyeSAmIGNvbXBvbmVudC9kb21pZnkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlU3RyaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJhd1xuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdUb0ZyYWdtZW50KHRlbXBsYXRlU3RyaW5nLCByYXcpIHtcbiAgLy8gdHJ5IGEgY2FjaGUgaGl0IGZpcnN0XG4gIHZhciBjYWNoZUtleSA9IHJhdyA/IHRlbXBsYXRlU3RyaW5nIDogdGVtcGxhdGVTdHJpbmcudHJpbSgpO1xuICB2YXIgaGl0ID0gdGVtcGxhdGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuXG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgdGFnTWF0Y2ggPSB0ZW1wbGF0ZVN0cmluZy5tYXRjaCh0YWdSRSQxKTtcbiAgdmFyIGVudGl0eU1hdGNoID0gZW50aXR5UkUudGVzdCh0ZW1wbGF0ZVN0cmluZyk7XG5cbiAgaWYgKCF0YWdNYXRjaCAmJiAhZW50aXR5TWF0Y2gpIHtcbiAgICAvLyB0ZXh0IG9ubHksIHJldHVybiBhIHNpbmdsZSB0ZXh0IG5vZGUuXG4gICAgZnJhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZW1wbGF0ZVN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSB0YWdNYXRjaCAmJiB0YWdNYXRjaFsxXTtcbiAgICB2YXIgd3JhcCA9IG1hcFt0YWddIHx8IG1hcC5lZmF1bHQ7XG4gICAgdmFyIGRlcHRoID0gd3JhcFswXTtcbiAgICB2YXIgcHJlZml4ID0gd3JhcFsxXTtcbiAgICB2YXIgc3VmZml4ID0gd3JhcFsyXTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgbm9kZS5pbm5lckhUTUwgPSBwcmVmaXggKyB0ZW1wbGF0ZVN0cmluZyArIHN1ZmZpeDtcbiAgICB3aGlsZSAoZGVwdGgtLSkge1xuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cblxuICAgIHZhciBjaGlsZDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIHdoaWxlIChjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3KSB7XG4gICAgdHJpbU5vZGUoZnJhZyk7XG4gIH1cbiAgdGVtcGxhdGVDYWNoZS5wdXQoY2FjaGVLZXksIGZyYWcpO1xuICByZXR1cm4gZnJhZztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdGVtcGxhdGUgbm9kZSB0byBhIERvY3VtZW50RnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIG5vZGVUb0ZyYWdtZW50KG5vZGUpIHtcbiAgLy8gaWYgaXRzIGEgdGVtcGxhdGUgdGFnIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBpdCxcbiAgLy8gaXRzIGNvbnRlbnQgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LlxuICBpZiAoaXNSZWFsVGVtcGxhdGUobm9kZSkpIHtcbiAgICB0cmltTm9kZShub2RlLmNvbnRlbnQpO1xuICAgIHJldHVybiBub2RlLmNvbnRlbnQ7XG4gIH1cbiAgLy8gc2NyaXB0IHRlbXBsYXRlXG4gIGlmIChub2RlLnRhZ05hbWUgPT09ICdTQ1JJUFQnKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvRnJhZ21lbnQobm9kZS50ZXh0Q29udGVudCk7XG4gIH1cbiAgLy8gbm9ybWFsIG5vZGUsIGNsb25lIGl0IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbFxuICB2YXIgY2xvbmVkTm9kZSA9IGNsb25lTm9kZShub2RlKTtcbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciBjaGlsZDtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgd2hpbGUgKGNoaWxkID0gY2xvbmVkTm9kZS5maXJzdENoaWxkKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG4gIHRyaW1Ob2RlKGZyYWcpO1xuICByZXR1cm4gZnJhZztcbn1cblxuLy8gVGVzdCBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSBTYWZhcmkgdGVtcGxhdGUgY2xvbmluZyBidWdcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3d1Zy5jZ2k/aWQ9MTM3NzU1XG52YXIgaGFzQnJva2VuVGVtcGxhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBhLmlubmVySFRNTCA9ICc8dGVtcGxhdGU+MTwvdGVtcGxhdGU+JztcbiAgICByZXR1cm4gIWEuY2xvbmVOb2RlKHRydWUpLmZpcnN0Q2hpbGQuaW5uZXJIVE1MO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLy8gVGVzdCBmb3IgSUUxMC8xMSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBjbG9uZSBidWdcbnZhciBoYXNUZXh0YXJlYUNsb25lQnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGluQnJvd3Nlcikge1xuICAgIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB0LnBsYWNlaG9sZGVyID0gJ3QnO1xuICAgIHJldHVybiB0LmNsb25lTm9kZSh0cnVlKS52YWx1ZSA9PT0gJ3QnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiAxLiBEZWFsIHdpdGggU2FmYXJpIGNsb25pbmcgbmVzdGVkIDx0ZW1wbGF0ZT4gYnVnIGJ5XG4gKiAgICBtYW51YWxseSBjbG9uaW5nIGFsbCB0ZW1wbGF0ZSBpbnN0YW5jZXMuXG4gKiAyLiBEZWFsIHdpdGggSUUxMC8xMSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWcgYnkgc2V0dGluZ1xuICogICAgdGhlIGNvcnJlY3QgdmFsdWUgYWZ0ZXIgY2xvbmluZy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gbm9kZVxuICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGNsb25lTm9kZShub2RlKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIW5vZGUucXVlcnlTZWxlY3RvckFsbCkge1xuICAgIHJldHVybiBub2RlLmNsb25lTm9kZSgpO1xuICB9XG4gIHZhciByZXMgPSBub2RlLmNsb25lTm9kZSh0cnVlKTtcbiAgdmFyIGksIG9yaWdpbmFsLCBjbG9uZWQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaGFzQnJva2VuVGVtcGxhdGUpIHtcbiAgICB2YXIgdGVtcENsb25lID0gcmVzO1xuICAgIGlmIChpc1JlYWxUZW1wbGF0ZShub2RlKSkge1xuICAgICAgbm9kZSA9IG5vZGUuY29udGVudDtcbiAgICAgIHRlbXBDbG9uZSA9IHJlcy5jb250ZW50O1xuICAgIH1cbiAgICBvcmlnaW5hbCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgndGVtcGxhdGUnKTtcbiAgICBpZiAob3JpZ2luYWwubGVuZ3RoKSB7XG4gICAgICBjbG9uZWQgPSB0ZW1wQ2xvbmUucXVlcnlTZWxlY3RvckFsbCgndGVtcGxhdGUnKTtcbiAgICAgIGkgPSBjbG9uZWQubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjbG9uZWRbaV0ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY2xvbmVOb2RlKG9yaWdpbmFsW2ldKSwgY2xvbmVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChoYXNUZXh0YXJlYUNsb25lQnVnKSB7XG4gICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgcmVzLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luYWwgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHRhcmVhJyk7XG4gICAgICBpZiAob3JpZ2luYWwubGVuZ3RoKSB7XG4gICAgICAgIGNsb25lZCA9IHJlcy5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpO1xuICAgICAgICBpID0gY2xvbmVkLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNsb25lZFtpXS52YWx1ZSA9IG9yaWdpbmFsW2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogUHJvY2VzcyB0aGUgdGVtcGxhdGUgb3B0aW9uIGFuZCBub3JtYWxpemVzIGl0IGludG8gYVxuICogYSBEb2N1bWVudEZyYWdtZW50IHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBwYXJ0aWFsIG9yIGFcbiAqIGluc3RhbmNlIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGVtcGxhdGVcbiAqICAgICAgICBQb3NzaWJsZSB2YWx1ZXMgaW5jbHVkZTpcbiAqICAgICAgICAtIERvY3VtZW50RnJhZ21lbnQgb2JqZWN0XG4gKiAgICAgICAgLSBOb2RlIG9iamVjdCBvZiB0eXBlIFRlbXBsYXRlXG4gKiAgICAgICAgLSBpZCBzZWxlY3RvcjogJyNzb21lLXRlbXBsYXRlLWlkJ1xuICogICAgICAgIC0gdGVtcGxhdGUgc3RyaW5nOiAnPGRpdj48c3Bhbj57e21zZ319PC9zcGFuPjwvZGl2PidcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdWxkQ2xvbmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmF3XG4gKiAgICAgICAgaW5saW5lIEhUTUwgaW50ZXJwb2xhdGlvbi4gRG8gbm90IGNoZWNrIGZvciBpZFxuICogICAgICAgIHNlbGVjdG9yIGFuZCBrZWVwIHdoaXRlc3BhY2UgaW4gdGhlIHN0cmluZy5cbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUodGVtcGxhdGUsIHNob3VsZENsb25lLCByYXcpIHtcbiAgdmFyIG5vZGUsIGZyYWc7XG5cbiAgLy8gaWYgdGhlIHRlbXBsYXRlIGlzIGFscmVhZHkgYSBkb2N1bWVudCBmcmFnbWVudCxcbiAgLy8gZG8gbm90aGluZ1xuICBpZiAoaXNGcmFnbWVudCh0ZW1wbGF0ZSkpIHtcbiAgICB0cmltTm9kZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHNob3VsZENsb25lID8gY2xvbmVOb2RlKHRlbXBsYXRlKSA6IHRlbXBsYXRlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBpZCBzZWxlY3RvclxuICAgIGlmICghcmF3ICYmIHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAvLyBpZCBzZWxlY3RvciBjYW4gYmUgY2FjaGVkIHRvb1xuICAgICAgZnJhZyA9IGlkU2VsZWN0b3JDYWNoZS5nZXQodGVtcGxhdGUpO1xuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0ZW1wbGF0ZS5zbGljZSgxKSk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgZnJhZyA9IG5vZGVUb0ZyYWdtZW50KG5vZGUpO1xuICAgICAgICAgIC8vIHNhdmUgc2VsZWN0b3IgdG8gY2FjaGVcbiAgICAgICAgICBpZFNlbGVjdG9yQ2FjaGUucHV0KHRlbXBsYXRlLCBmcmFnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgc3RyaW5nIHRlbXBsYXRlXG4gICAgICBmcmFnID0gc3RyaW5nVG9GcmFnbWVudCh0ZW1wbGF0ZSwgcmF3KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAvLyBhIGRpcmVjdCBub2RlXG4gICAgZnJhZyA9IG5vZGVUb0ZyYWdtZW50KHRlbXBsYXRlKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnICYmIHNob3VsZENsb25lID8gY2xvbmVOb2RlKGZyYWcpIDogZnJhZztcbn1cblxudmFyIHRlbXBsYXRlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGNsb25lTm9kZTogY2xvbmVOb2RlLFxuICBwYXJzZVRlbXBsYXRlOiBwYXJzZVRlbXBsYXRlXG59KTtcblxudmFyIGh0bWwgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBhIGNvbW1lbnQgbm9kZSBtZWFucyB0aGlzIGlzIGEgYmluZGluZyBmb3JcbiAgICAvLyB7e3sgaW5saW5lIHVuZXNjYXBlZCBodG1sIH19fVxuICAgIGlmICh0aGlzLmVsLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAvLyBob2xkIG5vZGVzXG4gICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAvLyByZXBsYWNlIHRoZSBwbGFjZWhvbGRlciB3aXRoIHByb3BlciBhbmNob3JcbiAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LWh0bWwnKTtcbiAgICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHZhbHVlID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgdGhpcy5zd2FwKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgc3dhcDogZnVuY3Rpb24gc3dhcCh2YWx1ZSkge1xuICAgIC8vIHJlbW92ZSBvbGQgbm9kZXNcbiAgICB2YXIgaSA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHJlbW92ZSh0aGlzLm5vZGVzW2ldKTtcbiAgICB9XG4gICAgLy8gY29udmVydCBuZXcgdmFsdWUgdG8gYSBmcmFnbWVudFxuICAgIC8vIGRvIG5vdCBhdHRlbXB0IHRvIHJldHJpZXZlIGZyb20gaWQgc2VsZWN0b3JcbiAgICB2YXIgZnJhZyA9IHBhcnNlVGVtcGxhdGUodmFsdWUsIHRydWUsIHRydWUpO1xuICAgIC8vIHNhdmUgYSByZWZlcmVuY2UgdG8gdGhlc2Ugbm9kZXMgc28gd2UgY2FuIHJlbW92ZSBsYXRlclxuICAgIHRoaXMubm9kZXMgPSB0b0FycmF5KGZyYWcuY2hpbGROb2Rlcyk7XG4gICAgYmVmb3JlKGZyYWcsIHRoaXMuYW5jaG9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBmb3IgYSBwYXJ0aWFsbHktY29tcGlsZWQgZnJhZ21lbnQuXG4gKiBDYW4gb3B0aW9uYWxseSBjb21waWxlIGNvbnRlbnQgd2l0aCBhIGNoaWxkIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtlclxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7VnVlfSBbaG9zdF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gKi9cbmZ1bmN0aW9uIEZyYWdtZW50KGxpbmtlciwgdm0sIGZyYWcsIGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5jaGlsZEZyYWdzID0gW107XG4gIHRoaXMudm0gPSB2bTtcbiAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICB0aGlzLmluc2VydGVkID0gZmFsc2U7XG4gIHRoaXMucGFyZW50RnJhZyA9IHBhcmVudEZyYWc7XG4gIGlmIChwYXJlbnRGcmFnKSB7XG4gICAgcGFyZW50RnJhZy5jaGlsZEZyYWdzLnB1c2godGhpcyk7XG4gIH1cbiAgdGhpcy51bmxpbmsgPSBsaW5rZXIodm0sIGZyYWcsIGhvc3QsIHNjb3BlLCB0aGlzKTtcbiAgdmFyIHNpbmdsZSA9IHRoaXMuc2luZ2xlID0gZnJhZy5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJlxuICAvLyBkbyBub3QgZ28gc2luZ2xlIG1vZGUgaWYgdGhlIG9ubHkgbm9kZSBpcyBhbiBhbmNob3JcbiAgIWZyYWcuY2hpbGROb2Rlc1swXS5fX3ZfYW5jaG9yO1xuICBpZiAoc2luZ2xlKSB7XG4gICAgdGhpcy5ub2RlID0gZnJhZy5jaGlsZE5vZGVzWzBdO1xuICAgIHRoaXMuYmVmb3JlID0gc2luZ2xlQmVmb3JlO1xuICAgIHRoaXMucmVtb3ZlID0gc2luZ2xlUmVtb3ZlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubm9kZSA9IGNyZWF0ZUFuY2hvcignZnJhZ21lbnQtc3RhcnQnKTtcbiAgICB0aGlzLmVuZCA9IGNyZWF0ZUFuY2hvcignZnJhZ21lbnQtZW5kJyk7XG4gICAgdGhpcy5mcmFnID0gZnJhZztcbiAgICBwcmVwZW5kKHRoaXMubm9kZSwgZnJhZyk7XG4gICAgZnJhZy5hcHBlbmRDaGlsZCh0aGlzLmVuZCk7XG4gICAgdGhpcy5iZWZvcmUgPSBtdWx0aUJlZm9yZTtcbiAgICB0aGlzLnJlbW92ZSA9IG11bHRpUmVtb3ZlO1xuICB9XG4gIHRoaXMubm9kZS5fX3ZfZnJhZyA9IHRoaXM7XG59XG5cbi8qKlxuICogQ2FsbCBhdHRhY2gvZGV0YWNoIGZvciBhbGwgY29tcG9uZW50cyBjb250YWluZWQgd2l0aGluXG4gKiB0aGlzIGZyYWdtZW50LiBBbHNvIGRvIHNvIHJlY3Vyc2l2ZWx5IGZvciBhbGwgY2hpbGRcbiAqIGZyYWdtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmNhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgdmFyIGksIGw7XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5jaGlsZEZyYWdzW2ldLmNhbGxIb29rKGhvb2spO1xuICB9XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGhvb2sodGhpcy5jaGlsZHJlbltpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZUJlZm9yZSh0YXJnZXQsIHdpdGhUcmFuc2l0aW9uKSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSB0cnVlO1xuICB2YXIgbWV0aG9kID0gd2l0aFRyYW5zaXRpb24gIT09IGZhbHNlID8gYmVmb3JlV2l0aFRyYW5zaXRpb24gOiBiZWZvcmU7XG4gIG1ldGhvZCh0aGlzLm5vZGUsIHRhcmdldCwgdGhpcy52bSk7XG4gIGlmIChpbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGZyYWdtZW50LCBzaW5nbGUgbm9kZSB2ZXJzaW9uXG4gKi9cblxuZnVuY3Rpb24gc2luZ2xlUmVtb3ZlKCkge1xuICB0aGlzLmluc2VydGVkID0gZmFsc2U7XG4gIHZhciBzaG91bGRDYWxsUmVtb3ZlID0gaW5Eb2ModGhpcy5ub2RlKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xuICByZW1vdmVXaXRoVHJhbnNpdGlvbih0aGlzLm5vZGUsIHRoaXMudm0sIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2hvdWxkQ2FsbFJlbW92ZSkge1xuICAgICAgc2VsZi5jYWxsSG9vayhkZXRhY2gpO1xuICAgIH1cbiAgICBzZWxmLmRlc3Ryb3koKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIG11bHRpLW5vZGVzIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIG11bHRpQmVmb3JlKHRhcmdldCwgd2l0aFRyYW5zaXRpb24pIHtcbiAgdGhpcy5pbnNlcnRlZCA9IHRydWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHZhciBtZXRob2QgPSB3aXRoVHJhbnNpdGlvbiAhPT0gZmFsc2UgPyBiZWZvcmVXaXRoVHJhbnNpdGlvbiA6IGJlZm9yZTtcbiAgbWFwTm9kZVJhbmdlKHRoaXMubm9kZSwgdGhpcy5lbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbWV0aG9kKG5vZGUsIHRhcmdldCwgdm0pO1xuICB9KTtcbiAgaWYgKGluRG9jKHRoaXMubm9kZSkpIHtcbiAgICB0aGlzLmNhbGxIb29rKGF0dGFjaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZnJhZ21lbnQsIG11bHRpLW5vZGVzIHZlcnNpb25cbiAqL1xuXG5mdW5jdGlvbiBtdWx0aVJlbW92ZSgpIHtcbiAgdGhpcy5pbnNlcnRlZCA9IGZhbHNlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzaG91bGRDYWxsUmVtb3ZlID0gaW5Eb2ModGhpcy5ub2RlKTtcbiAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcbiAgcmVtb3ZlTm9kZVJhbmdlKHRoaXMubm9kZSwgdGhpcy5lbmQsIHRoaXMudm0sIHRoaXMuZnJhZywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzaG91bGRDYWxsUmVtb3ZlKSB7XG4gICAgICBzZWxmLmNhbGxIb29rKGRldGFjaCk7XG4gICAgfVxuICAgIHNlbGYuZGVzdHJveSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQcmVwYXJlIHRoZSBmcmFnbWVudCBmb3IgcmVtb3ZhbC5cbiAqL1xuXG5GcmFnbWVudC5wcm90b3R5cGUuYmVmb3JlUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSwgbDtcbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBjYWxsIHRoZSBzYW1lIG1ldGhvZCByZWN1cnNpdmVseSBvbiBjaGlsZFxuICAgIC8vIGZyYWdtZW50cywgZGVwdGgtZmlyc3RcbiAgICB0aGlzLmNoaWxkRnJhZ3NbaV0uYmVmb3JlUmVtb3ZlKGZhbHNlKTtcbiAgfVxuICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBDYWxsIGRlc3Ryb3kgZm9yIGFsbCBjb250YWluZWQgaW5zdGFuY2VzLFxuICAgIC8vIHdpdGggcmVtb3ZlOmZhbHNlIGFuZCBkZWZlcjp0cnVlLlxuICAgIC8vIERlZmVyIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG9cbiAgICAvLyBrZWVwIHRoZSBjaGlsZHJlbiB0byBjYWxsIGRldGFjaCBob29rc1xuICAgIC8vIG9uIHRoZW0uXG4gICAgdGhpcy5jaGlsZHJlbltpXS4kZGVzdHJveShmYWxzZSwgdHJ1ZSk7XG4gIH1cbiAgdmFyIGRpcnMgPSB0aGlzLnVubGluay5kaXJzO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBkaXNhYmxlIHRoZSB3YXRjaGVycyBvbiBhbGwgdGhlIGRpcmVjdGl2ZXNcbiAgICAvLyBzbyB0aGF0IHRoZSByZW5kZXJlZCBjb250ZW50IHN0YXlzIHRoZSBzYW1lXG4gICAgLy8gZHVyaW5nIHJlbW92YWwuXG4gICAgZGlyc1tpXS5fd2F0Y2hlciAmJiBkaXJzW2ldLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgZnJhZ21lbnQuXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBhcmVudEZyYWcpIHtcbiAgICB0aGlzLnBhcmVudEZyYWcuY2hpbGRGcmFncy4kcmVtb3ZlKHRoaXMpO1xuICB9XG4gIHRoaXMubm9kZS5fX3ZfZnJhZyA9IG51bGw7XG4gIHRoaXMudW5saW5rKCk7XG59O1xuXG4vKipcbiAqIENhbGwgYXR0YWNoIGhvb2sgZm9yIGEgVnVlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICovXG5cbmZ1bmN0aW9uIGF0dGFjaChjaGlsZCkge1xuICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkICYmIGluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICBjaGlsZC5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsIGRldGFjaCBob29rIGZvciBhIFZ1ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBkZXRhY2goY2hpbGQpIHtcbiAgaWYgKGNoaWxkLl9pc0F0dGFjaGVkICYmICFpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgY2hpbGQuX2NhbGxIb29rKCdkZXRhY2hlZCcpO1xuICB9XG59XG5cbnZhciBsaW5rZXJDYWNoZSA9IG5ldyBDYWNoZSg1MDAwKTtcblxuLyoqXG4gKiBBIGZhY3RvcnkgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGFcbiAqIGZyYWdtZW50LiBDYWNoZXMgdGhlIGNvbXBpbGVkIGxpbmtlciBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKi9cbmZ1bmN0aW9uIEZyYWdtZW50RmFjdG9yeSh2bSwgZWwpIHtcbiAgdGhpcy52bSA9IHZtO1xuICB2YXIgdGVtcGxhdGU7XG4gIHZhciBpc1N0cmluZyA9IHR5cGVvZiBlbCA9PT0gJ3N0cmluZyc7XG4gIGlmIChpc1N0cmluZyB8fCBpc1RlbXBsYXRlKGVsKSkge1xuICAgIHRlbXBsYXRlID0gcGFyc2VUZW1wbGF0ZShlbCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdGVtcGxhdGUuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG4gIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgLy8gbGlua2VyIGNhbiBiZSBjYWNoZWQsIGJ1dCBvbmx5IGZvciBjb21wb25lbnRzXG4gIHZhciBsaW5rZXI7XG4gIHZhciBjaWQgPSB2bS5jb25zdHJ1Y3Rvci5jaWQ7XG4gIGlmIChjaWQgPiAwKSB7XG4gICAgdmFyIGNhY2hlSWQgPSBjaWQgKyAoaXNTdHJpbmcgPyBlbCA6IGdldE91dGVySFRNTChlbCkpO1xuICAgIGxpbmtlciA9IGxpbmtlckNhY2hlLmdldChjYWNoZUlkKTtcbiAgICBpZiAoIWxpbmtlcikge1xuICAgICAgbGlua2VyID0gY29tcGlsZSh0ZW1wbGF0ZSwgdm0uJG9wdGlvbnMsIHRydWUpO1xuICAgICAgbGlua2VyQ2FjaGUucHV0KGNhY2hlSWQsIGxpbmtlcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxpbmtlciA9IGNvbXBpbGUodGVtcGxhdGUsIHZtLiRvcHRpb25zLCB0cnVlKTtcbiAgfVxuICB0aGlzLmxpbmtlciA9IGxpbmtlcjtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBmcmFnbWVudCBpbnN0YW5jZSB3aXRoIGdpdmVuIGhvc3QgYW5kIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSBob3N0XG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IHBhcmVudEZyYWdcbiAqL1xuXG5GcmFnbWVudEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChob3N0LCBzY29wZSwgcGFyZW50RnJhZykge1xuICB2YXIgZnJhZyA9IGNsb25lTm9kZSh0aGlzLnRlbXBsYXRlKTtcbiAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmxpbmtlciwgdGhpcy52bSwgZnJhZywgaG9zdCwgc2NvcGUsIHBhcmVudEZyYWcpO1xufTtcblxudmFyIE9OID0gNzAwO1xudmFyIE1PREVMID0gODAwO1xudmFyIEJJTkQgPSA4NTA7XG52YXIgVFJBTlNJVElPTiA9IDExMDA7XG52YXIgRUwgPSAxNTAwO1xudmFyIENPTVBPTkVOVCA9IDE1MDA7XG52YXIgUEFSVElBTCA9IDE3NTA7XG52YXIgRk9SID0gMjAwMDtcbnZhciBJRiA9IDIwMDA7XG52YXIgU0xPVCA9IDIxMDA7XG5cbnZhciB1aWQkMyA9IDA7XG5cbnZhciB2Rm9yID0ge1xuXG4gIHByaW9yaXR5OiBGT1IsXG5cbiAgcGFyYW1zOiBbJ3RyYWNrLWJ5JywgJ3N0YWdnZXInLCAnZW50ZXItc3RhZ2dlcicsICdsZWF2ZS1zdGFnZ2VyJ10sXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBzdXBwb3J0IFwiaXRlbSBpbi9vZiBpdGVtc1wiIHN5bnRheFxuICAgIHZhciBpbk1hdGNoID0gdGhpcy5leHByZXNzaW9uLm1hdGNoKC8oLiopICg/OmlufG9mKSAoLiopLyk7XG4gICAgaWYgKGluTWF0Y2gpIHtcbiAgICAgIHZhciBpdE1hdGNoID0gaW5NYXRjaFsxXS5tYXRjaCgvXFwoKC4qKSwoLiopXFwpLyk7XG4gICAgICBpZiAoaXRNYXRjaCkge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRNYXRjaFsxXS50cmltKCk7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBpdE1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGluTWF0Y2hbMl07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFsaWFzKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0FsaWFzIGlzIHJlcXVpcmVkIGluIHYtZm9yLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVpZCBhcyBhIGNhY2hlIGlkZW50aWZpZXJcbiAgICB0aGlzLmlkID0gJ19fdi1mb3JfXycgKyArK3VpZCQzO1xuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhbiBvcHRpb24gbGlzdCxcbiAgICAvLyBzbyB0aGF0IHdlIGtub3cgaWYgd2UgbmVlZCB0byB1cGRhdGUgdGhlIDxzZWxlY3Q+J3NcbiAgICAvLyB2LW1vZGVsIHdoZW4gdGhlIG9wdGlvbiBsaXN0IGhhcyBjaGFuZ2VkLlxuICAgIC8vIGJlY2F1c2Ugdi1tb2RlbCBoYXMgYSBsb3dlciBwcmlvcml0eSB0aGFuIHYtZm9yLFxuICAgIC8vIHRoZSB2LW1vZGVsIGlzIG5vdCBib3VuZCBoZXJlIHlldCwgc28gd2UgaGF2ZSB0b1xuICAgIC8vIHJldHJpdmUgaXQgaW4gdGhlIGFjdHVhbCB1cGRhdGVNb2RlbCgpIGZ1bmN0aW9uLlxuICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgdGhpcy5pc09wdGlvbiA9ICh0YWcgPT09ICdPUFRJT04nIHx8IHRhZyA9PT0gJ09QVEdST1VQJykgJiYgdGhpcy5lbC5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdTRUxFQ1QnO1xuXG4gICAgLy8gc2V0dXAgYW5jaG9yIG5vZGVzXG4gICAgdGhpcy5zdGFydCA9IGNyZWF0ZUFuY2hvcigndi1mb3Itc3RhcnQnKTtcbiAgICB0aGlzLmVuZCA9IGNyZWF0ZUFuY2hvcigndi1mb3ItZW5kJyk7XG4gICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmVuZCk7XG4gICAgYmVmb3JlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcblxuICAgIC8vIGNhY2hlXG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBmcmFnbWVudCBmYWN0b3J5XG4gICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShkYXRhKSB7XG4gICAgdGhpcy5kaWZmKGRhdGEpO1xuICAgIHRoaXMudXBkYXRlUmVmKCk7XG4gICAgdGhpcy51cGRhdGVNb2RlbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaWZmLCBiYXNlZCBvbiBuZXcgZGF0YSBhbmQgb2xkIGRhdGEsIGRldGVybWluZSB0aGVcbiAgICogbWluaW11bSBhbW91bnQgb2YgRE9NIG1hbmlwdWxhdGlvbnMgbmVlZGVkIHRvIG1ha2UgdGhlXG4gICAqIERPTSByZWZsZWN0IHRoZSBuZXcgZGF0YSBBcnJheS5cbiAgICpcbiAgICogVGhlIGFsZ29yaXRobSBkaWZmcyB0aGUgbmV3IGRhdGEgQXJyYXkgYnkgc3RvcmluZyBhXG4gICAqIGhpZGRlbiByZWZlcmVuY2UgdG8gYW4gb3duZXIgdm0gaW5zdGFuY2Ugb24gcHJldmlvdXNseVxuICAgKiBzZWVuIGRhdGEuIFRoaXMgYWxsb3dzIHVzIHRvIGFjaGlldmUgTyhuKSB3aGljaCBpc1xuICAgKiBiZXR0ZXIgdGhhbiBhIGxldmVuc2h0ZWluIGRpc3RhbmNlIGJhc2VkIGFsZ29yaXRobSxcbiAgICogd2hpY2ggaXMgTyhtICogbikuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAgICovXG5cbiAgZGlmZjogZnVuY3Rpb24gZGlmZihkYXRhKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIEFycmF5IHdhcyBjb252ZXJ0ZWQgZnJvbSBhbiBPYmplY3RcbiAgICB2YXIgaXRlbSA9IGRhdGFbMF07XG4gICAgdmFyIGNvbnZlcnRlZEZyb21PYmplY3QgPSB0aGlzLmZyb21PYmplY3QgPSBpc09iamVjdChpdGVtKSAmJiBoYXNPd24oaXRlbSwgJyRrZXknKSAmJiBoYXNPd24oaXRlbSwgJyR2YWx1ZScpO1xuXG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBvbGRGcmFncyA9IHRoaXMuZnJhZ3M7XG4gICAgdmFyIGZyYWdzID0gdGhpcy5mcmFncyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgdmFyIGFsaWFzID0gdGhpcy5hbGlhcztcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yO1xuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuICAgIHZhciBpbkRvY3VtZW50ID0gaW5Eb2Moc3RhcnQpO1xuICAgIHZhciBpbml0ID0gIW9sZEZyYWdzO1xuICAgIHZhciBpLCBsLCBmcmFnLCBrZXksIHZhbHVlLCBwcmltaXRpdmU7XG5cbiAgICAvLyBGaXJzdCBwYXNzLCBnbyB0aHJvdWdoIHRoZSBuZXcgQXJyYXkgYW5kIGZpbGwgdXBcbiAgICAvLyB0aGUgbmV3IGZyYWdzIGFycmF5LiBJZiBhIHBpZWNlIG9mIGRhdGEgaGFzIGEgY2FjaGVkXG4gICAgLy8gaW5zdGFuY2UgZm9yIGl0LCB3ZSByZXVzZSBpdC4gT3RoZXJ3aXNlIGJ1aWxkIGEgbmV3XG4gICAgLy8gaW5zdGFuY2UuXG4gICAgZm9yIChpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpdGVtID0gZGF0YVtpXTtcbiAgICAgIGtleSA9IGNvbnZlcnRlZEZyb21PYmplY3QgPyBpdGVtLiRrZXkgOiBudWxsO1xuICAgICAgdmFsdWUgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4kdmFsdWUgOiBpdGVtO1xuICAgICAgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGZyYWcgPSAhaW5pdCAmJiB0aGlzLmdldENhY2hlZEZyYWcodmFsdWUsIGksIGtleSk7XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICAvLyByZXVzYWJsZSBmcmFnbWVudFxuICAgICAgICBmcmFnLnJldXNlZCA9IHRydWU7XG4gICAgICAgIC8vIHVwZGF0ZSAkaW5kZXhcbiAgICAgICAgZnJhZy5zY29wZS4kaW5kZXggPSBpO1xuICAgICAgICAvLyB1cGRhdGUgJGtleVxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgZnJhZy5zY29wZS4ka2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBpdGVyYXRvclxuICAgICAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICBmcmFnLnNjb3BlW2l0ZXJhdG9yXSA9IGtleSAhPT0gbnVsbCA/IGtleSA6IGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGRhdGEgZm9yIHRyYWNrLWJ5LCBvYmplY3QgcmVwZWF0ICZcbiAgICAgICAgLy8gcHJpbWl0aXZlIHZhbHVlcy5cbiAgICAgICAgaWYgKHRyYWNrQnlLZXkgfHwgY29udmVydGVkRnJvbU9iamVjdCB8fCBwcmltaXRpdmUpIHtcbiAgICAgICAgICBmcmFnLnNjb3BlW2FsaWFzXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgaXNudGFuY2VcbiAgICAgICAgZnJhZyA9IHRoaXMuY3JlYXRlKHZhbHVlLCBhbGlhcywgaSwga2V5KTtcbiAgICAgICAgZnJhZy5mcmVzaCA9ICFpbml0O1xuICAgICAgfVxuICAgICAgZnJhZ3NbaV0gPSBmcmFnO1xuICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgZnJhZy5iZWZvcmUoZW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSdyZSBkb25lIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZWNvbmQgcGFzcywgZ28gdGhyb3VnaCB0aGUgb2xkIGZyYWdtZW50cyBhbmRcbiAgICAvLyBkZXN0cm95IHRob3NlIHdobyBhcmUgbm90IHJldXNlZCAoYW5kIHJlbW92ZSB0aGVtXG4gICAgLy8gZnJvbSBjYWNoZSlcbiAgICB2YXIgcmVtb3ZhbEluZGV4ID0gMDtcbiAgICB2YXIgdG90YWxSZW1vdmVkID0gb2xkRnJhZ3MubGVuZ3RoIC0gZnJhZ3MubGVuZ3RoO1xuICAgIC8vIHdoZW4gcmVtb3ZpbmcgYSBsYXJnZSBudW1iZXIgb2YgZnJhZ21lbnRzLCB3YXRjaGVyIHJlbW92YWxcbiAgICAvLyB0dXJucyBvdXQgdG8gYmUgYSBwZXJmIGJvdHRsZW5lY2ssIHNvIHdlIGJhdGNoIHRoZSB3YXRjaGVyXG4gICAgLy8gcmVtb3ZhbHMgaW50byBhIHNpbmdsZSBmaWx0ZXIgY2FsbCFcbiAgICB0aGlzLnZtLl92Rm9yUmVtb3ZpbmcgPSB0cnVlO1xuICAgIGZvciAoaSA9IDAsIGwgPSBvbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZyYWcgPSBvbGRGcmFnc1tpXTtcbiAgICAgIGlmICghZnJhZy5yZXVzZWQpIHtcbiAgICAgICAgdGhpcy5kZWxldGVDYWNoZWRGcmFnKGZyYWcpO1xuICAgICAgICB0aGlzLnJlbW92ZShmcmFnLCByZW1vdmFsSW5kZXgrKywgdG90YWxSZW1vdmVkLCBpbkRvY3VtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52bS5fdkZvclJlbW92aW5nID0gZmFsc2U7XG4gICAgaWYgKHJlbW92YWxJbmRleCkge1xuICAgICAgdGhpcy52bS5fd2F0Y2hlcnMgPSB0aGlzLnZtLl93YXRjaGVycy5maWx0ZXIoZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgcmV0dXJuIHcuYWN0aXZlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmluYWwgcGFzcywgbW92ZS9pbnNlcnQgbmV3IGZyYWdtZW50cyBpbnRvIHRoZVxuICAgIC8vIHJpZ2h0IHBsYWNlLlxuICAgIHZhciB0YXJnZXRQcmV2LCBwcmV2RWwsIGN1cnJlbnRQcmV2O1xuICAgIHZhciBpbnNlcnRpb25JbmRleCA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGZyYWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZnJhZyA9IGZyYWdzW2ldO1xuICAgICAgLy8gdGhpcyBpcyB0aGUgZnJhZyB0aGF0IHdlIHNob3VsZCBiZSBhZnRlclxuICAgICAgdGFyZ2V0UHJldiA9IGZyYWdzW2kgLSAxXTtcbiAgICAgIHByZXZFbCA9IHRhcmdldFByZXYgPyB0YXJnZXRQcmV2LnN0YWdnZXJDYiA/IHRhcmdldFByZXYuc3RhZ2dlckFuY2hvciA6IHRhcmdldFByZXYuZW5kIHx8IHRhcmdldFByZXYubm9kZSA6IHN0YXJ0O1xuICAgICAgaWYgKGZyYWcucmV1c2VkICYmICFmcmFnLnN0YWdnZXJDYikge1xuICAgICAgICBjdXJyZW50UHJldiA9IGZpbmRQcmV2RnJhZyhmcmFnLCBzdGFydCwgdGhpcy5pZCk7XG4gICAgICAgIGlmIChjdXJyZW50UHJldiAhPT0gdGFyZ2V0UHJldiAmJiAoIWN1cnJlbnRQcmV2IHx8XG4gICAgICAgIC8vIG9wdGltaXphdGlvbiBmb3IgbW92aW5nIGEgc2luZ2xlIGl0ZW0uXG4gICAgICAgIC8vIHRoYW5rcyB0byBzdWdnZXN0aW9ucyBieSBAbGl2b3JhcyBpbiAjMTgwN1xuICAgICAgICBmaW5kUHJldkZyYWcoY3VycmVudFByZXYsIHN0YXJ0LCB0aGlzLmlkKSAhPT0gdGFyZ2V0UHJldikpIHtcbiAgICAgICAgICB0aGlzLm1vdmUoZnJhZywgcHJldkVsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbmV3IGluc3RhbmNlLCBvciBzdGlsbCBpbiBzdGFnZ2VyLlxuICAgICAgICAvLyBpbnNlcnQgd2l0aCB1cGRhdGVkIHN0YWdnZXIgaW5kZXguXG4gICAgICAgIHRoaXMuaW5zZXJ0KGZyYWcsIGluc2VydGlvbkluZGV4KyssIHByZXZFbCwgaW5Eb2N1bWVudCk7XG4gICAgICB9XG4gICAgICBmcmFnLnJldXNlZCA9IGZyYWcuZnJlc2ggPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWxpYXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICAgKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAgICovXG5cbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUsIGFsaWFzLCBpbmRleCwga2V5KSB7XG4gICAgdmFyIGhvc3QgPSB0aGlzLl9ob3N0O1xuICAgIC8vIGNyZWF0ZSBpdGVyYXRpb24gc2NvcGVcbiAgICB2YXIgcGFyZW50U2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtO1xuICAgIHZhciBzY29wZSA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUpO1xuICAgIC8vIHJlZiBob2xkZXIgZm9yIHRoZSBzY29wZVxuICAgIHNjb3BlLiRyZWZzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZS4kcmVmcyk7XG4gICAgc2NvcGUuJGVscyA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUuJGVscyk7XG4gICAgLy8gbWFrZSBzdXJlIHBvaW50ICRwYXJlbnQgdG8gcGFyZW50IHNjb3BlXG4gICAgc2NvcGUuJHBhcmVudCA9IHBhcmVudFNjb3BlO1xuICAgIC8vIGZvciB0d28td2F5IGJpbmRpbmcgb24gYWxpYXNcbiAgICBzY29wZS4kZm9yQ29udGV4dCA9IHRoaXM7XG4gICAgLy8gZGVmaW5lIHNjb3BlIHByb3BlcnRpZXNcbiAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgYWxpYXMsIHZhbHVlLCB0cnVlIC8qIGRvIG5vdCBvYnNlcnZlICovKTtcbiAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgJyRpbmRleCcsIGluZGV4KTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgJyRrZXknLCBrZXkpO1xuICAgIH0gZWxzZSBpZiAoc2NvcGUuJGtleSkge1xuICAgICAgLy8gYXZvaWQgYWNjaWRlbnRhbCBmYWxsYmFja1xuICAgICAgZGVmKHNjb3BlLCAnJGtleScsIG51bGwpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pdGVyYXRvcikge1xuICAgICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsIHRoaXMuaXRlcmF0b3IsIGtleSAhPT0gbnVsbCA/IGtleSA6IGluZGV4KTtcbiAgICB9XG4gICAgdmFyIGZyYWcgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKGhvc3QsIHNjb3BlLCB0aGlzLl9mcmFnKTtcbiAgICBmcmFnLmZvcklkID0gdGhpcy5pZDtcbiAgICB0aGlzLmNhY2hlRnJhZyh2YWx1ZSwgZnJhZywgaW5kZXgsIGtleSk7XG4gICAgcmV0dXJuIGZyYWc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdi1yZWYgb24gb3duZXIgdm0uXG4gICAqL1xuXG4gIHVwZGF0ZVJlZjogZnVuY3Rpb24gdXBkYXRlUmVmKCkge1xuICAgIHZhciByZWYgPSB0aGlzLmRlc2NyaXB0b3IucmVmO1xuICAgIGlmICghcmVmKSByZXR1cm47XG4gICAgdmFyIGhhc2ggPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHJlZnM7XG4gICAgdmFyIHJlZnM7XG4gICAgaWYgKCF0aGlzLmZyb21PYmplY3QpIHtcbiAgICAgIHJlZnMgPSB0aGlzLmZyYWdzLm1hcChmaW5kVm1Gcm9tRnJhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnMgPSB7fTtcbiAgICAgIHRoaXMuZnJhZ3MuZm9yRWFjaChmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICByZWZzW2ZyYWcuc2NvcGUuJGtleV0gPSBmaW5kVm1Gcm9tRnJhZyhmcmFnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBoYXNoW3JlZl0gPSByZWZzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3Igb3B0aW9uIGxpc3RzLCB1cGRhdGUgdGhlIGNvbnRhaW5pbmcgdi1tb2RlbCBvblxuICAgKiBwYXJlbnQgPHNlbGVjdD4uXG4gICAqL1xuXG4gIHVwZGF0ZU1vZGVsOiBmdW5jdGlvbiB1cGRhdGVNb2RlbCgpIHtcbiAgICBpZiAodGhpcy5pc09wdGlvbikge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuc3RhcnQucGFyZW50Tm9kZTtcbiAgICAgIHZhciBtb2RlbCA9IHBhcmVudCAmJiBwYXJlbnQuX192X21vZGVsO1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIG1vZGVsLmZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSBmcmFnbWVudC4gSGFuZGxlcyBzdGFnZ2VyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge05vZGV9IHByZXZFbFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluRG9jdW1lbnRcbiAgICovXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoZnJhZywgaW5kZXgsIHByZXZFbCwgaW5Eb2N1bWVudCkge1xuICAgIGlmIChmcmFnLnN0YWdnZXJDYikge1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IuY2FuY2VsKCk7XG4gICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgfVxuICAgIHZhciBzdGFnZ2VyQW1vdW50ID0gdGhpcy5nZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCBudWxsLCAnZW50ZXInKTtcbiAgICBpZiAoaW5Eb2N1bWVudCAmJiBzdGFnZ2VyQW1vdW50KSB7XG4gICAgICAvLyBjcmVhdGUgYW4gYW5jaG9yIGFuZCBpbnNlcnQgaXQgc3luY2hyb25vdXNseSxcbiAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIHJlc29sdmUgdGhlIGNvcnJlY3Qgb3JkZXIgd2l0aG91dFxuICAgICAgLy8gd29ycnlpbmcgYWJvdXQgc29tZSBlbGVtZW50cyBub3QgaW5zZXJ0ZWQgeWV0XG4gICAgICB2YXIgYW5jaG9yID0gZnJhZy5zdGFnZ2VyQW5jaG9yO1xuICAgICAgaWYgKCFhbmNob3IpIHtcbiAgICAgICAgYW5jaG9yID0gZnJhZy5zdGFnZ2VyQW5jaG9yID0gY3JlYXRlQW5jaG9yKCdzdGFnZ2VyLWFuY2hvcicpO1xuICAgICAgICBhbmNob3IuX192X2ZyYWcgPSBmcmFnO1xuICAgICAgfVxuICAgICAgYWZ0ZXIoYW5jaG9yLCBwcmV2RWwpO1xuICAgICAgdmFyIG9wID0gZnJhZy5zdGFnZ2VyQ2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICAgICAgZnJhZy5iZWZvcmUoYW5jaG9yKTtcbiAgICAgICAgcmVtb3ZlKGFuY2hvcik7XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQob3AsIHN0YWdnZXJBbW91bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnLmJlZm9yZShwcmV2RWwubmV4dFNpYmxpbmcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGEgZnJhZ21lbnQuIEhhbmRsZXMgc3RhZ2dlcmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5Eb2N1bWVudFxuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShmcmFnLCBpbmRleCwgdG90YWwsIGluRG9jdW1lbnQpIHtcbiAgICBpZiAoZnJhZy5zdGFnZ2VyQ2IpIHtcbiAgICAgIGZyYWcuc3RhZ2dlckNiLmNhbmNlbCgpO1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgICAgLy8gaXQncyBub3QgcG9zc2libGUgZm9yIHRoZSBzYW1lIGZyYWcgdG8gYmUgcmVtb3ZlZFxuICAgICAgLy8gdHdpY2UsIHNvIGlmIHdlIGhhdmUgYSBwZW5kaW5nIHN0YWdnZXIgY2FsbGJhY2ssXG4gICAgICAvLyBpdCBtZWFucyB0aGlzIGZyYWcgaXMgcXVldWVkIGZvciBlbnRlciBidXQgcmVtb3ZlZFxuICAgICAgLy8gYmVmb3JlIGl0cyB0cmFuc2l0aW9uIHN0YXJ0ZWQuIFNpbmNlIGl0IGlzIGFscmVhZHlcbiAgICAgIC8vIGRlc3Ryb3llZCwgd2UgY2FuIGp1c3QgbGVhdmUgaXQgaW4gZGV0YWNoZWQgc3RhdGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdGFnZ2VyQW1vdW50ID0gdGhpcy5nZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCB0b3RhbCwgJ2xlYXZlJyk7XG4gICAgaWYgKGluRG9jdW1lbnQgJiYgc3RhZ2dlckFtb3VudCkge1xuICAgICAgdmFyIG9wID0gZnJhZy5zdGFnZ2VyQ2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICAgICAgZnJhZy5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChvcCwgc3RhZ2dlckFtb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcucmVtb3ZlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgZnJhZ21lbnQgdG8gYSBuZXcgcG9zaXRpb24uXG4gICAqIEZvcmNlIG5vIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOb2RlfSBwcmV2RWxcbiAgICovXG5cbiAgbW92ZTogZnVuY3Rpb24gbW92ZShmcmFnLCBwcmV2RWwpIHtcbiAgICAvLyBmaXggYSBjb21tb24gaXNzdWUgd2l0aCBTb3J0YWJsZTpcbiAgICAvLyBpZiBwcmV2RWwgZG9lc24ndCBoYXZlIG5leHRTaWJsaW5nLCB0aGlzIG1lYW5zIGl0J3NcbiAgICAvLyBiZWVuIGRyYWdnZWQgYWZ0ZXIgdGhlIGVuZCBhbmNob3IuIEp1c3QgcmUtcG9zaXRpb25cbiAgICAvLyB0aGUgZW5kIGFuY2hvciB0byB0aGUgZW5kIG9mIHRoZSBjb250YWluZXIuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFwcmV2RWwubmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuZW5kLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5lbmQpO1xuICAgIH1cbiAgICBmcmFnLmJlZm9yZShwcmV2RWwubmV4dFNpYmxpbmcsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FjaGUgYSBmcmFnbWVudCB1c2luZyB0cmFjay1ieSBvciB0aGUgb2JqZWN0IGtleS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICovXG5cbiAgY2FjaGVGcmFnOiBmdW5jdGlvbiBjYWNoZUZyYWcodmFsdWUsIGZyYWcsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB2YXIgaWQ7XG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgaWQgPSB0cmFja0J5S2V5ID8gdHJhY2tCeUtleSA9PT0gJyRpbmRleCcgPyBpbmRleCA6IHZhbHVlW3RyYWNrQnlLZXldIDoga2V5IHx8IHZhbHVlO1xuICAgICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgICAgY2FjaGVbaWRdID0gZnJhZztcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tCeUtleSAhPT0gJyRpbmRleCcpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHRoaXMuaWQ7XG4gICAgICBpZiAoaGFzT3duKHZhbHVlLCBpZCkpIHtcbiAgICAgICAgaWYgKHZhbHVlW2lkXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlW2lkXSA9IGZyYWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWYodmFsdWUsIGlkLCBmcmFnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnJhZy5yYXcgPSB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgY2FjaGVkIGZyYWdtZW50IGZyb20gdGhlIHZhbHVlL2luZGV4L2tleVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge0ZyYWdtZW50fVxuICAgKi9cblxuICBnZXRDYWNoZWRGcmFnOiBmdW5jdGlvbiBnZXRDYWNoZWRGcmFnKHZhbHVlLCBpbmRleCwga2V5KSB7XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgIHZhciBmcmFnO1xuICAgIGlmIChrZXkgfHwgdHJhY2tCeUtleSB8fCBwcmltaXRpdmUpIHtcbiAgICAgIHZhciBpZCA9IHRyYWNrQnlLZXkgPyB0cmFja0J5S2V5ID09PSAnJGluZGV4JyA/IGluZGV4IDogdmFsdWVbdHJhY2tCeUtleV0gOiBrZXkgfHwgdmFsdWU7XG4gICAgICBmcmFnID0gdGhpcy5jYWNoZVtpZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcgPSB2YWx1ZVt0aGlzLmlkXTtcbiAgICB9XG4gICAgaWYgKGZyYWcgJiYgKGZyYWcucmV1c2VkIHx8IGZyYWcuZnJlc2gpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMud2FybkR1cGxpY2F0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBmcmFnbWVudCBmcm9tIGNhY2hlLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqL1xuXG4gIGRlbGV0ZUNhY2hlZEZyYWc6IGZ1bmN0aW9uIGRlbGV0ZUNhY2hlZEZyYWcoZnJhZykge1xuICAgIHZhciB2YWx1ZSA9IGZyYWcucmF3O1xuICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICB2YXIgc2NvcGUgPSBmcmFnLnNjb3BlO1xuICAgIHZhciBpbmRleCA9IHNjb3BlLiRpbmRleDtcbiAgICAvLyBmaXggIzk0ODogYXZvaWQgYWNjaWRlbnRhbGx5IGZhbGwgdGhyb3VnaCB0b1xuICAgIC8vIGEgcGFyZW50IHJlcGVhdGVyIHdoaWNoIGhhcHBlbnMgdG8gaGF2ZSAka2V5LlxuICAgIHZhciBrZXkgPSBoYXNPd24oc2NvcGUsICcka2V5JykgJiYgc2NvcGUuJGtleTtcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICBpZiAodHJhY2tCeUtleSB8fCBrZXkgfHwgcHJpbWl0aXZlKSB7XG4gICAgICB2YXIgaWQgPSB0cmFja0J5S2V5ID8gdHJhY2tCeUtleSA9PT0gJyRpbmRleCcgPyBpbmRleCA6IHZhbHVlW3RyYWNrQnlLZXldIDoga2V5IHx8IHZhbHVlO1xuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVt0aGlzLmlkXSA9IG51bGw7XG4gICAgICBmcmFnLnJhdyA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YWdnZXIgYW1vdW50IGZvciBhbiBpbnNlcnRpb24vcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqL1xuXG4gIGdldFN0YWdnZXI6IGZ1bmN0aW9uIGdldFN0YWdnZXIoZnJhZywgaW5kZXgsIHRvdGFsLCB0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUgKyAnU3RhZ2dlcic7XG4gICAgdmFyIHRyYW5zID0gZnJhZy5ub2RlLl9fdl90cmFucztcbiAgICB2YXIgaG9va3MgPSB0cmFucyAmJiB0cmFucy5ob29rcztcbiAgICB2YXIgaG9vayA9IGhvb2tzICYmIChob29rc1t0eXBlXSB8fCBob29rcy5zdGFnZ2VyKTtcbiAgICByZXR1cm4gaG9vayA/IGhvb2suY2FsbChmcmFnLCBpbmRleCwgdG90YWwpIDogaW5kZXggKiBwYXJzZUludCh0aGlzLnBhcmFtc1t0eXBlXSB8fCB0aGlzLnBhcmFtcy5zdGFnZ2VyLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByZS1wcm9jZXNzIHRoZSB2YWx1ZSBiZWZvcmUgcGlwaW5nIGl0IHRocm91Z2ggdGhlXG4gICAqIGZpbHRlcnMuIFRoaXMgaXMgcGFzc2VkIHRvIGFuZCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIuXG4gICAqL1xuXG4gIF9wcmVQcm9jZXNzOiBmdW5jdGlvbiBfcHJlUHJvY2Vzcyh2YWx1ZSkge1xuICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdHlwZSwgc3RvcmUgdGhlIHVuLWZpbHRlcmVkIHJhdyB2YWx1ZS5cbiAgICB0aGlzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQb3N0LXByb2Nlc3MgdGhlIHZhbHVlIGFmdGVyIGl0IGhhcyBiZWVuIHBpcGVkIHRocm91Z2hcbiAgICogdGhlIGZpbHRlcnMuIFRoaXMgaXMgcGFzc2VkIHRvIGFuZCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIuXG4gICAqXG4gICAqIEl0IGlzIG5lY2Vzc2FyeSBmb3IgdGhpcyB0byBiZSBjYWxsZWQgZHVyaW5nIHRoZVxuICAgKiB3YXRoY2VyJ3MgZGVwZW5kZW5jeSBjb2xsZWN0aW9uIHBoYXNlIGJlY2F1c2Ugd2Ugd2FudFxuICAgKiB0aGUgdi1mb3IgdG8gdXBkYXRlIHdoZW4gdGhlIHNvdXJjZSBPYmplY3QgaXMgbXV0YXRlZC5cbiAgICovXG5cbiAgX3Bvc3RQcm9jZXNzOiBmdW5jdGlvbiBfcG9zdFByb2Nlc3ModmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAvLyBjb252ZXJ0IHBsYWluIG9iamVjdCB0byBhcnJheS5cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkoaSk7XG4gICAgICB2YXIga2V5O1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXNbaV0gPSB7XG4gICAgICAgICAgJGtleToga2V5LFxuICAgICAgICAgICR2YWx1ZTogdmFsdWVba2V5XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHJhbmdlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSB8fCBbXTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgaWYgKHRoaXMuZGVzY3JpcHRvci5yZWYpIHtcbiAgICAgICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kcmVmc1t0aGlzLmRlc2NyaXB0b3IucmVmXSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdzKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuZnJhZ3MubGVuZ3RoO1xuICAgICAgdmFyIGZyYWc7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGZyYWcgPSB0aGlzLmZyYWdzW2ldO1xuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlZEZyYWcoZnJhZyk7XG4gICAgICAgIGZyYWcuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gZmluZCB0aGUgcHJldmlvdXMgZWxlbWVudCB0aGF0IGlzIGEgZnJhZ21lbnRcbiAqIGFuY2hvci4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBhIGRlc3Ryb3llZCBmcmFnJ3NcbiAqIGVsZW1lbnQgY291bGQgc3RpbGwgYmUgbGluZ2VyaW5nIGluIHRoZSBET00gYmVmb3JlIGl0c1xuICogbGVhdmluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLCBidXQgaXRzIGluc2VydGVkIGZsYWdcbiAqIHNob3VsZCBoYXZlIGJlZW4gc2V0IHRvIGZhbHNlIHNvIHdlIGNhbiBza2lwIHRoZW0uXG4gKlxuICogSWYgdGhpcyBpcyBhIGJsb2NrIHJlcGVhdCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2Ugb25seVxuICogcmV0dXJuIGZyYWcgdGhhdCBpcyBib3VuZCB0byB0aGlzIHYtZm9yLiAoc2VlICM5MjkpXG4gKlxuICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICogQHBhcmFtIHtDb21tZW50fFRleHR9IGFuY2hvclxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBmaW5kUHJldkZyYWcoZnJhZywgYW5jaG9yLCBpZCkge1xuICB2YXIgZWwgPSBmcmFnLm5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFlbCkgcmV0dXJuO1xuICBmcmFnID0gZWwuX192X2ZyYWc7XG4gIHdoaWxlICgoIWZyYWcgfHwgZnJhZy5mb3JJZCAhPT0gaWQgfHwgIWZyYWcuaW5zZXJ0ZWQpICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICBlbCA9IGVsLnByZXZpb3VzU2libGluZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgZnJhZyA9IGVsLl9fdl9mcmFnO1xuICB9XG4gIHJldHVybiBmcmFnO1xufVxuXG4vKipcbiAqIEZpbmQgYSB2bSBmcm9tIGEgZnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICogQHJldHVybiB7VnVlfHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBmaW5kVm1Gcm9tRnJhZyhmcmFnKSB7XG4gIHZhciBub2RlID0gZnJhZy5ub2RlO1xuICAvLyBoYW5kbGUgbXVsdGktbm9kZSBmcmFnXG4gIGlmIChmcmFnLmVuZCkge1xuICAgIHdoaWxlICghbm9kZS5fX3Z1ZV9fICYmIG5vZGUgIT09IGZyYWcuZW5kICYmIG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZS5fX3Z1ZV9fO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJhbmdlIGFycmF5IGZyb20gZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiByYW5nZShuKSB7XG4gIHZhciBpID0gLTE7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoTWF0aC5mbG9vcihuKSk7XG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgcmV0W2ldID0gaTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2Rm9yLndhcm5EdXBsaWNhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB3YXJuKCdEdXBsaWNhdGUgdmFsdWUgZm91bmQgaW4gdi1mb3I9XCInICsgdGhpcy5kZXNjcmlwdG9yLnJhdyArICdcIjogJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcuIFVzZSB0cmFjay1ieT1cIiRpbmRleFwiIGlmICcgKyAneW91IGFyZSBleHBlY3RpbmcgZHVwbGljYXRlIHZhbHVlcy4nKTtcbiAgfTtcbn1cblxudmFyIHZJZiA9IHtcblxuICBwcmlvcml0eTogSUYsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGlmICghZWwuX192dWVfXykge1xuICAgICAgLy8gY2hlY2sgZWxzZSBibG9ja1xuICAgICAgdmFyIG5leHQgPSBlbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICBpZiAobmV4dCAmJiBnZXRBdHRyKG5leHQsICd2LWVsc2UnKSAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmUobmV4dCk7XG4gICAgICAgIHRoaXMuZWxzZUVsID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIG1haW4gYmxvY2tcbiAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LWlmJyk7XG4gICAgICByZXBsYWNlKGVsLCB0aGlzLmFuY2hvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1pZj1cIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCIgY2Fubm90IGJlICcgKyAndXNlZCBvbiBhbiBpbnN0YW5jZSByb290IGVsZW1lbnQuJyk7XG4gICAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmludmFsaWQpIHJldHVybjtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5mcmFnKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KCkge1xuICAgIGlmICh0aGlzLmVsc2VGcmFnKSB7XG4gICAgICB0aGlzLmVsc2VGcmFnLnJlbW92ZSgpO1xuICAgICAgdGhpcy5lbHNlRnJhZyA9IG51bGw7XG4gICAgfVxuICAgIC8vIGxhenkgaW5pdCBmYWN0b3J5XG4gICAgaWYgKCF0aGlzLmZhY3RvcnkpIHtcbiAgICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy52bSwgdGhpcy5lbCk7XG4gICAgfVxuICAgIHRoaXMuZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUodGhpcy5faG9zdCwgdGhpcy5fc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgIHRoaXMuZnJhZy5iZWZvcmUodGhpcy5hbmNob3IpO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsc2VFbCAmJiAhdGhpcy5lbHNlRnJhZykge1xuICAgICAgaWYgKCF0aGlzLmVsc2VGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuZWxzZUZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMuZWxzZUVsLl9jb250ZXh0IHx8IHRoaXMudm0sIHRoaXMuZWxzZUVsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWxzZUZyYWcgPSB0aGlzLmVsc2VGYWN0b3J5LmNyZWF0ZSh0aGlzLl9ob3N0LCB0aGlzLl9zY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgICB0aGlzLmVsc2VGcmFnLmJlZm9yZSh0aGlzLmFuY2hvcik7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsc2VGcmFnKSB7XG4gICAgICB0aGlzLmVsc2VGcmFnLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBzaG93ID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gY2hlY2sgZWxzZSBibG9ja1xuICAgIHZhciBuZXh0ID0gdGhpcy5lbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgaWYgKG5leHQgJiYgZ2V0QXR0cihuZXh0LCAndi1lbHNlJykgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZWxzZUVsID0gbmV4dDtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmFwcGx5KHRoaXMuZWwsIHZhbHVlKTtcbiAgICBpZiAodGhpcy5lbHNlRWwpIHtcbiAgICAgIHRoaXMuYXBwbHkodGhpcy5lbHNlRWwsICF2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseShlbCwgdmFsdWUpIHtcbiAgICBpZiAoaW5Eb2MoZWwpKSB7XG4gICAgICBhcHBseVRyYW5zaXRpb24oZWwsIHZhbHVlID8gMSA6IC0xLCB0b2dnbGUsIHRoaXMudm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2dnbGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gJycgOiAnbm9uZSc7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdGV4dCQyID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGlzUmFuZ2UgPSBlbC50eXBlID09PSAncmFuZ2UnO1xuICAgIHZhciBsYXp5ID0gdGhpcy5wYXJhbXMubGF6eTtcbiAgICB2YXIgbnVtYmVyID0gdGhpcy5wYXJhbXMubnVtYmVyO1xuICAgIHZhciBkZWJvdW5jZSA9IHRoaXMucGFyYW1zLmRlYm91bmNlO1xuXG4gICAgLy8gaGFuZGxlIGNvbXBvc2l0aW9uIGV2ZW50cy5cbiAgICAvLyAgIGh0dHA6Ly9ibG9nLmV2YW55b3UubWUvMjAxNC8wMS8wMy9jb21wb3NpdGlvbi1ldmVudC9cbiAgICAvLyBza2lwIHRoaXMgZm9yIEFuZHJvaWQgYmVjYXVzZSBpdCBoYW5kbGVzIGNvbXBvc2l0aW9uXG4gICAgLy8gZXZlbnRzIHF1aXRlIGRpZmZlcmVudGx5LiBBbmRyb2lkIGRvZXNuJ3QgdHJpZ2dlclxuICAgIC8vIGNvbXBvc2l0aW9uIGV2ZW50cyBmb3IgbGFuZ3VhZ2UgaW5wdXQgbWV0aG9kcyBlLmcuXG4gICAgLy8gQ2hpbmVzZSwgYnV0IGluc3RlYWQgdHJpZ2dlcnMgdGhlbSBmb3Igc3BlbGxpbmdcbiAgICAvLyBzdWdnZXN0aW9ucy4uLiAoc2VlIERpc2N1c3Npb24vIzE2MilcbiAgICB2YXIgY29tcG9zaW5nID0gZmFsc2U7XG4gICAgaWYgKCFpc0FuZHJvaWQgJiYgIWlzUmFuZ2UpIHtcbiAgICAgIHRoaXMub24oJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBvc2luZyA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2NvbXBvc2l0aW9uZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gaW4gSUUxMSB0aGUgXCJjb21wb3NpdGlvbmVuZFwiIGV2ZW50IGZpcmVzIEFGVEVSXG4gICAgICAgIC8vIHRoZSBcImlucHV0XCIgZXZlbnQsIHNvIHRoZSBpbnB1dCBoYW5kbGVyIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gYXQgdGhlIGVuZC4uLiBoYXZlIHRvIGNhbGwgaXQgaGVyZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gIzEzMjc6IGluIGxhenkgbW9kZSB0aGlzIGlzIHVuZWNlc3NhcnkuXG4gICAgICAgIGlmICghbGF6eSkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBtZXNzaW5nIHdpdGggdGhlIGlucHV0IHdoZW4gdXNlciBpcyB0eXBpbmcsXG4gICAgLy8gYW5kIGZvcmNlIHVwZGF0ZSBvbiBibHVyLlxuICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgIGlmICghaXNSYW5nZSAmJiAhbGF6eSkge1xuICAgICAgdGhpcy5vbignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZm9jdXNlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvLyBkbyBub3Qgc3luYyB2YWx1ZSBhZnRlciBmcmFnbWVudCByZW1vdmFsICgjMjAxNylcbiAgICAgICAgaWYgKCFzZWxmLl9mcmFnIHx8IHNlbGYuX2ZyYWcuaW5zZXJ0ZWQpIHtcbiAgICAgICAgICBzZWxmLnJhd0xpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE5vdyBhdHRhY2ggdGhlIG1haW4gbGlzdGVuZXJcbiAgICB0aGlzLmxpc3RlbmVyID0gdGhpcy5yYXdMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb21wb3NpbmcgfHwgIXNlbGYuX2JvdW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2YWwgPSBudW1iZXIgfHwgaXNSYW5nZSA/IHRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgICAgc2VsZi5zZXQodmFsKTtcbiAgICAgIC8vIGZvcmNlIHVwZGF0ZSBvbiBuZXh0IHRpY2sgdG8gYXZvaWQgbG9jayAmIHNhbWUgdmFsdWVcbiAgICAgIC8vIGFsc28gb25seSB1cGRhdGUgd2hlbiB1c2VyIGlzIG5vdCB0eXBpbmdcbiAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYuX2JvdW5kICYmICFzZWxmLmZvY3VzZWQpIHtcbiAgICAgICAgICBzZWxmLnVwZGF0ZShzZWxmLl93YXRjaGVyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFwcGx5IGRlYm91bmNlXG4gICAgaWYgKGRlYm91bmNlKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyID0gX2RlYm91bmNlKHRoaXMubGlzdGVuZXIsIGRlYm91bmNlKTtcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IGpRdWVyeSBldmVudHMsIHNpbmNlIGpRdWVyeS50cmlnZ2VyKCkgZG9lc24ndFxuICAgIC8vIHRyaWdnZXIgbmF0aXZlIGV2ZW50cyBpbiBzb21lIGNhc2VzIGFuZCBzb21lIHBsdWdpbnNcbiAgICAvLyByZWx5IG9uICQudHJpZ2dlcigpXG4gICAgLy9cbiAgICAvLyBXZSB3YW50IHRvIG1ha2Ugc3VyZSBpZiBhIGxpc3RlbmVyIGlzIGF0dGFjaGVkIHVzaW5nXG4gICAgLy8galF1ZXJ5LCBpdCBpcyBhbHNvIHJlbW92ZWQgd2l0aCBqUXVlcnksIHRoYXQncyB3aHlcbiAgICAvLyB3ZSBkbyB0aGUgY2hlY2sgZm9yIGVhY2ggZGlyZWN0aXZlIGluc3RhbmNlIGFuZFxuICAgIC8vIHN0b3JlIHRoYXQgY2hlY2sgcmVzdWx0IG9uIGl0c2VsZi4gVGhpcyBhbHNvIGFsbG93c1xuICAgIC8vIGVhc2llciB0ZXN0IGNvdmVyYWdlIGNvbnRyb2wgYnkgdW5zZXR0aW5nIHRoZSBnbG9iYWxcbiAgICAvLyBqUXVlcnkgdmFyaWFibGUgaW4gdGVzdHMuXG4gICAgdGhpcy5oYXNqUXVlcnkgPSB0eXBlb2YgalF1ZXJ5ID09PSAnZnVuY3Rpb24nO1xuICAgIGlmICh0aGlzLmhhc2pRdWVyeSkge1xuICAgICAgdmFyIG1ldGhvZCA9IGpRdWVyeS5mbi5vbiA/ICdvbicgOiAnYmluZCc7XG4gICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2NoYW5nZScsIHRoaXMucmF3TGlzdGVuZXIpO1xuICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgIGpRdWVyeShlbClbbWV0aG9kXSgnaW5wdXQnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5yYXdMaXN0ZW5lcik7XG4gICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgdGhpcy5vbignaW5wdXQnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTkgZG9lc24ndCBmaXJlIGlucHV0IGV2ZW50IG9uIGJhY2tzcGFjZS9kZWwvY3V0XG4gICAgaWYgKCFsYXp5ICYmIGlzSUU5KSB7XG4gICAgICB0aGlzLm9uKCdjdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHRUaWNrKHNlbGYubGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdrZXl1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDQ2IHx8IGUua2V5Q29kZSA9PT0gOCkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGluaXRpYWwgdmFsdWUgaWYgcHJlc2VudFxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJiBlbC52YWx1ZS50cmltKCkpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmVsLnZhbHVlID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGlmICh0aGlzLmhhc2pRdWVyeSkge1xuICAgICAgdmFyIG1ldGhvZCA9IGpRdWVyeS5mbi5vZmYgPyAnb2ZmJyA6ICd1bmJpbmQnO1xuICAgICAgalF1ZXJ5KGVsKVttZXRob2RdKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIGpRdWVyeShlbClbbWV0aG9kXSgnaW5wdXQnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciByYWRpbyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHZhbHVlIG92ZXJ3cml0ZSB2aWEgdi1iaW5kOnZhbHVlXG4gICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpKSB7XG4gICAgICAgIHJldHVybiBlbC5fdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgdmFsID0gZWwudmFsdWU7XG4gICAgICBpZiAoc2VsZi5wYXJhbXMubnVtYmVyKSB7XG4gICAgICAgIHZhbCA9IHRvTnVtYmVyKHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5zZXQoc2VsZi5nZXRWYWx1ZSgpKTtcbiAgICB9O1xuICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuXG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5lbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgfVxufTtcblxudmFyIHNlbGVjdCA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgLy8gbWV0aG9kIHRvIGZvcmNlIHVwZGF0ZSBET00gdXNpbmcgbGF0ZXN0IHZhbHVlLlxuICAgIHRoaXMuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5fd2F0Y2hlcikge1xuICAgICAgICBzZWxmLnVwZGF0ZShzZWxmLl93YXRjaGVyLmdldCgpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIG11bHRpcGxlIHNlbGVjdFxuICAgIHZhciBtdWx0aXBsZSA9IHRoaXMubXVsdGlwbGUgPSBlbC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJyk7XG5cbiAgICAvLyBhdHRhY2ggbGlzdGVuZXJcbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUoZWwsIG11bHRpcGxlKTtcbiAgICAgIHZhbHVlID0gc2VsZi5wYXJhbXMubnVtYmVyID8gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAodG9OdW1iZXIpIDogdG9OdW1iZXIodmFsdWUpIDogdmFsdWU7XG4gICAgICBzZWxmLnNldCh2YWx1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcblxuICAgIC8vIGlmIGhhcyBpbml0aWFsIHZhbHVlLCBzZXQgYWZ0ZXJCaW5kXG4gICAgdmFyIGluaXRWYWx1ZSA9IGdldFZhbHVlKGVsLCBtdWx0aXBsZSwgdHJ1ZSk7XG4gICAgaWYgKG11bHRpcGxlICYmIGluaXRWYWx1ZS5sZW5ndGggfHwgIW11bHRpcGxlICYmIGluaXRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cblxuICAgIC8vIEFsbCBtYWpvciBicm93c2VycyBleGNlcHQgRmlyZWZveCByZXNldHNcbiAgICAvLyBzZWxlY3RlZEluZGV4IHdpdGggdmFsdWUgLTEgdG8gMCB3aGVuIHRoZSBlbGVtZW50XG4gICAgLy8gaXMgYXBwZW5kZWQgdG8gYSBuZXcgcGFyZW50LCB0aGVyZWZvcmUgd2UgaGF2ZSB0b1xuICAgIC8vIGZvcmNlIGEgRE9NIHVwZGF0ZSB3aGVuZXZlciB0aGF0IGhhcHBlbnMuLi5cbiAgICB0aGlzLnZtLiRvbignaG9vazphdHRhY2hlZCcsIHRoaXMuZm9yY2VVcGRhdGUpO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgdmFyIG11bHRpID0gdGhpcy5tdWx0aXBsZSAmJiBpc0FycmF5KHZhbHVlKTtcbiAgICB2YXIgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gICAgdmFyIGkgPSBvcHRpb25zLmxlbmd0aDtcbiAgICB2YXIgb3AsIHZhbDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBvcCA9IG9wdGlvbnNbaV07XG4gICAgICB2YWwgPSBvcC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykgPyBvcC5fdmFsdWUgOiBvcC52YWx1ZTtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICAgICAgb3Auc2VsZWN0ZWQgPSBtdWx0aSA/IGluZGV4T2YkMSh2YWx1ZSwgdmFsKSA+IC0xIDogbG9vc2VFcXVhbCh2YWx1ZSwgdmFsKTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhpcy52bS4kb2ZmKCdob29rOmF0dGFjaGVkJywgdGhpcy5mb3JjZVVwZGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHNlbGVjdCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7U2VsZWN0RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbXVsdGlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQHJldHVybiB7QXJyYXl8Kn1cbiAqL1xuXG5mdW5jdGlvbiBnZXRWYWx1ZShlbCwgbXVsdGksIGluaXQpIHtcbiAgdmFyIHJlcyA9IG11bHRpID8gW10gOiBudWxsO1xuICB2YXIgb3AsIHZhbCwgc2VsZWN0ZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcCA9IGVsLm9wdGlvbnNbaV07XG4gICAgc2VsZWN0ZWQgPSBpbml0ID8gb3AuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpIDogb3Auc2VsZWN0ZWQ7XG4gICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICB2YWwgPSBvcC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykgPyBvcC5fdmFsdWUgOiBvcC52YWx1ZTtcbiAgICAgIGlmIChtdWx0aSkge1xuICAgICAgICByZXMucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBOYXRpdmUgQXJyYXkuaW5kZXhPZiB1c2VzIHN0cmljdCBlcXVhbCwgYnV0IGluIHRoaXNcbiAqIGNhc2Ugd2UgbmVlZCB0byBtYXRjaCBzdHJpbmcvbnVtYmVycyB3aXRoIGN1c3RvbSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuZnVuY3Rpb24gaW5kZXhPZiQxKGFyciwgdmFsKSB7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxudmFyIGNoZWNrYm94ID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGVsLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSA/IGVsLl92YWx1ZSA6IHNlbGYucGFyYW1zLm51bWJlciA/IHRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRCb29sZWFuVmFsdWUoKSB7XG4gICAgICB2YXIgdmFsID0gZWwuY2hlY2tlZDtcbiAgICAgIGlmICh2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX3RydWVWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsICYmIGVsLmhhc093blByb3BlcnR5KCdfZmFsc2VWYWx1ZScpKSB7XG4gICAgICAgIHJldHVybiBlbC5fZmFsc2VWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtb2RlbCA9IHNlbGYuX3dhdGNoZXIudmFsdWU7XG4gICAgICBpZiAoaXNBcnJheShtb2RlbCkpIHtcbiAgICAgICAgdmFyIHZhbCA9IHNlbGYuZ2V0VmFsdWUoKTtcbiAgICAgICAgaWYgKGVsLmNoZWNrZWQpIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZihtb2RlbCwgdmFsKSA8IDApIHtcbiAgICAgICAgICAgIG1vZGVsLnB1c2godmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kZWwuJHJlbW92ZSh2YWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNldChnZXRCb29sZWFuVmFsdWUoKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBlbC5jaGVja2VkID0gaW5kZXhPZih2YWx1ZSwgdGhpcy5nZXRWYWx1ZSgpKSA+IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZWwuX3RydWVWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5jaGVja2VkID0gISF2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBoYW5kbGVycyA9IHtcbiAgdGV4dDogdGV4dCQyLFxuICByYWRpbzogcmFkaW8sXG4gIHNlbGVjdDogc2VsZWN0LFxuICBjaGVja2JveDogY2hlY2tib3hcbn07XG5cbnZhciBtb2RlbCA9IHtcblxuICBwcmlvcml0eTogTU9ERUwsXG4gIHR3b1dheTogdHJ1ZSxcbiAgaGFuZGxlcnM6IGhhbmRsZXJzLFxuICBwYXJhbXM6IFsnbGF6eScsICdudW1iZXInLCAnZGVib3VuY2UnXSxcblxuICAvKipcbiAgICogUG9zc2libGUgZWxlbWVudHM6XG4gICAqICAgPHNlbGVjdD5cbiAgICogICA8dGV4dGFyZWE+XG4gICAqICAgPGlucHV0IHR5cGU9XCIqXCI+XG4gICAqICAgICAtIHRleHRcbiAgICogICAgIC0gY2hlY2tib3hcbiAgICogICAgIC0gcmFkaW9cbiAgICogICAgIC0gbnVtYmVyXG4gICAqL1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gZnJpZW5kbHkgd2FybmluZy4uLlxuICAgIHRoaXMuY2hlY2tGaWx0ZXJzKCk7XG4gICAgaWYgKHRoaXMuaGFzUmVhZCAmJiAhdGhpcy5oYXNXcml0ZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIGEgcmVhZC1vbmx5IGZpbHRlciB3aXRoICcgKyAndi1tb2RlbC4gWW91IG1pZ2h0IHdhbnQgdG8gdXNlIGEgdHdvLXdheSBmaWx0ZXIgJyArICd0byBlbnN1cmUgY29ycmVjdCBiZWhhdmlvci4nKTtcbiAgICB9XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgdGFnID0gZWwudGFnTmFtZTtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAodGFnID09PSAnSU5QVVQnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnNbZWwudHlwZV0gfHwgaGFuZGxlcnMudGV4dDtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVycy5zZWxlY3Q7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVycy50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ3YtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBlbGVtZW50IHR5cGU6ICcgKyB0YWcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbC5fX3ZfbW9kZWwgPSB0aGlzO1xuICAgIGhhbmRsZXIuYmluZC5jYWxsKHRoaXMpO1xuICAgIHRoaXMudXBkYXRlID0gaGFuZGxlci51cGRhdGU7XG4gICAgdGhpcy5fdW5iaW5kID0gaGFuZGxlci51bmJpbmQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIHJlYWQvd3JpdGUgZmlsdGVyIHN0YXRzLlxuICAgKi9cblxuICBjaGVja0ZpbHRlcnM6IGZ1bmN0aW9uIGNoZWNrRmlsdGVycygpIHtcbiAgICB2YXIgZmlsdGVycyA9IHRoaXMuZmlsdGVycztcbiAgICBpZiAoIWZpbHRlcnMpIHJldHVybjtcbiAgICB2YXIgaSA9IGZpbHRlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBmaWx0ZXIgPSByZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBmaWx0ZXJzW2ldLm5hbWUpO1xuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgZmlsdGVyLnJlYWQpIHtcbiAgICAgICAgdGhpcy5oYXNSZWFkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXIud3JpdGUpIHtcbiAgICAgICAgdGhpcy5oYXNXcml0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMuZWwuX192X21vZGVsID0gbnVsbDtcbiAgICB0aGlzLl91bmJpbmQgJiYgdGhpcy5fdW5iaW5kKCk7XG4gIH1cbn07XG5cbi8vIGtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICAnZGVsZXRlJzogWzgsIDQ2XSxcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MFxufTtcblxuZnVuY3Rpb24ga2V5RmlsdGVyKGhhbmRsZXIsIGtleXMpIHtcbiAgdmFyIGNvZGVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjaGFyQ29kZSA9IGtleS5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChjaGFyQ29kZSA+IDQ3ICYmIGNoYXJDb2RlIDwgNTgpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChrZXksIDEwKTtcbiAgICB9XG4gICAgaWYgKGtleS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNoYXJDb2RlID0ga2V5LnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjaGFyQ29kZSA+IDY0ICYmIGNoYXJDb2RlIDwgOTEpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJDb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5Q29kZXNba2V5XTtcbiAgfSk7XG4gIGNvZGVzID0gW10uY29uY2F0LmFwcGx5KFtdLCBjb2Rlcyk7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlIYW5kbGVyKGUpIHtcbiAgICBpZiAoY29kZXMuaW5kZXhPZihlLmtleUNvZGUpID4gLTEpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzdG9wRmlsdGVyKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BIYW5kbGVyKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRGaWx0ZXIoaGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEhhbmRsZXIoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxmRmlsdGVyKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlbGZIYW5kbGVyKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBvbiQxID0ge1xuXG4gIHByaW9yaXR5OiBPTixcbiAgYWNjZXB0U3RhdGVtZW50OiB0cnVlLFxuICBrZXlDb2Rlczoga2V5Q29kZXMsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBkZWFsIHdpdGggaWZyYW1lc1xuICAgIGlmICh0aGlzLmVsLnRhZ05hbWUgPT09ICdJRlJBTUUnICYmIHRoaXMuYXJnICE9PSAnbG9hZCcpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuaWZyYW1lQmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb24oc2VsZi5lbC5jb250ZW50V2luZG93LCBzZWxmLmFyZywgc2VsZi5oYW5kbGVyLCBzZWxmLm1vZGlmaWVycy5jYXB0dXJlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKCdsb2FkJywgdGhpcy5pZnJhbWVCaW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoaGFuZGxlcikge1xuICAgIC8vIHN0dWIgYSBub29wIGZvciB2LW9uIHdpdGggbm8gdmFsdWUsXG4gICAgLy8gZS5nLiBAbW91c2Vkb3duLnByZXZlbnRcbiAgICBpZiAoIXRoaXMuZGVzY3JpcHRvci5yYXcpIHtcbiAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1vbjonICsgdGhpcy5hcmcgKyAnPVwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiBleHBlY3RzIGEgZnVuY3Rpb24gdmFsdWUsICcgKyAnZ290ICcgKyBoYW5kbGVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBtb2RpZmllcnNcbiAgICBpZiAodGhpcy5tb2RpZmllcnMuc3RvcCkge1xuICAgICAgaGFuZGxlciA9IHN0b3BGaWx0ZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGlmaWVycy5wcmV2ZW50KSB7XG4gICAgICBoYW5kbGVyID0gcHJldmVudEZpbHRlcihoYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kaWZpZXJzLnNlbGYpIHtcbiAgICAgIGhhbmRsZXIgPSBzZWxmRmlsdGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBrZXkgZmlsdGVyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm1vZGlmaWVycykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgIT09ICdzdG9wJyAmJiBrZXkgIT09ICdwcmV2ZW50JyAmJiBrZXkgIT09ICdzZWxmJztcbiAgICB9KTtcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGhhbmRsZXIgPSBrZXlGaWx0ZXIoaGFuZGxlciwga2V5cyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cbiAgICBpZiAodGhpcy5pZnJhbWVCaW5kKSB7XG4gICAgICB0aGlzLmlmcmFtZUJpbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb24odGhpcy5lbCwgdGhpcy5hcmcsIHRoaXMuaGFuZGxlciwgdGhpcy5tb2RpZmllcnMuY2FwdHVyZSk7XG4gICAgfVxuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmlmcmFtZUJpbmQgPyB0aGlzLmVsLmNvbnRlbnRXaW5kb3cgOiB0aGlzLmVsO1xuICAgIGlmICh0aGlzLmhhbmRsZXIpIHtcbiAgICAgIG9mZihlbCwgdGhpcy5hcmcsIHRoaXMuaGFuZGxlcik7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxufTtcblxudmFyIHByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctbXMtJ107XG52YXIgY2FtZWxQcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xudmFyIGltcG9ydGFudFJFID0gLyFpbXBvcnRhbnQ7PyQvO1xudmFyIHByb3BDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbnZhciB0ZXN0RWwgPSBudWxsO1xuXG52YXIgc3R5bGUgPSB7XG5cbiAgZGVlcDogdHJ1ZSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmVsLnN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZS5yZWR1Y2UoZXh0ZW5kLCB7fSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZSB8fCB7fSk7XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZU9iamVjdDogZnVuY3Rpb24gaGFuZGxlT2JqZWN0KHZhbHVlKSB7XG4gICAgLy8gY2FjaGUgb2JqZWN0IHN0eWxlcyBzbyB0aGF0IG9ubHkgY2hhbmdlZCBwcm9wc1xuICAgIC8vIGFyZSBhY3R1YWxseSB1cGRhdGVkLlxuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUgfHwgKHRoaXMuY2FjaGUgPSB7fSk7XG4gICAgdmFyIG5hbWUsIHZhbDtcbiAgICBmb3IgKG5hbWUgaW4gY2FjaGUpIHtcbiAgICAgIGlmICghKG5hbWUgaW4gdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2luZ2xlKG5hbWUsIG51bGwpO1xuICAgICAgICBkZWxldGUgY2FjaGVbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICAgICAgdmFsID0gdmFsdWVbbmFtZV07XG4gICAgICBpZiAodmFsICE9PSBjYWNoZVtuYW1lXSkge1xuICAgICAgICBjYWNoZVtuYW1lXSA9IHZhbDtcbiAgICAgICAgdGhpcy5oYW5kbGVTaW5nbGUobmFtZSwgdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlU2luZ2xlOiBmdW5jdGlvbiBoYW5kbGVTaW5nbGUocHJvcCwgdmFsdWUpIHtcbiAgICBwcm9wID0gbm9ybWFsaXplKHByb3ApO1xuICAgIGlmICghcHJvcCkgcmV0dXJuOyAvLyB1bnN1cHBvcnRlZCBwcm9wXG4gICAgLy8gY2FzdCBwb3NzaWJsZSBudW1iZXJzL2Jvb2xlYW5zIGludG8gc3RyaW5nc1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZSArPSAnJztcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHZhciBpc0ltcG9ydGFudCA9IGltcG9ydGFudFJFLnRlc3QodmFsdWUpID8gJ2ltcG9ydGFudCcgOiAnJztcbiAgICAgIGlmIChpc0ltcG9ydGFudCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKS50cmltKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVsLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIHZhbHVlLCBpc0ltcG9ydGFudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcCk7XG4gICAgfVxuICB9XG5cbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgQ1NTIHByb3BlcnR5IG5hbWUuXG4gKiAtIGNhY2hlIHJlc3VsdFxuICogLSBhdXRvIHByZWZpeFxuICogLSBjYW1lbENhc2UgLT4gZGFzaC1jYXNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemUocHJvcCkge1xuICBpZiAocHJvcENhY2hlW3Byb3BdKSB7XG4gICAgcmV0dXJuIHByb3BDYWNoZVtwcm9wXTtcbiAgfVxuICB2YXIgcmVzID0gcHJlZml4KHByb3ApO1xuICBwcm9wQ2FjaGVbcHJvcF0gPSBwcm9wQ2FjaGVbcmVzXSA9IHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBBdXRvIGRldGVjdCB0aGUgYXBwcm9wcmlhdGUgcHJlZml4IGZvciBhIENTUyBwcm9wZXJ0eS5cbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81MjM2OTJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHByZWZpeChwcm9wKSB7XG4gIHByb3AgPSBoeXBoZW5hdGUocHJvcCk7XG4gIHZhciBjYW1lbCA9IGNhbWVsaXplKHByb3ApO1xuICB2YXIgdXBwZXIgPSBjYW1lbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsLnNsaWNlKDEpO1xuICBpZiAoIXRlc3RFbCkge1xuICAgIHRlc3RFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB9XG4gIHZhciBpID0gcHJlZml4ZXMubGVuZ3RoO1xuICB2YXIgcHJlZml4ZWQ7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBwcmVmaXhlZCA9IGNhbWVsUHJlZml4ZXNbaV0gKyB1cHBlcjtcbiAgICBpZiAocHJlZml4ZWQgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZXNbaV0gKyBwcm9wO1xuICAgIH1cbiAgfVxuICBpZiAoY2FtZWwgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn1cblxuLy8geGxpbmtcbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xudmFyIHhsaW5rUkUgPSAvXnhsaW5rOi87XG5cbi8vIGNoZWNrIGZvciBhdHRyaWJ1dGVzIHRoYXQgcHJvaGliaXQgaW50ZXJwb2xhdGlvbnNcbnZhciBkaXNhbGxvd2VkSW50ZXJwQXR0clJFID0gL152LXxeOnxeQHxeKD86aXN8dHJhbnNpdGlvbnx0cmFuc2l0aW9uLW1vZGV8ZGVib3VuY2V8dHJhY2stYnl8c3RhZ2dlcnxlbnRlci1zdGFnZ2VyfGxlYXZlLXN0YWdnZXIpJC87XG4vLyB0aGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBhbHNvIHNldCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXNcbi8vIGJlY2F1c2UgdGhleSBvbmx5IGFmZmVjdCB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgZWxlbWVudFxudmFyIGF0dHJXaXRoUHJvcHNSRSA9IC9eKD86dmFsdWV8Y2hlY2tlZHxzZWxlY3RlZHxtdXRlZCkkLztcbi8vIHRoZXNlIGF0dHJpYnV0ZXMgZXhwZWN0IGVudW1yYXRlZCB2YWx1ZXMgb2YgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiXG4vLyBidXQgYXJlIG5vdCBib29sZWFuIGF0dHJpYnV0ZXNcbnZhciBlbnVtZXJhdGVkQXR0clJFID0gL14oPzpkcmFnZ2FibGV8Y29udGVudGVkaXRhYmxlfHNwZWxsY2hlY2spJC87XG5cbi8vIHRoZXNlIGF0dHJpYnV0ZXMgc2hvdWxkIHNldCBhIGhpZGRlbiBwcm9wZXJ0eSBmb3Jcbi8vIGJpbmRpbmcgdi1tb2RlbCB0byBvYmplY3QgdmFsdWVzXG52YXIgbW9kZWxQcm9wcyA9IHtcbiAgdmFsdWU6ICdfdmFsdWUnLFxuICAndHJ1ZS12YWx1ZSc6ICdfdHJ1ZVZhbHVlJyxcbiAgJ2ZhbHNlLXZhbHVlJzogJ19mYWxzZVZhbHVlJ1xufTtcblxudmFyIGJpbmQkMSA9IHtcblxuICBwcmlvcml0eTogQklORCxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBhdHRyID0gdGhpcy5hcmc7XG4gICAgdmFyIHRhZyA9IHRoaXMuZWwudGFnTmFtZTtcbiAgICAvLyBzaG91bGQgYmUgZGVlcCB3YXRjaCBvbiBvYmplY3QgbW9kZVxuICAgIGlmICghYXR0cikge1xuICAgICAgdGhpcy5kZWVwID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIGludGVycG9sYXRpb24gYmluZGluZ3NcbiAgICB2YXIgZGVzY3JpcHRvciA9IHRoaXMuZGVzY3JpcHRvcjtcbiAgICB2YXIgdG9rZW5zID0gZGVzY3JpcHRvci5pbnRlcnA7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgLy8gaGFuZGxlIGludGVycG9sYXRpb25zIHdpdGggb25lLXRpbWUgdG9rZW5zXG4gICAgICBpZiAoZGVzY3JpcHRvci5oYXNPbmVUaW1lKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHRva2Vuc1RvRXhwKHRva2VucywgdGhpcy5fc2NvcGUgfHwgdGhpcy52bSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgYWxsb3cgYmluZGluZyBvbiBuYXRpdmUgYXR0cmlidXRlc1xuICAgICAgaWYgKGRpc2FsbG93ZWRJbnRlcnBBdHRyUkUudGVzdChhdHRyKSB8fCBhdHRyID09PSAnbmFtZScgJiYgKHRhZyA9PT0gJ1BBUlRJQUwnIHx8IHRhZyA9PT0gJ1NMT1QnKSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oYXR0ciArICc9XCInICsgZGVzY3JpcHRvci5yYXcgKyAnXCI6ICcgKyAnYXR0cmlidXRlIGludGVycG9sYXRpb24gaXMgbm90IGFsbG93ZWQgaW4gVnVlLmpzICcgKyAnZGlyZWN0aXZlcyBhbmQgc3BlY2lhbCBhdHRyaWJ1dGVzLicpO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmF3ID0gYXR0ciArICc9XCInICsgZGVzY3JpcHRvci5yYXcgKyAnXCI6ICc7XG4gICAgICAgIC8vIHdhcm4gc3JjXG4gICAgICAgIGlmIChhdHRyID09PSAnc3JjJykge1xuICAgICAgICAgIHdhcm4ocmF3ICsgJ2ludGVycG9sYXRpb24gaW4gXCJzcmNcIiBhdHRyaWJ1dGUgd2lsbCBjYXVzZSAnICsgJ2EgNDA0IHJlcXVlc3QuIFVzZSB2LWJpbmQ6c3JjIGluc3RlYWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3YXJuIHN0eWxlXG4gICAgICAgIGlmIChhdHRyID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgd2FybihyYXcgKyAnaW50ZXJwb2xhdGlvbiBpbiBcInN0eWxlXCIgYXR0cmlidXRlIHdpbGwgY2F1c2UgJyArICd0aGUgYXR0cmlidXRlIHRvIGJlIGRpc2NhcmRlZCBpbiBJbnRlcm5ldCBFeHBsb3Jlci4gJyArICdVc2Ugdi1iaW5kOnN0eWxlIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhdHRyID0gdGhpcy5hcmc7XG4gICAgaWYgKHRoaXMuYXJnKSB7XG4gICAgICB0aGlzLmhhbmRsZVNpbmdsZShhdHRyLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlIHx8IHt9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gc2hhcmUgb2JqZWN0IGhhbmRsZXIgd2l0aCB2LWJpbmQ6Y2xhc3NcbiAgaGFuZGxlT2JqZWN0OiBzdHlsZS5oYW5kbGVPYmplY3QsXG5cbiAgaGFuZGxlU2luZ2xlOiBmdW5jdGlvbiBoYW5kbGVTaW5nbGUoYXR0ciwgdmFsdWUpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBpbnRlcnAgPSB0aGlzLmRlc2NyaXB0b3IuaW50ZXJwO1xuICAgIGlmICh0aGlzLm1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgYXR0ciA9IGNhbWVsaXplKGF0dHIpO1xuICAgIH1cbiAgICBpZiAoIWludGVycCAmJiBhdHRyV2l0aFByb3BzUkUudGVzdChhdHRyKSAmJiBhdHRyIGluIGVsKSB7XG4gICAgICBlbFthdHRyXSA9IGF0dHIgPT09ICd2YWx1ZScgPyB2YWx1ZSA9PSBudWxsIC8vIElFOSB3aWxsIHNldCBpbnB1dC52YWx1ZSB0byBcIm51bGxcIiBmb3IgbnVsbC4uLlxuICAgICAgPyAnJyA6IHZhbHVlIDogdmFsdWU7XG4gICAgfVxuICAgIC8vIHNldCBtb2RlbCBwcm9wc1xuICAgIHZhciBtb2RlbFByb3AgPSBtb2RlbFByb3BzW2F0dHJdO1xuICAgIGlmICghaW50ZXJwICYmIG1vZGVsUHJvcCkge1xuICAgICAgZWxbbW9kZWxQcm9wXSA9IHZhbHVlO1xuICAgICAgLy8gdXBkYXRlIHYtbW9kZWwgaWYgcHJlc2VudFxuICAgICAgdmFyIG1vZGVsID0gZWwuX192X21vZGVsO1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIG1vZGVsLmxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGRvIG5vdCBzZXQgdmFsdWUgYXR0cmlidXRlIGZvciB0ZXh0YXJlYVxuICAgIGlmIChhdHRyID09PSAndmFsdWUnICYmIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdXBkYXRlIGF0dHJpYnV0ZVxuICAgIGlmIChlbnVtZXJhdGVkQXR0clJFLnRlc3QoYXR0cikpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChhdHRyID09PSAnY2xhc3MnKSB7XG4gICAgICAgIC8vIGhhbmRsZSBlZGdlIGNhc2UgIzE5NjA6XG4gICAgICAgIC8vIGNsYXNzIGludGVycG9sYXRpb24gc2hvdWxkIG5vdCBvdmVyd3JpdGUgVnVlIHRyYW5zaXRpb24gY2xhc3NcbiAgICAgICAgaWYgKGVsLl9fdl90cmFucykge1xuICAgICAgICAgIHZhbHVlICs9ICcgJyArIGVsLl9fdl90cmFucy5pZCArICctdHJhbnNpdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q2xhc3MoZWwsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoeGxpbmtSRS50ZXN0KGF0dHIpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGF0dHIsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGVsID0ge1xuXG4gIHByaW9yaXR5OiBFTCxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdGhpcy5hcmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGlkID0gdGhpcy5pZCA9IGNhbWVsaXplKHRoaXMuYXJnKTtcbiAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kZWxzO1xuICAgIGlmIChoYXNPd24ocmVmcywgaWQpKSB7XG4gICAgICByZWZzW2lkXSA9IHRoaXMuZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHJlZnMsIGlkLCB0aGlzLmVsKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdmFyIHJlZnMgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJGVscztcbiAgICBpZiAocmVmc1t0aGlzLmlkXSA9PT0gdGhpcy5lbCkge1xuICAgICAgcmVmc1t0aGlzLmlkXSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcmVmID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1yZWY6JyArIHRoaXMuYXJnICsgJyBtdXN0IGJlIHVzZWQgb24gYSBjaGlsZCAnICsgJ2NvbXBvbmVudC4gRm91bmQgb24gPCcgKyB0aGlzLmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICc+LicpO1xuICB9XG59O1xuXG52YXIgY2xvYWsgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB0aGlzLnZtLiRvbmNlKCdwcmUtaG9vazpjb21waWxlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndi1jbG9haycpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBtdXN0IGV4cG9ydCBwbGFpbiBvYmplY3RcbnZhciBkaXJlY3RpdmVzID0ge1xuICB0ZXh0OiB0ZXh0JDEsXG4gIGh0bWw6IGh0bWwsXG4gICdmb3InOiB2Rm9yLFxuICAnaWYnOiB2SWYsXG4gIHNob3c6IHNob3csXG4gIG1vZGVsOiBtb2RlbCxcbiAgb246IG9uJDEsXG4gIGJpbmQ6IGJpbmQkMSxcbiAgZWw6IGVsLFxuICByZWY6IHJlZixcbiAgY2xvYWs6IGNsb2FrXG59O1xuXG52YXIgdkNsYXNzID0ge1xuXG4gIGRlZXA6IHRydWUsXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3Qoc3RyaW5nVG9PYmplY3QodmFsdWUpKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhpcy5oYW5kbGVBcnJheSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH1cbiAgfSxcblxuICBoYW5kbGVPYmplY3Q6IGZ1bmN0aW9uIGhhbmRsZU9iamVjdCh2YWx1ZSkge1xuICAgIHRoaXMuY2xlYW51cCh2YWx1ZSk7XG4gICAgdmFyIGtleXMgPSB0aGlzLnByZXZLZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy5lbCwga2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZUFycmF5OiBmdW5jdGlvbiBoYW5kbGVBcnJheSh2YWx1ZSkge1xuICAgIHRoaXMuY2xlYW51cCh2YWx1ZSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLmVsLCB2YWx1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJldktleXMgPSB2YWx1ZS5zbGljZSgpO1xuICB9LFxuXG4gIGNsZWFudXA6IGZ1bmN0aW9uIGNsZWFudXAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5wcmV2S2V5cykge1xuICAgICAgdmFyIGkgPSB0aGlzLnByZXZLZXlzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMucHJldktleXNbaV07XG4gICAgICAgIGlmIChrZXkgJiYgKCF2YWx1ZSB8fCAhY29udGFpbnModmFsdWUsIGtleSkpKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc3RyaW5nVG9PYmplY3QodmFsdWUpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIga2V5cyA9IHZhbHVlLnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmVzW2tleXNbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjb250YWlucyh2YWx1ZSwga2V5KSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLmluZGV4T2Yoa2V5KSA+IC0xIDogaGFzT3duKHZhbHVlLCBrZXkpO1xufVxuXG52YXIgY29tcG9uZW50ID0ge1xuXG4gIHByaW9yaXR5OiBDT01QT05FTlQsXG5cbiAgcGFyYW1zOiBbJ2tlZXAtYWxpdmUnLCAndHJhbnNpdGlvbi1tb2RlJywgJ2lubGluZS10ZW1wbGF0ZSddLFxuXG4gIC8qKlxuICAgKiBTZXR1cC4gVHdvIHBvc3NpYmxlIHVzYWdlczpcbiAgICpcbiAgICogLSBzdGF0aWM6XG4gICAqICAgPGNvbXA+IG9yIDxkaXYgdi1jb21wb25lbnQ9XCJjb21wXCI+XG4gICAqXG4gICAqIC0gZHluYW1pYzpcbiAgICogICA8Y29tcG9uZW50IDppcz1cInZpZXdcIj5cbiAgICovXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICBpZiAoIXRoaXMuZWwuX192dWVfXykge1xuICAgICAgLy8ga2VlcC1hbGl2ZSBjYWNoZVxuICAgICAgdGhpcy5rZWVwQWxpdmUgPSB0aGlzLnBhcmFtcy5rZWVwQWxpdmU7XG4gICAgICBpZiAodGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlXG4gICAgICBpZiAodGhpcy5wYXJhbXMuaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgICAgLy8gZXh0cmFjdCBpbmxpbmUgdGVtcGxhdGUgYXMgYSBEb2N1bWVudEZyYWdtZW50XG4gICAgICAgIHRoaXMuaW5saW5lVGVtcGxhdGUgPSBleHRyYWN0Q29udGVudCh0aGlzLmVsLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbXBvbmVudCByZXNvbHV0aW9uIHJlbGF0ZWQgc3RhdGVcbiAgICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiID0gdGhpcy5Db21wb25lbnQgPSBudWxsO1xuICAgICAgLy8gdHJhbnNpdGlvbiByZWxhdGVkIHN0YXRlXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFscyA9IDA7XG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBudWxsO1xuICAgICAgLy8gY3JlYXRlIGEgcmVmIGFuY2hvclxuICAgICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtY29tcG9uZW50Jyk7XG4gICAgICByZXBsYWNlKHRoaXMuZWwsIHRoaXMuYW5jaG9yKTtcbiAgICAgIC8vIHJlbW92ZSBpcyBhdHRyaWJ1dGUuXG4gICAgICAvLyB0aGlzIGlzIHJlbW92ZWQgZHVyaW5nIGNvbXBpbGF0aW9uLCBidXQgYmVjYXVzZSBjb21waWxhdGlvbiBpc1xuICAgICAgLy8gY2FjaGVkLCB3aGVuIHRoZSBjb21wb25lbnQgaXMgdXNlZCBlbHNld2hlcmUgdGhpcyBhdHRyaWJ1dGVcbiAgICAgIC8vIHdpbGwgcmVtYWluIGF0IGxpbmsgdGltZS5cbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdpcycpO1xuICAgICAgLy8gcmVtb3ZlIHJlZiwgc2FtZSBhcyBhYm92ZVxuICAgICAgaWYgKHRoaXMuZGVzY3JpcHRvci5yZWYpIHtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ3YtcmVmOicgKyBoeXBoZW5hdGUodGhpcy5kZXNjcmlwdG9yLnJlZikpO1xuICAgICAgfVxuICAgICAgLy8gaWYgc3RhdGljLCBidWlsZCByaWdodCBub3cuXG4gICAgICBpZiAodGhpcy5saXRlcmFsKSB7XG4gICAgICAgIHRoaXMuc2V0Q29tcG9uZW50KHRoaXMuZXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignY2Fubm90IG1vdW50IGNvbXBvbmVudCBcIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCIgJyArICdvbiBhbHJlYWR5IG1vdW50ZWQgZWxlbWVudDogJyArIHRoaXMuZWwpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHVibGljIHVwZGF0ZSwgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyIGluIHRoZSBkeW5hbWljXG4gICAqIGxpdGVyYWwgc2NlbmFyaW8sIGUuZy4gPGNvbXBvbmVudCA6aXM9XCJ2aWV3XCI+XG4gICAqL1xuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmxpdGVyYWwpIHtcbiAgICAgIHRoaXMuc2V0Q29tcG9uZW50KHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN3aXRjaCBkeW5hbWljIGNvbXBvbmVudHMuIE1heSByZXNvbHZlIHRoZSBjb21wb25lbnRcbiAgICogYXN5bmNocm9ub3VzbHksIGFuZCBwZXJmb3JtIHRyYW5zaXRpb24gYmFzZWQgb25cbiAgICogc3BlY2lmaWVkIHRyYW5zaXRpb24gbW9kZS4gQWNjZXB0cyBhIGZldyBhZGRpdGlvbmFsXG4gICAqIGFyZ3VtZW50cyBzcGVjaWZpY2FsbHkgZm9yIHZ1ZS1yb3V0ZXIuXG4gICAqXG4gICAqIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgZnVsbCB0cmFuc2l0aW9uIGlzXG4gICAqIGZpbmlzaGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBzZXRDb21wb25lbnQ6IGZ1bmN0aW9uIHNldENvbXBvbmVudCh2YWx1ZSwgY2IpIHtcbiAgICB0aGlzLmludmFsaWRhdGVQZW5kaW5nKCk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgLy8ganVzdCByZW1vdmUgY3VycmVudFxuICAgICAgdGhpcy51bmJ1aWxkKHRydWUpO1xuICAgICAgdGhpcy5yZW1vdmUodGhpcy5jaGlsZFZNLCBjYik7XG4gICAgICB0aGlzLmNoaWxkVk0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLnJlc29sdmVDb21wb25lbnQodmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5tb3VudENvbXBvbmVudChjYik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc29sdmUgdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciB0byB1c2Ugd2hlbiBjcmVhdGluZ1xuICAgKiB0aGUgY2hpbGQgdm0uXG4gICAqL1xuXG4gIHJlc29sdmVDb21wb25lbnQ6IGZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQoaWQsIGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiID0gY2FuY2VsbGFibGUoZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgICAgc2VsZi5Db21wb25lbnROYW1lID0gQ29tcG9uZW50Lm9wdGlvbnMubmFtZSB8fCBpZDtcbiAgICAgIHNlbGYuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgICAgY2IoKTtcbiAgICB9KTtcbiAgICB0aGlzLnZtLl9yZXNvbHZlQ29tcG9uZW50KGlkLCB0aGlzLnBlbmRpbmdDb21wb25lbnRDYik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSB1c2luZyB0aGUgY3VycmVudCBjb25zdHJ1Y3RvciBhbmRcbiAgICogcmVwbGFjZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuIFRoaXMgbWV0aG9kIGRvZXNuJ3QgY2FyZVxuICAgKiB3aGV0aGVyIHRoZSBuZXcgY29tcG9uZW50IGFuZCB0aGUgb2xkIG9uZSBhcmUgYWN0dWFsbHlcbiAgICogdGhlIHNhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIG1vdW50Q29tcG9uZW50KGNiKSB7XG4gICAgLy8gYWN0dWFsIG1vdW50XG4gICAgdGhpcy51bmJ1aWxkKHRydWUpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYWN0aXZhdGVIb29rcyA9IHRoaXMuQ29tcG9uZW50Lm9wdGlvbnMuYWN0aXZhdGU7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGVkKCk7XG4gICAgdmFyIG5ld0NvbXBvbmVudCA9IHRoaXMuYnVpbGQoKTtcbiAgICBpZiAoYWN0aXZhdGVIb29rcyAmJiAhY2FjaGVkKSB7XG4gICAgICB0aGlzLndhaXRpbmdGb3IgPSBuZXdDb21wb25lbnQ7XG4gICAgICBjYWxsQWN0aXZhdGVIb29rcyhhY3RpdmF0ZUhvb2tzLCBuZXdDb21wb25lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYud2FpdGluZ0ZvciAhPT0gbmV3Q29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYud2FpdGluZ0ZvciA9IG51bGw7XG4gICAgICAgIHNlbGYudHJhbnNpdGlvbihuZXdDb21wb25lbnQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGUgcmVmIGZvciBrZXB0LWFsaXZlIGNvbXBvbmVudFxuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICBuZXdDb21wb25lbnQuX3VwZGF0ZVJlZigpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2l0aW9uKG5ld0NvbXBvbmVudCwgY2IpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogV2hlbiB0aGUgY29tcG9uZW50IGNoYW5nZXMgb3IgdW5iaW5kcyBiZWZvcmUgYW4gYXN5bmNcbiAgICogY29uc3RydWN0b3IgaXMgcmVzb2x2ZWQsIHdlIG5lZWQgdG8gaW52YWxpZGF0ZSBpdHNcbiAgICogcGVuZGluZyBjYWxsYmFjay5cbiAgICovXG5cbiAgaW52YWxpZGF0ZVBlbmRpbmc6IGZ1bmN0aW9uIGludmFsaWRhdGVQZW5kaW5nKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdDb21wb25lbnRDYikge1xuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IuY2FuY2VsKCk7XG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZS9pbnNlcnQgYSBuZXcgY2hpbGQgdm0uXG4gICAqIElmIGtlZXAgYWxpdmUgYW5kIGhhcyBjYWNoZWQgaW5zdGFuY2UsIGluc2VydCB0aGF0XG4gICAqIGluc3RhbmNlOyBvdGhlcndpc2UgYnVpbGQgYSBuZXcgb25lIGFuZCBjYWNoZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRyYU9wdGlvbnNdXG4gICAqIEByZXR1cm4ge1Z1ZX0gLSB0aGUgY3JlYXRlZCBpbnN0YW5jZVxuICAgKi9cblxuICBidWlsZDogZnVuY3Rpb24gYnVpbGQoZXh0cmFPcHRpb25zKSB7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGVkKCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuQ29tcG9uZW50KSB7XG4gICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBuYW1lOiB0aGlzLkNvbXBvbmVudE5hbWUsXG4gICAgICAgIGVsOiBjbG9uZU5vZGUodGhpcy5lbCksXG4gICAgICAgIHRlbXBsYXRlOiB0aGlzLmlubGluZVRlbXBsYXRlLFxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gYWRkIHRoZSBjaGlsZCB3aXRoIGNvcnJlY3QgcGFyZW50XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGl0cyBwYXJlbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIHRoZSB0cmFuc2NsdXNpb24gaG9zdC5cbiAgICAgICAgcGFyZW50OiB0aGlzLl9ob3N0IHx8IHRoaXMudm0sXG4gICAgICAgIC8vIGlmIG5vIGlubGluZS10ZW1wbGF0ZSwgdGhlbiB0aGUgY29tcGlsZWRcbiAgICAgICAgLy8gbGlua2VyIGNhbiBiZSBjYWNoZWQgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICAgICAgX2xpbmtlckNhY2hhYmxlOiAhdGhpcy5pbmxpbmVUZW1wbGF0ZSxcbiAgICAgICAgX3JlZjogdGhpcy5kZXNjcmlwdG9yLnJlZixcbiAgICAgICAgX2FzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgICBfaXNSb3V0ZXJWaWV3OiB0aGlzLl9pc1JvdXRlclZpZXcsXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGNvbnRleHRcbiAgICAgICAgLy8gd2lsbCBiZSB0aGUgY29tbW9uIHBhcmVudCB2bSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICAgIC8vIGFuZCBpdHMgaG9zdC5cbiAgICAgICAgX2NvbnRleHQ6IHRoaXMudm0sXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgaW5zaWRlIGFuIGlubGluZSB2LWZvciwgdGhlIHNjb3BlXG4gICAgICAgIC8vIHdpbGwgYmUgdGhlIGludGVybWVkaWF0ZSBzY29wZSBjcmVhdGVkIGZvciB0aGlzXG4gICAgICAgIC8vIHJlcGVhdCBmcmFnbWVudC4gdGhpcyBpcyB1c2VkIGZvciBsaW5raW5nIHByb3BzXG4gICAgICAgIC8vIGFuZCBjb250YWluZXIgZGlyZWN0aXZlcy5cbiAgICAgICAgX3Njb3BlOiB0aGlzLl9zY29wZSxcbiAgICAgICAgLy8gcGFzcyBpbiB0aGUgb3duZXIgZnJhZ21lbnQgb2YgdGhpcyBjb21wb25lbnQuXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IHNvIHRoYXQgdGhlIGZyYWdtZW50IGNhbiBrZWVwXG4gICAgICAgIC8vIHRyYWNrIG9mIGl0cyBjb250YWluZWQgY29tcG9uZW50cyBpbiBvcmRlciB0b1xuICAgICAgICAvLyBjYWxsIGF0dGFjaC9kZXRhY2ggaG9va3MgZm9yIHRoZW0uXG4gICAgICAgIF9mcmFnOiB0aGlzLl9mcmFnXG4gICAgICB9O1xuICAgICAgLy8gZXh0cmEgb3B0aW9uc1xuICAgICAgLy8gaW4gMS4wLjAgdGhpcyBpcyB1c2VkIGJ5IHZ1ZS1yb3V0ZXIgb25seVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChvcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuQ29tcG9uZW50KG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgIHRoaXMuY2FjaGVbdGhpcy5Db21wb25lbnQuY2lkXSA9IGNoaWxkO1xuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsLmhhc0F0dHJpYnV0ZSgndHJhbnNpdGlvbicpICYmIGNoaWxkLl9pc0ZyYWdtZW50KSB7XG4gICAgICAgIHdhcm4oJ1RyYW5zaXRpb25zIHdpbGwgbm90IHdvcmsgb24gYSBmcmFnbWVudCBpbnN0YW5jZS4gJyArICdUZW1wbGF0ZTogJyArIGNoaWxkLiRvcHRpb25zLnRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyeSB0byBnZXQgYSBjYWNoZWQgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtWdWV8dW5kZWZpbmVkfVxuICAgKi9cblxuICBnZXRDYWNoZWQ6IGZ1bmN0aW9uIGdldENhY2hlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5rZWVwQWxpdmUgJiYgdGhpcy5jYWNoZVt0aGlzLkNvbXBvbmVudC5jaWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUZWFyZG93biB0aGUgY3VycmVudCBjaGlsZCwgYnV0IGRlZmVycyBjbGVhbnVwIHNvXG4gICAqIHRoYXQgd2UgY2FuIHNlcGFyYXRlIHRoZSBkZXN0cm95IGFuZCByZW1vdmFsIHN0ZXBzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyXG4gICAqL1xuXG4gIHVuYnVpbGQ6IGZ1bmN0aW9uIHVuYnVpbGQoZGVmZXIpIHtcbiAgICBpZiAodGhpcy53YWl0aW5nRm9yKSB7XG4gICAgICB0aGlzLndhaXRpbmdGb3IuJGRlc3Ryb3koKTtcbiAgICAgIHRoaXMud2FpdGluZ0ZvciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRWTTtcbiAgICBpZiAoIWNoaWxkIHx8IHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHJlZlxuICAgICAgICBjaGlsZC5faW5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBjaGlsZC5fdXBkYXRlUmVmKHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB0aGUgc29sZSBwdXJwb3NlIG9mIGBkZWZlckNsZWFudXBgIGlzIHNvIHRoYXQgd2UgY2FuXG4gICAgLy8gXCJkZWFjdGl2YXRlXCIgdGhlIHZtIHJpZ2h0IG5vdyBhbmQgcGVyZm9ybSBET00gcmVtb3ZhbFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLiRkZXN0cm95KGZhbHNlLCBkZWZlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjdXJyZW50IGRlc3Ryb3llZCBjaGlsZCBhbmQgbWFudWFsbHkgZG9cbiAgICogdGhlIGNsZWFudXAgYWZ0ZXIgcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY2hpbGQsIGNiKSB7XG4gICAgdmFyIGtlZXBBbGl2ZSA9IHRoaXMua2VlcEFsaXZlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgLy8gd2UgbWF5IGhhdmUgYSBjb21wb25lbnQgc3dpdGNoIHdoZW4gYSBwcmV2aW91c1xuICAgICAgLy8gY29tcG9uZW50IGlzIHN0aWxsIGJlaW5nIHRyYW5zaXRpb25lZCBvdXQuXG4gICAgICAvLyB3ZSB3YW50IHRvIHRyaWdnZXIgb25seSBvbmUgbGFzdGVzdCBpbnNlcnRpb24gY2JcbiAgICAgIC8vIHdoZW4gdGhlIGV4aXN0aW5nIHRyYW5zaXRpb24gZmluaXNoZXMuICgjMTExOSlcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxzKys7XG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBjYjtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGNoaWxkLiRyZW1vdmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFscy0tO1xuICAgICAgICBpZiAoIWtlZXBBbGl2ZSkgY2hpbGQuX2NsZWFudXAoKTtcbiAgICAgICAgaWYgKCFzZWxmLnBlbmRpbmdSZW1vdmFscyAmJiBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IpIHtcbiAgICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IoKTtcbiAgICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWN0dWFsbHkgc3dhcCB0aGUgY29tcG9uZW50cywgZGVwZW5kaW5nIG9uIHRoZVxuICAgKiB0cmFuc2l0aW9uIG1vZGUuIERlZmF1bHRzIHRvIHNpbXVsdGFuZW91cy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIHRyYW5zaXRpb246IGZ1bmN0aW9uIHRyYW5zaXRpb24odGFyZ2V0LCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY2hpbGRWTTtcbiAgICAvLyBmb3IgZGV2dG9vbCBpbnNwZWN0aW9uXG4gICAgaWYgKGN1cnJlbnQpIGN1cnJlbnQuX2luYWN0aXZlID0gdHJ1ZTtcbiAgICB0YXJnZXQuX2luYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jaGlsZFZNID0gdGFyZ2V0O1xuICAgIHN3aXRjaCAoc2VsZi5wYXJhbXMudHJhbnNpdGlvbk1vZGUpIHtcbiAgICAgIGNhc2UgJ2luLW91dCc6XG4gICAgICAgIHRhcmdldC4kYmVmb3JlKHNlbGYuYW5jaG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5yZW1vdmUoY3VycmVudCwgY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvdXQtaW4nOlxuICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LiRiZWZvcmUoc2VsZi5hbmNob3IsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc2VsZi5yZW1vdmUoY3VycmVudCk7XG4gICAgICAgIHRhcmdldC4kYmVmb3JlKHNlbGYuYW5jaG9yLCBjYik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbmJpbmQuXG4gICAqL1xuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKTtcbiAgICAvLyBEbyBub3QgZGVmZXIgY2xlYW51cCB3aGVuIHVuYmluZGluZ1xuICAgIHRoaXMudW5idWlsZCgpO1xuICAgIC8vIGRlc3Ryb3kgYWxsIGtlZXAtYWxpdmUgY2FjaGVkIGluc3RhbmNlc1xuICAgIGlmICh0aGlzLmNhY2hlKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0uJGRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUgPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGFjdGl2YXRlIGhvb2tzIGluIG9yZGVyIChhc3luY2hyb25vdXMpXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaG9va3NcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVIb29rcyhob29rcywgdm0sIGNiKSB7XG4gIHZhciB0b3RhbCA9IGhvb2tzLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIGhvb2tzWzBdLmNhbGwodm0sIG5leHQpO1xuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmICgrK2NhbGxlZCA+PSB0b3RhbCkge1xuICAgICAgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va3NbY2FsbGVkXS5jYWxsKHZtLCBuZXh0KTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJpbmRpbmdNb2RlcyA9IGNvbmZpZy5fcHJvcEJpbmRpbmdNb2RlcztcblxudmFyIHByb3BEZWYgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLnZtO1xuICAgIHZhciBwYXJlbnQgPSBjaGlsZC5fY29udGV4dDtcbiAgICAvLyBwYXNzZWQgaW4gZnJvbSBjb21waWxlciBkaXJlY3RseVxuICAgIHZhciBwcm9wID0gdGhpcy5kZXNjcmlwdG9yLnByb3A7XG4gICAgdmFyIGNoaWxkS2V5ID0gcHJvcC5wYXRoO1xuICAgIHZhciBwYXJlbnRLZXkgPSBwcm9wLnBhcmVudFBhdGg7XG4gICAgdmFyIHR3b1dheSA9IHByb3AubW9kZSA9PT0gYmluZGluZ01vZGVzLlRXT19XQVk7XG5cbiAgICB2YXIgcGFyZW50V2F0Y2hlciA9IHRoaXMucGFyZW50V2F0Y2hlciA9IG5ldyBXYXRjaGVyKHBhcmVudCwgcGFyZW50S2V5LCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB2YWwgPSBjb2VyY2VQcm9wKHByb3AsIHZhbCk7XG4gICAgICBpZiAoYXNzZXJ0UHJvcChwcm9wLCB2YWwpKSB7XG4gICAgICAgIGNoaWxkW2NoaWxkS2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB0d29XYXk6IHR3b1dheSxcbiAgICAgIGZpbHRlcnM6IHByb3AuZmlsdGVycyxcbiAgICAgIC8vIGltcG9ydGFudDogcHJvcHMgbmVlZCB0byBiZSBvYnNlcnZlZCBvbiB0aGVcbiAgICAgIC8vIHYtZm9yIHNjb3BlIGlmIHByZXNlbnRcbiAgICAgIHNjb3BlOiB0aGlzLl9zY29wZVxuICAgIH0pO1xuXG4gICAgLy8gc2V0IHRoZSBjaGlsZCBpbml0aWFsIHZhbHVlLlxuICAgIGluaXRQcm9wKGNoaWxkLCBwcm9wLCBwYXJlbnRXYXRjaGVyLnZhbHVlKTtcblxuICAgIC8vIHNldHVwIHR3by13YXkgYmluZGluZ1xuICAgIGlmICh0d29XYXkpIHtcbiAgICAgIC8vIGltcG9ydGFudDogZGVmZXIgdGhlIGNoaWxkIHdhdGNoZXIgY3JlYXRpb24gdW50aWxcbiAgICAgIC8vIHRoZSBjcmVhdGVkIGhvb2sgKGFmdGVyIGRhdGEgb2JzZXJ2YXRpb24pXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBjaGlsZC4kb25jZSgncHJlLWhvb2s6Y3JlYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5jaGlsZFdhdGNoZXIgPSBuZXcgV2F0Y2hlcihjaGlsZCwgY2hpbGRLZXksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICBwYXJlbnRXYXRjaGVyLnNldCh2YWwpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgLy8gZW5zdXJlIHN5bmMgdXB3YXJkIGJlZm9yZSBwYXJlbnQgc3luYyBkb3duLlxuICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGluIGNhc2VzIGUuZy4gdGhlIGNoaWxkXG4gICAgICAgICAgLy8gbXV0YXRlcyBhIHByb3AgYXJyYXksIHRoZW4gcmVwbGFjZXMgaXQuICgjMTY4MylcbiAgICAgICAgICBzeW5jOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMucGFyZW50V2F0Y2hlci50ZWFyZG93bigpO1xuICAgIGlmICh0aGlzLmNoaWxkV2F0Y2hlcikge1xuICAgICAgdGhpcy5jaGlsZFdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBxdWV1ZSQxID0gW107XG52YXIgcXVldWVkID0gZmFsc2U7XG5cbi8qKlxuICogUHVzaCBhIGpvYiBpbnRvIHRoZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2JcbiAqL1xuXG5mdW5jdGlvbiBwdXNoSm9iKGpvYikge1xuICBxdWV1ZSQxLnB1c2goam9iKTtcbiAgaWYgKCFxdWV1ZWQpIHtcbiAgICBxdWV1ZWQgPSB0cnVlO1xuICAgIG5leHRUaWNrKGZsdXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIEZsdXNoIHRoZSBxdWV1ZSwgYW5kIGRvIG9uZSBmb3JjZWQgcmVmbG93IGJlZm9yZVxuICogdHJpZ2dlcmluZyB0cmFuc2l0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgLy8gRm9yY2UgbGF5b3V0XG4gIHZhciBmID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZSQxLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWUkMVtpXSgpO1xuICB9XG4gIHF1ZXVlJDEgPSBbXTtcbiAgcXVldWVkID0gZmFsc2U7XG4gIC8vIGR1bW15IHJldHVybiwgc28ganMgbGludGVycyBkb24ndCBjb21wbGFpbiBhYm91dFxuICAvLyB1bnVzZWQgdmFyaWFibGUgZlxuICByZXR1cm4gZjtcbn1cblxudmFyIFRZUEVfVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBUWVBFX0FOSU1BVElPTiA9ICdhbmltYXRpb24nO1xudmFyIHRyYW5zRHVyYXRpb25Qcm9wID0gdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nO1xudmFyIGFuaW1EdXJhdGlvblByb3AgPSBhbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJztcblxuLyoqXG4gKiBBIFRyYW5zaXRpb24gb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIHRoZSBzdGF0ZSBhbmQgbG9naWNcbiAqIG9mIHRoZSB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IGhvb2tzXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuZnVuY3Rpb24gVHJhbnNpdGlvbihlbCwgaWQsIGhvb2tzLCB2bSkge1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuZWwgPSBlbDtcbiAgdGhpcy5lbnRlckNsYXNzID0gaG9va3MgJiYgaG9va3MuZW50ZXJDbGFzcyB8fCBpZCArICctZW50ZXInO1xuICB0aGlzLmxlYXZlQ2xhc3MgPSBob29rcyAmJiBob29rcy5sZWF2ZUNsYXNzIHx8IGlkICsgJy1sZWF2ZSc7XG4gIHRoaXMuaG9va3MgPSBob29rcztcbiAgdGhpcy52bSA9IHZtO1xuICAvLyBhc3luYyBzdGF0ZVxuICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gdGhpcy5vcCA9IHRoaXMuY2IgPSBudWxsO1xuICB0aGlzLmp1c3RFbnRlcmVkID0gZmFsc2U7XG4gIHRoaXMuZW50ZXJlZCA9IHRoaXMubGVmdCA9IGZhbHNlO1xuICB0aGlzLnR5cGVDYWNoZSA9IHt9O1xuICAvLyBjaGVjayBjc3MgdHJhbnNpdGlvbiB0eXBlXG4gIHRoaXMudHlwZSA9IGhvb2tzICYmIGhvb2tzLnR5cGU7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0aGlzLnR5cGUgJiYgdGhpcy50eXBlICE9PSBUWVBFX1RSQU5TSVRJT04gJiYgdGhpcy50eXBlICE9PSBUWVBFX0FOSU1BVElPTikge1xuICAgICAgd2FybignaW52YWxpZCBDU1MgdHJhbnNpdGlvbiB0eXBlIGZvciB0cmFuc2l0aW9uPVwiJyArIHRoaXMuaWQgKyAnXCI6ICcgKyB0aGlzLnR5cGUpO1xuICAgIH1cbiAgfVxuICAvLyBiaW5kXG4gIHZhciBzZWxmID0gdGhpcztbJ2VudGVyTmV4dFRpY2snLCAnZW50ZXJEb25lJywgJ2xlYXZlTmV4dFRpY2snLCAnbGVhdmVEb25lJ10uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIHNlbGZbbV0gPSBiaW5kKHNlbGZbbV0sIHNlbGYpO1xuICB9KTtcbn1cblxudmFyIHAkMSA9IFRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG4vKipcbiAqIFN0YXJ0IGFuIGVudGVyaW5nIHRyYW5zaXRpb24uXG4gKlxuICogMS4gZW50ZXIgdHJhbnNpdGlvbiB0cmlnZ2VyZWRcbiAqIDIuIGNhbGwgYmVmb3JlRW50ZXIgaG9va1xuICogMy4gYWRkIGVudGVyIGNsYXNzXG4gKiA0LiBpbnNlcnQvc2hvdyBlbGVtZW50XG4gKiA1LiBjYWxsIGVudGVyIGhvb2sgKHdpdGggcG9zc2libGUgZXhwbGljaXQganMgY2FsbGJhY2spXG4gKiA2LiByZWZsb3dcbiAqIDcuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAqICAgIC0gdHJhbnNpdGlvbjpcbiAqICAgICAgICByZW1vdmUgY2xhc3Mgbm93LCB3YWl0IGZvciB0cmFuc2l0aW9uZW5kLFxuICogICAgICAgIHRoZW4gZG9uZSBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogICAgLSBhbmltYXRpb246XG4gKiAgICAgICAgd2FpdCBmb3IgYW5pbWF0aW9uZW5kLCByZW1vdmUgY2xhc3MsXG4gKiAgICAgICAgdGhlbiBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIG5vIGNzcyB0cmFuc2l0aW9uOlxuICogICAgICAgIGRvbmUgbm93IGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiA4LiB3YWl0IGZvciBlaXRoZXIgZG9uZSBvciBqcyBjYWxsYmFjaywgdGhlbiBjYWxsXG4gKiAgICBhZnRlckVudGVyIGhvb2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSBpbnNlcnQvc2hvdyB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbnAkMS5lbnRlciA9IGZ1bmN0aW9uIChvcCwgY2IpIHtcbiAgdGhpcy5jYW5jZWxQZW5kaW5nKCk7XG4gIHRoaXMuY2FsbEhvb2soJ2JlZm9yZUVudGVyJyk7XG4gIHRoaXMuY2IgPSBjYjtcbiAgYWRkQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgb3AoKTtcbiAgdGhpcy5lbnRlcmVkID0gZmFsc2U7XG4gIHRoaXMuY2FsbEhvb2tXaXRoQ2IoJ2VudGVyJyk7XG4gIGlmICh0aGlzLmVudGVyZWQpIHtcbiAgICByZXR1cm47IC8vIHVzZXIgY2FsbGVkIGRvbmUgc3luY2hyb25vdXNseS5cbiAgfVxuICB0aGlzLmNhbmNlbCA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5lbnRlckNhbmNlbGxlZDtcbiAgcHVzaEpvYih0aGlzLmVudGVyTmV4dFRpY2spO1xufTtcblxuLyoqXG4gKiBUaGUgXCJuZXh0VGlja1wiIHBoYXNlIG9mIGFuIGVudGVyaW5nIHRyYW5zaXRpb24sIHdoaWNoIGlzXG4gKiB0byBiZSBwdXNoZWQgaW50byBhIHF1ZXVlIGFuZCBleGVjdXRlZCBhZnRlciBhIHJlZmxvdyBzb1xuICogdGhhdCByZW1vdmluZyB0aGUgY2xhc3MgY2FuIHRyaWdnZXIgYSBDU1MgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEuZW50ZXJOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gSW1wb3J0YW50IGhhY2s6XG4gIC8vIGluIENocm9tZSwgaWYgYSBqdXN0LWVudGVyZWQgZWxlbWVudCBpcyBhcHBsaWVkIHRoZVxuICAvLyBsZWF2ZSBjbGFzcyB3aGlsZSBpdHMgaW50ZXJwb2xhdGVkIHByb3BlcnR5IHN0aWxsIGhhc1xuICAvLyBhIHZlcnkgc21hbGwgdmFsdWUgKHdpdGhpbiBvbmUgZnJhbWUpLCBDaHJvbWUgd2lsbFxuICAvLyBza2lwIHRoZSBsZWF2ZSB0cmFuc2l0aW9uIGVudGlyZWx5IGFuZCBub3QgZmlyaW5nIHRoZVxuICAvLyB0cmFuc3Rpb25lbmQgZXZlbnQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHByb3RlY3RlZFxuICAvLyBhZ2FpbnN0IHN1Y2ggY2FzZXMgdXNpbmcgYSBvbmUtZnJhbWUgdGltZW91dC5cbiAgdGhpcy5qdXN0RW50ZXJlZCA9IHRydWU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5qdXN0RW50ZXJlZCA9IGZhbHNlO1xuICB9LCAxNyk7XG5cbiAgdmFyIGVudGVyRG9uZSA9IHRoaXMuZW50ZXJEb25lO1xuICB2YXIgdHlwZSA9IHRoaXMuZ2V0Q3NzVHJhbnNpdGlvblR5cGUodGhpcy5lbnRlckNsYXNzKTtcbiAgaWYgKCF0aGlzLnBlbmRpbmdKc0NiKSB7XG4gICAgaWYgKHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTikge1xuICAgICAgLy8gdHJpZ2dlciB0cmFuc2l0aW9uIGJ5IHJlbW92aW5nIGVudGVyIGNsYXNzIG5vd1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgICAgIHRoaXMuc2V0dXBDc3NDYih0cmFuc2l0aW9uRW5kRXZlbnQsIGVudGVyRG9uZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBUWVBFX0FOSU1BVElPTikge1xuICAgICAgdGhpcy5zZXR1cENzc0NiKGFuaW1hdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlckRvbmUoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gVFlQRV9UUkFOU0lUSU9OKSB7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgXCJjbGVhbnVwXCIgcGhhc2Ugb2YgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEuZW50ZXJEb25lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVudGVyZWQgPSB0cnVlO1xuICB0aGlzLmNhbmNlbCA9IHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsO1xuICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICB0aGlzLmNhbGxIb29rKCdhZnRlckVudGVyJyk7XG4gIGlmICh0aGlzLmNiKSB0aGlzLmNiKCk7XG59O1xuXG4vKipcbiAqIFN0YXJ0IGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICpcbiAqIDEuIGxlYXZlIHRyYW5zaXRpb24gdHJpZ2dlcmVkLlxuICogMi4gY2FsbCBiZWZvcmVMZWF2ZSBob29rXG4gKiAzLiBhZGQgbGVhdmUgY2xhc3MgKHRyaWdnZXIgY3NzIHRyYW5zaXRpb24pXG4gKiA0LiBjYWxsIGxlYXZlIGhvb2sgKHdpdGggcG9zc2libGUgZXhwbGljaXQganMgY2FsbGJhY2spXG4gKiA1LiByZWZsb3cgaWYgbm8gZXhwbGljaXQganMgY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAqIDYuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAqICAgIC0gdHJhbnNpdGlvbiBvciBhbmltYXRpb246XG4gKiAgICAgICAgd2FpdCBmb3IgZW5kIGV2ZW50LCByZW1vdmUgY2xhc3MsIHRoZW4gZG9uZSBpZlxuICogICAgICAgIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIG5vIGNzcyB0cmFuc2l0aW9uOlxuICogICAgICAgIGRvbmUgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqIDcuIHdhaXQgZm9yIGVpdGhlciBkb25lIG9yIGpzIGNhbGxiYWNrLCB0aGVuIGNhbGxcbiAqICAgIGFmdGVyTGVhdmUgaG9vay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHJlbW92ZS9oaWRlIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxucCQxLmxlYXZlID0gZnVuY3Rpb24gKG9wLCBjYikge1xuICB0aGlzLmNhbmNlbFBlbmRpbmcoKTtcbiAgdGhpcy5jYWxsSG9vaygnYmVmb3JlTGVhdmUnKTtcbiAgdGhpcy5vcCA9IG9wO1xuICB0aGlzLmNiID0gY2I7XG4gIGFkZENsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcyk7XG4gIHRoaXMubGVmdCA9IGZhbHNlO1xuICB0aGlzLmNhbGxIb29rV2l0aENiKCdsZWF2ZScpO1xuICBpZiAodGhpcy5sZWZ0KSB7XG4gICAgcmV0dXJuOyAvLyB1c2VyIGNhbGxlZCBkb25lIHN5bmNocm9ub3VzbHkuXG4gIH1cbiAgdGhpcy5jYW5jZWwgPSB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MubGVhdmVDYW5jZWxsZWQ7XG4gIC8vIG9ubHkgbmVlZCB0byBoYW5kbGUgbGVhdmVEb25lIGlmXG4gIC8vIDEuIHRoZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgZG9uZSAoc3luY2hyb25vdXNseSBjYWxsZWRcbiAgLy8gICAgYnkgdGhlIHVzZXIsIHdoaWNoIGNhdXNlcyB0aGlzLm9wIHNldCB0byBudWxsKVxuICAvLyAyLiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrXG4gIGlmICh0aGlzLm9wICYmICF0aGlzLnBlbmRpbmdKc0NiKSB7XG4gICAgLy8gaWYgYSBDU1MgdHJhbnNpdGlvbiBsZWF2ZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgZW50ZXIsXG4gICAgLy8gdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQgbmV2ZXIgZmlyZXMuIHRoZXJlZm9yZSB3ZVxuICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBlbmQgdGhlIGxlYXZlIGltbWVkaWF0ZWx5LlxuICAgIGlmICh0aGlzLmp1c3RFbnRlcmVkKSB7XG4gICAgICB0aGlzLmxlYXZlRG9uZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoSm9iKHRoaXMubGVhdmVOZXh0VGljayk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBcIm5leHRUaWNrXCIgcGhhc2Ugb2YgYSBsZWF2aW5nIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmxlYXZlTmV4dFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0eXBlID0gdGhpcy5nZXRDc3NUcmFuc2l0aW9uVHlwZSh0aGlzLmxlYXZlQ2xhc3MpO1xuICBpZiAodHlwZSkge1xuICAgIHZhciBldmVudCA9IHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICAgIHRoaXMuc2V0dXBDc3NDYihldmVudCwgdGhpcy5sZWF2ZURvbmUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGVhdmVEb25lKCk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIFwiY2xlYW51cFwiIHBoYXNlIG9mIGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5sZWF2ZURvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGVmdCA9IHRydWU7XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5wZW5kaW5nSnNDYiA9IG51bGw7XG4gIHRoaXMub3AoKTtcbiAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKTtcbiAgdGhpcy5jYWxsSG9vaygnYWZ0ZXJMZWF2ZScpO1xuICBpZiAodGhpcy5jYikgdGhpcy5jYigpO1xuICB0aGlzLm9wID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FuY2VsIGFueSBwZW5kaW5nIGNhbGxiYWNrcyBmcm9tIGEgcHJldmlvdXNseSBydW5uaW5nXG4gKiBidXQgbm90IGZpbmlzaGVkIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmNhbmNlbFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub3AgPSB0aGlzLmNiID0gbnVsbDtcbiAgdmFyIGhhc1BlbmRpbmcgPSBmYWxzZTtcbiAgaWYgKHRoaXMucGVuZGluZ0Nzc0NiKSB7XG4gICAgaGFzUGVuZGluZyA9IHRydWU7XG4gICAgb2ZmKHRoaXMuZWwsIHRoaXMucGVuZGluZ0Nzc0V2ZW50LCB0aGlzLnBlbmRpbmdDc3NDYik7XG4gICAgdGhpcy5wZW5kaW5nQ3NzRXZlbnQgPSB0aGlzLnBlbmRpbmdDc3NDYiA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICBoYXNQZW5kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBlbmRpbmdKc0NiLmNhbmNlbCgpO1xuICAgIHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsO1xuICB9XG4gIGlmIChoYXNQZW5kaW5nKSB7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmxlYXZlQ2xhc3MpO1xuICB9XG4gIGlmICh0aGlzLmNhbmNlbCkge1xuICAgIHRoaXMuY2FuY2VsLmNhbGwodGhpcy52bSwgdGhpcy5lbCk7XG4gICAgdGhpcy5jYW5jZWwgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGwgYSB1c2VyLXByb3ZpZGVkIHN5bmNocm9ub3VzIGhvb2sgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5wJDEuY2FsbEhvb2sgPSBmdW5jdGlvbiAodHlwZSkge1xuICBpZiAodGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzW3R5cGVdKSB7XG4gICAgdGhpcy5ob29rc1t0eXBlXS5jYWxsKHRoaXMudm0sIHRoaXMuZWwpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGwgYSB1c2VyLXByb3ZpZGVkLCBwb3RlbnRpYWxseS1hc3luYyBob29rIGZ1bmN0aW9uLlxuICogV2UgY2hlY2sgZm9yIHRoZSBsZW5ndGggb2YgYXJndW1lbnRzIHRvIHNlZSBpZiB0aGUgaG9va1xuICogZXhwZWN0cyBhIGBkb25lYCBjYWxsYmFjay4gSWYgdHJ1ZSwgdGhlIHRyYW5zaXRpb24ncyBlbmRcbiAqIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB3aGVuIHRoZSB1c2VyIGNhbGxzIHRoYXQgY2FsbGJhY2s7XG4gKiBvdGhlcndpc2UsIHRoZSBlbmQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgQ1NTIHRyYW5zaXRpb24gb3JcbiAqIGFuaW1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5cbnAkMS5jYWxsSG9va1dpdGhDYiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBob29rID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzW3R5cGVdO1xuICBpZiAoaG9vaykge1xuICAgIGlmIChob29rLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMucGVuZGluZ0pzQ2IgPSBjYW5jZWxsYWJsZSh0aGlzW3R5cGUgKyAnRG9uZSddKTtcbiAgICB9XG4gICAgaG9vay5jYWxsKHRoaXMudm0sIHRoaXMuZWwsIHRoaXMucGVuZGluZ0pzQ2IpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhbiBlbGVtZW50J3MgdHJhbnNpdGlvbiB0eXBlIGJhc2VkIG9uIHRoZVxuICogY2FsY3VsYXRlZCBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5cbnAkMS5nZXRDc3NUcmFuc2l0aW9uVHlwZSA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghdHJhbnNpdGlvbkVuZEV2ZW50IHx8XG4gIC8vIHNraXAgQ1NTIHRyYW5zaXRpb25zIGlmIHBhZ2UgaXMgbm90IHZpc2libGUgLVxuICAvLyB0aGlzIHNvbHZlcyB0aGUgaXNzdWUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHMgbm90XG4gIC8vIGZpcmluZyB1bnRpbCB0aGUgcGFnZSBpcyB2aXNpYmxlIGFnYWluLlxuICAvLyBwYWdlVmlzaWJpbGl0eSBBUEkgaXMgc3VwcG9ydGVkIGluIElFMTArLCBzYW1lIGFzXG4gIC8vIENTUyB0cmFuc2l0aW9ucy5cbiAgZG9jdW1lbnQuaGlkZGVuIHx8XG4gIC8vIGV4cGxpY2l0IGpzLW9ubHkgdHJhbnNpdGlvblxuICB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MuY3NzID09PSBmYWxzZSB8fFxuICAvLyBlbGVtZW50IGlzIGhpZGRlblxuICBpc0hpZGRlbih0aGlzLmVsKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdHlwZSA9IHRoaXMudHlwZSB8fCB0aGlzLnR5cGVDYWNoZVtjbGFzc05hbWVdO1xuICBpZiAodHlwZSkgcmV0dXJuIHR5cGU7XG4gIHZhciBpbmxpbmVTdHlsZXMgPSB0aGlzLmVsLnN0eWxlO1xuICB2YXIgY29tcHV0ZWRTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsKTtcbiAgdmFyIHRyYW5zRHVyYXRpb24gPSBpbmxpbmVTdHlsZXNbdHJhbnNEdXJhdGlvblByb3BdIHx8IGNvbXB1dGVkU3R5bGVzW3RyYW5zRHVyYXRpb25Qcm9wXTtcbiAgaWYgKHRyYW5zRHVyYXRpb24gJiYgdHJhbnNEdXJhdGlvbiAhPT0gJzBzJykge1xuICAgIHR5cGUgPSBUWVBFX1RSQU5TSVRJT047XG4gIH0gZWxzZSB7XG4gICAgdmFyIGFuaW1EdXJhdGlvbiA9IGlubGluZVN0eWxlc1thbmltRHVyYXRpb25Qcm9wXSB8fCBjb21wdXRlZFN0eWxlc1thbmltRHVyYXRpb25Qcm9wXTtcbiAgICBpZiAoYW5pbUR1cmF0aW9uICYmIGFuaW1EdXJhdGlvbiAhPT0gJzBzJykge1xuICAgICAgdHlwZSA9IFRZUEVfQU5JTUFUSU9OO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZSkge1xuICAgIHRoaXMudHlwZUNhY2hlW2NsYXNzTmFtZV0gPSB0eXBlO1xuICB9XG4gIHJldHVybiB0eXBlO1xufTtcblxuLyoqXG4gKiBTZXR1cCBhIENTUyB0cmFuc2l0aW9uZW5kL2FuaW1hdGlvbmVuZCBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxucCQxLnNldHVwQ3NzQ2IgPSBmdW5jdGlvbiAoZXZlbnQsIGNiKSB7XG4gIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID0gZXZlbnQ7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVsID0gdGhpcy5lbDtcbiAgdmFyIG9uRW5kID0gdGhpcy5wZW5kaW5nQ3NzQ2IgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIG9mZihlbCwgZXZlbnQsIG9uRW5kKTtcbiAgICAgIHNlbGYucGVuZGluZ0Nzc0V2ZW50ID0gc2VsZi5wZW5kaW5nQ3NzQ2IgPSBudWxsO1xuICAgICAgaWYgKCFzZWxmLnBlbmRpbmdKc0NiICYmIGNiKSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBvbihlbCwgZXZlbnQsIG9uRW5kKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBoaWRkZW4gLSBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3RcbiAqIHNraXAgdGhlIHRyYW5zaXRpb24gYWxsdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0hpZGRlbihlbCkge1xuICBpZiAoL3N2ZyQvLnRlc3QoZWwubmFtZXNwYWNlVVJJKSkge1xuICAgIC8vIFNWRyBlbGVtZW50cyBkbyBub3QgaGF2ZSBvZmZzZXQoV2lkdGh8SGVpZ2h0KVxuICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGhlIGNsaWVudCByZWN0XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gIShyZWN0LndpZHRoIHx8IHJlY3QuaGVpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gIShlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uJDEgPSB7XG5cbiAgcHJpb3JpdHk6IFRSQU5TSVRJT04sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoaWQsIG9sZElkKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAvLyByZXNvbHZlIG9uIG93bmVyIHZtXG4gICAgdmFyIGhvb2tzID0gcmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICd0cmFuc2l0aW9ucycsIGlkKTtcbiAgICBpZCA9IGlkIHx8ICd2JztcbiAgICBlbC5fX3ZfdHJhbnMgPSBuZXcgVHJhbnNpdGlvbihlbCwgaWQsIGhvb2tzLCB0aGlzLnZtKTtcbiAgICBpZiAob2xkSWQpIHtcbiAgICAgIHJlbW92ZUNsYXNzKGVsLCBvbGRJZCArICctdHJhbnNpdGlvbicpO1xuICAgIH1cbiAgICBhZGRDbGFzcyhlbCwgaWQgKyAnLXRyYW5zaXRpb24nKTtcbiAgfVxufTtcblxudmFyIGludGVybmFsRGlyZWN0aXZlcyA9IHtcbiAgc3R5bGU6IHN0eWxlLFxuICAnY2xhc3MnOiB2Q2xhc3MsXG4gIGNvbXBvbmVudDogY29tcG9uZW50LFxuICBwcm9wOiBwcm9wRGVmLFxuICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uJDFcbn07XG5cbnZhciBwcm9wQmluZGluZ01vZGVzID0gY29uZmlnLl9wcm9wQmluZGluZ01vZGVzO1xudmFyIGVtcHR5ID0ge307XG5cbi8vIHJlZ2V4ZXNcbnZhciBpZGVudFJFJDEgPSAvXlskX2EtekEtWl0rW1xcdyRdKiQvO1xudmFyIHNldHRhYmxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKihcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFtbXlxcW1xcXV0rXFxdKSokLztcblxuLyoqXG4gKiBDb21waWxlIHByb3BzIG9uIGEgcm9vdCBlbGVtZW50IGFuZCByZXR1cm5cbiAqIGEgcHJvcHMgbGluayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BPcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJvcHNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlUHJvcHMoZWwsIHByb3BPcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IFtdO1xuICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wT3B0aW9ucyk7XG4gIHZhciBpID0gbmFtZXMubGVuZ3RoO1xuICB2YXIgb3B0aW9ucywgbmFtZSwgYXR0ciwgdmFsdWUsIHBhdGgsIHBhcnNlZCwgcHJvcDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICBvcHRpb25zID0gcHJvcE9wdGlvbnNbbmFtZV0gfHwgZW1wdHk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnJGRhdGEnKSB7XG4gICAgICB3YXJuKCdEbyBub3QgdXNlICRkYXRhIGFzIHByb3AuJyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBwcm9wcyBjb3VsZCBjb250YWluIGRhc2hlcywgd2hpY2ggd2lsbCBiZVxuICAgIC8vIGludGVycHJldGVkIGFzIG1pbnVzIGNhbGN1bGF0aW9ucyBieSB0aGUgcGFyc2VyXG4gICAgLy8gc28gd2UgbmVlZCB0byBjYW1lbGl6ZSB0aGUgcGF0aCBoZXJlXG4gICAgcGF0aCA9IGNhbWVsaXplKG5hbWUpO1xuICAgIGlmICghaWRlbnRSRSQxLnRlc3QocGF0aCkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBwcm9wIGtleTogXCInICsgbmFtZSArICdcIi4gUHJvcCBrZXlzICcgKyAnbXVzdCBiZSB2YWxpZCBpZGVudGlmaWVycy4nKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHByb3AgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBtb2RlOiBwcm9wQmluZGluZ01vZGVzLk9ORV9XQVksXG4gICAgICByYXc6IG51bGxcbiAgICB9O1xuXG4gICAgYXR0ciA9IGh5cGhlbmF0ZShuYW1lKTtcbiAgICAvLyBmaXJzdCBjaGVjayBkeW5hbWljIHZlcnNpb25cbiAgICBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIpKSA9PT0gbnVsbCkge1xuICAgICAgaWYgKCh2YWx1ZSA9IGdldEJpbmRBdHRyKGVsLCBhdHRyICsgJy5zeW5jJykpICE9PSBudWxsKSB7XG4gICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuVFdPX1dBWTtcbiAgICAgIH0gZWxzZSBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIgKyAnLm9uY2UnKSkgIT09IG51bGwpIHtcbiAgICAgICAgcHJvcC5tb2RlID0gcHJvcEJpbmRpbmdNb2Rlcy5PTkVfVElNRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAvLyBoYXMgZHluYW1pYyBiaW5kaW5nIVxuICAgICAgcHJvcC5yYXcgPSB2YWx1ZTtcbiAgICAgIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKHZhbHVlKTtcbiAgICAgIHZhbHVlID0gcGFyc2VkLmV4cHJlc3Npb247XG4gICAgICBwcm9wLmZpbHRlcnMgPSBwYXJzZWQuZmlsdGVycztcbiAgICAgIC8vIGNoZWNrIGJpbmRpbmcgdHlwZVxuICAgICAgaWYgKGlzTGl0ZXJhbCh2YWx1ZSkgJiYgIXBhcnNlZC5maWx0ZXJzKSB7XG4gICAgICAgIC8vIGZvciBleHByZXNzaW9ucyBjb250YWluaW5nIGxpdGVyYWwgbnVtYmVycyBhbmRcbiAgICAgICAgLy8gYm9vbGVhbnMsIHRoZXJlJ3Mgbm8gbmVlZCB0byBzZXR1cCBhIHByb3AgYmluZGluZyxcbiAgICAgICAgLy8gc28gd2UgY2FuIG9wdGltaXplIHRoZW0gYXMgYSBvbmUtdGltZSBzZXQuXG4gICAgICAgIHByb3Aub3B0aW1pemVkTGl0ZXJhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLmR5bmFtaWMgPSB0cnVlO1xuICAgICAgICAvLyBjaGVjayBub24tc2V0dGFibGUgcGF0aCBmb3IgdHdvLXdheSBiaW5kaW5nc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBwcm9wLm1vZGUgPT09IHByb3BCaW5kaW5nTW9kZXMuVFdPX1dBWSAmJiAhc2V0dGFibGVQYXRoUkUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICBwcm9wLm1vZGUgPSBwcm9wQmluZGluZ01vZGVzLk9ORV9XQVk7XG4gICAgICAgICAgd2FybignQ2Fubm90IGJpbmQgdHdvLXdheSBwcm9wIHdpdGggbm9uLXNldHRhYmxlICcgKyAncGFyZW50IHBhdGg6ICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb3AucGFyZW50UGF0aCA9IHZhbHVlO1xuXG4gICAgICAvLyB3YXJuIHJlcXVpcmVkIHR3by13YXlcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMudHdvV2F5ICYmIHByb3AubW9kZSAhPT0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZKSB7XG4gICAgICAgIHdhcm4oJ1Byb3AgXCInICsgbmFtZSArICdcIiBleHBlY3RzIGEgdHdvLXdheSBiaW5kaW5nIHR5cGUuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgodmFsdWUgPSBnZXRBdHRyKGVsLCBhdHRyKSkgIT09IG51bGwpIHtcbiAgICAgIC8vIGhhcyBsaXRlcmFsIGJpbmRpbmchXG4gICAgICBwcm9wLnJhdyA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gY2hlY2sgcG9zc2libGUgY2FtZWxDYXNlIHByb3AgdXNhZ2VcbiAgICAgIHZhciBsb3dlckNhc2VOYW1lID0gcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSAvW0EtWlxcLV0vLnRlc3QobmFtZSkgJiYgKGVsLmdldEF0dHJpYnV0ZShsb3dlckNhc2VOYW1lKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJzonICsgbG93ZXJDYXNlTmFtZSkgfHwgZWwuZ2V0QXR0cmlidXRlKCd2LWJpbmQ6JyArIGxvd2VyQ2FzZU5hbWUpIHx8IGVsLmdldEF0dHJpYnV0ZSgnOicgKyBsb3dlckNhc2VOYW1lICsgJy5vbmNlJykgfHwgZWwuZ2V0QXR0cmlidXRlKCd2LWJpbmQ6JyArIGxvd2VyQ2FzZU5hbWUgKyAnLm9uY2UnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJzonICsgbG93ZXJDYXNlTmFtZSArICcuc3luYycpIHx8IGVsLmdldEF0dHJpYnV0ZSgndi1iaW5kOicgKyBsb3dlckNhc2VOYW1lICsgJy5zeW5jJykpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm4oJ1Bvc3NpYmxlIHVzYWdlIGVycm9yIGZvciBwcm9wIGAnICsgbG93ZXJDYXNlTmFtZSArICdgIC0gJyArICdkaWQgeW91IG1lYW4gYCcgKyBhdHRyICsgJ2A/IEhUTUwgaXMgY2FzZS1pbnNlbnNpdGl2ZSwgcmVtZW1iZXIgdG8gdXNlICcgKyAna2ViYWItY2FzZSBmb3IgcHJvcHMgaW4gdGVtcGxhdGVzLicpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnJlcXVpcmVkKSB7XG4gICAgICAgIC8vIHdhcm4gbWlzc2luZyByZXF1aXJlZFxuICAgICAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6ICcgKyBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcHVzaCBwcm9wXG4gICAgcHJvcHMucHVzaChwcm9wKTtcbiAgfVxuICByZXR1cm4gbWFrZVByb3BzTGlua0ZuKHByb3BzKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBwcm9wcyB0byBhIHZtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJvcHNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlUHJvcHNMaW5rRm4ocHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb3BzTGlua0ZuKHZtLCBzY29wZSkge1xuICAgIC8vIHN0b3JlIHJlc29sdmVkIHByb3BzIGluZm9cbiAgICB2bS5fcHJvcHMgPSB7fTtcbiAgICB2YXIgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB2YXIgcHJvcCwgcGF0aCwgb3B0aW9ucywgdmFsdWUsIHJhdztcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBwcm9wID0gcHJvcHNbaV07XG4gICAgICByYXcgPSBwcm9wLnJhdztcbiAgICAgIHBhdGggPSBwcm9wLnBhdGg7XG4gICAgICBvcHRpb25zID0gcHJvcC5vcHRpb25zO1xuICAgICAgdm0uX3Byb3BzW3BhdGhdID0gcHJvcDtcbiAgICAgIGlmIChyYXcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBhYnNlbnQgcHJvcFxuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICAgIC8vIGR5bmFtaWMgcHJvcFxuICAgICAgICBpZiAocHJvcC5tb2RlID09PSBwcm9wQmluZGluZ01vZGVzLk9ORV9USU1FKSB7XG4gICAgICAgICAgLy8gb25lIHRpbWUgYmluZGluZ1xuICAgICAgICAgIHZhbHVlID0gKHNjb3BlIHx8IHZtLl9jb250ZXh0IHx8IHZtKS4kZ2V0KHByb3AucGFyZW50UGF0aCk7XG4gICAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodm0uX2NvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGR5bmFtaWMgYmluZGluZ1xuICAgICAgICAgICAgdm0uX2JpbmREaXIoe1xuICAgICAgICAgICAgICBuYW1lOiAncHJvcCcsXG4gICAgICAgICAgICAgIGRlZjogcHJvcERlZixcbiAgICAgICAgICAgICAgcHJvcDogcHJvcFxuICAgICAgICAgICAgfSwgbnVsbCwgbnVsbCwgc2NvcGUpOyAvLyBlbCwgaG9zdCwgc2NvcGVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByb290IGluc3RhbmNlXG4gICAgICAgICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2bS4kZ2V0KHByb3AucGFyZW50UGF0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3Aub3B0aW1pemVkTGl0ZXJhbCkge1xuICAgICAgICAvLyBvcHRpbWl6ZWQgbGl0ZXJhbCwgY2FzdCBpdCBhbmQganVzdCBzZXQgb25jZVxuICAgICAgICB2YXIgc3RyaXBwZWQgPSBzdHJpcFF1b3RlcyhyYXcpO1xuICAgICAgICB2YWx1ZSA9IHN0cmlwcGVkID09PSByYXcgPyB0b0Jvb2xlYW4odG9OdW1iZXIocmF3KSkgOiBzdHJpcHBlZDtcbiAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0cmluZyBsaXRlcmFsLCBidXQgd2UgbmVlZCB0byBjYXRlciBmb3JcbiAgICAgICAgLy8gQm9vbGVhbiBwcm9wcyB3aXRoIG5vIHZhbHVlXG4gICAgICAgIHZhbHVlID0gb3B0aW9ucy50eXBlID09PSBCb29sZWFuICYmIHJhdyA9PT0gJycgPyB0cnVlIDogcmF3O1xuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3BlY2lhbCBiaW5kaW5nIHByZWZpeGVzXG52YXIgYmluZFJFID0gL152LWJpbmQ6fF46LztcbnZhciBvblJFID0gL152LW9uOnxeQC87XG52YXIgZGlyQXR0clJFID0gL152LShbXjpdKykoPzokfDooLiopJCkvO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW15cXC5dKy9nO1xudmFyIHRyYW5zaXRpb25SRSA9IC9eKHYtYmluZDp8Oik/dHJhbnNpdGlvbiQvO1xuXG4vLyB0ZXJtaW5hbCBkaXJlY3RpdmVzXG52YXIgdGVybWluYWxEaXJlY3RpdmVzID0gWydmb3InLCAnaWYnXTtcblxuLy8gZGVmYXVsdCBkaXJlY3RpdmUgcHJpb3JpdHlcbnZhciBERUZBVUxUX1BSSU9SSVRZID0gMTAwMDtcblxuLyoqXG4gKiBDb21waWxlIGEgdGVtcGxhdGUgYW5kIHJldHVybiBhIHJldXNhYmxlIGNvbXBvc2l0ZSBsaW5rXG4gKiBmdW5jdGlvbiwgd2hpY2ggcmVjdXJzaXZlbHkgY29udGFpbnMgbW9yZSBsaW5rIGZ1bmN0aW9uc1xuICogaW5zaWRlLiBUaGlzIHRvcCBsZXZlbCBjb21waWxlIGZ1bmN0aW9uIHdvdWxkIG5vcm1hbGx5XG4gKiBiZSBjYWxsZWQgb24gaW5zdGFuY2Ugcm9vdCBub2RlcywgYnV0IGNhbiBhbHNvIGJlIHVzZWRcbiAqIGZvciBwYXJ0aWFsIGNvbXBpbGF0aW9uIGlmIHRoZSBwYXJ0aWFsIGFyZ3VtZW50IGlzIHRydWUuXG4gKlxuICogVGhlIHJldHVybmVkIGNvbXBvc2l0ZSBsaW5rIGZ1bmN0aW9uLCB3aGVuIGNhbGxlZCwgd2lsbFxuICogcmV0dXJuIGFuIHVubGluayBmdW5jdGlvbiB0aGF0IHRlYXJzZG93biBhbGwgZGlyZWN0aXZlc1xuICogY3JlYXRlZCBkdXJpbmcgdGhlIGxpbmtpbmcgcGhhc2UuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBwYXJ0aWFsXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlKGVsLCBvcHRpb25zLCBwYXJ0aWFsKSB7XG4gIC8vIGxpbmsgZnVuY3Rpb24gZm9yIHRoZSBub2RlIGl0c2VsZi5cbiAgdmFyIG5vZGVMaW5rRm4gPSBwYXJ0aWFsIHx8ICFvcHRpb25zLl9hc0NvbXBvbmVudCA/IGNvbXBpbGVOb2RlKGVsLCBvcHRpb25zKSA6IG51bGw7XG4gIC8vIGxpbmsgZnVuY3Rpb24gZm9yIHRoZSBjaGlsZE5vZGVzXG4gIHZhciBjaGlsZExpbmtGbiA9ICEobm9kZUxpbmtGbiAmJiBub2RlTGlua0ZuLnRlcm1pbmFsKSAmJiBlbC50YWdOYW1lICE9PSAnU0NSSVBUJyAmJiBlbC5oYXNDaGlsZE5vZGVzKCkgPyBjb21waWxlTm9kZUxpc3QoZWwuY2hpbGROb2Rlcywgb3B0aW9ucykgOiBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGNvbXBvc2l0ZSBsaW5rZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGEgYWxyZWFkeVxuICAgKiBjb21waWxlZCBwaWVjZSBvZiBET00sIHdoaWNoIGluc3RhbnRpYXRlcyBhbGwgZGlyZWN0aXZlXG4gICAqIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICAgKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdIC0gaG9zdCB2bSBvZiB0cmFuc2NsdWRlZCBjb250ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gbGluayBjb250ZXh0IGZyYWdtZW50XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICovXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBvc2l0ZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgLy8gY2FjaGUgY2hpbGROb2RlcyBiZWZvcmUgbGlua2luZyBwYXJlbnQsIGZpeCAjNjU3XG4gICAgdmFyIGNoaWxkTm9kZXMgPSB0b0FycmF5KGVsLmNoaWxkTm9kZXMpO1xuICAgIC8vIGxpbmtcbiAgICB2YXIgZGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uIGNvbXBvc2l0ZUxpbmtDYXB0dXJlcigpIHtcbiAgICAgIGlmIChub2RlTGlua0ZuKSBub2RlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgICAgaWYgKGNoaWxkTGlua0ZuKSBjaGlsZExpbmtGbih2bSwgY2hpbGROb2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgIH0sIHZtKTtcbiAgICByZXR1cm4gbWFrZVVubGlua0ZuKHZtLCBkaXJzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBcHBseSBhIGxpbmtlciB0byBhIHZtL2VsZW1lbnQgcGFpciBhbmQgY2FwdHVyZSB0aGVcbiAqIGRpcmVjdGl2ZXMgY3JlYXRlZCBkdXJpbmcgdGhlIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlua2VyXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiBsaW5rQW5kQ2FwdHVyZShsaW5rZXIsIHZtKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIHJlc2V0IGRpcmVjdGl2ZXMgYmVmb3JlIGV2ZXJ5IGNhcHR1cmUgaW4gcHJvZHVjdGlvblxuICAgIC8vIG1vZGUsIHNvIHRoYXQgd2hlbiB1bmxpbmtpbmcgd2UgZG9uJ3QgbmVlZCB0byBzcGxpY2VcbiAgICAvLyB0aGVtIG91dCAod2hpY2ggdHVybnMgb3V0IHRvIGJlIGEgcGVyZiBoaXQpLlxuICAgIC8vIHRoZXkgYXJlIGtlcHQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIHRoZXkgYXJlXG4gICAgLy8gdXNlZnVsIGZvciBWdWUncyBvd24gdGVzdHMuXG4gICAgdm0uX2RpcmVjdGl2ZXMgPSBbXTtcbiAgfVxuICB2YXIgb3JpZ2luYWxEaXJDb3VudCA9IHZtLl9kaXJlY3RpdmVzLmxlbmd0aDtcbiAgbGlua2VyKCk7XG4gIHZhciBkaXJzID0gdm0uX2RpcmVjdGl2ZXMuc2xpY2Uob3JpZ2luYWxEaXJDb3VudCk7XG4gIGRpcnMuc29ydChkaXJlY3RpdmVDb21wYXJhdG9yKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpcnNbaV0uX2JpbmQoKTtcbiAgfVxuICByZXR1cm4gZGlycztcbn1cblxuLyoqXG4gKiBEaXJlY3RpdmUgcHJpb3JpdHkgc29ydCBjb21wYXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKi9cblxuZnVuY3Rpb24gZGlyZWN0aXZlQ29tcGFyYXRvcihhLCBiKSB7XG4gIGEgPSBhLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFk7XG4gIGIgPSBiLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFk7XG4gIHJldHVybiBhID4gYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xufVxuXG4vKipcbiAqIExpbmtlciBmdW5jdGlvbnMgcmV0dXJuIGFuIHVubGluayBmdW5jdGlvbiB0aGF0XG4gKiB0ZWFyc2Rvd24gYWxsIGRpcmVjdGl2ZXMgaW5zdGFuY2VzIGdlbmVyYXRlZCBkdXJpbmdcbiAqIHRoZSBwcm9jZXNzLlxuICpcbiAqIFdlIGNyZWF0ZSB1bmxpbmsgZnVuY3Rpb25zIHdpdGggb25seSB0aGUgbmVjZXNzYXJ5XG4gKiBpbmZvcm1hdGlvbiB0byBhdm9pZCByZXRhaW5pbmcgYWRkaXRpb25hbCBjbG9zdXJlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7QXJyYXl9IGRpcnNcbiAqIEBwYXJhbSB7VnVlfSBbY29udGV4dF1cbiAqIEBwYXJhbSB7QXJyYXl9IFtjb250ZXh0RGlyc11cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIG1ha2VVbmxpbmtGbih2bSwgZGlycywgY29udGV4dCwgY29udGV4dERpcnMpIHtcbiAgZnVuY3Rpb24gdW5saW5rKGRlc3Ryb3lpbmcpIHtcbiAgICB0ZWFyZG93bkRpcnModm0sIGRpcnMsIGRlc3Ryb3lpbmcpO1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHREaXJzKSB7XG4gICAgICB0ZWFyZG93bkRpcnMoY29udGV4dCwgY29udGV4dERpcnMpO1xuICAgIH1cbiAgfVxuICAvLyBleHBvc2UgbGlua2VkIGRpcmVjdGl2ZXNcbiAgdW5saW5rLmRpcnMgPSBkaXJzO1xuICByZXR1cm4gdW5saW5rO1xufVxuXG4vKipcbiAqIFRlYXJkb3duIHBhcnRpYWwgbGlua2VkIGRpcmVjdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRlc3Ryb3lpbmdcbiAqL1xuXG5mdW5jdGlvbiB0ZWFyZG93bkRpcnModm0sIGRpcnMsIGRlc3Ryb3lpbmcpIHtcbiAgdmFyIGkgPSBkaXJzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGRpcnNbaV0uX3RlYXJkb3duKCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWRlc3Ryb3lpbmcpIHtcbiAgICAgIHZtLl9kaXJlY3RpdmVzLiRyZW1vdmUoZGlyc1tpXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBsaW5rIHByb3BzIG9uIGFuIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZUFuZExpbmtQcm9wcyh2bSwgZWwsIHByb3BzLCBzY29wZSkge1xuICB2YXIgcHJvcHNMaW5rRm4gPSBjb21waWxlUHJvcHMoZWwsIHByb3BzKTtcbiAgdmFyIHByb3BEaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgIHByb3BzTGlua0ZuKHZtLCBzY29wZSk7XG4gIH0sIHZtKTtcbiAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgcHJvcERpcnMpO1xufVxuXG4vKipcbiAqIENvbXBpbGUgdGhlIHJvb3QgZWxlbWVudCBvZiBhbiBpbnN0YW5jZS5cbiAqXG4gKiAxLiBhdHRycyBvbiBjb250ZXh0IGNvbnRhaW5lciAoY29udGV4dCBzY29wZSlcbiAqIDIuIGF0dHJzIG9uIHRoZSBjb21wb25lbnQgdGVtcGxhdGUgcm9vdCBub2RlLCBpZlxuICogICAgcmVwbGFjZTp0cnVlIChjaGlsZCBzY29wZSlcbiAqXG4gKiBJZiB0aGlzIGlzIGEgZnJhZ21lbnQgaW5zdGFuY2UsIHdlIG9ubHkgbmVlZCB0byBjb21waWxlIDEuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0T3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVJvb3QoZWwsIG9wdGlvbnMsIGNvbnRleHRPcHRpb25zKSB7XG4gIHZhciBjb250YWluZXJBdHRycyA9IG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzO1xuICB2YXIgcmVwbGFjZXJBdHRycyA9IG9wdGlvbnMuX3JlcGxhY2VyQXR0cnM7XG4gIHZhciBjb250ZXh0TGlua0ZuLCByZXBsYWNlckxpbmtGbjtcblxuICAvLyBvbmx5IG5lZWQgdG8gY29tcGlsZSBvdGhlciBhdHRyaWJ1dGVzIGZvclxuICAvLyBub24tZnJhZ21lbnQgaW5zdGFuY2VzXG4gIGlmIChlbC5ub2RlVHlwZSAhPT0gMTEpIHtcbiAgICAvLyBmb3IgY29tcG9uZW50cywgY29udGFpbmVyIGFuZCByZXBsYWNlciBuZWVkIHRvIGJlXG4gICAgLy8gY29tcGlsZWQgc2VwYXJhdGVseSBhbmQgbGlua2VkIGluIGRpZmZlcmVudCBzY29wZXMuXG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgICAvLyAyLiBjb250YWluZXIgYXR0cmlidXRlc1xuICAgICAgaWYgKGNvbnRhaW5lckF0dHJzICYmIGNvbnRleHRPcHRpb25zKSB7XG4gICAgICAgIGNvbnRleHRMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhjb250YWluZXJBdHRycywgY29udGV4dE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcGxhY2VyQXR0cnMpIHtcbiAgICAgICAgLy8gMy4gcmVwbGFjZXIgYXR0cmlidXRlc1xuICAgICAgICByZXBsYWNlckxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKHJlcGxhY2VyQXR0cnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub24tY29tcG9uZW50LCBqdXN0IGNvbXBpbGUgYXMgYSBub3JtYWwgZWxlbWVudC5cbiAgICAgIHJlcGxhY2VyTGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMoZWwuYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29udGFpbmVyQXR0cnMpIHtcbiAgICAvLyB3YXJuIGNvbnRhaW5lciBkaXJlY3RpdmVzIGZvciBmcmFnbWVudCBpbnN0YW5jZXNcbiAgICB2YXIgbmFtZXMgPSBjb250YWluZXJBdHRycy5maWx0ZXIoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIC8vIGFsbG93IHZ1ZS1sb2FkZXIvdnVlaWZ5IHNjb3BlZCBjc3MgYXR0cmlidXRlc1xuICAgICAgcmV0dXJuIGF0dHIubmFtZS5pbmRleE9mKCdfdi0nKSA8IDAgJiZcbiAgICAgIC8vIGFsbG93IGV2ZW50IGxpc3RlbmVyc1xuICAgICAgIW9uUkUudGVzdChhdHRyLm5hbWUpICYmXG4gICAgICAvLyBhbGxvdyBzbG90c1xuICAgICAgYXR0ci5uYW1lICE9PSAnc2xvdCc7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICByZXR1cm4gJ1wiJyArIGF0dHIubmFtZSArICdcIic7XG4gICAgfSk7XG4gICAgaWYgKG5hbWVzLmxlbmd0aCkge1xuICAgICAgdmFyIHBsdXJhbCA9IG5hbWVzLmxlbmd0aCA+IDE7XG4gICAgICB3YXJuKCdBdHRyaWJ1dGUnICsgKHBsdXJhbCA/ICdzICcgOiAnICcpICsgbmFtZXMuam9pbignLCAnKSArIChwbHVyYWwgPyAnIGFyZScgOiAnIGlzJykgKyAnIGlnbm9yZWQgb24gY29tcG9uZW50ICcgKyAnPCcgKyBvcHRpb25zLmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICc+IGJlY2F1c2UgJyArICd0aGUgY29tcG9uZW50IGlzIGEgZnJhZ21lbnQgaW5zdGFuY2U6ICcgKyAnaHR0cDovL3Z1ZWpzLm9yZy9ndWlkZS9jb21wb25lbnRzLmh0bWwjRnJhZ21lbnRfSW5zdGFuY2UnKTtcbiAgICB9XG4gIH1cblxuICBvcHRpb25zLl9jb250YWluZXJBdHRycyA9IG9wdGlvbnMuX3JlcGxhY2VyQXR0cnMgPSBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24gcm9vdExpbmtGbih2bSwgZWwsIHNjb3BlKSB7XG4gICAgLy8gbGluayBjb250ZXh0IHNjb3BlIGRpcnNcbiAgICB2YXIgY29udGV4dCA9IHZtLl9jb250ZXh0O1xuICAgIHZhciBjb250ZXh0RGlycztcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0TGlua0ZuKSB7XG4gICAgICBjb250ZXh0RGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGV4dExpbmtGbihjb250ZXh0LCBlbCwgbnVsbCwgc2NvcGUpO1xuICAgICAgfSwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gbGluayBzZWxmXG4gICAgdmFyIHNlbGZEaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlcGxhY2VyTGlua0ZuKSByZXBsYWNlckxpbmtGbih2bSwgZWwpO1xuICAgIH0sIHZtKTtcblxuICAgIC8vIHJldHVybiB0aGUgdW5saW5rIGZ1bmN0aW9uIHRoYXQgdGVhcnNkb3duIGNvbnRleHRcbiAgICAvLyBjb250YWluZXIgZGlyZWN0aXZlcy5cbiAgICByZXR1cm4gbWFrZVVubGlua0ZuKHZtLCBzZWxmRGlycywgY29udGV4dCwgY29udGV4dERpcnMpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBub2RlIGFuZCByZXR1cm4gYSBub2RlTGlua0ZuIGJhc2VkIG9uIHRoZVxuICogbm9kZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufG51bGx9XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZU5vZGUobm9kZSwgb3B0aW9ucykge1xuICB2YXIgdHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gIGlmICh0eXBlID09PSAxICYmIG5vZGUudGFnTmFtZSAhPT0gJ1NDUklQVCcpIHtcbiAgICByZXR1cm4gY29tcGlsZUVsZW1lbnQobm9kZSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gMyAmJiBub2RlLmRhdGEudHJpbSgpKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVUZXh0Tm9kZShub2RlLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlRWxlbWVudChlbCwgb3B0aW9ucykge1xuICAvLyBwcmVwcm9jZXNzIHRleHRhcmVhcy5cbiAgLy8gdGV4dGFyZWEgdHJlYXRzIGl0cyB0ZXh0IGNvbnRlbnQgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gIC8vIGp1c3QgYmluZCBpdCBhcyBhbiBhdHRyIGRpcmVjdGl2ZSBmb3IgdmFsdWUuXG4gIGlmIChlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgdmFyIHRva2VucyA9IHBhcnNlVGV4dChlbC52YWx1ZSk7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCc6dmFsdWUnLCB0b2tlbnNUb0V4cCh0b2tlbnMpKTtcbiAgICAgIGVsLnZhbHVlID0gJyc7XG4gICAgfVxuICB9XG4gIHZhciBsaW5rRm47XG4gIHZhciBoYXNBdHRycyA9IGVsLmhhc0F0dHJpYnV0ZXMoKTtcbiAgLy8gY2hlY2sgdGVybWluYWwgZGlyZWN0aXZlcyAoZm9yICYgaWYpXG4gIGlmIChoYXNBdHRycykge1xuICAgIGxpbmtGbiA9IGNoZWNrVGVybWluYWxEaXJlY3RpdmVzKGVsLCBvcHRpb25zKTtcbiAgfVxuICAvLyBjaGVjayBlbGVtZW50IGRpcmVjdGl2ZXNcbiAgaWYgKCFsaW5rRm4pIHtcbiAgICBsaW5rRm4gPSBjaGVja0VsZW1lbnREaXJlY3RpdmVzKGVsLCBvcHRpb25zKTtcbiAgfVxuICAvLyBjaGVjayBjb21wb25lbnRcbiAgaWYgKCFsaW5rRm4pIHtcbiAgICBsaW5rRm4gPSBjaGVja0NvbXBvbmVudChlbCwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgaWYgKCFsaW5rRm4gJiYgaGFzQXR0cnMpIHtcbiAgICBsaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhlbC5hdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbGlua0ZuO1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSB0ZXh0Tm9kZSBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge1RleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH0gdGV4dE5vZGVMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlVGV4dE5vZGUobm9kZSwgb3B0aW9ucykge1xuICAvLyBza2lwIG1hcmtlZCB0ZXh0IG5vZGVzXG4gIGlmIChub2RlLl9za2lwKSB7XG4gICAgcmV0dXJuIHJlbW92ZVRleHQ7XG4gIH1cblxuICB2YXIgdG9rZW5zID0gcGFyc2VUZXh0KG5vZGUud2hvbGVUZXh0KTtcbiAgaWYgKCF0b2tlbnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIG1hcmsgYWRqYWNlbnQgdGV4dCBub2RlcyBhcyBza2lwcGVkLFxuICAvLyBiZWNhdXNlIHdlIGFyZSB1c2luZyBub2RlLndob2xlVGV4dCB0byBjb21waWxlXG4gIC8vIGFsbCBhZGphY2VudCB0ZXh0IG5vZGVzIHRvZ2V0aGVyLiBUaGlzIGZpeGVzXG4gIC8vIGlzc3VlcyBpbiBJRSB3aGVyZSBzb21ldGltZXMgaXQgc3BsaXRzIHVwIGEgc2luZ2xlXG4gIC8vIHRleHQgbm9kZSBpbnRvIG11bHRpcGxlIG9uZXMuXG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSA9PT0gMykge1xuICAgIG5leHQuX3NraXAgPSB0cnVlO1xuICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICB9XG5cbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciBlbCwgdG9rZW47XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgIGVsID0gdG9rZW4udGFnID8gcHJvY2Vzc1RleHRUb2tlbih0b2tlbiwgb3B0aW9ucykgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0b2tlbi52YWx1ZSk7XG4gICAgZnJhZy5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbiAgcmV0dXJuIG1ha2VUZXh0Tm9kZUxpbmtGbih0b2tlbnMsIGZyYWcsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIExpbmtlciBmb3IgYW4gc2tpcHBlZCB0ZXh0IG5vZGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge1RleHR9IG5vZGVcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVUZXh0KHZtLCBub2RlKSB7XG4gIHJlbW92ZShub2RlKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgc2luZ2xlIHRleHQgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzVGV4dFRva2VuKHRva2VuLCBvcHRpb25zKSB7XG4gIHZhciBlbDtcbiAgaWYgKHRva2VuLm9uZVRpbWUpIHtcbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodG9rZW4uaHRtbCkge1xuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCd2LWh0bWwnKTtcbiAgICAgIHNldFRva2VuVHlwZSgnaHRtbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSB3aWxsIGNsZWFuIHVwIGVtcHR5IHRleHROb2RlcyBkdXJpbmdcbiAgICAgIC8vIGZyYWcuY2xvbmVOb2RlKHRydWUpLCBzbyB3ZSBoYXZlIHRvIGdpdmUgaXRcbiAgICAgIC8vIHNvbWV0aGluZyBoZXJlLi4uXG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJyk7XG4gICAgICBzZXRUb2tlblR5cGUoJ3RleHQnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0VG9rZW5UeXBlKHR5cGUpIHtcbiAgICBpZiAodG9rZW4uZGVzY3JpcHRvcikgcmV0dXJuO1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZSh0b2tlbi52YWx1ZSk7XG4gICAgdG9rZW4uZGVzY3JpcHRvciA9IHtcbiAgICAgIG5hbWU6IHR5cGUsXG4gICAgICBkZWY6IGRpcmVjdGl2ZXNbdHlwZV0sXG4gICAgICBleHByZXNzaW9uOiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICAgIGZpbHRlcnM6IHBhcnNlZC5maWx0ZXJzXG4gICAgfTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogQnVpbGQgYSBmdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyBhIHRleHROb2RlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gdG9rZW5zXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqL1xuXG5mdW5jdGlvbiBtYWtlVGV4dE5vZGVMaW5rRm4odG9rZW5zLCBmcmFnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0ZXh0Tm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlKSB7XG4gICAgdmFyIGZyYWdDbG9uZSA9IGZyYWcuY2xvbmVOb2RlKHRydWUpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShmcmFnQ2xvbmUuY2hpbGROb2Rlcyk7XG4gICAgdmFyIHRva2VuLCB2YWx1ZSwgbm9kZTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgIGlmICh0b2tlbi50YWcpIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmICh0b2tlbi5vbmVUaW1lKSB7XG4gICAgICAgICAgdmFsdWUgPSAoc2NvcGUgfHwgdm0pLiRldmFsKHZhbHVlKTtcbiAgICAgICAgICBpZiAodG9rZW4uaHRtbCkge1xuICAgICAgICAgICAgcmVwbGFjZShub2RlLCBwYXJzZVRlbXBsYXRlKHZhbHVlLCB0cnVlKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bS5fYmluZERpcih0b2tlbi5kZXNjcmlwdG9yLCBub2RlLCBob3N0LCBzY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShlbCwgZnJhZ0Nsb25lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgbm9kZSBsaXN0IGFuZCByZXR1cm4gYSBjaGlsZExpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge05vZGVMaXN0fSBub2RlTGlzdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlTm9kZUxpc3Qobm9kZUxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGxpbmtGbnMgPSBbXTtcbiAgdmFyIG5vZGVMaW5rRm4sIGNoaWxkTGlua0ZuLCBub2RlO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5vZGUgPSBub2RlTGlzdFtpXTtcbiAgICBub2RlTGlua0ZuID0gY29tcGlsZU5vZGUobm9kZSwgb3B0aW9ucyk7XG4gICAgY2hpbGRMaW5rRm4gPSAhKG5vZGVMaW5rRm4gJiYgbm9kZUxpbmtGbi50ZXJtaW5hbCkgJiYgbm9kZS50YWdOYW1lICE9PSAnU0NSSVBUJyAmJiBub2RlLmhhc0NoaWxkTm9kZXMoKSA/IGNvbXBpbGVOb2RlTGlzdChub2RlLmNoaWxkTm9kZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgICBsaW5rRm5zLnB1c2gobm9kZUxpbmtGbiwgY2hpbGRMaW5rRm4pO1xuICB9XG4gIHJldHVybiBsaW5rRm5zLmxlbmd0aCA/IG1ha2VDaGlsZExpbmtGbihsaW5rRm5zKSA6IG51bGw7XG59XG5cbi8qKlxuICogTWFrZSBhIGNoaWxkIGxpbmsgZnVuY3Rpb24gZm9yIGEgbm9kZSdzIGNoaWxkTm9kZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxGdW5jdGlvbj59IGxpbmtGbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBjaGlsZExpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VDaGlsZExpbmtGbihsaW5rRm5zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjaGlsZExpbmtGbih2bSwgbm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgdmFyIG5vZGUsIG5vZGVMaW5rRm4sIGNoaWxkcmVuTGlua0ZuO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gMCwgbCA9IGxpbmtGbnMubGVuZ3RoOyBpIDwgbDsgbisrKSB7XG4gICAgICBub2RlID0gbm9kZXNbbl07XG4gICAgICBub2RlTGlua0ZuID0gbGlua0Zuc1tpKytdO1xuICAgICAgY2hpbGRyZW5MaW5rRm4gPSBsaW5rRm5zW2krK107XG4gICAgICAvLyBjYWNoZSBjaGlsZE5vZGVzIGJlZm9yZSBsaW5raW5nIHBhcmVudCwgZml4ICM2NTdcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShub2RlLmNoaWxkTm9kZXMpO1xuICAgICAgaWYgKG5vZGVMaW5rRm4pIHtcbiAgICAgICAgbm9kZUxpbmtGbih2bSwgbm9kZSwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkcmVuTGlua0ZuKSB7XG4gICAgICAgIGNoaWxkcmVuTGlua0ZuKHZtLCBjaGlsZE5vZGVzLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGZvciBlbGVtZW50IGRpcmVjdGl2ZXMgKGN1c3RvbSBlbGVtZW50cyB0aGF0IHNob3VsZFxuICogYmUgcmVzb3ZsZWQgYXMgdGVybWluYWwgZGlyZWN0aXZlcykuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBjaGVja0VsZW1lbnREaXJlY3RpdmVzKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChjb21tb25UYWdSRS50ZXN0KHRhZykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZWxlbWVudERpcmVjdGl2ZXMnLCB0YWcpO1xuICBpZiAoZGVmKSB7XG4gICAgcmV0dXJuIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4oZWwsIHRhZywgJycsIG9wdGlvbnMsIGRlZik7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGEgY29tcG9uZW50LiBJZiB5ZXMsIHJldHVyblxuICogYSBjb21wb25lbnQgbGluayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50KGVsLCBvcHRpb25zKSB7XG4gIHZhciBjb21wb25lbnQgPSBjaGVja0NvbXBvbmVudEF0dHIoZWwsIG9wdGlvbnMpO1xuICBpZiAoY29tcG9uZW50KSB7XG4gICAgdmFyIHJlZiA9IGZpbmRSZWYoZWwpO1xuICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgbmFtZTogJ2NvbXBvbmVudCcsXG4gICAgICByZWY6IHJlZixcbiAgICAgIGV4cHJlc3Npb246IGNvbXBvbmVudC5pZCxcbiAgICAgIGRlZjogaW50ZXJuYWxEaXJlY3RpdmVzLmNvbXBvbmVudCxcbiAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICBsaXRlcmFsOiAhY29tcG9uZW50LmR5bmFtaWNcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjb21wb25lbnRMaW5rRm4gPSBmdW5jdGlvbiBjb21wb25lbnRMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSgoc2NvcGUgfHwgdm0pLiRyZWZzLCByZWYsIG51bGwpO1xuICAgICAgfVxuICAgICAgdm0uX2JpbmREaXIoZGVzY3JpcHRvciwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICB9O1xuICAgIGNvbXBvbmVudExpbmtGbi50ZXJtaW5hbCA9IHRydWU7XG4gICAgcmV0dXJuIGNvbXBvbmVudExpbmtGbjtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGFuIGVsZW1lbnQgZm9yIHRlcm1pbmFsIGRpcmVjdGl2ZXMgaW4gZml4ZWQgb3JkZXIuXG4gKiBJZiBpdCBmaW5kcyBvbmUsIHJldHVybiBhIHRlcm1pbmFsIGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNoZWNrVGVybWluYWxEaXJlY3RpdmVzKGVsLCBvcHRpb25zKSB7XG4gIC8vIHNraXAgdi1wcmVcbiAgaWYgKGdldEF0dHIoZWwsICd2LXByZScpICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNraXA7XG4gIH1cbiAgLy8gc2tpcCB2LWVsc2UgYmxvY2ssIGJ1dCBvbmx5IGlmIGZvbGxvd2luZyB2LWlmXG4gIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3YtZWxzZScpKSB7XG4gICAgdmFyIHByZXYgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIGlmIChwcmV2ICYmIHByZXYuaGFzQXR0cmlidXRlKCd2LWlmJykpIHtcbiAgICAgIHJldHVybiBza2lwO1xuICAgIH1cbiAgfVxuICB2YXIgdmFsdWUsIGRpck5hbWU7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdGVybWluYWxEaXJlY3RpdmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpck5hbWUgPSB0ZXJtaW5hbERpcmVjdGl2ZXNbaV07XG4gICAgdmFsdWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3YtJyArIGRpck5hbWUpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgZGlyTmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBza2lwKCkge31cbnNraXAudGVybWluYWwgPSB0cnVlO1xuXG4vKipcbiAqIEJ1aWxkIGEgbm9kZSBsaW5rIGZ1bmN0aW9uIGZvciBhIHRlcm1pbmFsIGRpcmVjdGl2ZS5cbiAqIEEgdGVybWluYWwgbGluayBmdW5jdGlvbiB0ZXJtaW5hdGVzIHRoZSBjdXJyZW50XG4gKiBjb21waWxhdGlvbiByZWN1cnNpb24gYW5kIGhhbmRsZXMgY29tcGlsYXRpb24gb2YgdGhlXG4gKiBzdWJ0cmVlIGluIHRoZSBkaXJlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGRpck5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGVmXVxuICogQHJldHVybiB7RnVuY3Rpb259IHRlcm1pbmFsTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgZGlyTmFtZSwgdmFsdWUsIG9wdGlvbnMsIGRlZikge1xuICB2YXIgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUodmFsdWUpO1xuICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICBuYW1lOiBkaXJOYW1lLFxuICAgIGV4cHJlc3Npb246IHBhcnNlZC5leHByZXNzaW9uLFxuICAgIGZpbHRlcnM6IHBhcnNlZC5maWx0ZXJzLFxuICAgIHJhdzogdmFsdWUsXG4gICAgLy8gZWl0aGVyIGFuIGVsZW1lbnQgZGlyZWN0aXZlLCBvciBpZi9mb3JcbiAgICAvLyAjMjM2NiBvciBjdXN0b20gdGVybWluYWwgZGlyZWN0aXZlXG4gICAgZGVmOiBkZWYgfHwgcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyTmFtZSlcbiAgfTtcbiAgLy8gY2hlY2sgcmVmIGZvciB2LWZvciBhbmQgcm91dGVyLXZpZXdcbiAgaWYgKGRpck5hbWUgPT09ICdmb3InIHx8IGRpck5hbWUgPT09ICdyb3V0ZXItdmlldycpIHtcbiAgICBkZXNjcmlwdG9yLnJlZiA9IGZpbmRSZWYoZWwpO1xuICB9XG4gIHZhciBmbiA9IGZ1bmN0aW9uIHRlcm1pbmFsTm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IucmVmKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSgoc2NvcGUgfHwgdm0pLiRyZWZzLCBkZXNjcmlwdG9yLnJlZiwgbnVsbCk7XG4gICAgfVxuICAgIHZtLl9iaW5kRGlyKGRlc2NyaXB0b3IsIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gIH07XG4gIGZuLnRlcm1pbmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIENvbXBpbGUgdGhlIGRpcmVjdGl2ZXMgb24gYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbGlua2VyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8TmFtZWROb2RlTWFwfSBhdHRyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVEaXJlY3RpdmVzKGF0dHJzLCBvcHRpb25zKSB7XG4gIHZhciBpID0gYXR0cnMubGVuZ3RoO1xuICB2YXIgZGlycyA9IFtdO1xuICB2YXIgYXR0ciwgbmFtZSwgdmFsdWUsIHJhd05hbWUsIHJhd1ZhbHVlLCBkaXJOYW1lLCBhcmcsIG1vZGlmaWVycywgZGlyRGVmLCB0b2tlbnMsIG1hdGNoZWQ7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgbmFtZSA9IHJhd05hbWUgPSBhdHRyLm5hbWU7XG4gICAgdmFsdWUgPSByYXdWYWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgdG9rZW5zID0gcGFyc2VUZXh0KHZhbHVlKTtcbiAgICAvLyByZXNldCBhcmdcbiAgICBhcmcgPSBudWxsO1xuICAgIC8vIGNoZWNrIG1vZGlmaWVyc1xuICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuXG4gICAgLy8gYXR0cmlidXRlIGludGVycG9sYXRpb25zXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgdmFsdWUgPSB0b2tlbnNUb0V4cCh0b2tlbnMpO1xuICAgICAgYXJnID0gbmFtZTtcbiAgICAgIHB1c2hEaXIoJ2JpbmQnLCBkaXJlY3RpdmVzLmJpbmQsIHRva2Vucyk7XG4gICAgICAvLyB3YXJuIGFnYWluc3QgbWl4aW5nIG11c3RhY2hlcyB3aXRoIHYtYmluZFxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdjbGFzcycgJiYgQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChhdHRycywgZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gYXR0ci5uYW1lID09PSAnOmNsYXNzJyB8fCBhdHRyLm5hbWUgPT09ICd2LWJpbmQ6Y2xhc3MnO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdhcm4oJ2NsYXNzPVwiJyArIHJhd1ZhbHVlICsgJ1wiOiBEbyBub3QgbWl4IG11c3RhY2hlIGludGVycG9sYXRpb24gJyArICdhbmQgdi1iaW5kIGZvciBcImNsYXNzXCIgb24gdGhlIHNhbWUgZWxlbWVudC4gVXNlIG9uZSBvciB0aGUgb3RoZXIuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2VcblxuICAgICAgLy8gc3BlY2lhbCBhdHRyaWJ1dGU6IHRyYW5zaXRpb25cbiAgICAgIGlmICh0cmFuc2l0aW9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICBtb2RpZmllcnMubGl0ZXJhbCA9ICFiaW5kUkUudGVzdChuYW1lKTtcbiAgICAgICAgcHVzaERpcigndHJhbnNpdGlvbicsIGludGVybmFsRGlyZWN0aXZlcy50cmFuc2l0aW9uKTtcbiAgICAgIH0gZWxzZVxuXG4gICAgICAgIC8vIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICBhcmcgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICAgIHB1c2hEaXIoJ29uJywgZGlyZWN0aXZlcy5vbik7XG4gICAgICAgIH0gZWxzZVxuXG4gICAgICAgICAgLy8gYXR0cmlidXRlIGJpbmRpbmdzXG4gICAgICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBkaXJOYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICAgICAgaWYgKGRpck5hbWUgPT09ICdzdHlsZScgfHwgZGlyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICBwdXNoRGlyKGRpck5hbWUsIGludGVybmFsRGlyZWN0aXZlc1tkaXJOYW1lXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhcmcgPSBkaXJOYW1lO1xuICAgICAgICAgICAgICBwdXNoRGlyKCdiaW5kJywgZGlyZWN0aXZlcy5iaW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcblxuICAgICAgICAgICAgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIGlmIChtYXRjaGVkID0gbmFtZS5tYXRjaChkaXJBdHRyUkUpKSB7XG4gICAgICAgICAgICAgIGRpck5hbWUgPSBtYXRjaGVkWzFdO1xuICAgICAgICAgICAgICBhcmcgPSBtYXRjaGVkWzJdO1xuXG4gICAgICAgICAgICAgIC8vIHNraXAgdi1lbHNlICh3aGVuIHVzZWQgd2l0aCB2LXNob3cpXG4gICAgICAgICAgICAgIGlmIChkaXJOYW1lID09PSAnZWxzZScpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRpckRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpck5hbWUpO1xuXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXNzZXQoZGlyRGVmLCAnZGlyZWN0aXZlJywgZGlyTmFtZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZGlyRGVmKSB7XG4gICAgICAgICAgICAgICAgcHVzaERpcihkaXJOYW1lLCBkaXJEZWYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVzaCBhIGRpcmVjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpck5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IGRlZlxuICAgKiBAcGFyYW0ge0FycmF5fSBbaW50ZXJwVG9rZW5zXVxuICAgKi9cblxuICBmdW5jdGlvbiBwdXNoRGlyKGRpck5hbWUsIGRlZiwgaW50ZXJwVG9rZW5zKSB7XG4gICAgdmFyIGhhc09uZVRpbWVUb2tlbiA9IGludGVycFRva2VucyAmJiBoYXNPbmVUaW1lKGludGVycFRva2Vucyk7XG4gICAgdmFyIHBhcnNlZCA9ICFoYXNPbmVUaW1lVG9rZW4gJiYgcGFyc2VEaXJlY3RpdmUodmFsdWUpO1xuICAgIGRpcnMucHVzaCh7XG4gICAgICBuYW1lOiBkaXJOYW1lLFxuICAgICAgYXR0cjogcmF3TmFtZSxcbiAgICAgIHJhdzogcmF3VmFsdWUsXG4gICAgICBkZWY6IGRlZixcbiAgICAgIGFyZzogYXJnLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICAvLyBjb252ZXJzaW9uIGZyb20gaW50ZXJwb2xhdGlvbiBzdHJpbmdzIHdpdGggb25lLXRpbWUgdG9rZW5cbiAgICAgIC8vIHRvIGV4cHJlc3Npb24gaXMgZGlmZmVyZWQgdW50aWwgZGlyZWN0aXZlIGJpbmQgdGltZSBzbyB0aGF0IHdlXG4gICAgICAvLyBoYXZlIGFjY2VzcyB0byB0aGUgYWN0dWFsIHZtIGNvbnRleHQgZm9yIG9uZS10aW1lIGJpbmRpbmdzLlxuICAgICAgZXhwcmVzc2lvbjogcGFyc2VkICYmIHBhcnNlZC5leHByZXNzaW9uLFxuICAgICAgZmlsdGVyczogcGFyc2VkICYmIHBhcnNlZC5maWx0ZXJzLFxuICAgICAgaW50ZXJwOiBpbnRlcnBUb2tlbnMsXG4gICAgICBoYXNPbmVUaW1lOiBoYXNPbmVUaW1lVG9rZW5cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChkaXJzLmxlbmd0aCkge1xuICAgIHJldHVybiBtYWtlTm9kZUxpbmtGbihkaXJzKTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIG1vZGlmaWVycyBmcm9tIGRpcmVjdGl2ZSBhdHRyaWJ1dGUgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzKG5hbWUpIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBpID0gbWF0Y2gubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHJlc1ttYXRjaFtpXS5zbGljZSgxKV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgbGluayBmdW5jdGlvbiBmb3IgYWxsIGRpcmVjdGl2ZXMgb24gYSBzaW5nbGUgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJlY3RpdmVzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gZGlyZWN0aXZlc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VOb2RlTGlua0ZuKGRpcmVjdGl2ZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIC8vIHJldmVyc2UgYXBwbHkgYmVjYXVzZSBpdCdzIHNvcnRlZCBsb3cgdG8gaGlnaFxuICAgIHZhciBpID0gZGlyZWN0aXZlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX2JpbmREaXIoZGlyZWN0aXZlc1tpXSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gaW50ZXJwb2xhdGlvbiBzdHJpbmcgY29udGFpbnMgb25lLXRpbWUgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHRva2Vuc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXNPbmVUaW1lKHRva2Vucykge1xuICB2YXIgaSA9IHRva2Vucy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAodG9rZW5zW2ldLm9uZVRpbWUpIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciBzcGVjaWFsQ2hhclJFID0gL1teXFx3XFwtOlxcLl0vO1xuXG4vKipcbiAqIFByb2Nlc3MgYW4gZWxlbWVudCBvciBhIERvY3VtZW50RnJhZ21lbnQgYmFzZWQgb24gYVxuICogaW5zdGFuY2Ugb3B0aW9uIG9iamVjdC4gVGhpcyBhbGxvd3MgdXMgdG8gdHJhbnNjbHVkZVxuICogYSB0ZW1wbGF0ZSBub2RlL2ZyYWdtZW50IGJlZm9yZSB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCxcbiAqIHNvIHRoZSBwcm9jZXNzZWQgZnJhZ21lbnQgY2FuIHRoZW4gYmUgY2xvbmVkIGFuZCByZXVzZWRcbiAqIGluIHYtZm9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gdHJhbnNjbHVkZShlbCwgb3B0aW9ucykge1xuICAvLyBleHRyYWN0IGNvbnRhaW5lciBhdHRyaWJ1dGVzIHRvIHBhc3MgdGhlbSBkb3duXG4gIC8vIHRvIGNvbXBpbGVyLCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSBjb21waWxlZCBpblxuICAvLyBwYXJlbnQgc2NvcGUuIHdlIGFyZSBtdXRhdGluZyB0aGUgb3B0aW9ucyBvYmplY3QgaGVyZVxuICAvLyBhc3N1bWluZyB0aGUgc2FtZSBvYmplY3Qgd2lsbCBiZSB1c2VkIGZvciBjb21waWxlXG4gIC8vIHJpZ2h0IGFmdGVyIHRoaXMuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5fY29udGFpbmVyQXR0cnMgPSBleHRyYWN0QXR0cnMoZWwpO1xuICB9XG4gIC8vIGZvciB0ZW1wbGF0ZSB0YWdzLCB3aGF0IHdlIHdhbnQgaXMgaXRzIGNvbnRlbnQgYXNcbiAgLy8gYSBkb2N1bWVudEZyYWdtZW50IChmb3IgZnJhZ21lbnQgaW5zdGFuY2VzKVxuICBpZiAoaXNUZW1wbGF0ZShlbCkpIHtcbiAgICBlbCA9IHBhcnNlVGVtcGxhdGUoZWwpO1xuICB9XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50ICYmICFvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICBvcHRpb25zLnRlbXBsYXRlID0gJzxzbG90Pjwvc2xvdD4nO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgICAgb3B0aW9ucy5fY29udGVudCA9IGV4dHJhY3RDb250ZW50KGVsKTtcbiAgICAgIGVsID0gdHJhbnNjbHVkZVRlbXBsYXRlKGVsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRnJhZ21lbnQoZWwpKSB7XG4gICAgLy8gYW5jaG9ycyBmb3IgZnJhZ21lbnQgaW5zdGFuY2VcbiAgICAvLyBwYXNzaW5nIGluIGBwZXJzaXN0OiB0cnVlYCB0byBhdm9pZCB0aGVtIGJlaW5nXG4gICAgLy8gZGlzY2FyZGVkIGJ5IElFIGR1cmluZyB0ZW1wbGF0ZSBjbG9uaW5nXG4gICAgcHJlcGVuZChjcmVhdGVBbmNob3IoJ3Ytc3RhcnQnLCB0cnVlKSwgZWwpO1xuICAgIGVsLmFwcGVuZENoaWxkKGNyZWF0ZUFuY2hvcigndi1lbmQnLCB0cnVlKSk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlIG9wdGlvbi5cbiAqIElmIHRoZSByZXBsYWNlIG9wdGlvbiBpcyB0cnVlIHRoaXMgd2lsbCBzd2FwIHRoZSAkZWwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2NsdWRlVGVtcGxhdGUoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgdmFyIGZyYWcgPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0cnVlKTtcbiAgaWYgKGZyYWcpIHtcbiAgICB2YXIgcmVwbGFjZXIgPSBmcmFnLmZpcnN0Q2hpbGQ7XG4gICAgdmFyIHRhZyA9IHJlcGxhY2VyLnRhZ05hbWUgJiYgcmVwbGFjZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignWW91IGFyZSBtb3VudGluZyBhbiBpbnN0YW5jZSB3aXRoIGEgdGVtcGxhdGUgdG8gJyArICc8Ym9keT4uIFRoaXMgd2lsbCByZXBsYWNlIDxib2R5PiBlbnRpcmVseS4gWW91ICcgKyAnc2hvdWxkIHByb2JhYmx5IHVzZSBgcmVwbGFjZTogZmFsc2VgIGhlcmUuJyk7XG4gICAgICB9XG4gICAgICAvLyB0aGVyZSBhcmUgbWFueSBjYXNlcyB3aGVyZSB0aGUgaW5zdGFuY2UgbXVzdFxuICAgICAgLy8gYmVjb21lIGEgZnJhZ21lbnQgaW5zdGFuY2U6IGJhc2ljYWxseSBhbnl0aGluZyB0aGF0XG4gICAgICAvLyBjYW4gY3JlYXRlIG1vcmUgdGhhbiAxIHJvb3Qgbm9kZXMuXG4gICAgICBpZiAoXG4gICAgICAvLyBtdWx0aS1jaGlsZHJlbiB0ZW1wbGF0ZVxuICAgICAgZnJhZy5jaGlsZE5vZGVzLmxlbmd0aCA+IDEgfHxcbiAgICAgIC8vIG5vbi1lbGVtZW50IHRlbXBsYXRlXG4gICAgICByZXBsYWNlci5ub2RlVHlwZSAhPT0gMSB8fFxuICAgICAgLy8gc2luZ2xlIG5lc3RlZCBjb21wb25lbnRcbiAgICAgIHRhZyA9PT0gJ2NvbXBvbmVudCcgfHwgcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSB8fCBoYXNCaW5kQXR0cihyZXBsYWNlciwgJ2lzJykgfHxcbiAgICAgIC8vIGVsZW1lbnQgZGlyZWN0aXZlXG4gICAgICByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2VsZW1lbnREaXJlY3RpdmVzJywgdGFnKSB8fFxuICAgICAgLy8gZm9yIGJsb2NrXG4gICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtZm9yJykgfHxcbiAgICAgIC8vIGlmIGJsb2NrXG4gICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuX3JlcGxhY2VyQXR0cnMgPSBleHRyYWN0QXR0cnMocmVwbGFjZXIpO1xuICAgICAgICBtZXJnZUF0dHJzKGVsLCByZXBsYWNlcik7XG4gICAgICAgIHJldHVybiByZXBsYWNlcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246ICcgKyB0ZW1wbGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZXh0cmFjdCBhIGNvbXBvbmVudCBjb250YWluZXIncyBhdHRyaWJ1dGVzXG4gKiBpbnRvIGEgcGxhaW4gb2JqZWN0IGFycmF5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RBdHRycyhlbCkge1xuICBpZiAoZWwubm9kZVR5cGUgPT09IDEgJiYgZWwuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoZWwuYXR0cmlidXRlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0aGUgYXR0cmlidXRlcyBvZiB0d28gZWxlbWVudHMsIGFuZCBtYWtlIHN1cmVcbiAqIHRoZSBjbGFzcyBuYW1lcyBhcmUgbWVyZ2VkIHByb3Blcmx5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZnJvbVxuICogQHBhcmFtIHtFbGVtZW50fSB0b1xuICovXG5cbmZ1bmN0aW9uIG1lcmdlQXR0cnMoZnJvbSwgdG8pIHtcbiAgdmFyIGF0dHJzID0gZnJvbS5hdHRyaWJ1dGVzO1xuICB2YXIgaSA9IGF0dHJzLmxlbmd0aDtcbiAgdmFyIG5hbWUsIHZhbHVlO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgdmFsdWUgPSBhdHRyc1tpXS52YWx1ZTtcbiAgICBpZiAoIXRvLmhhc0F0dHJpYnV0ZShuYW1lKSAmJiAhc3BlY2lhbENoYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICB0by5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsYXNzJyAmJiAhcGFyc2VUZXh0KHZhbHVlKSkge1xuICAgICAgdmFsdWUudHJpbSgpLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICAgIGFkZENsYXNzKHRvLCBjbHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2NhbiBhbmQgZGV0ZXJtaW5lIHNsb3QgY29udGVudCBkaXN0cmlidXRpb24uXG4gKiBXZSBkbyB0aGlzIGR1cmluZyB0cmFuc2NsdXNpb24gaW5zdGVhZCBhdCBjb21waWxlIHRpbWUgc28gdGhhdFxuICogdGhlIGRpc3RyaWJ1dGlvbiBpcyBkZWNvdXBsZWQgZnJvbSB0aGUgY29tcGlsYXRpb24gb3JkZXIgb2ZcbiAqIHRoZSBzbG90cy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGVudFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzKHZtLCBjb250ZW50KSB7XG4gIGlmICghY29udGVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY29udGVudHMgPSB2bS5fc2xvdENvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGVsLCBuYW1lO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRlbnQuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZWwgPSBjb250ZW50LmNoaWxkcmVuW2ldO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaWYgKG5hbWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSkge1xuICAgICAgKGNvbnRlbnRzW25hbWVdIHx8IChjb250ZW50c1tuYW1lXSA9IFtdKSkucHVzaChlbCk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgfVxuICBmb3IgKG5hbWUgaW4gY29udGVudHMpIHtcbiAgICBjb250ZW50c1tuYW1lXSA9IGV4dHJhY3RGcmFnbWVudChjb250ZW50c1tuYW1lXSwgY29udGVudCk7XG4gIH1cbiAgaWYgKGNvbnRlbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgY29udGVudHNbJ2RlZmF1bHQnXSA9IGV4dHJhY3RGcmFnbWVudChjb250ZW50LmNoaWxkTm9kZXMsIGNvbnRlbnQpO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBxdWFsaWZpZWQgY29udGVudCBub2RlcyBmcm9tIGEgbm9kZSBsaXN0LlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVzXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RGcmFnbWVudChub2RlcywgcGFyZW50KSB7XG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBub2RlcyA9IHRvQXJyYXkobm9kZXMpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKGlzVGVtcGxhdGUobm9kZSkgJiYgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWlmJykgJiYgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWZvcicpKSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICBub2RlID0gcGFyc2VUZW1wbGF0ZShub2RlKTtcbiAgICB9XG4gICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgfVxuICByZXR1cm4gZnJhZztcbn1cblxuXG5cbnZhciBjb21waWxlciA9IE9iamVjdC5mcmVlemUoe1xuXHRjb21waWxlOiBjb21waWxlLFxuXHRjb21waWxlQW5kTGlua1Byb3BzOiBjb21waWxlQW5kTGlua1Byb3BzLFxuXHRjb21waWxlUm9vdDogY29tcGlsZVJvb3QsXG5cdHRlcm1pbmFsRGlyZWN0aXZlczogdGVybWluYWxEaXJlY3RpdmVzLFxuXHR0cmFuc2NsdWRlOiB0cmFuc2NsdWRlLFxuXHRyZXNvbHZlU2xvdHM6IHJlc29sdmVTbG90c1xufSk7XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogQWNjZXNzb3IgZm9yIGAkZGF0YWAgcHJvcGVydHksIHNpbmNlIHNldHRpbmcgJGRhdGFcbiAgICogcmVxdWlyZXMgb2JzZXJ2aW5nIHRoZSBuZXcgb2JqZWN0IGFuZCB1cGRhdGluZ1xuICAgKiBwcm94aWVkIHByb3BlcnRpZXMuXG4gICAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0RhdGEpIHtcbiAgICAgIGlmIChuZXdEYXRhICE9PSB0aGlzLl9kYXRhKSB7XG4gICAgICAgIHRoaXMuX3NldERhdGEobmV3RGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogU2V0dXAgdGhlIHNjb3BlIG9mIGFuIGluc3RhbmNlLCB3aGljaCBjb250YWluczpcbiAgICogLSBvYnNlcnZlZCBkYXRhXG4gICAqIC0gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgKiAtIHVzZXIgbWV0aG9kc1xuICAgKiAtIG1ldGEgcHJvcGVydGllc1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5pdFByb3BzKCk7XG4gICAgdGhpcy5faW5pdE1ldGEoKTtcbiAgICB0aGlzLl9pbml0TWV0aG9kcygpO1xuICAgIHRoaXMuX2luaXREYXRhKCk7XG4gICAgdGhpcy5faW5pdENvbXB1dGVkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgcHJvcHMuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgdmFyIGVsID0gb3B0aW9ucy5lbDtcbiAgICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICAgIGlmIChwcm9wcyAmJiAhZWwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignUHJvcHMgd2lsbCBub3QgYmUgY29tcGlsZWQgaWYgbm8gYGVsYCBvcHRpb24gaXMgJyArICdwcm92aWRlZCBhdCBpbnN0YW50aWF0aW9uLicpO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgdG8gY29udmVydCBzdHJpbmcgc2VsZWN0b3JzIGludG8gZWxlbWVudCBub3dcbiAgICBlbCA9IG9wdGlvbnMuZWwgPSBxdWVyeShlbCk7XG4gICAgdGhpcy5fcHJvcHNVbmxpbmtGbiA9IGVsICYmIGVsLm5vZGVUeXBlID09PSAxICYmIHByb3BzXG4gICAgLy8gcHJvcHMgbXVzdCBiZSBsaW5rZWQgaW4gcHJvcGVyIHNjb3BlIGlmIGluc2lkZSB2LWZvclxuICAgID8gY29tcGlsZUFuZExpbmtQcm9wcyh0aGlzLCBlbCwgcHJvcHMsIHRoaXMuX3Njb3BlKSA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGRhdGEuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhRm4gPSB0aGlzLiRvcHRpb25zLmRhdGE7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhID0gZGF0YUZuID8gZGF0YUZuKCkgOiB7fTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9wcm9wcztcbiAgICB2YXIgcnVudGltZURhdGEgPSB0aGlzLl9ydW50aW1lRGF0YSA/IHR5cGVvZiB0aGlzLl9ydW50aW1lRGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuX3J1bnRpbWVEYXRhKCkgOiB0aGlzLl9ydW50aW1lRGF0YSA6IG51bGw7XG4gICAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgdmFyIGksIGtleTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vIHRoZXJlIGFyZSB0d28gc2NlbmFyaW9zIHdoZXJlIHdlIGNhbiBwcm94eSBhIGRhdGEga2V5OlxuICAgICAgLy8gMS4gaXQncyBub3QgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcFxuICAgICAgLy8gMi4gaXQncyBwcm92aWRlZCB2aWEgYSBpbnN0YW50aWF0aW9uIG9wdGlvbiBBTkQgdGhlcmUgYXJlIG5vXG4gICAgICAvLyAgICB0ZW1wbGF0ZSBwcm9wIHByZXNlbnRcbiAgICAgIGlmICghcHJvcHMgfHwgIWhhc093bihwcm9wcywga2V5KSB8fCBydW50aW1lRGF0YSAmJiBoYXNPd24ocnVudGltZURhdGEsIGtleSkgJiYgcHJvcHNba2V5XS5yYXcgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcHJveHkoa2V5KTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdEYXRhIGZpZWxkIFwiJyArIGtleSArICdcIiBpcyBhbHJlYWR5IGRlZmluZWQgJyArICdhcyBhIHByb3AuIFVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb2JzZXJ2ZSBkYXRhXG4gICAgb2JzZXJ2ZShkYXRhLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogU3dhcCB0aGUgaW5zdGFuY2UncyAkZGF0YS4gQ2FsbGVkIGluICRkYXRhJ3Mgc2V0dGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbmV3RGF0YVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9zZXREYXRhID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICBuZXdEYXRhID0gbmV3RGF0YSB8fCB7fTtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdGhpcy5fZGF0YSA9IG5ld0RhdGE7XG4gICAgdmFyIGtleXMsIGtleSwgaTtcbiAgICAvLyB1bnByb3h5IGtleXMgbm90IHByZXNlbnQgaW4gbmV3IGRhdGFcbiAgICBrZXlzID0gT2JqZWN0LmtleXMob2xkRGF0YSk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIShrZXkgaW4gbmV3RGF0YSkpIHtcbiAgICAgICAgdGhpcy5fdW5wcm94eShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwcm94eSBrZXlzIG5vdCBhbHJlYWR5IHByb3hpZWQsXG4gICAgLy8gYW5kIHRyaWdnZXIgY2hhbmdlIGZvciBjaGFuZ2VkIHZhbHVlc1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhuZXdEYXRhKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghaGFzT3duKHRoaXMsIGtleSkpIHtcbiAgICAgICAgLy8gbmV3IHByb3BlcnR5XG4gICAgICAgIHRoaXMuX3Byb3h5KGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIG9sZERhdGEuX19vYl9fLnJlbW92ZVZtKHRoaXMpO1xuICAgIG9ic2VydmUobmV3RGF0YSwgdGhpcyk7XG4gICAgdGhpcy5fZGlnZXN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3h5IGEgcHJvcGVydHksIHNvIHRoYXRcbiAgICogdm0ucHJvcCA9PT0gdm0uX2RhdGEucHJvcFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3Byb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAvLyBuZWVkIHRvIHN0b3JlIHJlZiB0byBzZWxmIGhlcmVcbiAgICAgIC8vIGJlY2F1c2UgdGhlc2UgZ2V0dGVyL3NldHRlcnMgbWlnaHRcbiAgICAgIC8vIGJlIGNhbGxlZCBieSBjaGlsZCBzY29wZXMgdmlhXG4gICAgICAvLyBwcm90b3R5cGUgaW5oZXJpdGFuY2UuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBwcm94eUdldHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fZGF0YVtrZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHByb3h5U2V0dGVyKHZhbCkge1xuICAgICAgICAgIHNlbGYuX2RhdGFba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVbnByb3h5IGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fdW5wcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmNlIHVwZGF0ZSBvbiBldmVyeSB3YXRjaGVyIGluIHNjb3BlLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl93YXRjaGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuX3dhdGNoZXJzW2ldLnVwZGF0ZSh0cnVlKTsgLy8gc2hhbGxvdyB1cGRhdGVzXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXR1cCBjb21wdXRlZCBwcm9wZXJ0aWVzLiBUaGV5IGFyZSBlc3NlbnRpYWxseVxuICAgKiBzcGVjaWFsIGdldHRlci9zZXR0ZXJzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICBWdWUucHJvdG90eXBlLl9pbml0Q29tcHV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gdGhpcy4kb3B0aW9ucy5jb21wdXRlZDtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgICAgIHZhciBkZWYgPSB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmLmdldCA9IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLCB0aGlzKTtcbiAgICAgICAgICBkZWYuc2V0ID0gbm9vcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWYuZ2V0ID0gdXNlckRlZi5nZXQgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZSA/IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLmdldCwgdGhpcykgOiBiaW5kKHVzZXJEZWYuZ2V0LCB0aGlzKSA6IG5vb3A7XG4gICAgICAgICAgZGVmLnNldCA9IHVzZXJEZWYuc2V0ID8gYmluZCh1c2VyRGVmLnNldCwgdGhpcykgOiBub29wO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIGRlZik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VDb21wdXRlZEdldHRlcihnZXR0ZXIsIG93bmVyKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihvd25lciwgZ2V0dGVyLCBudWxsLCB7XG4gICAgICBsYXp5OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyKCkge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgaW5zdGFuY2UgbWV0aG9kcy4gTWV0aG9kcyBtdXN0IGJlIGJvdW5kIHRvIHRoZVxuICAgKiBpbnN0YW5jZSBzaW5jZSB0aGV5IG1pZ2h0IGJlIHBhc3NlZCBkb3duIGFzIGEgcHJvcCB0b1xuICAgKiBjaGlsZCBjb21wb25lbnRzLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0TWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWV0aG9kcyA9IHRoaXMuJG9wdGlvbnMubWV0aG9kcztcbiAgICBpZiAobWV0aG9kcykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgICAgdGhpc1trZXldID0gYmluZChtZXRob2RzW2tleV0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBtZXRhIGluZm9ybWF0aW9uIGxpa2UgJGluZGV4LCAka2V5ICYgJHZhbHVlLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0TWV0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWV0YXMgPSB0aGlzLiRvcHRpb25zLl9tZXRhO1xuICAgIGlmIChtZXRhcykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG1ldGFzKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHRoaXMsIGtleSwgbWV0YXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgZXZlbnRSRSA9IC9edi1vbjp8XkAvO1xuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBTZXR1cCB0aGUgaW5zdGFuY2UncyBvcHRpb24gZXZlbnRzICYgd2F0Y2hlcnMuXG4gICAqIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgd2UgcHVsbCBpdCBmcm9tIHRoZVxuICAgKiBpbnN0YW5jZSdzIG1ldGhvZHMgYnkgbmFtZS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgICByZWdpc3RlckNvbXBvbmVudEV2ZW50cyh0aGlzLCBvcHRpb25zLmVsKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJDYWxsYmFja3ModGhpcywgJyRvbicsIG9wdGlvbnMuZXZlbnRzKTtcbiAgICByZWdpc3RlckNhbGxiYWNrcyh0aGlzLCAnJHdhdGNoJywgb3B0aW9ucy53YXRjaCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHYtb24gZXZlbnRzIG9uIGEgY2hpbGQgY29tcG9uZW50XG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50RXZlbnRzKHZtLCBlbCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJpYnV0ZXM7XG4gICAgdmFyIG5hbWUsIGhhbmRsZXI7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgaWYgKGV2ZW50UkUudGVzdChuYW1lKSkge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGV2ZW50UkUsICcnKTtcbiAgICAgICAgaGFuZGxlciA9ICh2bS5fc2NvcGUgfHwgdm0uX2NvbnRleHQpLiRldmFsKGF0dHJzW2ldLnZhbHVlLCB0cnVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaGFuZGxlci5fZnJvbVBhcmVudCA9IHRydWU7XG4gICAgICAgICAgdm0uJG9uKG5hbWUucmVwbGFjZShldmVudFJFKSwgaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ3Ytb246JyArIG5hbWUgKyAnPVwiJyArIGF0dHJzW2ldLnZhbHVlICsgJ1wiJyArICh2bS4kb3B0aW9ucy5uYW1lID8gJyBvbiBjb21wb25lbnQgPCcgKyB2bS4kb3B0aW9ucy5uYW1lICsgJz4nIDogJycpICsgJyBleHBlY3RzIGEgZnVuY3Rpb24gdmFsdWUsIGdvdCAnICsgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgY2FsbGJhY2tzIGZvciBvcHRpb24gZXZlbnRzIGFuZCB3YXRjaGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGhhc2hcbiAgICovXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJDYWxsYmFja3Modm0sIGFjdGlvbiwgaGFzaCkge1xuICAgIGlmICghaGFzaCkgcmV0dXJuO1xuICAgIHZhciBoYW5kbGVycywga2V5LCBpLCBqO1xuICAgIGZvciAoa2V5IGluIGhhc2gpIHtcbiAgICAgIGhhbmRsZXJzID0gaGFzaFtrZXldO1xuICAgICAgaWYgKGlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVycyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byByZWdpc3RlciBhbiBldmVudC93YXRjaCBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ3xPYmplY3R9IGhhbmRsZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cblxuICBmdW5jdGlvbiByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBoYW5kbGVyO1xuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2bVthY3Rpb25dKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICAgICAgdmFyIG1ldGhvZCA9IG1ldGhvZHMgJiYgbWV0aG9kc1toYW5kbGVyXTtcbiAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgdm1bYWN0aW9uXShrZXksIG1ldGhvZCwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1Vua25vd24gbWV0aG9kOiBcIicgKyBoYW5kbGVyICsgJ1wiIHdoZW4gJyArICdyZWdpc3RlcmluZyBjYWxsYmFjayBmb3IgJyArIGFjdGlvbiArICc6IFwiJyArIGtleSArICdcIi4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgJiYgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlci5oYW5kbGVyLCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgcmVjdXJzaXZlIGF0dGFjaGVkL2RldGFjaGVkIGNhbGxzXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRET01Ib29rcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRvbignaG9vazphdHRhY2hlZCcsIG9uQXR0YWNoZWQpO1xuICAgIHRoaXMuJG9uKCdob29rOmRldGFjaGVkJywgb25EZXRhY2hlZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgYXR0YWNoZWQgaG9vayBvbiBjaGlsZHJlblxuICAgKi9cblxuICBmdW5jdGlvbiBvbkF0dGFjaGVkKCkge1xuICAgIGlmICghdGhpcy5faXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNhbGxBdHRhY2gpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRvciB0byBjYWxsIGF0dGFjaGVkIGhvb2tcbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNhbGxBdHRhY2goY2hpbGQpIHtcbiAgICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkICYmIGluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICAgIGNoaWxkLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gcmVjdXJzaXZlbHkgY2FsbCBkZXRhY2hlZCBob29rIG9uIGNoaWxkcmVuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uRGV0YWNoZWQoKSB7XG4gICAgaWYgKHRoaXMuX2lzQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2FsbERldGFjaCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdG9yIHRvIGNhbGwgZGV0YWNoZWQgaG9va1xuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAgICovXG5cbiAgZnVuY3Rpb24gY2FsbERldGFjaChjaGlsZCkge1xuICAgIGlmIChjaGlsZC5faXNBdHRhY2hlZCAmJiAhaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgICAgY2hpbGQuX2NhbGxIb29rKCdkZXRhY2hlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFsbCBoYW5kbGVycyBmb3IgYSBob29rXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBob29rXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2NhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgICB0aGlzLiRlbWl0KCdwcmUtaG9vazonICsgaG9vayk7XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy4kb3B0aW9uc1tob29rXTtcbiAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSBsaW5rcyBhIERPTSBlbGVtZW50IHdpdGggYSBwaWVjZSBvZiBkYXRhLFxuICogd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIGFuIGV4cHJlc3Npb24uXG4gKiBJdCByZWdpc3RlcnMgYSB3YXRjaGVyIHdpdGggdGhlIGV4cHJlc3Npb24gYW5kIGNhbGxzXG4gKiB0aGUgRE9NIHVwZGF0ZSBmdW5jdGlvbiB3aGVuIGEgY2hhbmdlIGlzIHRyaWdnZXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtOb2RlfSBlbFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvclxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gbmFtZVxuICogICAgICAgICAgICAgICAgIC0ge09iamVjdH0gZGVmXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBleHByZXNzaW9uXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXk8T2JqZWN0Pn0gW2ZpbHRlcnNdXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gbGl0ZXJhbFxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gYXR0clxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gcmF3XG4gKiBAcGFyYW0ge09iamVjdH0gZGVmIC0gZGlyZWN0aXZlIGRlZmluaXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdIC0gdHJhbnNjbHVzaW9uIGhvc3QgY29tcG9uZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ10gLSBvd25lciBmcmFnbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERpcmVjdGl2ZShkZXNjcmlwdG9yLCB2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdGhpcy5lbCA9IGVsO1xuICAvLyBjb3B5IGRlc2NyaXB0b3IgcHJvcGVydGllc1xuICB0aGlzLmRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yO1xuICB0aGlzLm5hbWUgPSBkZXNjcmlwdG9yLm5hbWU7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IGRlc2NyaXB0b3IuZXhwcmVzc2lvbjtcbiAgdGhpcy5hcmcgPSBkZXNjcmlwdG9yLmFyZztcbiAgdGhpcy5tb2RpZmllcnMgPSBkZXNjcmlwdG9yLm1vZGlmaWVycztcbiAgdGhpcy5maWx0ZXJzID0gZGVzY3JpcHRvci5maWx0ZXJzO1xuICB0aGlzLmxpdGVyYWwgPSB0aGlzLm1vZGlmaWVycyAmJiB0aGlzLm1vZGlmaWVycy5saXRlcmFsO1xuICAvLyBwcml2YXRlXG4gIHRoaXMuX2xvY2tlZCA9IGZhbHNlO1xuICB0aGlzLl9ib3VuZCA9IGZhbHNlO1xuICB0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xuICAvLyBsaW5rIGNvbnRleHRcbiAgdGhpcy5faG9zdCA9IGhvc3Q7XG4gIHRoaXMuX3Njb3BlID0gc2NvcGU7XG4gIHRoaXMuX2ZyYWcgPSBmcmFnO1xuICAvLyBzdG9yZSBkaXJlY3RpdmVzIG9uIG5vZGUgaW4gZGV2IG1vZGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy5lbCkge1xuICAgIHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzID0gdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMgfHwgW107XG4gICAgdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMucHVzaCh0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGRpcmVjdGl2ZSwgbWl4aW4gZGVmaW5pdGlvbiBwcm9wZXJ0aWVzLFxuICogc2V0dXAgdGhlIHdhdGNoZXIsIGNhbGwgZGVmaW5pdGlvbiBiaW5kKCkgYW5kIHVwZGF0ZSgpXG4gKiBpZiBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZcbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl9iaW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgdmFyIGRlc2NyaXB0b3IgPSB0aGlzLmRlc2NyaXB0b3I7XG5cbiAgLy8gcmVtb3ZlIGF0dHJpYnV0ZVxuICBpZiAoKG5hbWUgIT09ICdjbG9haycgfHwgdGhpcy52bS5faXNDb21waWxlZCkgJiYgdGhpcy5lbCAmJiB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSkge1xuICAgIHZhciBhdHRyID0gZGVzY3JpcHRvci5hdHRyIHx8ICd2LScgKyBuYW1lO1xuICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICB9XG5cbiAgLy8gY29weSBkZWYgcHJvcGVydGllc1xuICB2YXIgZGVmID0gZGVzY3JpcHRvci5kZWY7XG4gIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy51cGRhdGUgPSBkZWY7XG4gIH0gZWxzZSB7XG4gICAgZXh0ZW5kKHRoaXMsIGRlZik7XG4gIH1cblxuICAvLyBzZXR1cCBkaXJlY3RpdmUgcGFyYW1zXG4gIHRoaXMuX3NldHVwUGFyYW1zKCk7XG5cbiAgLy8gaW5pdGlhbCBiaW5kXG4gIGlmICh0aGlzLmJpbmQpIHtcbiAgICB0aGlzLmJpbmQoKTtcbiAgfVxuICB0aGlzLl9ib3VuZCA9IHRydWU7XG5cbiAgaWYgKHRoaXMubGl0ZXJhbCkge1xuICAgIHRoaXMudXBkYXRlICYmIHRoaXMudXBkYXRlKGRlc2NyaXB0b3IucmF3KTtcbiAgfSBlbHNlIGlmICgodGhpcy5leHByZXNzaW9uIHx8IHRoaXMubW9kaWZpZXJzKSAmJiAodGhpcy51cGRhdGUgfHwgdGhpcy50d29XYXkpICYmICF0aGlzLl9jaGVja1N0YXRlbWVudCgpKSB7XG4gICAgLy8gd3JhcHBlZCB1cGRhdGVyIGZvciBjb250ZXh0XG4gICAgdmFyIGRpciA9IHRoaXM7XG4gICAgaWYgKHRoaXMudXBkYXRlKSB7XG4gICAgICB0aGlzLl91cGRhdGUgPSBmdW5jdGlvbiAodmFsLCBvbGRWYWwpIHtcbiAgICAgICAgaWYgKCFkaXIuX2xvY2tlZCkge1xuICAgICAgICAgIGRpci51cGRhdGUodmFsLCBvbGRWYWwpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGUgPSBub29wO1xuICAgIH1cbiAgICB2YXIgcHJlUHJvY2VzcyA9IHRoaXMuX3ByZVByb2Nlc3MgPyBiaW5kKHRoaXMuX3ByZVByb2Nlc3MsIHRoaXMpIDogbnVsbDtcbiAgICB2YXIgcG9zdFByb2Nlc3MgPSB0aGlzLl9wb3N0UHJvY2VzcyA/IGJpbmQodGhpcy5fcG9zdFByb2Nlc3MsIHRoaXMpIDogbnVsbDtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih0aGlzLnZtLCB0aGlzLmV4cHJlc3Npb24sIHRoaXMuX3VwZGF0ZSwgLy8gY2FsbGJhY2tcbiAgICB7XG4gICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICB0d29XYXk6IHRoaXMudHdvV2F5LFxuICAgICAgZGVlcDogdGhpcy5kZWVwLFxuICAgICAgcHJlUHJvY2VzczogcHJlUHJvY2VzcyxcbiAgICAgIHBvc3RQcm9jZXNzOiBwb3N0UHJvY2VzcyxcbiAgICAgIHNjb3BlOiB0aGlzLl9zY29wZVxuICAgIH0pO1xuICAgIC8vIHYtbW9kZWwgd2l0aCBpbml0YWwgaW5saW5lIHZhbHVlIG5lZWQgdG8gc3luYyBiYWNrIHRvXG4gICAgLy8gbW9kZWwgaW5zdGVhZCBvZiB1cGRhdGUgdG8gRE9NIG9uIGluaXQuIFRoZXkgd291bGRcbiAgICAvLyBzZXQgdGhlIGFmdGVyQmluZCBob29rIHRvIGluZGljYXRlIHRoYXQuXG4gICAgaWYgKHRoaXMuYWZ0ZXJCaW5kKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlKHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXR1cCBhbGwgcGFyYW0gYXR0cmlidXRlcywgZS5nLiB0cmFjay1ieSxcbiAqIHRyYW5zaXRpb24tbW9kZSwgZXRjLi4uXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fc2V0dXBQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5wYXJhbXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAvLyBzd2FwIHRoZSBwYXJhbXMgYXJyYXkgd2l0aCBhIGZyZXNoIG9iamVjdC5cbiAgdGhpcy5wYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgaSA9IHBhcmFtcy5sZW5ndGg7XG4gIHZhciBrZXksIHZhbCwgbWFwcGVkS2V5O1xuICB3aGlsZSAoaS0tKSB7XG4gICAga2V5ID0gcGFyYW1zW2ldO1xuICAgIG1hcHBlZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgdmFsID0gZ2V0QmluZEF0dHIodGhpcy5lbCwga2V5KTtcbiAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgIC8vIGR5bmFtaWNcbiAgICAgIHRoaXMuX3NldHVwUGFyYW1XYXRjaGVyKG1hcHBlZEtleSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RhdGljXG4gICAgICB2YWwgPSBnZXRBdHRyKHRoaXMuZWwsIGtleSk7XG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5wYXJhbXNbbWFwcGVkS2V5XSA9IHZhbCA9PT0gJycgPyB0cnVlIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXR1cCBhIHdhdGNoZXIgZm9yIGEgZHluYW1pYyBwYXJhbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3NldHVwUGFyYW1XYXRjaGVyID0gZnVuY3Rpb24gKGtleSwgZXhwcmVzc2lvbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgdmFyIHVud2F0Y2ggPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHdhdGNoKGV4cHJlc3Npb24sIGZ1bmN0aW9uICh2YWwsIG9sZFZhbCkge1xuICAgIHNlbGYucGFyYW1zW2tleV0gPSB2YWw7XG4gICAgLy8gc2luY2Ugd2UgYXJlIGluIGltbWVkaWF0ZSBtb2RlLFxuICAgIC8vIG9ubHkgY2FsbCB0aGUgcGFyYW0gY2hhbmdlIGNhbGxiYWNrcyBpZiB0aGlzIGlzIG5vdCB0aGUgZmlyc3QgdXBkYXRlLlxuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHZhciBjYiA9IHNlbGYucGFyYW1XYXRjaGVycyAmJiBzZWxmLnBhcmFtV2F0Y2hlcnNba2V5XTtcbiAgICAgIGlmIChjYikge1xuICAgICAgICBjYi5jYWxsKHNlbGYsIHZhbCwgb2xkVmFsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgdXNlcjogZmFsc2VcbiAgfSk7KHRoaXMuX3BhcmFtVW53YXRjaEZucyB8fCAodGhpcy5fcGFyYW1VbndhdGNoRm5zID0gW10pKS5wdXNoKHVud2F0Y2gpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZGlyZWN0aXZlIGlzIGEgZnVuY3Rpb24gY2FsbGVyXG4gKiBhbmQgaWYgdGhlIGV4cHJlc3Npb24gaXMgYSBjYWxsYWJsZSBvbmUuIElmIGJvdGggdHJ1ZSxcbiAqIHdlIHdyYXAgdXAgdGhlIGV4cHJlc3Npb24gYW5kIHVzZSBpdCBhcyB0aGUgZXZlbnRcbiAqIGhhbmRsZXIuXG4gKlxuICogZS5nLiBvbi1jbGljaz1cImErK1wiXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl9jaGVja1N0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb247XG4gIGlmIChleHByZXNzaW9uICYmIHRoaXMuYWNjZXB0U3RhdGVtZW50ICYmICFpc1NpbXBsZVBhdGgoZXhwcmVzc2lvbikpIHtcbiAgICB2YXIgZm4gPSBwYXJzZUV4cHJlc3Npb24oZXhwcmVzc2lvbikuZ2V0O1xuICAgIHZhciBzY29wZSA9IHRoaXMuX3Njb3BlIHx8IHRoaXMudm07XG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcbiAgICAgIHNjb3BlLiRldmVudCA9IGU7XG4gICAgICBmbi5jYWxsKHNjb3BlLCBzY29wZSk7XG4gICAgICBzY29wZS4kZXZlbnQgPSBudWxsO1xuICAgIH07XG4gICAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgICAgaGFuZGxlciA9IHNjb3BlLl9hcHBseUZpbHRlcnMoaGFuZGxlciwgbnVsbCwgdGhpcy5maWx0ZXJzKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGUoaGFuZGxlcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHdpdGggdGhlIHNldHRlci5cbiAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiB0d28td2F5IGRpcmVjdGl2ZXNcbiAqIGUuZy4gdi1tb2RlbC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcHVibGljXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMudHdvV2F5KSB7XG4gICAgdGhpcy5fd2l0aExvY2soZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fd2F0Y2hlci5zZXQodmFsdWUpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKCdEaXJlY3RpdmUuc2V0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdHdvV2F5JyArICdkaXJlY3RpdmVzLicpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBmdW5jdGlvbiB3aGlsZSBwcmV2ZW50aW5nIHRoYXQgZnVuY3Rpb24gZnJvbVxuICogdHJpZ2dlcmluZyB1cGRhdGVzIG9uIHRoaXMgZGlyZWN0aXZlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fd2l0aExvY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLl9sb2NrZWQgPSB0cnVlO1xuICBmbi5jYWxsKHNlbGYpO1xuICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fbG9ja2VkID0gZmFsc2U7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdHRhY2hlcyBhIERPTSBldmVudCBsaXN0ZW5lclxuICogdG8gdGhlIGRpcmVjdGl2ZSBlbGVtZW50IGFuZCBhdXRvbWV0aWNhbGx5IHRlYXJzIGl0IGRvd25cbiAqIGR1cmluZyB1bmJpbmQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXVxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgb24odGhpcy5lbCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpOyh0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IFtdKSkucHVzaChbZXZlbnQsIGhhbmRsZXJdKTtcbn07XG5cbi8qKlxuICogVGVhcmRvd24gdGhlIHdhdGNoZXIgYW5kIGNhbGwgdW5iaW5kLlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3RlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fYm91bmQpIHtcbiAgICB0aGlzLl9ib3VuZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnVuYmluZCkge1xuICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dhdGNoZXIpIHtcbiAgICAgIHRoaXMuX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICB2YXIgaTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICBpID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgb2ZmKHRoaXMuZWwsIGxpc3RlbmVyc1tpXVswXSwgbGlzdGVuZXJzW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVud2F0Y2hGbnMgPSB0aGlzLl9wYXJhbVVud2F0Y2hGbnM7XG4gICAgaWYgKHVud2F0Y2hGbnMpIHtcbiAgICAgIGkgPSB1bndhdGNoRm5zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdW53YXRjaEZuc1tpXSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsKSB7XG4gICAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcy4kcmVtb3ZlKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnZtID0gdGhpcy5lbCA9IHRoaXMuX3dhdGNoZXIgPSB0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xuICB9XG59O1xuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBVcGRhdGUgdi1yZWYgZm9yIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlUmVmID0gZnVuY3Rpb24gKHJlbW92ZSkge1xuICAgIHZhciByZWYgPSB0aGlzLiRvcHRpb25zLl9yZWY7XG4gICAgaWYgKHJlZikge1xuICAgICAgdmFyIHJlZnMgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy5fY29udGV4dCkuJHJlZnM7XG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGlmIChyZWZzW3JlZl0gPT09IHRoaXMpIHtcbiAgICAgICAgICByZWZzW3JlZl0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZzW3JlZl0gPSB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVHJhbnNjbHVkZSwgY29tcGlsZSBhbmQgbGluayBlbGVtZW50LlxuICAgKlxuICAgKiBJZiBhIHByZS1jb21waWxlZCBsaW5rZXIgaXMgYXZhaWxhYmxlLCB0aGF0IG1lYW5zIHRoZVxuICAgKiBwYXNzZWQgaW4gZWxlbWVudCB3aWxsIGJlIHByZS10cmFuc2NsdWRlZCBhbmQgY29tcGlsZWRcbiAgICogYXMgd2VsbCAtIGFsbCB3ZSBuZWVkIHRvIGRvIGlzIHRvIGNhbGwgdGhlIGxpbmtlci5cbiAgICpcbiAgICogT3RoZXJ3aXNlIHdlIG5lZWQgdG8gY2FsbCB0cmFuc2NsdWRlL2NvbXBpbGUvbGluayBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG5cbiAgICAvLyB0cmFuc2NsdWRlIGFuZCBpbml0IGVsZW1lbnRcbiAgICAvLyB0cmFuc2NsdWRlIGNhbiBwb3RlbnRpYWxseSByZXBsYWNlIG9yaWdpbmFsXG4gICAgLy8gc28gd2UgbmVlZCB0byBrZWVwIHJlZmVyZW5jZTsgdGhpcyBzdGVwIGFsc28gaW5qZWN0c1xuICAgIC8vIHRoZSB0ZW1wbGF0ZSBhbmQgY2FjaGVzIHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gICAgLy8gb24gdGhlIGNvbnRhaW5lciBub2RlIGFuZCByZXBsYWNlciBub2RlLlxuICAgIHZhciBvcmlnaW5hbCA9IGVsO1xuICAgIGVsID0gdHJhbnNjbHVkZShlbCwgb3B0aW9ucyk7XG4gICAgdGhpcy5faW5pdEVsZW1lbnQoZWwpO1xuXG4gICAgLy8gaGFuZGxlIHYtcHJlIG9uIHJvb3Qgbm9kZSAoIzIwMjYpXG4gICAgaWYgKGVsLm5vZGVUeXBlID09PSAxICYmIGdldEF0dHIoZWwsICd2LXByZScpICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcm9vdCBpcyBhbHdheXMgY29tcGlsZWQgcGVyLWluc3RhbmNlLCBiZWNhdXNlXG4gICAgLy8gY29udGFpbmVyIGF0dHJzIGFuZCBwcm9wcyBjYW4gYmUgZGlmZmVyZW50IGV2ZXJ5IHRpbWUuXG4gICAgdmFyIGNvbnRleHRPcHRpb25zID0gdGhpcy5fY29udGV4dCAmJiB0aGlzLl9jb250ZXh0LiRvcHRpb25zO1xuICAgIHZhciByb290TGlua2VyID0gY29tcGlsZVJvb3QoZWwsIG9wdGlvbnMsIGNvbnRleHRPcHRpb25zKTtcblxuICAgIC8vIHJlc29sdmUgc2xvdCBkaXN0cmlidXRpb25cbiAgICByZXNvbHZlU2xvdHModGhpcywgb3B0aW9ucy5fY29udGVudCk7XG5cbiAgICAvLyBjb21waWxlIGFuZCBsaW5rIHRoZSByZXN0XG4gICAgdmFyIGNvbnRlbnRMaW5rRm47XG4gICAgdmFyIGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNvbXBvbmVudCBjb21waWxhdGlvbiBjYW4gYmUgY2FjaGVkXG4gICAgLy8gYXMgbG9uZyBhcyBpdCdzIG5vdCB1c2luZyBpbmxpbmUtdGVtcGxhdGVcbiAgICBpZiAob3B0aW9ucy5fbGlua2VyQ2FjaGFibGUpIHtcbiAgICAgIGNvbnRlbnRMaW5rRm4gPSBjdG9yLmxpbmtlcjtcbiAgICAgIGlmICghY29udGVudExpbmtGbikge1xuICAgICAgICBjb250ZW50TGlua0ZuID0gY3Rvci5saW5rZXIgPSBjb21waWxlKGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBsaW5rIHBoYXNlXG4gICAgLy8gbWFrZSBzdXJlIHRvIGxpbmsgcm9vdCB3aXRoIHByb3Agc2NvcGUhXG4gICAgdmFyIHJvb3RVbmxpbmtGbiA9IHJvb3RMaW5rZXIodGhpcywgZWwsIHRoaXMuX3Njb3BlKTtcbiAgICB2YXIgY29udGVudFVubGlua0ZuID0gY29udGVudExpbmtGbiA/IGNvbnRlbnRMaW5rRm4odGhpcywgZWwpIDogY29tcGlsZShlbCwgb3B0aW9ucykodGhpcywgZWwpO1xuXG4gICAgLy8gcmVnaXN0ZXIgY29tcG9zaXRlIHVubGluayBmdW5jdGlvblxuICAgIC8vIHRvIGJlIGNhbGxlZCBkdXJpbmcgaW5zdGFuY2UgZGVzdHJ1Y3Rpb25cbiAgICB0aGlzLl91bmxpbmtGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJvb3RVbmxpbmtGbigpO1xuICAgICAgLy8gcGFzc2luZyBkZXN0cm95aW5nOiB0cnVlIHRvIGF2b2lkIHNlYXJjaGluZyBhbmRcbiAgICAgIC8vIHNwbGljaW5nIHRoZSBkaXJlY3RpdmVzXG4gICAgICBjb250ZW50VW5saW5rRm4odHJ1ZSk7XG4gICAgfTtcblxuICAgIC8vIGZpbmFsbHkgcmVwbGFjZSBvcmlnaW5hbFxuICAgIGlmIChvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgIHJlcGxhY2Uob3JpZ2luYWwsIGVsKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0NvbXBpbGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9jYWxsSG9vaygnY29tcGlsZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBpbnN0YW5jZSBlbGVtZW50LiBDYWxsZWQgaW4gdGhlIHB1YmxpY1xuICAgKiAkbW91bnQoKSBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoaXNGcmFnbWVudChlbCkpIHtcbiAgICAgIHRoaXMuX2lzRnJhZ21lbnQgPSB0cnVlO1xuICAgICAgdGhpcy4kZWwgPSB0aGlzLl9mcmFnbWVudFN0YXJ0ID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50RW5kID0gZWwubGFzdENoaWxkO1xuICAgICAgLy8gc2V0IHBlcnNpc3RlZCB0ZXh0IGFuY2hvcnMgdG8gZW1wdHlcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudFN0YXJ0Lm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIHRoaXMuX2ZyYWdtZW50U3RhcnQuZGF0YSA9IHRoaXMuX2ZyYWdtZW50RW5kLmRhdGEgPSAnJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZyYWdtZW50ID0gZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsID0gZWw7XG4gICAgfVxuICAgIHRoaXMuJGVsLl9fdnVlX18gPSB0aGlzO1xuICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVDb21waWxlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgYmluZCBhIGRpcmVjdGl2ZSB0byBhbiBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGRpcmVjdGl2ZSBuYW1lXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgIC0gdGFyZ2V0IG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2MgLSBwYXJzZWQgZGlyZWN0aXZlIGRlc2NyaXB0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZiAgLSBkaXJlY3RpdmUgZGVmaW5pdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIHRyYW5zY2x1c2lvbiBob3N0IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIG93bmVyIGZyYWdtZW50XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2JpbmREaXIgPSBmdW5jdGlvbiAoZGVzY3JpcHRvciwgbm9kZSwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB0aGlzLl9kaXJlY3RpdmVzLnB1c2gobmV3IERpcmVjdGl2ZShkZXNjcmlwdG9yLCB0aGlzLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZWFyZG93biBhbiBpbnN0YW5jZSwgdW5vYnNlcnZlcyB0aGUgZGF0YSwgdW5iaW5kIGFsbCB0aGVcbiAgICogZGlyZWN0aXZlcywgdHVybiBvZmYgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmUgLSB3aGV0aGVyIHRvIHJlbW92ZSB0aGUgRE9NIG5vZGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJDbGVhbnVwIC0gaWYgdHJ1ZSwgZGVmZXIgY2xlYW51cCB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGNhbGxlZCBsYXRlclxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZSwgZGVmZXJDbGVhbnVwKSB7XG4gICAgaWYgKHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghZGVmZXJDbGVhbnVwKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVzdHJveVJlYWR5O1xuICAgIHZhciBwZW5kaW5nUmVtb3ZhbDtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBDbGVhbnVwIHNob3VsZCBiZSBjYWxsZWQgZWl0aGVyIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3lzbHkgYXNcbiAgICAvLyBjYWxsYmFjayBvZiB0aGlzLiRyZW1vdmUoKSwgb3IgaWYgcmVtb3ZlIGFuZCBkZWZlckNsZWFudXAgYXJlIGZhbHNlLlxuICAgIC8vIEluIGFueSBjYXNlIGl0IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIG90aGVyIHJlbW92aW5nLCB1bmJpbmRpbmcgYW5kXG4gICAgLy8gdHVybmluZyBvZiBpcyBkb25lXG4gICAgdmFyIGNsZWFudXBJZlBvc3NpYmxlID0gZnVuY3Rpb24gY2xlYW51cElmUG9zc2libGUoKSB7XG4gICAgICBpZiAoZGVzdHJveVJlYWR5ICYmICFwZW5kaW5nUmVtb3ZhbCAmJiAhZGVmZXJDbGVhbnVwKSB7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlIERPTSBlbGVtZW50XG4gICAgaWYgKHJlbW92ZSAmJiB0aGlzLiRlbCkge1xuICAgICAgcGVuZGluZ1JlbW92YWwgPSB0cnVlO1xuICAgICAgdGhpcy4kcmVtb3ZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGVuZGluZ1JlbW92YWwgPSBmYWxzZTtcbiAgICAgICAgY2xlYW51cElmUG9zc2libGUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdGhpcy5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdmFyIGk7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnQuIG9ubHkgbmVjZXNzYXJ5XG4gICAgLy8gaWYgcGFyZW50IGlzIG5vdCBiZWluZyBkZXN0cm95ZWQgYXMgd2VsbC5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcGFyZW50LiRjaGlsZHJlbi4kcmVtb3ZlKHRoaXMpO1xuICAgICAgLy8gdW5yZWdpc3RlciByZWYgKHJlbW92ZTogdHJ1ZSlcbiAgICAgIHRoaXMuX3VwZGF0ZVJlZih0cnVlKTtcbiAgICB9XG4gICAgLy8gZGVzdHJveSBhbGwgY2hpbGRyZW4uXG4gICAgaSA9IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLiRjaGlsZHJlbltpXS4kZGVzdHJveSgpO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biBwcm9wc1xuICAgIGlmICh0aGlzLl9wcm9wc1VubGlua0ZuKSB7XG4gICAgICB0aGlzLl9wcm9wc1VubGlua0ZuKCk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIGFsbCBkaXJlY3RpdmVzLiB0aGlzIGFsc28gdGVhcnNkb3duIGFsbFxuICAgIC8vIGRpcmVjdGl2ZS1vd25lZCB3YXRjaGVycy5cbiAgICBpZiAodGhpcy5fdW5saW5rRm4pIHtcbiAgICAgIHRoaXMuX3VubGlua0ZuKCk7XG4gICAgfVxuICAgIGkgPSB0aGlzLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBzZWxmIG9uICRlbFxuICAgIGlmICh0aGlzLiRlbCkge1xuICAgICAgdGhpcy4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVzdHJveVJlYWR5ID0gdHJ1ZTtcbiAgICBjbGVhbnVwSWZQb3NzaWJsZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCB0byBlbnN1cmUgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgbGVhdmUgdHJhbnNpdGlvbiBpZiB0aGVyZVxuICAgKiBpcyBhbnkuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2lzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gb3duZXIgZnJhZ21lbnRcbiAgICAvLyBkbyBpdCBpbiBjbGVhbnVwIHNvIHRoYXQgd2UgY2FuIGNhbGwgJGRlc3Ryb3kgd2l0aFxuICAgIC8vIGRlZmVyIHJpZ2h0IHdoZW4gYSBmcmFnbWVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkLlxuICAgIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgICB0aGlzLl9mcmFnLmNoaWxkcmVuLiRyZW1vdmUodGhpcyk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHRoaXMuX2RhdGEuX19vYl9fKSB7XG4gICAgICB0aGlzLl9kYXRhLl9fb2JfXy5yZW1vdmVWbSh0aGlzKTtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgcmVmZXJlbmNlcyB0byBwcml2YXRlIHByb3BlcnRpZXMgYW5kIG90aGVyXG4gICAgLy8gaW5zdGFuY2VzLiBwcmVzZXJ2ZSByZWZlcmVuY2UgdG8gX2RhdGEgc28gdGhhdCBwcm94eVxuICAgIC8vIGFjY2Vzc29ycyBzdGlsbCB3b3JrLiBUaGUgb25seSBwb3RlbnRpYWwgc2lkZSBlZmZlY3RcbiAgICAvLyBoZXJlIGlzIHRoYXQgbXV0YXRpbmcgdGhlIGluc3RhbmNlIGFmdGVyIGl0J3MgZGVzdHJveWVkXG4gICAgLy8gbWF5IGFmZmVjdCB0aGUgc3RhdGUgb2Ygb3RoZXIgY29tcG9uZW50cyB0aGF0IGFyZSBzdGlsbFxuICAgIC8vIG9ic2VydmluZyB0aGUgc2FtZSBvYmplY3QsIGJ1dCB0aGF0IHNlZW1zIHRvIGJlIGFcbiAgICAvLyByZWFzb25hYmxlIHJlc3BvbnNpYmlsaXR5IGZvciB0aGUgdXNlciByYXRoZXIgdGhhblxuICAgIC8vIGFsd2F5cyB0aHJvd2luZyBhbiBlcnJvciBvbiB0aGVtLlxuICAgIHRoaXMuJGVsID0gdGhpcy4kcGFyZW50ID0gdGhpcy4kcm9vdCA9IHRoaXMuJGNoaWxkcmVuID0gdGhpcy5fd2F0Y2hlcnMgPSB0aGlzLl9jb250ZXh0ID0gdGhpcy5fc2NvcGUgPSB0aGlzLl9kaXJlY3RpdmVzID0gbnVsbDtcbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB0aGlzLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5fY2FsbEhvb2soJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdGhpcy4kb2ZmKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1pc2NNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBBcHBseSBhIGxpc3Qgb2YgZmlsdGVyIChkZXNjcmlwdG9ycykgdG8gYSB2YWx1ZS5cbiAgICogVXNpbmcgcGxhaW4gZm9yIGxvb3BzIGhlcmUgYmVjYXVzZSB0aGlzIHdpbGwgYmUgY2FsbGVkIGluXG4gICAqIHRoZSBnZXR0ZXIgb2YgYW55IHdhdGNoZXIgd2l0aCBmaWx0ZXJzIHNvIGl0IGlzIHZlcnlcbiAgICogcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gW29sZFZhbHVlXVxuICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gd3JpdGVcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fYXBwbHlGaWx0ZXJzID0gZnVuY3Rpb24gKHZhbHVlLCBvbGRWYWx1ZSwgZmlsdGVycywgd3JpdGUpIHtcbiAgICB2YXIgZmlsdGVyLCBmbiwgYXJncywgYXJnLCBvZmZzZXQsIGksIGwsIGosIGs7XG4gICAgZm9yIChpID0gMCwgbCA9IGZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuICAgICAgZm4gPSByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBmaWx0ZXIubmFtZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnRBc3NldChmbiwgJ2ZpbHRlcicsIGZpbHRlci5uYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICghZm4pIGNvbnRpbnVlO1xuICAgICAgZm4gPSB3cml0ZSA/IGZuLndyaXRlIDogZm4ucmVhZCB8fCBmbjtcbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIGNvbnRpbnVlO1xuICAgICAgYXJncyA9IHdyaXRlID8gW3ZhbHVlLCBvbGRWYWx1ZV0gOiBbdmFsdWVdO1xuICAgICAgb2Zmc2V0ID0gd3JpdGUgPyAyIDogMTtcbiAgICAgIGlmIChmaWx0ZXIuYXJncykge1xuICAgICAgICBmb3IgKGogPSAwLCBrID0gZmlsdGVyLmFyZ3MubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgYXJnID0gZmlsdGVyLmFyZ3Nbal07XG4gICAgICAgICAgYXJnc1tqICsgb2Zmc2V0XSA9IGFyZy5keW5hbWljID8gdGhpcy4kZ2V0KGFyZy52YWx1ZSkgOiBhcmcudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzb2x2ZSBhIGNvbXBvbmVudCwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGNvbXBvbmVudFxuICAgKiBpcyBkZWZpbmVkIG5vcm1hbGx5IG9yIHVzaW5nIGFuIGFzeW5jIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAqIFJlc29sdmVzIHN5bmNocm9ub3VzbHkgaWYgYWxyZWFkeSByZXNvbHZlZCwgb3RoZXJ3aXNlXG4gICAqIHJlc29sdmVzIGFzeW5jaHJvbm91c2x5IGFuZCBjYWNoZXMgdGhlIHJlc29sdmVkXG4gICAqIGNvbnN0cnVjdG9yIG9uIHRoZSBmYWN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fcmVzb2x2ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChpZCwgY2IpIHtcbiAgICB2YXIgZmFjdG9yeSA9IHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnY29tcG9uZW50cycsIGlkKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0QXNzZXQoZmFjdG9yeSwgJ2NvbXBvbmVudCcsIGlkKTtcbiAgICB9XG4gICAgaWYgKCFmYWN0b3J5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5XG4gICAgaWYgKCFmYWN0b3J5Lm9wdGlvbnMpIHtcbiAgICAgIGlmIChmYWN0b3J5LnJlc29sdmVkKSB7XG4gICAgICAgIC8vIGNhY2hlZFxuICAgICAgICBjYihmYWN0b3J5LnJlc29sdmVkKTtcbiAgICAgIH0gZWxzZSBpZiAoZmFjdG9yeS5yZXF1ZXN0ZWQpIHtcbiAgICAgICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICAgICAgZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeS5yZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgY2JzID0gZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzID0gW2NiXTtcbiAgICAgICAgZmFjdG9yeS5jYWxsKHRoaXMsIGZ1bmN0aW9uIHJlc29sdmUocmVzKSB7XG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QocmVzKSkge1xuICAgICAgICAgICAgcmVzID0gVnVlLmV4dGVuZChyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSByZXM7XG4gICAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrc1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY2JzW2ldKHJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6ICcgKyBpZCArICcuICcgKyAocmVhc29uID8gJ1xcblJlYXNvbjogJyArIHJlYXNvbiA6ICcnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgY29tcG9uZW50XG4gICAgICBjYihmYWN0b3J5KTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBmaWx0ZXJSRSQxID0gL1tefF1cXHxbXnxdLztcblxuZnVuY3Rpb24gZGF0YUFQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIGZyb20gYW4gZXhwcmVzc2lvbiBvbiB0aGlzIHZtLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzU3RhdGVtZW50XVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRnZXQgPSBmdW5jdGlvbiAoZXhwLCBhc1N0YXRlbWVudCkge1xuICAgIHZhciByZXMgPSBwYXJzZUV4cHJlc3Npb24oZXhwKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBpZiAoYXNTdGF0ZW1lbnQgJiYgIWlzU2ltcGxlUGF0aChleHApKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0YXRlbWVudEhhbmRsZXIoKSB7XG4gICAgICAgICAgc2VsZi4kYXJndW1lbnRzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZXMuZ2V0LmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICAgICAgc2VsZi4kYXJndW1lbnRzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVzLmdldC5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZSBmcm9tIGFuIGV4cHJlc3Npb24gb24gdGhpcyB2bS5cbiAgICogVGhlIGV4cHJlc3Npb24gbXVzdCBiZSBhIHZhbGlkIGxlZnQtaGFuZFxuICAgKiBleHByZXNzaW9uIGluIGFuIGFzc2lnbm1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAgICogQHBhcmFtIHsqfSB2YWxcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gZnVuY3Rpb24gKGV4cCwgdmFsKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRXhwcmVzc2lvbihleHAsIHRydWUpO1xuICAgIGlmIChyZXMgJiYgcmVzLnNldCkge1xuICAgICAgcmVzLnNldC5jYWxsKHRoaXMsIHRoaXMsIHZhbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBwcm9wZXJ0eSBvbiB0aGUgVk1cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVsKHRoaXMuX2RhdGEsIGtleSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhdGNoIGFuIGV4cHJlc3Npb24sIHRyaWdnZXIgY2FsbGJhY2sgd2hlbiBpdHNcbiAgICogdmFsdWUgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGV4cE9yRm5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZGVlcFxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gaW1tZWRpYXRlXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIHVud2F0Y2hGblxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChleHBPckZuLCBjYiwgb3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHBhcnNlZDtcbiAgICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZShleHBPckZuKTtcbiAgICAgIGV4cE9yRm4gPSBwYXJzZWQuZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIHtcbiAgICAgIGRlZXA6IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWVwLFxuICAgICAgc3luYzogb3B0aW9ucyAmJiBvcHRpb25zLnN5bmMsXG4gICAgICBmaWx0ZXJzOiBwYXJzZWQgJiYgcGFyc2VkLmZpbHRlcnMsXG4gICAgICB1c2VyOiAhb3B0aW9ucyB8fCBvcHRpb25zLnVzZXIgIT09IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIGEgdGV4dCBkaXJlY3RpdmUsIGluY2x1ZGluZyBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthc1N0YXRlbWVudF1cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRldmFsID0gZnVuY3Rpb24gKHRleHQsIGFzU3RhdGVtZW50KSB7XG4gICAgLy8gY2hlY2sgZm9yIGZpbHRlcnMuXG4gICAgaWYgKGZpbHRlclJFJDEudGVzdCh0ZXh0KSkge1xuICAgICAgdmFyIGRpciA9IHBhcnNlRGlyZWN0aXZlKHRleHQpO1xuICAgICAgLy8gdGhlIGZpbHRlciByZWdleCBjaGVjayBtaWdodCBnaXZlIGZhbHNlIHBvc2l0aXZlXG4gICAgICAvLyBmb3IgcGlwZXMgaW5zaWRlIHN0cmluZ3MsIHNvIGl0J3MgcG9zc2libGUgdGhhdFxuICAgICAgLy8gd2UgZG9uJ3QgZ2V0IGFueSBmaWx0ZXJzIGhlcmVcbiAgICAgIHZhciB2YWwgPSB0aGlzLiRnZXQoZGlyLmV4cHJlc3Npb24sIGFzU3RhdGVtZW50KTtcbiAgICAgIHJldHVybiBkaXIuZmlsdGVycyA/IHRoaXMuX2FwcGx5RmlsdGVycyh2YWwsIG51bGwsIGRpci5maWx0ZXJzKSA6IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gZmlsdGVyXG4gICAgICByZXR1cm4gdGhpcy4kZ2V0KHRleHQsIGFzU3RhdGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVycG9sYXRlIGEgcGllY2Ugb2YgdGVtcGxhdGUgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdmFyIHRva2VucyA9IHBhcnNlVGV4dCh0ZXh0KTtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB2bS4kZXZhbCh0b2tlbnNbMF0udmFsdWUpICsgJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW4udGFnID8gdm0uJGV2YWwodG9rZW4udmFsdWUpIDogdG9rZW4udmFsdWU7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExvZyBpbnN0YW5jZSBkYXRhIGFzIGEgcGxhaW4gSlMgb2JqZWN0XG4gICAqIHNvIHRoYXQgaXQgaXMgZWFzaWVyIHRvIGluc3BlY3QgaW4gY29uc29sZS5cbiAgICogVGhpcyBtZXRob2QgYXNzdW1lcyBjb25zb2xlIGlzIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRsb2cgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBkYXRhID0gcGF0aCA/IGdldFBhdGgodGhpcy5fZGF0YSwgcGF0aCkgOiB0aGlzLl9kYXRhO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBkYXRhID0gY2xlYW4oZGF0YSk7XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgY29tcHV0ZWQgZmllbGRzXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICB2YXIga2V5O1xuICAgICAgZm9yIChrZXkgaW4gdGhpcy4kb3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgICBkYXRhW2tleV0gPSBjbGVhbih0aGlzW2tleV0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Byb3BzKSB7XG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuX3Byb3BzKSB7XG4gICAgICAgICAgZGF0YVtrZXldID0gY2xlYW4odGhpc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogXCJjbGVhblwiIGEgZ2V0dGVyL3NldHRlciBjb252ZXJ0ZWQgb2JqZWN0IGludG8gYSBwbGFpblxuICAgKiBvYmplY3QgY29weS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IC0gb2JqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgZnVuY3Rpb24gY2xlYW4ob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZG9tQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG9uLWluc3RhbmNlIG5leHRUaWNrLiBUaGUgY2FsbGJhY2sgaXNcbiAgICogYXV0by1ib3VuZCB0byB0aGUgaW5zdGFuY2UsIGFuZCB0aGlzIGF2b2lkcyBjb21wb25lbnRcbiAgICogbW9kdWxlcyBoYXZpbmcgdG8gcmVseSBvbiB0aGUgZ2xvYmFsIFZ1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBuZXh0VGljayhmbiwgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBpbnN0YW5jZSB0byB0YXJnZXRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGFwcGVuZFRvID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluc2VydCh0aGlzLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgYXBwZW5kLCBhcHBlbmRXaXRoVHJhbnNpdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByZXBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRwcmVwZW5kVG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICB0YXJnZXQgPSBxdWVyeSh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICB0aGlzLiRiZWZvcmUodGFyZ2V0LmZpcnN0Q2hpbGQsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGFwcGVuZFRvKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc2VydCBpbnN0YW5jZSBiZWZvcmUgdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRiZWZvcmUgPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gaW5zZXJ0KHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLCBiZWZvcmVXaXRoQ2IsIGJlZm9yZVdpdGhUcmFuc2l0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0IGluc3RhbmNlIGFmdGVyIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kYWZ0ZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICB0YXJnZXQgPSBxdWVyeSh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXQubmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQubmV4dFNpYmxpbmcsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGFwcGVuZFRvKHRhcmdldC5wYXJlbnROb2RlLCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGluc3RhbmNlIGZyb20gRE9NXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRyZW1vdmUgPSBmdW5jdGlvbiAoY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgaWYgKCF0aGlzLiRlbC5wYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm4gY2IgJiYgY2IoKTtcbiAgICB9XG4gICAgdmFyIGluRG9jdW1lbnQgPSB0aGlzLl9pc0F0dGFjaGVkICYmIGluRG9jKHRoaXMuJGVsKTtcbiAgICAvLyBpZiB3ZSBhcmUgbm90IGluIGRvY3VtZW50LCBubyBuZWVkIHRvIGNoZWNrXG4gICAgLy8gZm9yIHRyYW5zaXRpb25zXG4gICAgaWYgKCFpbkRvY3VtZW50KSB3aXRoVHJhbnNpdGlvbiA9IGZhbHNlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVhbENiID0gZnVuY3Rpb24gcmVhbENiKCkge1xuICAgICAgaWYgKGluRG9jdW1lbnQpIHNlbGYuX2NhbGxIb29rKCdkZXRhY2hlZCcpO1xuICAgICAgaWYgKGNiKSBjYigpO1xuICAgIH07XG4gICAgaWYgKHRoaXMuX2lzRnJhZ21lbnQpIHtcbiAgICAgIHJlbW92ZU5vZGVSYW5nZSh0aGlzLl9mcmFnbWVudFN0YXJ0LCB0aGlzLl9mcmFnbWVudEVuZCwgdGhpcywgdGhpcy5fZnJhZ21lbnQsIHJlYWxDYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvcCA9IHdpdGhUcmFuc2l0aW9uID09PSBmYWxzZSA/IHJlbW92ZVdpdGhDYiA6IHJlbW92ZVdpdGhUcmFuc2l0aW9uO1xuICAgICAgb3AodGhpcy4kZWwsIHRoaXMsIHJlYWxDYik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaGFyZWQgRE9NIGluc2VydGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wMSAtIG9wIGZvciBub24tdHJhbnNpdGlvbiBpbnNlcnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3AyIC0gb3AgZm9yIHRyYW5zaXRpb24gaW5zZXJ0XG4gICAqIEByZXR1cm4gdm1cbiAgICovXG5cbiAgZnVuY3Rpb24gaW5zZXJ0KHZtLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgb3AxLCBvcDIpIHtcbiAgICB0YXJnZXQgPSBxdWVyeSh0YXJnZXQpO1xuICAgIHZhciB0YXJnZXRJc0RldGFjaGVkID0gIWluRG9jKHRhcmdldCk7XG4gICAgdmFyIG9wID0gd2l0aFRyYW5zaXRpb24gPT09IGZhbHNlIHx8IHRhcmdldElzRGV0YWNoZWQgPyBvcDEgOiBvcDI7XG4gICAgdmFyIHNob3VsZENhbGxIb29rID0gIXRhcmdldElzRGV0YWNoZWQgJiYgIXZtLl9pc0F0dGFjaGVkICYmICFpbkRvYyh2bS4kZWwpO1xuICAgIGlmICh2bS5faXNGcmFnbWVudCkge1xuICAgICAgbWFwTm9kZVJhbmdlKHZtLl9mcmFnbWVudFN0YXJ0LCB2bS5fZnJhZ21lbnRFbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG9wKG5vZGUsIHRhcmdldCwgdm0pO1xuICAgICAgfSk7XG4gICAgICBjYiAmJiBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcCh2bS4kZWwsIHRhcmdldCwgdm0sIGNiKTtcbiAgICB9XG4gICAgaWYgKHNob3VsZENhbGxIb29rKSB7XG4gICAgICB2bS5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB2bTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBmb3Igc2VsZWN0b3JzXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IGVsXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHF1ZXJ5KGVsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKSA6IGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBvcGVyYXRpb24gdGhhdCB0YWtlcyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFwcGVuZChlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRCZWZvcmUgb3BlcmF0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge1Z1ZX0gdm0gLSB1bnVzZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBmdW5jdGlvbiBiZWZvcmVXaXRoQ2IoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgb3BlcmF0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgKiBAcGFyYW0ge1Z1ZX0gdm0gLSB1bnVzZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVXaXRoQ2IoZWwsIHZtLCBjYikge1xuICAgIHJlbW92ZShlbCk7XG4gICAgaWYgKGNiKSBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50c0FQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgKHRoaXMuX2V2ZW50c1tldmVudF0gfHwgKHRoaXMuX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAgICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgc2VsZi4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHRoaXMuJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gICAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciBjYnM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy4kcGFyZW50KSB7XG4gICAgICAgIGZvciAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICBpZiAoY2JzKSB7XG4gICAgICAgICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtY2JzLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIGNicyA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgLWNicy5sZW5ndGgpO1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtMSk7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlciBhbiBldmVudCBvbiBzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHNob3VsZFByb3BhZ2F0ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGlzU291cmNlID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJztcbiAgICBldmVudCA9IGlzU291cmNlID8gZXZlbnQgOiBldmVudC5uYW1lO1xuICAgIHZhciBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgIHZhciBzaG91bGRQcm9wYWdhdGUgPSBpc1NvdXJjZSB8fCAhY2JzO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGhhY2t5IHNvbHV0aW9uIHRvIHRoZSBxdWVzdGlvbiByYWlzZWRcbiAgICAgIC8vIGluICMyMTAyOiBmb3IgYW4gaW5saW5lIGNvbXBvbmVudCBsaXN0ZW5lciBsaWtlIDxjb21wIEB0ZXN0PVwiZG9UaGlzXCI+LFxuICAgICAgLy8gdGhlIHByb3BhZ2F0aW9uIGhhbmRsaW5nIGlzIHNvbWV3aGF0IGJyb2tlbi4gVGhlcmVmb3JlIHdlXG4gICAgICAvLyBuZWVkIHRvIHRyZWF0IHRoZXNlIGlubGluZSBjYWxsYmFja3MgZGlmZmVyZW50bHkuXG4gICAgICB2YXIgaGFzUGFyZW50Q2JzID0gaXNTb3VyY2UgJiYgY2JzLnNvbWUoZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHJldHVybiBjYi5fZnJvbVBhcmVudDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc1BhcmVudENicykge1xuICAgICAgICBzaG91bGRQcm9wYWdhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjYiA9IGNic1tpXTtcbiAgICAgICAgdmFyIHJlcyA9IGNiLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBpZiAocmVzID09PSB0cnVlICYmICghaGFzUGFyZW50Q2JzIHx8IGNiLl9mcm9tUGFyZW50KSkge1xuICAgICAgICAgIHNob3VsZFByb3BhZ2F0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZFByb3BhZ2F0ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgYnJvYWRjYXN0IGFuIGV2ZW50IHRvIGFsbCBjaGlsZHJlbiBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXZlbnRcbiAgICogQHBhcmFtIHsuLi4qfSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRicm9hZGNhc3QgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgaXNTb3VyY2UgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnO1xuICAgIGV2ZW50ID0gaXNTb3VyY2UgPyBldmVudCA6IGV2ZW50Lm5hbWU7XG4gICAgLy8gaWYgbm8gY2hpbGQgaGFzIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnQsXG4gICAgLy8gdGhlbiB0aGVyZSdzIG5vIG5lZWQgdG8gYnJvYWRjYXN0LlxuICAgIGlmICghdGhpcy5fZXZlbnRzQ291bnRbZXZlbnRdKSByZXR1cm47XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kY2hpbGRyZW47XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgaWYgKGlzU291cmNlKSB7XG4gICAgICAvLyB1c2Ugb2JqZWN0IGV2ZW50IHRvIGluZGljYXRlIG5vbi1zb3VyY2UgZW1pdFxuICAgICAgLy8gb24gY2hpbGRyZW5cbiAgICAgIGFyZ3NbMF0gPSB7IG5hbWU6IGV2ZW50LCBzb3VyY2U6IHRoaXMgfTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIHNob3VsZFByb3BhZ2F0ZSA9IGNoaWxkLiRlbWl0LmFwcGx5KGNoaWxkLCBhcmdzKTtcbiAgICAgIGlmIChzaG91bGRQcm9wYWdhdGUpIHtcbiAgICAgICAgY2hpbGQuJGJyb2FkY2FzdC5hcHBseShjaGlsZCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBwcm9wYWdhdGUgYW4gZXZlbnQgdXAgdGhlIHBhcmVudCBjaGFpbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7Li4uKn0gYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZGlzcGF0Y2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgc2hvdWxkUHJvcGFnYXRlID0gdGhpcy4kZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghc2hvdWxkUHJvcGFnYXRlKSByZXR1cm47XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudDtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAvLyB1c2Ugb2JqZWN0IGV2ZW50IHRvIGluZGljYXRlIG5vbi1zb3VyY2UgZW1pdFxuICAgIC8vIG9uIHBhcmVudHNcbiAgICBhcmdzWzBdID0geyBuYW1lOiBldmVudCwgc291cmNlOiB0aGlzIH07XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgc2hvdWxkUHJvcGFnYXRlID0gcGFyZW50LiRlbWl0LmFwcGx5KHBhcmVudCwgYXJncyk7XG4gICAgICBwYXJlbnQgPSBzaG91bGRQcm9wYWdhdGUgPyBwYXJlbnQuJHBhcmVudCA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIGxpc3RlbmVyIGNvdW50cyBvbiBhbGwgcGFyZW50cy5cbiAgICogVGhpcyBib29ra2VlcGluZyBhbGxvd3MgJGJyb2FkY2FzdCB0byByZXR1cm4gZWFybHkgd2hlblxuICAgKiBubyBjaGlsZCBoYXMgbGlzdGVuZWQgdG8gYSBjZXJ0YWluIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICAgKi9cblxuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIGZ1bmN0aW9uIG1vZGlmeUxpc3RlbmVyQ291bnQodm0sIGV2ZW50LCBjb3VudCkge1xuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIC8vIGhvb2tzIGRvIG5vdCBnZXQgYnJvYWRjYXN0ZWQgc28gbm8gbmVlZFxuICAgIC8vIHRvIGRvIGJvb2trZWVwaW5nIGZvciB0aGVtXG4gICAgaWYgKCFwYXJlbnQgfHwgIWNvdW50IHx8IGhvb2tSRS50ZXN0KGV2ZW50KSkgcmV0dXJuO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5fZXZlbnRzQ291bnRbZXZlbnRdID0gKHBhcmVudC5fZXZlbnRzQ291bnRbZXZlbnRdIHx8IDApICsgY291bnQ7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIFNldCBpbnN0YW5jZSB0YXJnZXQgZWxlbWVudCBhbmQga2ljayBvZmYgdGhlIGNvbXBpbGF0aW9uXG4gICAqIHByb2Nlc3MuIFRoZSBwYXNzZWQgaW4gYGVsYCBjYW4gYmUgYSBzZWxlY3RvciBzdHJpbmcsIGFuXG4gICAqIGV4aXN0aW5nIEVsZW1lbnQsIG9yIGEgRG9jdW1lbnRGcmFnbWVudCAoZm9yIGJsb2NrXG4gICAqIGluc3RhbmNlcykuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fHN0cmluZ30gZWxcbiAgICogQHB1YmxpY1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICh0aGlzLl9pc0NvbXBpbGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJyRtb3VudCgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbCA9IHF1ZXJ5KGVsKTtcbiAgICBpZiAoIWVsKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH1cbiAgICB0aGlzLl9jb21waWxlKGVsKTtcbiAgICB0aGlzLl9pbml0RE9NSG9va3MoKTtcbiAgICBpZiAoaW5Eb2ModGhpcy4kZWwpKSB7XG4gICAgICB0aGlzLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgICAgIHJlYWR5LmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJG9uY2UoJ2hvb2s6YXR0YWNoZWQnLCByZWFkeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXJrIGFuIGluc3RhbmNlIGFzIHJlYWR5LlxuICAgKi9cblxuICBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9jYWxsSG9vaygncmVhZHknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWFyZG93biB0aGUgaW5zdGFuY2UsIHNpbXBseSBkZWxlZ2F0ZSB0byB0aGUgaW50ZXJuYWxcbiAgICogX2Rlc3Ryb3kuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAocmVtb3ZlLCBkZWZlckNsZWFudXApIHtcbiAgICB0aGlzLl9kZXN0cm95KHJlbW92ZSwgZGVmZXJDbGVhbnVwKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFydGlhbGx5IGNvbXBpbGUgYSBwaWVjZSBvZiBET00gYW5kIHJldHVybiBhXG4gICAqIGRlY29tcGlsZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gICAqIEBwYXJhbSB7VnVlfSBbaG9zdF1cbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGNvbXBpbGUgPSBmdW5jdGlvbiAoZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgcmV0dXJuIGNvbXBpbGUoZWwsIHRoaXMuJG9wdGlvbnMsIHRydWUpKHRoaXMsIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGV4cG9zZWQgVnVlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEFQSSBjb252ZW50aW9uczpcbiAqIC0gcHVibGljIEFQSSBtZXRob2RzL3Byb3BlcnRpZXMgYXJlIHByZWZpeGVkIHdpdGggYCRgXG4gKiAtIGludGVybmFsIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZml4ZWQgd2l0aCBgX2BcbiAqIC0gbm9uLXByZWZpeGVkIHByb3BlcnRpZXMgYXJlIGFzc3VtZWQgdG8gYmUgcHJveGllZCB1c2VyXG4gKiAgIGRhdGEuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gVnVlKG9wdGlvbnMpIHtcbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuLy8gaW5zdGFsbCBpbnRlcm5hbHNcbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5taXNjTWl4aW4oVnVlKTtcblxuLy8gaW5zdGFsbCBpbnN0YW5jZSBBUElzXG5kYXRhQVBJKFZ1ZSk7XG5kb21BUEkoVnVlKTtcbmV2ZW50c0FQSShWdWUpO1xubGlmZWN5Y2xlQVBJKFZ1ZSk7XG5cbnZhciBzbG90ID0ge1xuXG4gIHByaW9yaXR5OiBTTE9ULFxuICBwYXJhbXM6IFsnbmFtZSddLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gdGhpcyB3YXMgcmVzb2x2ZWQgZHVyaW5nIGNvbXBvbmVudCB0cmFuc2NsdXNpb25cbiAgICB2YXIgbmFtZSA9IHRoaXMucGFyYW1zLm5hbWUgfHwgJ2RlZmF1bHQnO1xuICAgIHZhciBjb250ZW50ID0gdGhpcy52bS5fc2xvdENvbnRlbnRzICYmIHRoaXMudm0uX3Nsb3RDb250ZW50c1tuYW1lXTtcbiAgICBpZiAoIWNvbnRlbnQgfHwgIWNvbnRlbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICB0aGlzLmZhbGxiYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tcGlsZShjb250ZW50LmNsb25lTm9kZSh0cnVlKSwgdGhpcy52bS5fY29udGV4dCwgdGhpcy52bSk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUoY29udGVudCwgY29udGV4dCwgaG9zdCkge1xuICAgIGlmIChjb250ZW50ICYmIGNvbnRleHQpIHtcbiAgICAgIGlmICh0aGlzLmVsLmhhc0NoaWxkTm9kZXMoKSAmJiBjb250ZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmIGNvbnRlbnQuY2hpbGROb2Rlc1swXS5ub2RlVHlwZSA9PT0gMSAmJiBjb250ZW50LmNoaWxkTm9kZXNbMF0uaGFzQXR0cmlidXRlKCd2LWlmJykpIHtcbiAgICAgICAgLy8gaWYgdGhlIGluc2VydGVkIHNsb3QgaGFzIHYtaWZcbiAgICAgICAgLy8gaW5qZWN0IGZhbGxiYWNrIGNvbnRlbnQgYXMgdGhlIHYtZWxzZVxuICAgICAgICB2YXIgZWxzZUJsb2NrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgZWxzZUJsb2NrLnNldEF0dHJpYnV0ZSgndi1lbHNlJywgJycpO1xuICAgICAgICBlbHNlQmxvY2suaW5uZXJIVE1MID0gdGhpcy5lbC5pbm5lckhUTUw7XG4gICAgICAgIC8vIHRoZSBlbHNlIGJsb2NrIHNob3VsZCBiZSBjb21waWxlZCBpbiBjaGlsZCBzY29wZVxuICAgICAgICBlbHNlQmxvY2suX2NvbnRleHQgPSB0aGlzLnZtO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsc2VCbG9jayk7XG4gICAgICB9XG4gICAgICB2YXIgc2NvcGUgPSBob3N0ID8gaG9zdC5fc2NvcGUgOiB0aGlzLl9zY29wZTtcbiAgICAgIHRoaXMudW5saW5rID0gY29udGV4dC4kY29tcGlsZShjb250ZW50LCBob3N0LCBzY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgfVxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICByZXBsYWNlKHRoaXMuZWwsIGNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUodGhpcy5lbCk7XG4gICAgfVxuICB9LFxuXG4gIGZhbGxiYWNrOiBmdW5jdGlvbiBmYWxsYmFjaygpIHtcbiAgICB0aGlzLmNvbXBpbGUoZXh0cmFjdENvbnRlbnQodGhpcy5lbCwgdHJ1ZSksIHRoaXMudm0pO1xuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLnVubGluaykge1xuICAgICAgdGhpcy51bmxpbmsoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwYXJ0aWFsID0ge1xuXG4gIHByaW9yaXR5OiBQQVJUSUFMLFxuXG4gIHBhcmFtczogWyduYW1lJ10sXG5cbiAgLy8gd2F0Y2ggY2hhbmdlcyB0byBuYW1lIGZvciBkeW5hbWljIHBhcnRpYWxzXG4gIHBhcmFtV2F0Y2hlcnM6IHtcbiAgICBuYW1lOiBmdW5jdGlvbiBuYW1lKHZhbHVlKSB7XG4gICAgICB2SWYucmVtb3ZlLmNhbGwodGhpcyk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnNlcnQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LXBhcnRpYWwnKTtcbiAgICByZXBsYWNlKHRoaXMuZWwsIHRoaXMuYW5jaG9yKTtcbiAgICB0aGlzLmluc2VydCh0aGlzLnBhcmFtcy5uYW1lKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydChpZCkge1xuICAgIHZhciBwYXJ0aWFsID0gcmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICdwYXJ0aWFscycsIGlkKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0QXNzZXQocGFydGlhbCwgJ3BhcnRpYWwnLCBpZCk7XG4gICAgfVxuICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIHBhcnRpYWwpO1xuICAgICAgdklmLmluc2VydC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICBpZiAodGhpcy5mcmFnKSB7XG4gICAgICB0aGlzLmZyYWcuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGVsZW1lbnREaXJlY3RpdmVzID0ge1xuICBzbG90OiBzbG90LFxuICBwYXJ0aWFsOiBwYXJ0aWFsXG59O1xuXG52YXIgY29udmVydEFycmF5ID0gdkZvci5fcG9zdFByb2Nlc3M7XG5cbi8qKlxuICogTGltaXQgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAoRGVjaW1hbCBleHBlY3RlZClcbiAqL1xuXG5mdW5jdGlvbiBsaW1pdEJ5KGFyciwgbiwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA/IHBhcnNlSW50KG9mZnNldCwgMTApIDogMDtcbiAgbiA9IHRvTnVtYmVyKG4pO1xuICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInID8gYXJyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbikgOiBhcnI7XG59XG5cbi8qKlxuICogRmlsdGVyIGZpbHRlciBmb3IgYXJyYXlzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFxuICogQHBhcmFtIHtTdHJpbmd9IFtkZWxpbWl0ZXJdXG4gKiBAcGFyYW0ge1N0cmluZ30gLi4uZGF0YUtleXNcbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXJCeShhcnIsIHNlYXJjaCwgZGVsaW1pdGVyKSB7XG4gIGFyciA9IGNvbnZlcnRBcnJheShhcnIpO1xuICBpZiAoc2VhcmNoID09IG51bGwpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VhcmNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoc2VhcmNoKTtcbiAgfVxuICAvLyBjYXN0IHRvIGxvd2VyY2FzZSBzdHJpbmdcbiAgc2VhcmNoID0gKCcnICsgc2VhcmNoKS50b0xvd2VyQ2FzZSgpO1xuICAvLyBhbGxvdyBvcHRpb25hbCBgaW5gIGRlbGltaXRlclxuICAvLyBiZWNhdXNlIHdoeSBub3RcbiAgdmFyIG4gPSBkZWxpbWl0ZXIgPT09ICdpbicgPyAzIDogMjtcbiAgLy8gZXh0cmFjdCBhbmQgZmxhdHRlbiBrZXlzXG4gIHZhciBrZXlzID0gdG9BcnJheShhcmd1bWVudHMsIG4pLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgcmV0dXJuIHByZXYuY29uY2F0KGN1cik7XG4gIH0sIFtdKTtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaXRlbSwga2V5LCB2YWwsIGo7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBhcnJbaV07XG4gICAgdmFsID0gaXRlbSAmJiBpdGVtLiR2YWx1ZSB8fCBpdGVtO1xuICAgIGogPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAoaikge1xuICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2pdO1xuICAgICAgICBpZiAoa2V5ID09PSAnJGtleScgJiYgY29udGFpbnMkMShpdGVtLiRrZXksIHNlYXJjaCkgfHwgY29udGFpbnMkMShnZXRQYXRoKHZhbCwga2V5KSwgc2VhcmNoKSkge1xuICAgICAgICAgIHJlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250YWlucyQxKGl0ZW0sIHNlYXJjaCkpIHtcbiAgICAgIHJlcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEZpbHRlciBmaWx0ZXIgZm9yIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzb3J0S2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gcmV2ZXJzZVxuICovXG5cbmZ1bmN0aW9uIG9yZGVyQnkoYXJyLCBzb3J0S2V5LCByZXZlcnNlKSB7XG4gIGFyciA9IGNvbnZlcnRBcnJheShhcnIpO1xuICBpZiAoIXNvcnRLZXkpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIHZhciBvcmRlciA9IHJldmVyc2UgJiYgcmV2ZXJzZSA8IDAgPyAtMSA6IDE7XG4gIC8vIHNvcnQgb24gYSBjb3B5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGFycmF5XG4gIHJldHVybiBhcnIuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKHNvcnRLZXkgIT09ICcka2V5Jykge1xuICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICckdmFsdWUnIGluIGEpIGEgPSBhLiR2YWx1ZTtcbiAgICAgIGlmIChpc09iamVjdChiKSAmJiAnJHZhbHVlJyBpbiBiKSBiID0gYi4kdmFsdWU7XG4gICAgfVxuICAgIGEgPSBpc09iamVjdChhKSA/IGdldFBhdGgoYSwgc29ydEtleSkgOiBhO1xuICAgIGIgPSBpc09iamVjdChiKSA/IGdldFBhdGgoYiwgc29ydEtleSkgOiBiO1xuICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gb3JkZXIgOiAtb3JkZXI7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN0cmluZyBjb250YWluIGhlbHBlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoXG4gKi9cblxuZnVuY3Rpb24gY29udGFpbnMkMSh2YWwsIHNlYXJjaCkge1xuICB2YXIgaTtcbiAgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGNvbnRhaW5zJDEodmFsW2tleXNbaV1dLCBzZWFyY2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY29udGFpbnMkMSh2YWxbaV0sIHNlYXJjaCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gpID4gLTE7XG4gIH1cbn1cblxudmFyIGRpZ2l0c1JFID0gLyhcXGR7M30pKD89XFxkKS9nO1xuXG4vLyBhc3NldCBjb2xsZWN0aW9ucyBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LlxudmFyIGZpbHRlcnMgPSB7XG5cbiAgb3JkZXJCeTogb3JkZXJCeSxcbiAgZmlsdGVyQnk6IGZpbHRlckJ5LFxuICBsaW1pdEJ5OiBsaW1pdEJ5LFxuXG4gIC8qKlxuICAgKiBTdHJpbmdpZnkgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRlbnRcbiAgICovXG5cbiAganNvbjoge1xuICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQodmFsdWUsIGluZGVudCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCBOdW1iZXIoaW5kZW50KSB8fCAyKTtcbiAgICB9LFxuICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiAnYWJjJyA9PiAnQWJjJ1xuICAgKi9cblxuICBjYXBpdGFsaXplOiBmdW5jdGlvbiBjYXBpdGFsaXplKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkgcmV0dXJuICcnO1xuICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdmFsdWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zbGljZSgxKTtcbiAgfSxcblxuICAvKipcbiAgICogJ2FiYycgPT4gJ0FCQydcbiAgICovXG5cbiAgdXBwZXJjYXNlOiBmdW5jdGlvbiB1cHBlcmNhc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyB2YWx1ZS50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgfSxcblxuICAvKipcbiAgICogJ0FiQycgPT4gJ2FiYydcbiAgICovXG5cbiAgbG93ZXJjYXNlOiBmdW5jdGlvbiBsb3dlcmNhc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgfSxcblxuICAvKipcbiAgICogMTIzNDUgPT4gJDEyLDM0NS4wMFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2lnblxuICAgKi9cblxuICBjdXJyZW5jeTogZnVuY3Rpb24gY3VycmVuY3kodmFsdWUsIF9jdXJyZW5jeSkge1xuICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgIXZhbHVlICYmIHZhbHVlICE9PSAwKSByZXR1cm4gJyc7XG4gICAgX2N1cnJlbmN5ID0gX2N1cnJlbmN5ICE9IG51bGwgPyBfY3VycmVuY3kgOiAnJCc7XG4gICAgdmFyIHN0cmluZ2lmaWVkID0gTWF0aC5hYnModmFsdWUpLnRvRml4ZWQoMik7XG4gICAgdmFyIF9pbnQgPSBzdHJpbmdpZmllZC5zbGljZSgwLCAtMyk7XG4gICAgdmFyIGkgPSBfaW50Lmxlbmd0aCAlIDM7XG4gICAgdmFyIGhlYWQgPSBpID4gMCA/IF9pbnQuc2xpY2UoMCwgaSkgKyAoX2ludC5sZW5ndGggPiAzID8gJywnIDogJycpIDogJyc7XG4gICAgdmFyIF9mbG9hdCA9IHN0cmluZ2lmaWVkLnNsaWNlKC0zKTtcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/ICctJyA6ICcnO1xuICAgIHJldHVybiBzaWduICsgX2N1cnJlbmN5ICsgaGVhZCArIF9pbnQuc2xpY2UoaSkucmVwbGFjZShkaWdpdHNSRSwgJyQxLCcpICsgX2Zsb2F0O1xuICB9LFxuXG4gIC8qKlxuICAgKiAnaXRlbScgPT4gJ2l0ZW1zJ1xuICAgKlxuICAgKiBAcGFyYW1zXG4gICAqICBhbiBhcnJheSBvZiBzdHJpbmdzIGNvcnJlc3BvbmRpbmcgdG9cbiAgICogIHRoZSBzaW5nbGUsIGRvdWJsZSwgdHJpcGxlIC4uLiBmb3JtcyBvZiB0aGUgd29yZCB0b1xuICAgKiAgYmUgcGx1cmFsaXplZC4gV2hlbiB0aGUgbnVtYmVyIHRvIGJlIHBsdXJhbGl6ZWRcbiAgICogIGV4Y2VlZHMgdGhlIGxlbmd0aCBvZiB0aGUgYXJncywgaXQgd2lsbCB1c2UgdGhlIGxhc3RcbiAgICogIGVudHJ5IGluIHRoZSBhcnJheS5cbiAgICpcbiAgICogIGUuZy4gWydzaW5nbGUnLCAnZG91YmxlJywgJ3RyaXBsZScsICdtdWx0aXBsZSddXG4gICAqL1xuXG4gIHBsdXJhbGl6ZTogZnVuY3Rpb24gcGx1cmFsaXplKHZhbHVlKSB7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGFyZ3MubGVuZ3RoID4gMSA/IGFyZ3NbdmFsdWUgJSAxMCAtIDFdIHx8IGFyZ3NbYXJncy5sZW5ndGggLSAxXSA6IGFyZ3NbMF0gKyAodmFsdWUgPT09IDEgPyAnJyA6ICdzJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlYm91bmNlIGEgaGFuZGxlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXkgPSAzMDBcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIGRlYm91bmNlOiBmdW5jdGlvbiBkZWJvdW5jZShoYW5kbGVyLCBkZWxheSkge1xuICAgIGlmICghaGFuZGxlcikgcmV0dXJuO1xuICAgIGlmICghZGVsYXkpIHtcbiAgICAgIGRlbGF5ID0gMzAwO1xuICAgIH1cbiAgICByZXR1cm4gX2RlYm91bmNlKGhhbmRsZXIsIGRlbGF5KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaW5zdGFsbEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBWdWUgYW5kIGV2ZXJ5IGNvbnN0cnVjdG9yIHRoYXQgZXh0ZW5kcyBWdWUgaGFzIGFuXG4gICAqIGFzc29jaWF0ZWQgb3B0aW9ucyBvYmplY3QsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZCBkdXJpbmdcbiAgICogY29tcGlsYXRpb24gc3RlcHMgYXMgYHRoaXMuY29uc3RydWN0b3Iub3B0aW9uc2AuXG4gICAqXG4gICAqIFRoZXNlIGNhbiBiZSBzZWVuIGFzIHRoZSBkZWZhdWx0IG9wdGlvbnMgb2YgZXZlcnlcbiAgICogVnVlIGluc3RhbmNlLlxuICAgKi9cblxuICBWdWUub3B0aW9ucyA9IHtcbiAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgIGVsZW1lbnREaXJlY3RpdmVzOiBlbGVtZW50RGlyZWN0aXZlcyxcbiAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICAgIHRyYW5zaXRpb25zOiB7fSxcbiAgICBjb21wb25lbnRzOiB7fSxcbiAgICBwYXJ0aWFsczoge30sXG4gICAgcmVwbGFjZTogdHJ1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBFeHBvc2UgdXNlZnVsIGludGVybmFsc1xuICAgKi9cblxuICBWdWUudXRpbCA9IHV0aWw7XG4gIFZ1ZS5jb25maWcgPSBjb25maWc7XG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZVsnZGVsZXRlJ10gPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9sbG93aW5nIGFyZSBleHBvc2VkIGZvciBhZHZhbmNlZCB1c2FnZSAvIHBsdWdpbnNcbiAgICovXG5cbiAgVnVlLmNvbXBpbGVyID0gY29tcGlsZXI7XG4gIFZ1ZS5GcmFnbWVudEZhY3RvcnkgPSBGcmFnbWVudEZhY3Rvcnk7XG4gIFZ1ZS5pbnRlcm5hbERpcmVjdGl2ZXMgPSBpbnRlcm5hbERpcmVjdGl2ZXM7XG4gIFZ1ZS5wYXJzZXJzID0ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgdGV4dDogdGV4dCxcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgZGlyZWN0aXZlOiBkaXJlY3RpdmUsXG4gICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICB9O1xuXG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG5cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5kT3B0aW9uc1xuICAgKi9cblxuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBpc0ZpcnN0RXh0ZW5kID0gU3VwZXIuY2lkID09PSAwO1xuICAgIGlmIChpc0ZpcnN0RXh0ZW5kICYmIGV4dGVuZE9wdGlvbnMuX0N0b3IpIHtcbiAgICAgIHJldHVybiBleHRlbmRPcHRpb25zLl9DdG9yO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICsgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY2F0ZXJzIGFuZCB0aGUgaHlwaGVuLicpO1xuICAgICAgICBuYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFN1YiA9IGNyZWF0ZUNsYXNzKG5hbWUgfHwgJ1Z1ZUNvbXBvbmVudCcpO1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoU3VwZXIub3B0aW9ucywgZXh0ZW5kT3B0aW9ucyk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb25cbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBpZiAoaXNGaXJzdEV4dGVuZCkge1xuICAgICAgZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IFN1YjtcbiAgICB9XG4gICAgcmV0dXJuIFN1YjtcbiAgfTtcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdWItY2xhc3MgY29uc3RydWN0b3Igd2l0aCB0aGVcbiAgICogZ2l2ZW4gbmFtZS4gVGhpcyBnaXZlcyB1cyBtdWNoIG5pY2VyIG91dHB1dCB3aGVuXG4gICAqIGxvZ2dpbmcgaW5zdGFuY2VzIGluIHRoZSBjb25zb2xlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3MobmFtZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jICovXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uICcgKyBjbGFzc2lmeShuYW1lKSArICcgKG9wdGlvbnMpIHsgdGhpcy5faW5pdChvcHRpb25zKSB9JykoKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldy1mdW5jICovXG4gIH1cblxuICAvKipcbiAgICogUGx1Z2luIHN5c3RlbVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luXG4gICAqL1xuXG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgcGx1Z2luLmluc3RhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgZ2xvYmFsIG1peGluIGJ5IG1lcmdpbmcgaXQgaW50byB0aGUgZGVmYXVsdFxuICAgKiBvcHRpb25zLlxuICAgKi9cblxuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICBWdWUub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhWdWUub3B0aW9ucywgbWl4aW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHNpZ25hdHVyZTpcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAqIEBwYXJhbSB7Kn0gZGVmaW5pdGlvblxuICAgKi9cblxuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChpZCwgZGVmaW5pdGlvbikge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIChjb21tb25UYWdSRS50ZXN0KGlkKSB8fCByZXNlcnZlZFRhZ1JFLnRlc3QoaWQpKSkge1xuICAgICAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICsgJ2lkOiAnICsgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSBWdWUuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyBleHBvc2UgaW50ZXJuYWwgdHJhbnNpdGlvbiBBUElcbiAgZXh0ZW5kKFZ1ZS50cmFuc2l0aW9uLCB0cmFuc2l0aW9uKTtcbn1cblxuaW5zdGFsbEdsb2JhbEFQSShWdWUpO1xuXG5WdWUudmVyc2lvbiA9ICcxLjAuMTgnO1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgaWYgKGRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpbkJyb3dzZXIgJiYgL0Nocm9tZVxcL1xcZCsvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgY29uc29sZS5sb2coJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWdWU7IiwidmFyIGluc2VydGVkID0gZXhwb3J0cy5jYWNoZSA9IHt9XG5cbmV4cG9ydHMuaW5zZXJ0ID0gZnVuY3Rpb24gKGNzcykge1xuICBpZiAoaW5zZXJ0ZWRbY3NzXSkgcmV0dXJuXG4gIGluc2VydGVkW2Nzc10gPSB0cnVlXG5cbiAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIGVsZW0uc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJylcblxuICBpZiAoJ3RleHRDb250ZW50JyBpbiBlbGVtKSB7XG4gICAgZWxlbS50ZXh0Q29udGVudCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIGVsZW0uc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH1cblxuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGVsZW0pXG4gIHJldHVybiBlbGVtXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdnVlID0gcmVxdWlyZSgnLi4vbGlicy92dWUuanMnKTtcblxudmFyIF92dWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdnVlKTtcblxudmFyIF92dWVSZWFkYWJsZU51bWJlciA9IHJlcXVpcmUoJy4uL2xpYnMvdnVlLXJlYWRhYmxlLW51bWJlci5qcycpO1xuXG52YXIgX3Z1ZVJlYWRhYmxlTnVtYmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Z1ZVJlYWRhYmxlTnVtYmVyKTtcblxudmFyIF92dWVDbGlja091dHNpZGUgPSByZXF1aXJlKCcuLi9saWJzL3Z1ZS1jbGljay1vdXRzaWRlLmpzJyk7XG5cbnZhciBfdnVlQ2xpY2tPdXRzaWRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Z1ZUNsaWNrT3V0c2lkZSk7XG5cbnZhciBfdnVlTG9hZGluZ0JhciA9IHJlcXVpcmUoJy4vb3RoZXIvdnVlLWxvYWRpbmctYmFyLnZ1ZScpO1xuXG52YXIgX3Z1ZUxvYWRpbmdCYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdnVlTG9hZGluZ0Jhcik7XG5cbnZhciBfZ3JpZCA9IHJlcXVpcmUoJy4vb3RoZXIvZ3JpZC52dWUnKTtcblxudmFyIF9ncmlkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyaWQpO1xuXG52YXIgX25hdmlnYXRpb24gPSByZXF1aXJlKCcuL25hdi9uYXZpZ2F0aW9uLnZ1ZScpO1xuXG52YXIgX25hdmlnYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbmF2aWdhdGlvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIERlYnVnIG1vZGVcblxuXG4vLyBJbXBvcnQgdGhlIGxpYnJhcnlcbl92dWUyLmRlZmF1bHQuY29uZmlnLmRlYnVnID0gdHJ1ZTtcblxuLy8gSW1wb3J0IENvbXBvbmVudFxuXG5cbi8vIEltcG9ydCBQbHVnaW5cblxuX3Z1ZTIuZGVmYXVsdC5jb25maWcuZGV2dG9vbHMgPSB0cnVlO1xuXG4vLyBHbG9iYWwgRnVuY3Rpb25cbmdsb2JhbC5jbGVhblVwID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xufTtcblxuLy8gR2xvYmFsIEZpbHRlclxuX3Z1ZTIuZGVmYXVsdC5maWx0ZXIoJ3JlYWRhYmxlLW51bWJlcicsIF92dWVSZWFkYWJsZU51bWJlcjIuZGVmYXVsdCk7XG5cbi8vIEdsb2JhbCBEaXJlY3RpdmVcbl92dWUyLmRlZmF1bHQuZGlyZWN0aXZlKCdjbGljay1vdXRzaWRlJywgX3Z1ZUNsaWNrT3V0c2lkZTIuZGVmYXVsdCk7XG5cbi8vIEdsb2JhbCBDb21wb25lbnRcbl92dWUyLmRlZmF1bHQuY29tcG9uZW50KCdncmlkJywgX2dyaWQyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG5cbiAgcmVwbGFjZTogZmFsc2UsXG5cbiAgY29tcG9uZW50czogeyBuYXZpZ2F0aW9uOiBfbmF2aWdhdGlvbjIuZGVmYXVsdCwgbG9hZGluZ0JhcjogX3Z1ZUxvYWRpbmdCYXIyLmRlZmF1bHQgfSxcblxuICBtZXRob2RzOiB7XG4gICAgYmFja1RvVG9wOiBmdW5jdGlvbiBiYWNrVG9Ub3AoKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IDA7XG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy4kYWN0aW9uKCdzZXJ2aWNlczppbml0aWFsX3N0YXRlJyk7XG4gIH1cbn07XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIjxkaXY+PGRpdiBjbGFzcz1cXFwiY29udGFpbmVyLW1pbmlcXFwiPjxsb2FkaW5nLWJhciB2LWJpbmQ6cHJvZ3Jlc3Muc3luYz1cXFwic3RhdGUuc2VydmljZXMucHJvZ3Jlc3NcXFwiPjwvbG9hZGluZy1iYXI+PC9kaXY+PG5hdmlnYXRpb24+PC9uYXZpZ2F0aW9uPjxkaXYgY2xhc3M9XFxcIm1haW4td3JhcHBlclxcXCI+PGRpdiBjbGFzcz1cXFwiY29udGFpbmVyLW1pbmlcXFwiPjxyb3V0ZXItdmlldz48L3JvdXRlci12aWV3PjwvZGl2PjwvZGl2PjxhIEBjbGljay5wcmV2ZW50PVxcXCJiYWNrVG9Ub3BcXFwiIGNsYXNzPVxcXCJiYWNrLXRvLXRvcFxcXCI+PGkgY2xhc3M9XFxcImlvbi1jaGV2cm9uLXVwXFxcIj48L2k+PC9hPjxmb290ZXI+PGRpdiBjbGFzcz1cXFwiY29udGFpbmVyLW1pbmlcXFwiPjxwIGNsYXNzPVxcXCJjb3B5cmlnaHRcXFwiPkNvcHlyaWdodCAoYykgQnk8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vQm9zTmF1ZmFsXFxcIj4gQm9zIE5hdWZhbDwvYT48L3A+PC9kaXY+PC9mb290ZXI+PC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL3Zhci93d3cvZ2l0aHViL3Z1ZS1taW5pLXNob3AvYXNzZXRzL2pzL2NvbXBvbmVudHMvYXBwLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG5cbiAgcHJvcHM6IHtcbiAgICBoYXNDaG9vc2VuOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge31cbiAgICB9XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBjYXRlZ29yaWVzOiBmdW5jdGlvbiBjYXRlZ29yaWVzKCkge1xuICAgICAgdmFyIGNhdGVnb3J5ID0gdGhpcy4kcm91dGUucGFyYW1zLmNhdGVnb3J5O1xuICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgIHRoaXMuc3RhdGUucHJvZHVjdC5hbGwuZm9yRWFjaChmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgICAgICBwcm9kdWN0LmNhdGVnb3JpZXMuZm9yRWFjaChmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgICBjYXRlZ29yeSA9IGNhdGVnb3J5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICB2YXIgZHVwbGljYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gZHVwbGljYXRlKSBkdXBsaWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWR1cGxpY2F0ZWQpIGNhdGVnb3JpZXMucHVzaChjYXRlZ29yeSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2F0ZWdvcmllcztcbiAgICB9XG4gIH1cblxufTtcbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiPGRpdiBjbGFzcz1cXFwiY2F0ZWdvcmllcyBhbmltYXRlZCBmYWRlSW5Eb3duXFxcIj48aDM+Q2hvb3NlIGEgY2F0ZWdvcnk6PC9oMz48YSB2LWZvcj1cXFwiY2F0ZWdvcnkgaW4gY2F0ZWdvcmllc1xcXCIgaHJlZj1cXFwiIyEvY2F0ZWdvcnkve3sgY2F0ZWdvcnkgfX1cXFwiIEBjbGljaz1cXFwiaGFzQ2hvb3NlbigpXFxcIj57eyBjYXRlZ29yeSB8IGNhcGl0YWxpemUgfX08L2E+PC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL3Zhci93d3cvZ2l0aHViL3Z1ZS1taW5pLXNob3AvYXNzZXRzL2pzL2NvbXBvbmVudHMvbmF2L2NhdGVnb3JpZXMudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gbW9kdWxlLmV4cG9ydHMub3B0aW9ucyA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2VhcmNoID0gcmVxdWlyZSgnLi9zZWFyY2gudnVlJyk7XG5cbnZhciBfc2VhcmNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlYXJjaCk7XG5cbnZhciBfY2F0ZWdvcmllcyA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy52dWUnKTtcblxudmFyIF9jYXRlZ29yaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NhdGVnb3JpZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlYXJjaGluZzogZmFsc2UsXG4gICAgICBjaG9vc2luZ0NhdGVnb3J5OiBmYWxzZSxcbiAgICAgIG5ld0l0ZW06IGZhbHNlXG4gICAgfTtcbiAgfSxcblxuXG4gIGNvbXBvbmVudHM6IHtcbiAgICBzZWFyY2g6IF9zZWFyY2gyLmRlZmF1bHQsXG4gICAgY2F0ZWdvcmllczogX2NhdGVnb3JpZXMyLmRlZmF1bHRcbiAgfSxcblxuICB3YXRjaDoge1xuICAgICdzdGF0ZS5jYXJ0LnRvdGFsSXRlbSc6IGZ1bmN0aW9uIHN0YXRlQ2FydFRvdGFsSXRlbSh2YWwsIG9sZCkge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIGlmICh2YWwgPiBvbGQpIHtcbiAgICAgICAgbWUubmV3SXRlbSA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lLm5ld0l0ZW0gPSBmYWxzZTtcbiAgICAgICAgfSwgNzUwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIHRvZ2dsZVNlYXJjaEJhcjogZnVuY3Rpb24gdG9nZ2xlU2VhcmNoQmFyKCkge1xuICAgICAgdGhpcy5jaG9vc2luZ0NhdGVnb3J5ID0gZmFsc2U7XG4gICAgICB0aGlzLnNlYXJjaGluZyA9ICF0aGlzLnNlYXJjaGluZztcbiAgICB9LFxuICAgIHRvZ2dsZUNhdGVnb3J5TGlzdDogZnVuY3Rpb24gdG9nZ2xlQ2F0ZWdvcnlMaXN0KCkge1xuICAgICAgdGhpcy5zZWFyY2hpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2hvb3NpbmdDYXRlZ29yeSA9ICF0aGlzLmNob29zaW5nQ2F0ZWdvcnk7XG4gICAgfVxuICB9LFxuXG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIG1lLm5ld0l0ZW0gPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgbWUubmV3SXRlbSA9IGZhbHNlO1xuICAgIH0sIDc1MCk7XG4gIH1cbn07XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIjxuYXY+PGRpdiBjbGFzcz1cXFwiY29udGFpbmVyLW1pbmlcXFwiPjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+PGdyaWQgeHM9XFxcIjhcXFwiPjxhIGhyZWY9XFxcIiMhL1xcXCI+PGltZyBzcmM9XFxcIi4vYXNzZXRzL2ltZy9sb2dvLnBuZ1xcXCIvPjwvYT48L2dyaWQ+PGdyaWQgeHM9XFxcIjRcXFwiIGNsYXNzZXM9XFxcInRleHQtcmlnaHRcXFwiPjxidXR0b24gQGNsaWNrPVxcXCJ0b2dnbGVTZWFyY2hCYXJcXFwiPjxpIGNsYXNzPVxcXCJ7eyBzZWFyY2hpbmcgPyAnaW9uLWFuZHJvaWQtY2xvc2UgY29sb3ItcmVkJyA6ICdpb24taW9zLXNlYXJjaC1zdHJvbmcnIH19XFxcIj48L2k+PC9idXR0b24+PGJ1dHRvbj48YSBocmVmPVxcXCIjIS9jYXJ0XFxcIj48aSBjbGFzcz1cXFwiaW9uLWJhZ1xcXCI+PHNwYW4gdi1pZj1cXFwic3RhdGUuY2FydC50b3RhbEl0ZW1cXFwiIHYtYmluZDpjbGFzcz1cXFwieyBib3VuY2VJbjogbmV3SXRlbSB9XFxcIiBjbGFzcz1cXFwiYmFkZ2UgYW5pbWF0ZWRcXFwiPnt7IHN0YXRlLmNhcnQudG90YWxJdGVtIH19PC9zcGFuPjwvaT48L2E+PC9idXR0b24+PGJ1dHRvbiBAY2xpY2s9XFxcInRvZ2dsZUNhdGVnb3J5TGlzdFxcXCI+PGkgY2xhc3M9XFxcInt7IGNob29zaW5nQ2F0ZWdvcnkgPyAnaW9uLWFuZHJvaWQtY2xvc2UgY29sb3ItcmVkJyA6ICdpb24tcHJpY2V0YWdzJyB9fVxcXCI+PC9pPjwvYnV0dG9uPjwvZ3JpZD48L2Rpdj48c2VhcmNoIHYtaWY9XFxcInNlYXJjaGluZ1xcXCIgdi1iaW5kOmhhcy1zZWFyY2hlZD1cXFwidG9nZ2xlU2VhcmNoQmFyXFxcIj48L3NlYXJjaD48Y2F0ZWdvcmllcyB2LWlmPVxcXCJjaG9vc2luZ0NhdGVnb3J5XFxcIiB2LWJpbmQ6aGFzLWNob29zZW49XFxcInRvZ2dsZUNhdGVnb3J5TGlzdFxcXCI+PC9jYXRlZ29yaWVzPjwvZGl2PjwvbmF2PlwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi92YXIvd3d3L2dpdGh1Yi92dWUtbWluaS1zaG9wL2Fzc2V0cy9qcy9jb21wb25lbnRzL25hdi9uYXZpZ2F0aW9uLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG5cbiAgcHJvcHM6IHtcbiAgICBoYXNTZWFyY2hlZDoge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9XG4gICAgfVxuICB9LFxuXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzOiBmYWxzZSxcbiAgICAgIHNlYXJjaDogXCJcIlxuICAgIH07XG4gIH0sXG5cblxuICBtZXRob2RzOiB7XG4gICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcbiAgICAgIHRoaXMuZm9jdXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2VhcmNoID0gXCJcIjtcbiAgICB9LFxuICAgIHN1Ym1pdDogZnVuY3Rpb24gc3VibWl0KCkge1xuICAgICAgcm91dGVyLmdvKCcvc2VhcmNoP3E9JyArIGVuY29kZVVSSSh0aGlzLnNlYXJjaCkpO1xuICAgICAgdGhpcy5oYXNTZWFyY2hlZCgpO1xuICAgIH1cbiAgfVxuXG59O1xuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCI8Zm9ybSB2LWJpbmQ6Y2xhc3M9XFxcInsgZm9jdXM6IGZvY3VzIH1cXFwiIEBzdWJtaXQucHJldmVudD1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwic2VhcmNoLWJhciBhbmltYXRlZCBmYWRlSW5Eb3duXFxcIj48ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPjxncmlkIHhzPVxcXCIxMFxcXCI+PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJDYXJpIFByb2R1ay4uLlxcXCIgQGZvY3VzPVxcXCIkc2V0KCdmb2N1cycsdHJ1ZSlcXFwiIEBibHVyPVxcXCJibHVyXFxcIiB2LW1vZGVsPVxcXCJzZWFyY2hcXFwiLz48L2dyaWQ+PGdyaWQgeHM9XFxcIjJcXFwiIGNsYXNzZXM9XFxcInRleHQtcmlnaHQgYW5pbWF0ZWQgYm91bmNlSW5cXFwiIHYtaWY9XFxcImZvY3VzXFxcIj48YnV0dG9uIHR5cGU9XFxcInN1Ym1pdFxcXCI+PGkgY2xhc3M9XFxcImlvbi1hcnJvdy1yaWdodC1jXFxcIj48L2k+PC9idXR0b24+PC9ncmlkPjwvZGl2PjwvZm9ybT5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvdmFyL3d3dy9naXRodWIvdnVlLW1pbmktc2hvcC9hc3NldHMvanMvY29tcG9uZW50cy9uYXYvc2VhcmNoLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuXG5cdHByb3BzOiB7XG5cdFx0J3hzJzoge30sXG5cdFx0J3hzT2Zmc2V0Jzoge30sXG5cdFx0J3NtJzoge30sXG5cdFx0J3NtT2Zmc2V0Jzoge30sXG5cdFx0J21kJzoge30sXG5cdFx0J21kT2Zmc2V0Jzoge30sXG5cdFx0J2xnJzoge30sXG5cdFx0J2xnT2Zmc2V0Jzoge30sXG5cdFx0J2lkJzoge30sXG5cdFx0J2NsYXNzZXMnOiB7XG5cdFx0XHRkZWZhdWx0OiBcIlwiXG5cdFx0fSxcblx0XHQnYmluZENsYXNzJzoge31cblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRhbGxDbGFzc2VzOiBcIlwiLFxuXHRcdFx0YmluZGVkQ2xhc3NlczogXCJcIlxuXHRcdH07XG5cdH0sXG5cblxuXHRjb21wdXRlZDoge1xuXHRcdGFsbENsYXNzZXM6IGZ1bmN0aW9uIGFsbENsYXNzZXMoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jbGFzc2VzICsgJyAnICsgdGhpcy5iaW5kZWRDbGFzc2VzICsgJyAnICsgdGhpcy5jb2xDbGFzc2VzO1xuXHRcdH0sXG5cdFx0YmluZGVkQ2xhc3NlczogZnVuY3Rpb24gYmluZGVkQ2xhc3NlcygpIHtcblx0XHRcdHZhciBjbGVhbiA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmluZENsYXNzLCB7fSk7XG5cblx0XHRcdHZhciBiaW5kZWQgPSBjbGVhbjtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoY2xlYW4pO1xuXG5cdFx0XHR2YXIgaGFzQmluZGVkID0gW107XG5cdFx0XHRmb3IgKHZhciBpIGluIGtleXMpIHtcblx0XHRcdFx0dmFyIGNsYXNzZXMgPSBrZXlzW2ldO1xuXHRcdFx0XHRpZiAoYmluZGVkW2NsYXNzZXNdKSBoYXNCaW5kZWQucHVzaChjbGFzc2VzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGhhc0JpbmRlZC5qb2luKFwiIFwiKTtcblx0XHR9LFxuXHRcdGNvbENsYXNzZXM6IGZ1bmN0aW9uIGNvbENsYXNzZXMoKSB7XG5cdFx0XHR2YXIgeHMgPSB0aGlzLnhzID8gXCIgY29sLXhzLVwiICsgdGhpcy54cyA6IFwiXCI7XG5cdFx0XHR2YXIgc20gPSB0aGlzLnNtID8gXCIgY29sLXNtLVwiICsgdGhpcy5zbSA6IFwiXCI7XG5cdFx0XHR2YXIgbWQgPSB0aGlzLm1kID8gXCIgY29sLW1kLVwiICsgdGhpcy5tZCA6IFwiXCI7XG5cdFx0XHR2YXIgbGcgPSB0aGlzLmxnID8gXCIgY29sLWxnLVwiICsgdGhpcy5sZyA6IFwiXCI7XG5cdFx0XHR2YXIgeHNPZmZzZXQgPSB0aGlzLnhzT2Zmc2V0ID8gXCIgY29sLXhzLW9mZnNldC1cIiArIHRoaXMueHNPZmZzZXQgOiBcIlwiO1xuXHRcdFx0dmFyIHNtT2Zmc2V0ID0gdGhpcy5zbU9mZnNldCA/IFwiIGNvbC1zbS1vZmZzZXQtXCIgKyB0aGlzLnNtT2Zmc2V0IDogXCJcIjtcblx0XHRcdHZhciBtZE9mZnNldCA9IHRoaXMubWRPZmZzZXQgPyBcIiBjb2wtbWQtb2Zmc2V0LVwiICsgdGhpcy5tZE9mZnNldCA6IFwiXCI7XG5cdFx0XHR2YXIgbGdPZmZzZXQgPSB0aGlzLmxnT2Zmc2V0ID8gXCIgY29sLWxnLW9mZnNldC1cIiArIHRoaXMubGdPZmZzZXQgOiBcIlwiO1xuXHRcdFx0cmV0dXJuIHhzICsgc20gKyBtZCArIGxnICsgeHNPZmZzZXQgKyBzbU9mZnNldCArIG1kT2Zmc2V0ICsgbGdPZmZzZXQ7XG5cdFx0fVxuXHR9XG5cbn07XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIjxkaXYgOmNsYXNzPVxcXCJhbGxDbGFzc2VzXFxcIiA6aWQ9XFxcImlkXFxcIj48c2xvdD48L3Nsb3Q+PC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL3Zhci93d3cvZ2l0aHViL3Z1ZS1taW5pLXNob3AvYXNzZXRzL2pzL2NvbXBvbmVudHMvb3RoZXIvZ3JpZC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCAodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsInZhciBfX3Z1ZWlmeV9zdHlsZV9fID0gcmVxdWlyZShcInZ1ZWlmeS1pbnNlcnQtY3NzXCIpLmluc2VydChcIlxcblxcdC5sb2FkaW5nLWJhcntcXG5cXHRcXHR0cmFuc2l0aW9uOmFsbCAwLjNzIGVhc2U7XFxuXFx0XFx0LW1vei10cmFuc2l0aW9uOmFsbCAwLjNzIGVhc2U7XFxuXFx0XFx0LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAwLjNzIGVhc2U7XFxuXFx0XFx0LW8tdHJhbnNpdGlvbjphbGwgMC4zcyBlYXNlO1xcblxcdH1cXG5cXHQubG9hZGluZy1iYXJ7XFxuXFx0XFx0cG9zaXRpb246IGZpeGVkO1xcblxcdFxcdHRvcDogMDtcXG5cXHRcXHRiYWNrZ3JvdW5kOiAjMDM2RkZGO1xcblxcdFxcdGhlaWdodDogM3B4O1xcblxcdFxcdG9wYWNpdHk6IDE7XFxuICAgIHotaW5kZXg6IDEwMDtcXG5cXHR9XFxuXFx0Lmdsb3ctYmFye1xcblxcdFxcdHRvcDogMDtcXG5cXHRcXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0XFx0d2lkdGg6IDEwMHB4O1xcblxcdFxcdGhlaWdodDogMTAwJTtcXG5cXHRcXHRib3gtc2hhZG93OiAtM3B4IDAgMTVweCAxcHggcmdiYSgwLCAyMCwgMjU1LCAwLjQpXFxuXFx0fVxcblxcblxcdC50by1yaWdodC5sb2FkaW5nLWJhcntcXG5cXHRcXHRsZWZ0OiAwO1xcblxcdH1cXG5cXHQudG8tcmlnaHQgLmdsb3ctYmFye1xcblxcdFxcdHJpZ2h0OiAwO1xcblxcdH1cXG5cXG5cXHQudG8tbGVmdC5sb2FkaW5nLWJhcntcXG5cXHRcXHRyaWdodDogMDtcXG5cXHR9XFxuXFx0LnRvLWxlZnQgLmdsb3ctYmFye1xcblxcdFxcdGxlZnQ6IDA7XFxuXFx0fVxcblxcblxcdC5mdWxsLmxvYWRpbmctYmFye1xcblxcdFxcdHRyYW5zaXRpb246YWxsIDAuMXMgZWFzZTtcXG5cXHRcXHQtbW96LXRyYW5zaXRpb246YWxsIDAuMXMgZWFzZTtcXG5cXHRcXHQtd2Via2l0LXRyYW5zaXRpb246YWxsIDAuMXMgZWFzZTtcXG5cXHRcXHQtby10cmFuc2l0aW9uOmFsbCAwLjFzIGVhc2U7XFxuXFx0XFx0aGVpZ2h0OiAwO1xcblxcdFxcdG9wYWNpdHk6IDA7XFxuXFx0fVxcblxcblxcdC5lcnJvci5sb2FkaW5nLWJhcntcXG5cXHRcXHRiYWNrZ3JvdW5kOiAjRjQ0MzM2O1xcblxcdH1cXG5cXHQuZXJyb3IgLmdsb3ctYmFye1xcblxcdFxcdGJveC1zaGFkb3c6IC0zcHggMCAxNXB4IDFweCByZ2JhKDI0NCwgNjcsIDU0LCAwLjQpO1xcblxcdH1cXG5cIilcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxuXG4vKiEgQ29weXJpZ2h0IChjKSAyMDE2IE5hdWZhbCBSYWJiYW5pIChodHRwOi8vZ2l0aHViLmNvbS9Cb3NOYXVmYWwpXG4qIExpY2Vuc2VkIFVuZGVyIE1JVCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbipcbiogVnVlIExvZGluZyBCYXIgLSBWZXJzaW9uIDAuMC4xXG4qXG4qL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG5cdHByb3BzOiB7XG5cdFx0aWQ6IFN0cmluZyxcblx0XHRjbGFzczogU3RyaW5nLFxuXG5cdFx0cHJvZ3Jlc3M6IE51bWJlciwgLy8gVGhlIHByb2dyZXNzIG9mIGxvYWRpbmcgYmFyXG5cblx0XHQvLyB0aGUgZGlyZWN0aW9uIG9mIGxvYWRpbmcgYmFyXG5cdFx0ZGlyZWN0aW9uOiB7XG5cdFx0XHR0eXBlOiBTdHJpbmcsXG5cdFx0XHRkZWZhdWx0OiBcInJpZ2h0XCJcblx0XHR9LFxuXG5cdFx0ZXJyb3I6IEJvb2xlYW4gLy8gTG9hZGluZyBCYXIgZXJyb3Igc3RhdGVcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHQvLyBUbyBzaG93XG5cdFx0XHRzaG93OiB0cnVlLFxuXG5cdFx0XHQvLyBiaW5kaW5nIGNsYXNzIHdoZW4gaXQgZW5kXG5cdFx0XHRmdWxsOiAnJyxcblxuXHRcdFx0Ly8gc3RhdGUgdG8gYW5pbWF0ZSB0aGUgd2lkdGggb2YgbG9hZGluZyBiYXJcblx0XHRcdHdpZHRoOiAwLFxuXG5cdFx0XHQvLyBpbmRpY2F0ZSB0aGUgbG9hZGluZyBiYXIgaXMgaW4gMTAwJSAoIHNvLCB3YWl0IGl0IHRpbGwgZ29uZSApXG5cdFx0XHR3YWl0OiBmYWxzZVxuXHRcdH07XG5cdH0sXG5cblxuXHR3YXRjaDoge1xuXHRcdHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyh2YWwsIG9sZCkge1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdFx0aWYgKG9sZCA9PSAwICYmIHZhbCA+IDApIHtcblx0XHRcdFx0Ly8gQ2FsbGJhY2sgRXZlbnQgd2hlbiBpdCdzIHN0YXJ0ZWRcblx0XHRcdFx0dGhpcy4kZGlzcGF0Y2goJ2xvYWRpbmctYmFyOnN0YXJ0ZWQnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHZhbCA+IDEgJiYgdmFsIDwgMTAwKSB7XG5cdFx0XHRcdC8vIENhbGxiYWNrIEV2ZW50IHdoZW4gaXQncyBsb2FkaW5nXG5cdFx0XHRcdHRoaXMuJGRpc3BhdGNoKCdsb2FkaW5nLWJhcjpsb2FkaW5nJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdoZW4gdGhlIHByb2dyZXNzIGVuZFxuXHRcdFx0aWYgKHRoaXMucHJvZ3Jlc3MgPT0gMTAwKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXcgcHJvZ3Jlc3MgY2hhbmdlXG5cdFx0XHRcdHRoaXMud2FpdCA9IHRydWU7XG5cblx0XHRcdFx0Ly8gU3RhcnQgYW5pbWF0ZSBpdFxuXHRcdFx0XHR0aGlzLndpZHRoID0gMTAwO1xuXG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdC8vIGFuaW1hdGUgd2hlbiBlbGVtZW50IHJlbW92ZWRcblx0XHRcdFx0XHRfdGhpcy5mdWxsID0gJ2Z1bGwnO1xuXHRcdFx0XHRcdF90aGlzLmVycm9yID0gZmFsc2U7XG5cblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdC8vcmVtb3ZlIGJhciBlbGVtZW50XG5cdFx0XHRcdFx0XHRfdGhpcy5zaG93ID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdC8vIE5ldyBFbGVtZW50IGlzIGF2YWlsYWJsZSB0byBjcmVhdGUgbm93XG5cdFx0XHRcdFx0XHRfdGhpcy5wcm9ncmVzcyA9IDA7XG5cdFx0XHRcdFx0XHRfdGhpcy53YWl0ID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHQvLyBTaG93IEJhclxuXHRcdFx0XHRcdFx0XHRfdGhpcy5mdWxsID0gJyc7XG5cdFx0XHRcdFx0XHRcdF90aGlzLnNob3cgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIENhbGxiYWNrIEV2ZW50IHdoZW4gaXQncyBsb2FkZWQgYW5kIHRvdGFsbHkgZ29uZVxuXHRcdFx0XHRcdFx0XHRfdGhpcy4kZGlzcGF0Y2goJ2xvYWRpbmctYmFyOmxvYWRlZCcpO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdC8vIER1cmF0aW9uIHRvIFdhaXRpbmcgZm9yIHNsaWNrIGhpZGluZyBhbmltYXRpb25cblx0XHRcdFx0XHR9LCAyNTApO1xuXG5cdFx0XHRcdFx0Ly8gRHVyYXRpb24gaXMgZGVwZW5kIG9uIGNzcyBhbmltYXRpb24tZHVyYXRpb24gb2YgbG9hZGluZy1iYXJcblx0XHRcdFx0fSwgNzAwKTtcblxuXHRcdFx0XHQvLyBXaGVuIHRoZSBwcm9ncmVzcyBkb2Vzbid0IGVuZCB5ZXRcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBEbyBub3JtYWx5IGxvYWRpbmcgYmFyIGFuaW1hdGlvblxuXHRcdFx0XHRcdHRoaXMuZnVsbCA9ICcnO1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSB2YWw7XG5cdFx0XHRcdH1cblx0XHR9LFxuXHRcdGVycm9yOiBmdW5jdGlvbiBlcnJvcih2YWwsIG9sZCkge1xuXHRcdFx0dGhpcy5wcm9ncmVzcyA9IDEwMDtcblx0XHRcdC8vIENhbGxiYWNrIEV2ZW50IHdoZW4gaXQncyBlcnJvclxuXHRcdFx0dGhpcy4kZGlzcGF0Y2goJ2xvYWRpbmctYmFyOmVycm9yJyk7XG5cdFx0fVxuXHR9LFxuXG5cdG1ldGhvZHM6IHtcblx0XHRzdHlsaW5nOiBmdW5jdGlvbiBzdHlsaW5nKCkge1xuXHRcdFx0Ly8gV2hlbiBsb2FkaW5nIGJhciBzdGlsbCBpbiBwcm9ncmVzc1xuXHRcdFx0aWYgKCF0aGlzLndhaXQpIHtcblx0XHRcdFx0cmV0dXJuIHsgd2lkdGg6IHRoaXMud2lkdGggKyAnJScgfTtcblxuXHRcdFx0XHQvLyBXaGVuIGxvYWRpbmcgYmFyIGVuZFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBNYWtlIGl0IHN0dWNrIGF0IDEwMCB0byB3YWl0aW5nIHRoZSBhbmltYXRpb25cblx0XHRcdFx0XHRyZXR1cm4geyB3aWR0aDogJzEwMCUnIH07XG5cdFx0XHRcdH1cblx0XHR9XG5cdH1cblxufTtcbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiXFxuPGRpdiB2LWlmPVxcXCJzaG93XFxcIiBjbGFzcz1cXFwibG9hZGluZy1iYXIgdG8te3sgZGlyZWN0aW9uIH19IHt7IGZ1bGwgfX0ge3sgY2xhc3MgIT0gdW5kZWZpbmVkID8gY2xhc3MgOiAnJyB9fSB7eyBlcnJvciA/ICdlcnJvcicgOiAnJyB9fVxcXCIgOmlkPVxcXCJpZCAhPSB1bmRlZmluZWQgPyAnbG9hZGluZy1iYXItJytpZCA6ICcnXFxcIiA6c3R5bGU9XFxcInN0eWxpbmcoKVxcXCI+XFxuXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiZ2xvdy1iYXJcXFwiPjwvZGl2PlxcblxcbjwvZGl2PlxcblwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi92YXIvd3d3L2dpdGh1Yi92dWUtbWluaS1zaG9wL2Fzc2V0cy9qcy9jb21wb25lbnRzL290aGVyL3Z1ZS1sb2FkaW5nLWJhci52dWVcIlxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKCkge1xuICAgIHJlcXVpcmUoXCJ2dWVpZnktaW5zZXJ0LWNzc1wiKS5jYWNoZVtcIlxcblxcdC5sb2FkaW5nLWJhcntcXG5cXHRcXHR0cmFuc2l0aW9uOmFsbCAwLjNzIGVhc2U7XFxuXFx0XFx0LW1vei10cmFuc2l0aW9uOmFsbCAwLjNzIGVhc2U7XFxuXFx0XFx0LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAwLjNzIGVhc2U7XFxuXFx0XFx0LW8tdHJhbnNpdGlvbjphbGwgMC4zcyBlYXNlO1xcblxcdH1cXG5cXHQubG9hZGluZy1iYXJ7XFxuXFx0XFx0cG9zaXRpb246IGZpeGVkO1xcblxcdFxcdHRvcDogMDtcXG5cXHRcXHRiYWNrZ3JvdW5kOiAjMDM2RkZGO1xcblxcdFxcdGhlaWdodDogM3B4O1xcblxcdFxcdG9wYWNpdHk6IDE7XFxuICAgIHotaW5kZXg6IDEwMDtcXG5cXHR9XFxuXFx0Lmdsb3ctYmFye1xcblxcdFxcdHRvcDogMDtcXG5cXHRcXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0XFx0d2lkdGg6IDEwMHB4O1xcblxcdFxcdGhlaWdodDogMTAwJTtcXG5cXHRcXHRib3gtc2hhZG93OiAtM3B4IDAgMTVweCAxcHggcmdiYSgwLCAyMCwgMjU1LCAwLjQpXFxuXFx0fVxcblxcblxcdC50by1yaWdodC5sb2FkaW5nLWJhcntcXG5cXHRcXHRsZWZ0OiAwO1xcblxcdH1cXG5cXHQudG8tcmlnaHQgLmdsb3ctYmFye1xcblxcdFxcdHJpZ2h0OiAwO1xcblxcdH1cXG5cXG5cXHQudG8tbGVmdC5sb2FkaW5nLWJhcntcXG5cXHRcXHRyaWdodDogMDtcXG5cXHR9XFxuXFx0LnRvLWxlZnQgLmdsb3ctYmFye1xcblxcdFxcdGxlZnQ6IDA7XFxuXFx0fVxcblxcblxcdC5mdWxsLmxvYWRpbmctYmFye1xcblxcdFxcdHRyYW5zaXRpb246YWxsIDAuMXMgZWFzZTtcXG5cXHRcXHQtbW96LXRyYW5zaXRpb246YWxsIDAuMXMgZWFzZTtcXG5cXHRcXHQtd2Via2l0LXRyYW5zaXRpb246YWxsIDAuMXMgZWFzZTtcXG5cXHRcXHQtby10cmFuc2l0aW9uOmFsbCAwLjFzIGVhc2U7XFxuXFx0XFx0aGVpZ2h0OiAwO1xcblxcdFxcdG9wYWNpdHk6IDA7XFxuXFx0fVxcblxcblxcdC5lcnJvci5sb2FkaW5nLWJhcntcXG5cXHRcXHRiYWNrZ3JvdW5kOiAjRjQ0MzM2O1xcblxcdH1cXG5cXHQuZXJyb3IgLmdsb3ctYmFye1xcblxcdFxcdGJveC1zaGFkb3c6IC0zcHggMCAxNXB4IDFweCByZ2JhKDI0NCwgNjcsIDU0LCAwLjQpO1xcblxcdH1cXG5cIl0gPSBmYWxzZVxuICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoX192dWVpZnlfc3R5bGVfXylcbiAgfSlcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gbW9kdWxlLmV4cG9ydHMub3B0aW9ucyA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGNvbXB1dGVkOiB7XG4gICAgdG90YWw6IGZ1bmN0aW9uIHRvdGFsKCkge1xuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIHRoaXMuc3RhdGUuY2FydC5hbGwuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgdG90YWxQcmljZSA9IGl0ZW0ucHJpY2UgKiBpdGVtLmFtb3VudDtcbiAgICAgICAgdG90YWwgKz0gdG90YWxQcmljZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgY2hlY2tPdXQ6IGZ1bmN0aW9uIGNoZWNrT3V0KCkge1xuICAgICAgdGhpcy4kYWN0aW9uKCdjYXJ0OmNoZWNrb3V0Jyk7XG4gICAgfVxuICB9XG5cbn07XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIjxkaXYgY2xhc3M9XFxcImNhcnRcXFwiPjxkaXYgdi1pZj1cXFwic3RhdGUuY2FydC50b3RhbEl0ZW0gIT09IDBcXFwiPjxoMj5Zb3VyIENhcnQgSXRlbXM8L2gyPjx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtaG92ZXIgY2hlY2tvdXRcXFwiPjx0cj48dGggY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj5Oby48L3RoPjx0aCBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPk5hbWU8L3RoPjx0aCBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPlF0eS48L3RoPjx0aCBjbGFzcz1cXFwidGV4dC1yaWdodFxcXCI+UHJpY2U8L3RoPjx0aCBjbGFzcz1cXFwidGV4dC1yaWdodFxcXCI+VG90YWw8L3RoPjwvdHI+PHRyIHYtZm9yPVxcXCJpdGVtIGluIHN0YXRlLmNhcnQuYWxsXFxcIj48dGQgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj57eyAkaW5kZXggKyAxIH19PC90ZD48dGQgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj57eyBpdGVtLm5hbWUgfX0gLSB7eyBpdGVtLmNvbG9yIH19PC90ZD48dGQgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj57eyBpdGVtLmFtb3VudCB9fTwvdGQ+PHRkIGNsYXNzPVxcXCJ0ZXh0LXJpZ2h0XFxcIj57eyBpdGVtLnByaWNlIHwgcmVhZGFibGUtbnVtYmVyIH19PC90ZD48dGQgY2xhc3M9XFxcInRleHQtcmlnaHRcXFwiPnt7IGl0ZW0ucHJpY2UgKiBpdGVtLmFtb3VudCB8IHJlYWRhYmxlLW51bWJlciB9fTwvdGQ+PC90cj48dHI+PHRoIGNvbHNwYW49XFxcIjJcXFwiPlRvdGFsPC90aD48dGggY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj57eyBzdGF0ZS5jYXJ0LnRvdGFsSXRlbSB9fTwvdGg+PHRoPjwvdGg+PHRoIGNsYXNzPVxcXCJ0ZXh0LXJpZ2h0XFxcIj5ScC4ge3sgdG90YWwgfCByZWFkYWJsZS1udW1iZXIgfX08L3RoPjwvdHI+PC90YWJsZT48YnV0dG9uIEBjbGljaz1cXFwiY2hlY2tPdXRcXFwiIGNsYXNzPVxcXCJidG5cXFwiPkNoZWNrb3V0PC9idXR0b24+PC9kaXY+PGgyIHYtZWxzZT1cXFwiXFxcIj5Zb3UgaGF2ZW4ndCBib3VnaHQgc29tZXRoaW5nIHlldC4uLjwvaDI+PC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL3Zhci93d3cvZ2l0aHViL3Z1ZS1taW5pLXNob3AvYXNzZXRzL2pzL2NvbXBvbmVudHMvcGFnZXMvY2FydC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCAodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlKVxuICB9XG59KSgpfSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wcm9kdWN0ID0gcmVxdWlyZSgnLi4vcHJvZHVjdC9wcm9kdWN0LnZ1ZScpO1xuXG52YXIgX3Byb2R1Y3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvZHVjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcblxuICBjb21wb25lbnRzOiB7IHByb2R1Y3Q6IF9wcm9kdWN0Mi5kZWZhdWx0IH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBwcm9kdWN0czogZnVuY3Rpb24gcHJvZHVjdHMoKSB7XG4gICAgICB2YXIgY2F0ZWdvcnkgPSB0aGlzLiRyb3V0ZS5wYXJhbXMuY2F0ZWdvcnkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChjYXRlZ29yeSA9PT0gdW5kZWZpbmVkIHx8IGNhdGVnb3J5ID09PSBudWxsIHx8IGNhdGVnb3J5ID09PSAnJykgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfTtcblxuICAgICAgdmFyIHRoZVByb2R1Y3RzID0gW107XG4gICAgICB0aGlzLnN0YXRlLnByb2R1Y3QuYWxsLmZvckVhY2goZnVuY3Rpb24gKHByb2R1Y3QpIHtcbiAgICAgICAgdmFyIGluY2x1ZGVkID0gZmFsc2U7XG4gICAgICAgIHByb2R1Y3QuY2F0ZWdvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjYXQpIHtcbiAgICAgICAgICBjYXQgPSBjYXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoY2F0ID09IGNhdGVnb3J5KSBpbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5jbHVkZWQpIHRoZVByb2R1Y3RzLnB1c2gocHJvZHVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGVQcm9kdWN0cztcbiAgICB9XG4gIH1cblxufTtcbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiPGRpdj48cCBjbGFzcz1cXFwicmVzdWx0XFxcIj5UaGUgUmVzdWx0IG9mIENhdGVnb3J5IFxcXCJ7eyAkcm91dGUucGFyYW1zLmNhdGVnb3J5IH19XFxcIjwvcD48cHJvZHVjdCB2LWZvcj1cXFwicHJvZHVjdCBpbiBwcm9kdWN0c1xcXCIgdi1iaW5kOnByb2R1Y3Q9XFxcInByb2R1Y3RcXFwiPjwvcHJvZHVjdD48aDMgdi1pZj1cXFwicHJvZHVjdHMubGVuZ3RoID09IDBcXFwiIGNsYXNzPVxcXCJub3QtZm91bmQgdGV4dC1jZW50ZXJcXFwiPlNvcnJ5Li4uIFdlIGNhbid0IGZvdW5kIHRoZW0gOig8L2gzPjwvZGl2PlwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi92YXIvd3d3L2dpdGh1Yi92dWUtbWluaS1zaG9wL2Fzc2V0cy9qcy9jb21wb25lbnRzL3BhZ2VzL2NhdGVnb3J5LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3Byb2R1Y3QgPSByZXF1aXJlKCcuLi9wcm9kdWN0L3Byb2R1Y3QudnVlJyk7XG5cbnZhciBfcHJvZHVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9kdWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuXG4gIGNvbXBvbmVudHM6IHsgcHJvZHVjdDogX3Byb2R1Y3QyLmRlZmF1bHQgfSxcblxuICBjb21wdXRlZDoge1xuICAgIHByb2R1Y3Q6IGZ1bmN0aW9uIHByb2R1Y3QoKSB7XG4gICAgICB2YXIgcHJvZHVjdE5hbWUgPSB0aGlzLiRyb3V0ZS5wYXJhbXMucHJvZHVjdE5hbWU7XG4gICAgICB2YXIgdGhlUHJvZHVjdCA9IHRoaXMuc3RhdGUucHJvZHVjdC5hbGwuZmluZChmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgICAgICByZXR1cm4gcHJvZHVjdC5rZWJhYk5hbWUgPT0gcHJvZHVjdE5hbWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGVQcm9kdWN0O1xuICAgIH1cbiAgfVxuXG59O1xuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCI8ZGl2Pjxwcm9kdWN0IHYtYmluZDpwcm9kdWN0PVxcXCJwcm9kdWN0XFxcIj48L3Byb2R1Y3Q+PC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL3Zhci93d3cvZ2l0aHViL3Z1ZS1taW5pLXNob3AvYXNzZXRzL2pzL2NvbXBvbmVudHMvcGFnZXMvZGV0aWwudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gbW9kdWxlLmV4cG9ydHMub3B0aW9ucyA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcHJvZHVjdCA9IHJlcXVpcmUoJy4uL3Byb2R1Y3QvcHJvZHVjdC52dWUnKTtcblxudmFyIF9wcm9kdWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb2R1Y3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGNvbXBvbmVudHM6IHsgcHJvZHVjdDogX3Byb2R1Y3QyLmRlZmF1bHQgfVxufTtcbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiPGRpdj48cHJvZHVjdCA6cHJvZHVjdD1cXFwicHJvZHVjdFxcXCIgdi1mb3I9XFxcInByb2R1Y3QgaW4gc3RhdGUucHJvZHVjdC5hbGxcXFwiPjwvcHJvZHVjdD48L2Rpdj5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvdmFyL3d3dy9naXRodWIvdnVlLW1pbmktc2hvcC9hc3NldHMvanMvY29tcG9uZW50cy9wYWdlcy9ob21lLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3Byb2R1Y3QgPSByZXF1aXJlKCcuLi9wcm9kdWN0L3Byb2R1Y3QudnVlJyk7XG5cbnZhciBfcHJvZHVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9kdWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuXG4gIGNvbXBvbmVudHM6IHsgcHJvZHVjdDogX3Byb2R1Y3QyLmRlZmF1bHQgfSxcblxuICBjb21wdXRlZDoge1xuICAgIHByb2R1Y3RzOiBmdW5jdGlvbiBwcm9kdWN0cygpIHtcbiAgICAgIHZhciBxdWVyeSA9IHRoaXMuJHJvdXRlLnF1ZXJ5LnEudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChxdWVyeSA9PT0gdW5kZWZpbmVkIHx8IHF1ZXJ5ID09PSBudWxsIHx8IHF1ZXJ5ID09PSAnJykgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfTtcbiAgICAgIHZhciB0aGVQcm9kdWN0cyA9IFtdO1xuXG4gICAgICB0aGlzLnN0YXRlLnByb2R1Y3QuYWxsLmZvckVhY2goZnVuY3Rpb24gKHByb2R1Y3QpIHtcbiAgICAgICAgdmFyIGluY2x1ZGVkID0gcHJvZHVjdC5uYW1lLnNlYXJjaChuZXcgUmVnRXhwKCcoJyArIHF1ZXJ5ICsgJyknLCAnaWcnKSk7XG4gICAgICAgIGlmIChpbmNsdWRlZCAhPT0gLTEpIHRoZVByb2R1Y3RzLnB1c2gocHJvZHVjdCk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoZVByb2R1Y3RzO1xuICAgIH1cbiAgfVxuXG59O1xuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCI8ZGl2PjxwIGNsYXNzPVxcXCJyZXN1bHRcXFwiPlRoZSBSZXN1bHQgb2YgU2VhcmNoaW5nIFF1ZXJ5IFxcXCJ7eyAkcm91dGUucXVlcnkucSB9fVxcXCI8L3A+PHByb2R1Y3Qgdi1mb3I9XFxcInByb2R1Y3QgaW4gcHJvZHVjdHNcXFwiIHYtYmluZDpwcm9kdWN0PVxcXCJwcm9kdWN0XFxcIj48L3Byb2R1Y3Q+PGgzIHYtaWY9XFxcInByb2R1Y3RzLmxlbmd0aCA9PSAwXFxcIiBjbGFzcz1cXFwibm90LWZvdW5kIHRleHQtY2VudGVyXFxcIj5Tb3JyeS4uLiBXZSBjYW4ndCBmb3VuZCB0aGVtIDooPC9oMz48L2Rpdj5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvdmFyL3d3dy9naXRodWIvdnVlLW1pbmktc2hvcC9hc3NldHMvanMvY29tcG9uZW50cy9wYWdlcy9zZWFyY2gudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gbW9kdWxlLmV4cG9ydHMub3B0aW9ucyA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcHJvZHVjdCA9IHJlcXVpcmUoJy4uLy4uL3N0b3Jlcy9wcm9kdWN0LmpzJyk7XG5cbnZhciBfcHJvZHVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9kdWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBwcm9wczoge1xuICAgIHByb2R1Y3Q6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6IHt9XG4gICAgfSxcbiAgICBhZGRUb0NhcnRDYWxsYmFjazoge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9XG4gICAgfSxcbiAgICBjb2xvclNlbGVjdGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG5cbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hvd1NoYXJlTGlzdDogZmFsc2UsXG4gICAgICBhZGRUb0NhcnRDbGlja2VkOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cblxuICB3YXRjaDoge1xuICAgIGNvbG9yU2VsZWN0ZWQ6IGZ1bmN0aW9uIGNvbG9yU2VsZWN0ZWQodmFsLCBvbGQpIHtcbiAgICAgIGlmICh2YWwgPT09IGZhbHNlKSB0aGlzLmFkZFRvQ2FydENsaWNrZWQgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGxpa2VJdDogZnVuY3Rpb24gbGlrZUl0KCkge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHRoaXMuJGFjdGlvbigncHJvZHVjdDp0b2dnbGVfbGlrZScsIHsgcHJvZHVjdDogbWUucHJvZHVjdCB9KTtcbiAgICB9LFxuICAgIHRvZ2dsZVNoYXJlOiBmdW5jdGlvbiB0b2dnbGVTaGFyZSgpIHtcbiAgICAgIHRoaXMuc2hvd1NoYXJlTGlzdCA9ICF0aGlzLnNob3dTaGFyZUxpc3Q7XG4gICAgfSxcbiAgICBhZGRUb0NhcnQ6IGZ1bmN0aW9uIGFkZFRvQ2FydCgpIHtcbiAgICAgIHRoaXMuYWRkVG9DYXJ0Q2FsbGJhY2soKTtcbiAgICAgIHRoaXMuYWRkVG9DYXJ0Q2xpY2tlZCA9ICF0aGlzLmFkZFRvQ2FydENsaWNrZWQ7XG4gICAgfVxuICB9XG5cbn07XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG47KHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiPyBtb2R1bGUuZXhwb3J0cy5vcHRpb25zOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBcIjxkaXYgY2xhc3M9XFxcImFjdGlvbnNcXFwiPjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+PGdyaWQgeHM9XFxcIjhcXFwiPjxidXR0b24gQGNsaWNrPVxcXCJsaWtlSXRcXFwiIGNsYXNzPVxcXCJidG4gbG92ZSB7eyBwcm9kdWN0Lmxpa2VkID8gJ2xvdmVkJyA6ICcnIH19XFxcIj48aSBjbGFzcz1cXFwiaW9uLWlvcy1oZWFydFxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJtbC1zbWFsbFxcXCI+e3sgcHJvZHVjdC5saWtlZCA/ICdVbmxpa2UnIDogJ0xpa2UnIH19PC9zcGFuPjwvYnV0dG9uPjxkaXYgY2xhc3M9XFxcInBzciBkaWJcXFwiPjxidXR0b24gQGNsaWNrPVxcXCJ0b2dnbGVTaGFyZVxcXCIgY2xhc3M9XFxcImJ0biBzaGFyZSBtbC1zbWFsbFxcXCI+PGkgY2xhc3M9XFxcImlvbi1hbmRyb2lkLXNoYXJlLWFsdFxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJtbC1zbWFsbFxcXCI+U2hhcmU8L3NwYW4+PC9idXR0b24+PGRpdiB2LWlmPVxcXCJzaG93U2hhcmVMaXN0XFxcIiB2LWNsaWNrLW91dHNpZGU6ZGVsYXk9XFxcInRvZ2dsZVNoYXJlXFxcIiBjbGFzcz1cXFwic2hhcmUtbGlzdCBhbmltYXRlZCBib3VuY2VJblxcXCI+PGEgaHJlZj1cXFwiaHR0cDovL3R3aXR0ZXIuY29tL2hvbWU/c3RhdHVzPUNoZWNrIHRoZSBWdWUgTWluaSBTaG9wIE91dCEgSXQncyBlaXRoZXIgZXhhbXBsZSBBcHAsIGJ1aWx0IHdpdGggVnVlIGpzIGh0dHBzOi8vYm9zbmF1ZmFsLmdpdGh1Yi5pby92dWUtbWluaS1zaG9wICN2dWVqcyAjamF2YXNjcmlwdCAjZ2l0aHViXFxcIiBjbGFzcz1cXFwidHdpdHRlclxcXCI+PGkgY2xhc3M9XFxcImlvbi1zb2NpYWwtdHdpdHRlclxcXCI+PC9pPjxzcGFuPlR3aXR0ZXI8L3NwYW4+PC9hPjxhIGhyZWY9XFxcImh0dHA6Ly93d3cuZmFjZWJvb2suY29tL3NoYXJlLnBocD91PWh0dHBzOi8vYm9zbmF1ZmFsLmdpdGh1Yi5pby92dWUtbWluaS1zaG9wXFxcIj48aSBjbGFzcz1cXFwiaW9uLXNvY2lhbC1mYWNlYm9va1xcXCI+PC9pPjxzcGFuPkZhY2Vib29rPC9zcGFuPjwvYT48L2Rpdj48L2Rpdj48L2dyaWQ+PGdyaWQgeHM9XFxcIjRcXFwiIGNsYXNzZXM9XFxcInRleHQtcmlnaHRcXFwiPjxidXR0b24gQGNsaWNrPVxcXCJhZGRUb0NhcnRcXFwiIGNsYXNzPVxcXCJwc3IgYnRuIGJ1eVxcXCI+e3sgYWRkVG9DYXJ0Q2xpY2tlZCA/ICdDaG9vc2UgVGhlIENvbG9yJyA6ICdBZGQgVG8gQ2FydCcgfX08L2J1dHRvbj48L2dyaWQ+PC9kaXY+PC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL3Zhci93d3cvZ2l0aHViL3Z1ZS1taW5pLXNob3AvYXNzZXRzL2pzL2NvbXBvbmVudHMvcHJvZHVjdC9hY3Rpb25zLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBwcm9wczoge1xuICAgIHNlbGVjdGVkQ2FsbGJhY2s6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fVxuICAgIH0sXG4gICAgcHJvZHVjdDoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDoge31cbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGNvbG9yU2VsZWN0ZWQ6IGZ1bmN0aW9uIGNvbG9yU2VsZWN0ZWQoc3RvY2spIHtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIG1lLnNlbGVjdGVkQ2FsbGJhY2soKTtcblxuICAgICAgdGhpcy4kYWN0aW9uKCdjYXJ0OmFkZF9pdGVtJywge1xuICAgICAgICBwcm9kdWN0OiBtZS5wcm9kdWN0LFxuICAgICAgICBjb2xvcjogc3RvY2suY29sb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbjsodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCI/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnM6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IFwiPGRpdiBjbGFzcz1cXFwiY29sb3JzXFxcIj48YnV0dG9uIHYtZm9yPVxcXCJzdG9jayBpbiBwcm9kdWN0LnN0b2Nrc1xcXCIgQGNsaWNrPVxcXCJjb2xvclNlbGVjdGVkKHN0b2NrKVxcXCIgdi1pZj1cXFwic3RvY2suc3RvY2sgIT09IDBcXFwiIGNsYXNzPVxcXCJidG5cXFwiPnt7IHN0b2NrLmNvbG9yIH19PHNwYW4+e3sgc3RvY2suc3RvY2sgfX08L3NwYW4+PC9idXR0b24+PC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL3Zhci93d3cvZ2l0aHViL3Z1ZS1taW5pLXNob3AvYXNzZXRzL2pzL2NvbXBvbmVudHMvcHJvZHVjdC9jb2xvcnMudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gbW9kdWxlLmV4cG9ydHMub3B0aW9ucyA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcblxuICBwcm9wczoge1xuICAgIHByb2R1Y3Q6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6IHt9XG4gICAgfVxuICB9LFxuXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1lbnQ6IFwiXCJcbiAgICB9O1xuICB9LFxuXG5cbiAgbWV0aG9kczoge1xuICAgIHN1Ym1pdDogZnVuY3Rpb24gc3VibWl0KCkge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHRoaXMuJGFjdGlvbigncHJvZHVjdDphZGRfY29tbWVudCcsIHtcbiAgICAgICAgcHJvZHVjdDogbWUucHJvZHVjdCxcbiAgICAgICAgY29udGVudDogbWUuY29tbWVudFxuICAgICAgfSk7XG4gICAgICBtZS5jb21tZW50ID0gXCJcIjtcbiAgICB9IC8vc3VibWl0KClcblxuICB9XG59O1xuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCI8ZGl2IGNsYXNzPVxcXCJjb21tZW50LWVkaXRvclxcXCI+PGg0IGNsYXNzPVxcXCJtYi0xNVxcXCI+TGVhdmUgYSBDb21tZW50PC9oND48Zm9ybSBAc3VibWl0LnByZXZlbnQ9XFxcInN1Ym1pdFxcXCI+PHRleHRhcmVhIHYtbW9kZWw9XFxcImNvbW1lbnRcXFwiIHBsYWNlaG9sZGVyPVxcXCJXcml0ZSBhIGNvbW1lbnQgaGVyZS4uLlxcXCI+PC90ZXh0YXJlYT48YnV0dG9uIHR5cGU9XFxcInN1Ym1pdFxcXCIgY2xhc3M9XFxcImJ0blxcXCI+U3VibWl0PC9idXR0b24+PC9mb3JtPjwvZGl2PlwiXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIHRydWUpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIi92YXIvd3d3L2dpdGh1Yi92dWUtbWluaS1zaG9wL2Fzc2V0cy9qcy9jb21wb25lbnRzL3Byb2R1Y3QvY29tbWVudC1lZGl0b3IudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gbW9kdWxlLmV4cG9ydHMub3B0aW9ucyA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG5cbiAgcHJvcHM6IHtcbiAgICBwcm9kdWN0OiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiB7fVxuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgZGVsZXRlX2NvbW1lbnQ6IGZ1bmN0aW9uIGRlbGV0ZV9jb21tZW50KGNvbW1lbnQpIHtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB0aGlzLiRhY3Rpb24oJ3Byb2R1Y3Q6ZGVsZXRlX2NvbW1lbnQnLCB7XG4gICAgICAgIHByb2R1Y3Q6IG1lLnByb2R1Y3QsXG4gICAgICAgIGNvbW1lbnQ6IGNvbW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG59O1xuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCI8ZGl2IHYtaWY9XFxcInByb2R1Y3QuY29tbWVudHMubGVuZ3RoICE9PSAwXFxcIiBjbGFzcz1cXFwiY29tbWVudC13cmFwcGVyXFxcIj48aDQ+e3sgcHJvZHVjdC5jb21tZW50cy5sZW5ndGggfX0gQ29tbWVudHM8L2g0PjxkaXYgdi1mb3I9XFxcImNvbW1lbnQgaW4gcHJvZHVjdC5jb21tZW50c1xcXCIgY2xhc3M9XFxcImNvbW1lbnRcXFwiPjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+PGdyaWQgeHM9XFxcIjJcXFwiPjxkaXYgY2xhc3M9XFxcImF2YXRhclxcXCI+PC9kaXY+PC9ncmlkPjxncmlkIHhzPVxcXCIxMFxcXCIgY2xhc3Nlcz1cXFwicGwtc21hbGxcXFwiPjxoNSBjbGFzcz1cXFwibmFtZVxcXCI+WW91PC9oNT48cCBjbGFzcz1cXFwiY29udGVudFxcXCI+PGJ1dHRvbiBAY2xpY2s9XFxcImRlbGV0ZV9jb21tZW50KCBjb21tZW50IClcXFwiIGNsYXNzPVxcXCJkZWxldGVcXFwiPjxpIGNsYXNzPVxcXCJpb24tYW5kcm9pZC1jbG9zZVxcXCI+PC9pPjwvYnV0dG9uPnt7IGNvbW1lbnQuY29udGVudCB9fTwvcD48L2dyaWQ+PC9kaXY+PC9kaXY+PC9kaXY+XCJcbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgdHJ1ZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiL3Zhci93d3cvZ2l0aHViL3Z1ZS1taW5pLXNob3AvYXNzZXRzL2pzL2NvbXBvbmVudHMvcHJvZHVjdC9jb21tZW50LnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUpXG4gIH1cbn0pKCl9IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NvbG9ycyA9IHJlcXVpcmUoJy4vY29sb3JzLnZ1ZScpO1xuXG52YXIgX2NvbG9yczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2xvcnMpO1xuXG52YXIgX2FjdGlvbnMgPSByZXF1aXJlKCcuL2FjdGlvbnMudnVlJyk7XG5cbnZhciBfYWN0aW9uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hY3Rpb25zKTtcblxudmFyIF9jb21tZW50ID0gcmVxdWlyZSgnLi9jb21tZW50LnZ1ZScpO1xuXG52YXIgX2NvbW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tbWVudCk7XG5cbnZhciBfY29tbWVudEVkaXRvciA9IHJlcXVpcmUoJy4vY29tbWVudC1lZGl0b3IudnVlJyk7XG5cbnZhciBfY29tbWVudEVkaXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21tZW50RWRpdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuXG4gIHByb3BzOiB7XG4gICAgcHJvZHVjdDoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDoge31cbiAgICB9XG4gIH0sXG5cbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hvd0NvbG9yOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cblxuICBjb21wb25lbnRzOiB7XG4gICAgY29sb3JzOiBfY29sb3JzMi5kZWZhdWx0LFxuICAgIGFjdGlvbnM6IF9hY3Rpb25zMi5kZWZhdWx0LFxuICAgIGNvbW1lbnQ6IF9jb21tZW50Mi5kZWZhdWx0LFxuICAgIGNvbW1lbnRFZGl0b3I6IF9jb21tZW50RWRpdG9yMi5kZWZhdWx0XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICB0b3RhbFN0b2NrOiBmdW5jdGlvbiB0b3RhbFN0b2NrKCkge1xuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIHRoaXMucHJvZHVjdC5zdG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB0b3RhbCArPSBpdGVtLnN0b2NrO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdG90YWw7XG4gICAgfSxcbiAgICBkZXRpbFBhZ2U6IGZ1bmN0aW9uIGRldGlsUGFnZSgpIHtcbiAgICAgIGlmICh0aGlzLiRyb3V0ZS5wYXRoLnNlYXJjaCgvXFwvcHJvZHVjdFxcLy9pZykgPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgYWRkVG9DYXJ0Q2FsbGJhY2s6IGZ1bmN0aW9uIGFkZFRvQ2FydENhbGxiYWNrKCkge1xuICAgICAgdGhpcy5zaG93Q29sb3IgPSAhdGhpcy5zaG93Q29sb3I7XG4gICAgfSxcbiAgICBjb2xvclNlbGVjdGVkOiBmdW5jdGlvbiBjb2xvclNlbGVjdGVkKGNvbG9yKSB7XG4gICAgICB0aGlzLnNob3dDb2xvciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG59O1xuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCI8ZGl2IHYtYmluZDpjbGFzcz1cXFwieyAnZGV0aWwtcGFnZSc6IGRldGlsUGFnZSB9XFxcIiBjbGFzcz1cXFwicHJvZHVjdFxcXCI+PGRpdiBjbGFzcz1cXFwiaW1nXFxcIj48YSBocmVmPVxcXCIjIS9wcm9kdWN0L3t7IHByb2R1Y3Qua2ViYWJOYW1lIH19XFxcIj48aW1nIDpzcmM9XFxcInByb2R1Y3QuaW1nXFxcIi8+PC9hPjwvZGl2PjxkaXYgY2xhc3M9XFxcImNvbnRlbnRcXFwiPjxhIGhyZWY9XFxcIiMhL3Byb2R1Y3Qve3sgcHJvZHVjdC5rZWJhYk5hbWUgfX1cXFwiIGNsYXNzPVxcXCJuYW1lXFxcIj57eyBwcm9kdWN0Lm5hbWUgfX08L2E+PHAgY2xhc3M9XFxcInByaWNlXFxcIj48Yj5ScC4ge3sgcHJvZHVjdC5wcmljZSB8IHJlYWRhYmxlLW51bWJlciB9fTwvYj48L3A+PHAgY2xhc3M9XFxcInN0b2NrIHRleHQtcmlnaHRcXFwiPjxiPlN0b2Nrczo8L2I+PHNwYW4+Jm5ic3A7IHt7IHRvdGFsU3RvY2sgfX0gcGNzPC9zcGFuPjwvcD48L2Rpdj48ZGl2IHYtaWY9XFxcImRldGlsUGFnZVxcXCIgY2xhc3M9XFxcImRldGlsXFxcIj57e3sgcHJvZHVjdC5kZXRhaWwgfX19PC9kaXY+PGNvbG9ycyB2LWlmPVxcXCJzaG93Q29sb3JcXFwiIHYtYmluZDpwcm9kdWN0PVxcXCJwcm9kdWN0XFxcIiB2LWJpbmQ6c2VsZWN0ZWQtY2FsbGJhY2s9XFxcImNvbG9yU2VsZWN0ZWRcXFwiPjwvY29sb3JzPjxhY3Rpb25zIHYtYmluZDpwcm9kdWN0PVxcXCJwcm9kdWN0XFxcIiB2LWJpbmQ6YWRkLXRvLWNhcnQtY2FsbGJhY2s9XFxcImFkZFRvQ2FydENhbGxiYWNrXFxcIiB2LWJpbmQ6Y29sb3Itc2VsZWN0ZWQ9XFxcInNob3dDb2xvclxcXCI+PC9hY3Rpb25zPjxjb21tZW50IHYtaWY9XFxcImRldGlsUGFnZVxcXCIgdi1iaW5kOnByb2R1Y3Q9XFxcInByb2R1Y3RcXFwiPjwvY29tbWVudD48Y29tbWVudC1lZGl0b3Igdi1pZj1cXFwiZGV0aWxQYWdlXFxcIiB2LWJpbmQ6cHJvZHVjdD1cXFwicHJvZHVjdFxcXCI+PC9jb21tZW50LWVkaXRvcj48L2Rpdj5cIlxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCB0cnVlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCIvdmFyL3d3dy9naXRodWIvdnVlLW1pbmktc2hvcC9hc3NldHMvanMvY29tcG9uZW50cy9wcm9kdWN0L3Byb2R1Y3QudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gbW9kdWxlLmV4cG9ydHMub3B0aW9ucyA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSlcbiAgfVxufSkoKX0iLCIvKiEgQ29weXJpZ2h0IChjKSAyMDE2IE5hdWZhbCBSYWJiYW5pIChodHRwOi8vZ2l0aHViLmNvbS9Cb3NOYXVmYWwpXG4qIExpY2Vuc2VkIFVuZGVyIE1JVCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbipcbiogVnVlIENsaWNrIE91dHNpZGUgLSBWZXJzaW9uQDEuMC4wXG4qXG4qL1xuXG4vLyBEaXJlY3RpdmUgZm9yIG91dHNpZGUgY2xpY2sgZGV0ZWN0aW9uc1xuZXhwb3J0IGRlZmF1bHQge1xuXG4gIHRpbWU6IDAsIC8vIG5lZWQgYSBkZWxheSB3aGVuIGl0IGNvbWUgdG9nZXRoZXIgd2l0aCAndi1pZidcblxuICBiaW5kKCl7XG4gICAgbGV0IG1lID0gdGhpc1xuXG4gICAgLy8gbWFrZSBhIGV2ZW50IGhhbmRsZXIgZm9yIGNsaWNrIGV2ZW50XG4gICAgdGhpcy5ldnQgPSAoZSkgPT4ge1xuXG4gICAgICAvLyBEZWxheSB0byBsZXQgVnVlIGV2YWx1YXRlIHYtaWYgZGlyZWN0aXZlXG4gICAgICBpZihtZS5hcmcgPT0gJ2RlbGF5Jyl7XG4gICAgICAgIG1lLnRpbWUrK1xuICAgICAgICBpZihtZS50aW1lID4gMSl7IC8vIGlmICd2LWlmJyBoYXMgYmVlbiBldmF1bGF0ZWRcbiAgICAgICAgICAvLyB0aGVuIGNoZWNrIHRoZSBjdXJyZW50IGNsaWNrIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAgLy8gaWYgc2FtZSB3aXRoIGRpcmVjdGl2ZSBlbGVtZW50LFxuICAgICAgICAgIC8vIGNhbGwgZnVuY3Rpb24gZnJvbSB2bSB3aGljaCBpcyBoYXMgYSBzYW1lIG5hbWUgd2l0aCB0aGUgZGlyZWN0aXZlIGV4cHJlc3Npb25cbiAgICAgICAgICBpZihlLnRhcmdldCAhPSBtZS5lbCkgbWUudm0uJGV2YWwobWUuZXhwcmVzc2lvbikoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGRlbGF5LCB1c3VhbGx5IG5vdCBmb2xsb3dlZCBieSB2LWlmLCB2LXNob3csIHYtY2xvYWsgZGlyZWN0aXZlXG4gICAgICBlbHNle1xuICAgICAgICBpZihlLnRhcmdldCAhPSBtZS5lbCkgbWUudm0uJGV2YWwobWUuZXhwcmVzc2lvbikoKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBBdHRhY2ggRXZlbnQgTGlzdGVuZXIgdG8gYm9keVxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLHRoaXMuZXZ0LCBmYWxzZSlcbiAgfSxcblxuICB1bmJpbmQoKXtcbiAgICAvLyBSZW1vdmUgRXZlbnQgTGlzdGVuZXIgZnJvbSBib2R5XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsdGhpcy5ldnQsIGZhbHNlKVxuICB9XG59O1xuIiwiLyohIENvcHlyaWdodCAoYykgMjAxNiBOYXVmYWwgUmFiYmFuaSAoaHR0cDovL2dpdGh1Yi5jb20vQm9zTmF1ZmFsKVxuKiBMaWNlbnNlZCBVbmRlciBNSVQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4qXG4qIFZ1ZSBSZWFkYWJsZSBOdW1iZXIgLSBWZXJzaW9uQDEuMC4wXG4qXG4qL1xuZXhwb3J0IGRlZmF1bHQge1xuXG5cdC8vIEJlY29tZSBSZWFkYWJsZSBOdW1iZXIgaW4gVmlld3Ncblx0cmVhZDogZnVuY3Rpb24odmFsKSB7XG5cblx0ICAvLyBQcmV2ZW50IGZhbGxpbmcgaW4gdW5kZWZpbmVkIHZhbHVlXG5cdCAgaWYodmFsID09PSAnJyB8fCB2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IE5hTiApIHJldHVybiAwO1xuXG5cdCAgLy8gaWYgdGhlcmUncyBhIHRydXRoeSB2YWx1ZS4uXG5cdCAgaWYodmFsKXtcblxuXHQgICAgLy8gSWYgdGhlIG51bWJlciBpcyBzdHJpbmcuLlxuXHQgICAgaWYodHlwZW9mIHZhbCA9PSAnc3RyaW5nJykge1xuXHQgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXjAvaWcsJycpOyAvLyBSZW1vdmUgZmlyc3QgXCIwXCJcblx0ICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcRC9pZywnJyk7IC8vIFJlbW92ZSBOb24gZGlnaXQgQ2hhclxuXHQgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXFxXL2lnLCcnKTsgLy8gUmVtb3ZlIE5vbiBXb3JkIENoYXJcblx0ICAgIH1cblxuXHQgICAgLy8gTWFrZSBhIFJlZ2V4XG5cdCAgICB2YXIgcmUgPSAvXFxkezEsM30vZzsgLy8gZ3JvdXBpbmcgZWFjaCAzIGRpZ2l0XG5cdCAgICB2YXIgdGFyZ2V0ID0gdmFsLnRvU3RyaW5nKCk7XG5cdCAgICB2YXIgbWF0Y2h5O1xuXG5cdCAgICAvLyBtYWtlIGFuIGFycmF5IGZvciBtYXRjaHkgc3RyaW5nXG5cdCAgICB2YXIgYXJyID0gW107XG5cdCAgICB3aGlsZSgobWF0Y2h5ID0gcmUuZXhlYyh0YXJnZXQpKSAhPT0gbnVsbCl7XG5cdCAgICAgIGFyci5wdXNoKG1hdGNoeVswXS5sZW5ndGgpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBDb252ZXJ0IFN0cmluZyB0byBBcnJheVxuXHQgICAgdmFyIHN0cmluZyA9IHRhcmdldC5zcGxpdCgnJyk7XG5cblx0ICAgIC8vIEFkZCBhIGNvbW1hIGV2ZXJ5IHRocmVlIGRpZ2l0IGZyb20gYmFja1xuXHQgICAgYXJyLnNwbGljZShhcnIubGVuZ3RoLTEpOyAvLyByZW1vdmUgYnVnZ3kgZmlyc3QgY29tbWFcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciB0aW1lID0gYXJyW2ldO1xuXHQgICAgICB2YXIgcG9zaXRpb24gPSBpKih0aW1lKzEpO1xuXHQgICAgICBzdHJpbmcuc3BsaWNlKHN0cmluZy5sZW5ndGgtcG9zaXRpb24tdGltZSwwLCcsJyk7XG5cdFx0XHR9XG5cblx0ICAgIC8vIGpvaW4gQXJyYXlcblx0ICAgIHJldHVybiBzdHJpbmcuam9pbignJyk7XG5cdCAgfVxuXG5cdFx0Ly8gUHJldmVudCBmYWxsaW5nIGluIHVuZGVmaW5lZCB2YWx1ZVxuXHRcdHJldHVybiB2YWw7XG5cdH0sXG5cblx0Ly8gVHdvIFdheSBGaWx0ZXIuLi5cblx0Ly8gYmVjb21lIGEgaW50ZWdlciBpbiB2LW1vZGVsXG5cdHdyaXRlOiBmdW5jdGlvbih2YWwpIHtcblx0ICAvLyBQcmV2ZW50IGZhbGxpbmcgaW4gdW5kZWZpbmVkIHZhbHVlXG5cdCAgaWYodmFsID09PSAnJyB8fCB2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IE5hTiApIHJldHVybiAwO1xuXG5cdFx0Ly8gbWFrZSBzdXJlIHRoZSB2YWwgaXMgc3RyaW5nXG5cdCAgaWYodHlwZW9mIHZhbCA9PSAnc3RyaW5nJykge1xuXHQgICAgLy8gcmVtb3ZlIG5vbiBXb3JkIENoYXJhY3RlclxuXHQgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcVy9pZywnJyk7XG5cdCAgfVxuXHQgIC8vIE1ha2Ugc3VyZSBpdCByZXR1cm4gYSByZWFsIGludGVnZXJcblx0ICByZXR1cm4gcGFyc2VGbG9hdCh2YWwpO1xuXHR9XG5cbn07XG4iLCIvKiFcbiAqIHZ1ZS1yb3V0ZXIgdjAuNy41XG4gKiAoYykgMjAxNSBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4hZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLlZ1ZVJvdXRlcj1lKCk6dC5WdWVSb3V0ZXI9ZSgpfSh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUocil7aWYobltyXSlyZXR1cm4gbltyXS5leHBvcnRzO3ZhciBvPW5bcl09e2V4cG9ydHM6e30saWQ6cixsb2FkZWQ6ITF9O3JldHVybiB0W3JdLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLGUpLG8ubG9hZGVkPSEwLG8uZXhwb3J0c312YXIgbj17fTtyZXR1cm4gZS5tPXQsZS5jPW4sZS5wPVwiXCIsZSgwKX0oW2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQsZSl7dmFyIG49ZS5jb21wb25lbnQ7QS51dGlsLmlzUGxhaW5PYmplY3QobikmJihuPWUuY29tcG9uZW50PUEuZXh0ZW5kKG4pKSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBuJiYoZS5jb21wb25lbnQ9bnVsbCxhLndhcm4oJ2ludmFsaWQgY29tcG9uZW50IGZvciByb3V0ZSBcIicrdCsnXCIuJykpfXZhciBvPW4oMSlbXCJkZWZhdWx0XCJdLGk9bigyKVtcImRlZmF1bHRcIl07ZS5fX2VzTW9kdWxlPSEwO3ZhciBhPW4oMykscz1pKGEpLHU9big3KSxjPWkodSksaD1uKDQpLGw9aShoKSxmPW4oOCkscD1pKGYpLGQ9bigxOCksdj1pKGQpLGc9bigyOCkseT1pKGcpLG09bigyOSksXz1pKG0pLHc9bigzMCksYj1pKHcpLHg9bigzMSksQz1pKHgpLFI9bigzMiksUD1pKFIpLEU9e1wiYWJzdHJhY3RcIjpiW1wiZGVmYXVsdFwiXSxoYXNoOkNbXCJkZWZhdWx0XCJdLGh0bWw1OlBbXCJkZWZhdWx0XCJdfSxBPXZvaWQgMCwkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg8PTB8fHZvaWQgMD09PWFyZ3VtZW50c1swXT97fTphcmd1bWVudHNbMF0sbj1lLmhhc2hiYW5nLHI9dm9pZCAwPT09bj8hMDpuLGk9ZVtcImFic3RyYWN0XCJdLGE9dm9pZCAwPT09aT8hMTppLHM9ZS5oaXN0b3J5LHU9dm9pZCAwPT09cz8hMTpzLGM9ZS5zYXZlU2Nyb2xsUG9zaXRpb24saD12b2lkIDA9PT1jPyExOmMsZj1lLnRyYW5zaXRpb25PbkxvYWQscD12b2lkIDA9PT1mPyExOmYsZD1lLnN1cHByZXNzVHJhbnNpdGlvbkVycm9yLHY9dm9pZCAwPT09ZD8hMTpkLGc9ZS5yb290LHk9dm9pZCAwPT09Zz9udWxsOmcsbT1lLmxpbmtBY3RpdmVDbGFzcyxfPXZvaWQgMD09PW0/XCJ2LWxpbmstYWN0aXZlXCI6bTtpZihvKHRoaXMsdCksIXQuaW5zdGFsbGVkKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBpbnN0YWxsIHRoZSBSb3V0ZXIgd2l0aCBWdWUudXNlKCkgYmVmb3JlIGNyZWF0aW5nIGFuIGluc3RhbmNlLlwiKTt0aGlzLmFwcD1udWxsLHRoaXMuX3ZpZXdzPVtdLHRoaXMuX2NoaWxkcmVuPVtdLHRoaXMuX3JlY29nbml6ZXI9bmV3IGxbXCJkZWZhdWx0XCJdLHRoaXMuX2d1YXJkUmVjb2duaXplcj1uZXcgbFtcImRlZmF1bHRcIl0sdGhpcy5fc3RhcnRlZD0hMSx0aGlzLl9zdGFydENiPW51bGwsdGhpcy5fY3VycmVudFJvdXRlPXt9LHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uPW51bGwsdGhpcy5fcHJldmlvdXNUcmFuc2l0aW9uPW51bGwsdGhpcy5fbm90Rm91bmRIYW5kbGVyPW51bGwsdGhpcy5fbm90Rm91bmRSZWRpcmVjdD1udWxsLHRoaXMuX2JlZm9yZUVhY2hIb29rcz1bXSx0aGlzLl9hZnRlckVhY2hIb29rcz1bXSx0aGlzLl9oYXNQdXNoU3RhdGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93Lmhpc3RvcnkmJndpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSx0aGlzLl9yZW5kZXJlZD0hMSx0aGlzLl90cmFuc2l0aW9uT25Mb2FkPXAsdGhpcy5fYWJzdHJhY3Q9YSx0aGlzLl9oYXNoYmFuZz1yLHRoaXMuX2hpc3Rvcnk9dGhpcy5faGFzUHVzaFN0YXRlJiZ1LHRoaXMuX3NhdmVTY3JvbGxQb3NpdGlvbj1oLHRoaXMuX2xpbmtBY3RpdmVDbGFzcz1fLHRoaXMuX3N1cHByZXNzPXY7dmFyIHc9QS51dGlsLmluQnJvd3Nlcjt0aGlzLm1vZGU9IXd8fHRoaXMuX2Fic3RyYWN0P1wiYWJzdHJhY3RcIjp0aGlzLl9oaXN0b3J5P1wiaHRtbDVcIjpcImhhc2hcIjt2YXIgYj1FW3RoaXMubW9kZV0seD10aGlzO3RoaXMuaGlzdG9yeT1uZXcgYih7cm9vdDp5LGhhc2hiYW5nOnRoaXMuX2hhc2hiYW5nLG9uQ2hhbmdlOmZ1bmN0aW9uKHQsZSxuKXt4Ll9tYXRjaCh0LGUsbil9fSl9cmV0dXJuIHQucHJvdG90eXBlLm1hcD1mdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gdCl0aGlzLm9uKGUsdFtlXSl9LHQucHJvdG90eXBlLm9uPWZ1bmN0aW9uKHQsZSl7XCIqXCI9PT10P3RoaXMuX25vdEZvdW5kKGUpOnRoaXMuX2FkZFJvdXRlKHQsZSxbXSl9LHQucHJvdG90eXBlLnJlZGlyZWN0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0KXRoaXMuX2FkZFJlZGlyZWN0KGUsdFtlXSl9LHQucHJvdG90eXBlLmFsaWFzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0KXRoaXMuX2FkZEFsaWFzKGUsdFtlXSl9LHQucHJvdG90eXBlLmJlZm9yZUVhY2g9ZnVuY3Rpb24odCl7dGhpcy5fYmVmb3JlRWFjaEhvb2tzLnB1c2godCl9LHQucHJvdG90eXBlLmFmdGVyRWFjaD1mdW5jdGlvbih0KXt0aGlzLl9hZnRlckVhY2hIb29rcy5wdXNoKHQpfSx0LnByb3RvdHlwZS5nbz1mdW5jdGlvbih0KXt2YXIgZT0hMSxuPSExO0EudXRpbC5pc09iamVjdCh0KSYmKGU9dC5yZXBsYWNlLG49dC5hcHBlbmQpLHQ9dGhpcy5fc3RyaW5naWZ5UGF0aCh0KSx0JiZ0aGlzLmhpc3RvcnkuZ28odCxlLG4pfSx0LnByb3RvdHlwZS5yZXBsYWNlPWZ1bmN0aW9uKHQpe3RoaXMuZ28oe3BhdGg6dCxyZXBsYWNlOiEwfSl9LHQucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLl9zdGFydGVkKXJldHVybiB2b2lkIGEud2FybihcImFscmVhZHkgc3RhcnRlZC5cIik7aWYodGhpcy5fc3RhcnRlZD0hMCx0aGlzLl9zdGFydENiPW4sIXRoaXMuYXBwKXtpZighdHx8IWUpdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzdGFydCB2dWUtcm91dGVyIHdpdGggYSBjb21wb25lbnQgYW5kIGEgcm9vdCBjb250YWluZXIuXCIpO3RoaXMuX2FwcENvbnRhaW5lcj1lO3ZhciByPXRoaXMuX2FwcENvbnN0cnVjdG9yPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dDpBLmV4dGVuZCh0KTtyLm9wdGlvbnMubmFtZT1yLm9wdGlvbnMubmFtZXx8XCJSb3V0ZXJBcHBcIn10aGlzLmhpc3Rvcnkuc3RhcnQoKX0sdC5wcm90b3R5cGUuc3RvcD1mdW5jdGlvbigpe3RoaXMuaGlzdG9yeS5zdG9wKCksdGhpcy5fc3RhcnRlZD0hMX0sdC5wcm90b3R5cGUuX2FkZFJvdXRlPWZ1bmN0aW9uKHQsZSxuKXtpZihyKHQsZSksZS5wYXRoPXQsZS5mdWxsUGF0aD0obi5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlLnBhdGh9LFwiXCIpK3QpLnJlcGxhY2UoXCIvL1wiLFwiL1wiKSxuLnB1c2goe3BhdGg6dCxoYW5kbGVyOmV9KSx0aGlzLl9yZWNvZ25pemVyLmFkZChuLHthczplLm5hbWV9KSxlLnN1YlJvdXRlcylmb3IodmFyIG8gaW4gZS5zdWJSb3V0ZXMpdGhpcy5fYWRkUm91dGUobyxlLnN1YlJvdXRlc1tvXSxuLnNsaWNlKCkpfSx0LnByb3RvdHlwZS5fbm90Rm91bmQ9ZnVuY3Rpb24odCl7cihcIipcIix0KSx0aGlzLl9ub3RGb3VuZEhhbmRsZXI9W3toYW5kbGVyOnR9XX0sdC5wcm90b3R5cGUuX2FkZFJlZGlyZWN0PWZ1bmN0aW9uKHQsZSl7XCIqXCI9PT10P3RoaXMuX25vdEZvdW5kUmVkaXJlY3Q9ZTp0aGlzLl9hZGRHdWFyZCh0LGUsdGhpcy5yZXBsYWNlKX0sdC5wcm90b3R5cGUuX2FkZEFsaWFzPWZ1bmN0aW9uKHQsZSl7dGhpcy5fYWRkR3VhcmQodCxlLHRoaXMuX21hdGNoKX0sdC5wcm90b3R5cGUuX2FkZEd1YXJkPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzO3RoaXMuX2d1YXJkUmVjb2duaXplci5hZGQoW3twYXRoOnQsaGFuZGxlcjpmdW5jdGlvbih0LG8pe3ZhciBpPWEubWFwUGFyYW1zKGUsdC5wYXJhbXMsbyk7bi5jYWxsKHIsaSl9fV0pfSx0LnByb3RvdHlwZS5fY2hlY2tHdWFyZD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9ndWFyZFJlY29nbml6ZXIucmVjb2duaXplKHQpO3JldHVybiBlPyhlWzBdLmhhbmRsZXIoZVswXSxlLnF1ZXJ5UGFyYW1zKSwhMCk6dGhpcy5fbm90Rm91bmRSZWRpcmVjdCYmKGU9dGhpcy5fcmVjb2duaXplci5yZWNvZ25pemUodCksIWUpPyh0aGlzLnJlcGxhY2UodGhpcy5fbm90Rm91bmRSZWRpcmVjdCksITApOnZvaWQgMH0sdC5wcm90b3R5cGUuX21hdGNoPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzO2lmKCF0aGlzLl9jaGVja0d1YXJkKHQpKXt2YXIgbz10aGlzLl9jdXJyZW50Um91dGUsaT10aGlzLl9jdXJyZW50VHJhbnNpdGlvbjtpZihpKXtpZihpLnRvLnBhdGg9PT10KXJldHVybjtpZihvLnBhdGg9PT10KXJldHVybiBpLmFib3J0ZWQ9ITAsdm9pZCh0aGlzLl9jdXJyZW50VHJhbnNpdGlvbj10aGlzLl9wcmV2VHJhbnNpdGlvbik7aS5hYm9ydGVkPSEwfXZhciBhPW5ldyBwW1wiZGVmYXVsdFwiXSh0LHRoaXMpLHM9bmV3IHZbXCJkZWZhdWx0XCJdKHRoaXMsYSxvKTt0aGlzLl9wcmV2VHJhbnNpdGlvbj1pLHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uPXMsdGhpcy5hcHB8fCh0aGlzLmFwcD1uZXcgdGhpcy5fYXBwQ29uc3RydWN0b3Ioe2VsOnRoaXMuX2FwcENvbnRhaW5lcixfbWV0YTp7JHJvdXRlOmF9fSkpO3ZhciB1PXRoaXMuX2JlZm9yZUVhY2hIb29rcyxjPWZ1bmN0aW9uKCl7cy5zdGFydChmdW5jdGlvbigpe3IuX3Bvc3RUcmFuc2l0aW9uKGEsZSxuKX0pfTt1Lmxlbmd0aD9zLnJ1blF1ZXVlKHUsZnVuY3Rpb24odCxlLG4pe3M9PT1yLl9jdXJyZW50VHJhbnNpdGlvbiYmcy5jYWxsSG9vayh0LG51bGwsbix7ZXhwZWN0Qm9vbGVhbjohMH0pfSxjKTpjKCksIXRoaXMuX3JlbmRlcmVkJiZ0aGlzLl9zdGFydENiJiZ0aGlzLl9zdGFydENiLmNhbGwobnVsbCksdGhpcy5fcmVuZGVyZWQ9ITB9fSx0LnByb3RvdHlwZS5fb25UcmFuc2l0aW9uVmFsaWRhdGVkPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2N1cnJlbnRSb3V0ZT10LnRvO3RoaXMuYXBwLiRyb3V0ZSE9PWUmJih0aGlzLmFwcC4kcm91dGU9ZSx0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuJHJvdXRlPWV9KSksdGhpcy5fYWZ0ZXJFYWNoSG9va3MubGVuZ3RoJiZ0aGlzLl9hZnRlckVhY2hIb29rcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNhbGwobnVsbCx7dG86dC50byxmcm9tOnQuZnJvbX0pfSksdGhpcy5fY3VycmVudFRyYW5zaXRpb24uZG9uZT0hMH0sdC5wcm90b3R5cGUuX3Bvc3RUcmFuc2l0aW9uPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1lJiZlLnBvcztyJiZ0aGlzLl9zYXZlU2Nyb2xsUG9zaXRpb24/QS5uZXh0VGljayhmdW5jdGlvbigpe3dpbmRvdy5zY3JvbGxUbyhyLngsci55KX0pOm4mJkEubmV4dFRpY2soZnVuY3Rpb24oKXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChuLnNsaWNlKDEpKTt0JiZ3aW5kb3cuc2Nyb2xsVG8od2luZG93LnNjcm9sbFgsdC5vZmZzZXRUb3ApfSl9LHQucHJvdG90eXBlLl9zdHJpbmdpZnlQYXRoPWZ1bmN0aW9uKHQpe2lmKHQmJlwib2JqZWN0XCI9PXR5cGVvZiB0KXtpZih0Lm5hbWUpe3ZhciBlPXQucGFyYW1zfHx7fTtyZXR1cm4gdC5xdWVyeSYmKGUucXVlcnlQYXJhbXM9dC5xdWVyeSksdGhpcy5fcmVjb2duaXplci5nZW5lcmF0ZSh0Lm5hbWUsZSl9cmV0dXJuIHQucGF0aD90LnBhdGg6XCJcIn1yZXR1cm4gdD90K1wiXCI6XCJcIn0sdH0oKTskLmluc3RhbGxlZD0hMSwkLmluc3RhbGw9ZnVuY3Rpb24odCl7cmV0dXJuICQuaW5zdGFsbGVkP3ZvaWQgYS53YXJuKFwiYWxyZWFkeSBpbnN0YWxsZWQuXCIpOihBPXQsY1tcImRlZmF1bHRcIl0oQSkseVtcImRlZmF1bHRcIl0oQSksX1tcImRlZmF1bHRcIl0oQSksc1tcImRlZmF1bHRcIl0uVnVlPUEsdm9pZCgkLmluc3RhbGxlZD0hMCkpfSxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuVnVlJiZ3aW5kb3cuVnVlLnVzZSgkKSxlW1wiZGVmYXVsdFwiXT0kLHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjtlW1wiZGVmYXVsdFwiXT1mdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9LGUuX19lc01vZHVsZT0hMH0sZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjtlW1wiZGVmYXVsdFwiXT1mdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e1wiZGVmYXVsdFwiOnR9fSxlLl9fZXNNb2R1bGU9ITB9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3dpbmRvdy5jb25zb2xlJiYoY29uc29sZS53YXJuKFwiW3Z1ZS1yb3V0ZXJdIFwiK3QpLCghcC5WdWV8fHAuVnVlLmNvbmZpZy5kZWJ1ZykmJmNvbnNvbGUud2FybihuZXcgRXJyb3IoXCJ3YXJuaW5nIHN0YWNrIHRyYWNlOlwiKS5zdGFjaykpfWZ1bmN0aW9uIG8odCxlLG4pe3ZhciByPXQubWF0Y2goLyhcXD8uKikkLyk7aWYociYmKHI9clsxXSx0PXQuc2xpY2UoMCwtci5sZW5ndGgpKSxcIj9cIj09PWUuY2hhckF0KDApKXJldHVybiB0K2U7dmFyIG89dC5zcGxpdChcIi9cIik7biYmb1tvLmxlbmd0aC0xXXx8by5wb3AoKTtmb3IodmFyIGk9ZS5yZXBsYWNlKC9eXFwvLyxcIlwiKS5zcGxpdChcIi9cIiksYT0wO2E8aS5sZW5ndGg7YSsrKXt2YXIgcz1pW2FdO1wiLlwiIT09cyYmKFwiLi5cIj09PXM/by5wb3AoKTpvLnB1c2gocykpfXJldHVyblwiXCIhPT1vWzBdJiZvLnVuc2hpZnQoXCJcIiksby5qb2luKFwiL1wiKX1mdW5jdGlvbiBpKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRoZW59ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPXQmJih0LiRvcHRpb25zfHx0Lm9wdGlvbnMpO3JldHVybiBuJiZuLnJvdXRlJiZuLnJvdXRlW2VdfWZ1bmN0aW9uIHModCxlKXtkP2QuJG9wdGlvbnMuY29tcG9uZW50cy5fPXQuY29tcG9uZW50OmQ9e3Jlc29sdmU6cC5WdWUucHJvdG90eXBlLl9yZXNvbHZlQ29tcG9uZW50LCRvcHRpb25zOntjb21wb25lbnRzOntfOnQuY29tcG9uZW50fX19LGQucmVzb2x2ZShcIl9cIixmdW5jdGlvbihuKXt0LmNvbXBvbmVudD1uLGUobil9KX1mdW5jdGlvbiB1KHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLHQ9dC5yZXBsYWNlKC86KFteXFwvXSspL2csZnVuY3Rpb24obixvKXt2YXIgaT1lW29dO3JldHVybiBpfHxyKCdwYXJhbSBcIicrbysnXCIgbm90IGZvdW5kIHdoZW4gZ2VuZXJhdGluZyBwYXRoIGZvciBcIicrdCsnXCIgd2l0aCBwYXJhbXMgJytKU09OLnN0cmluZ2lmeShlKSksaXx8XCJcIn0pLG4mJih0Kz1mKG4pKSx0fXZhciBjPW4oMilbXCJkZWZhdWx0XCJdO2UuX19lc01vZHVsZT0hMCxlLndhcm49cixlLnJlc29sdmVQYXRoPW8sZS5pc1Byb21pc2U9aSxlLmdldFJvdXRlQ29uZmlnPWEsZS5yZXNvbHZlQXN5bmNDb21wb25lbnQ9cyxlLm1hcFBhcmFtcz11O3ZhciBoPW4oNCksbD1jKGgpLGY9bFtcImRlZmF1bHRcIl0ucHJvdG90eXBlLmdlbmVyYXRlUXVlcnlTdHJpbmcscD17fTtlW1wiZGVmYXVsdFwiXT1wO3ZhciBkPXZvaWQgMH0sZnVuY3Rpb24odCxlLG4pe3ZhciByOyhmdW5jdGlvbih0KXsoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKHQsZSxuKXt0aGlzLnBhdGg9dCx0aGlzLm1hdGNoZXI9ZSx0aGlzLmRlbGVnYXRlPW59ZnVuY3Rpb24gaSh0KXt0aGlzLnJvdXRlcz17fSx0aGlzLmNoaWxkcmVuPXt9LHRoaXMudGFyZ2V0PXR9ZnVuY3Rpb24gYSh0LGUsbil7cmV0dXJuIGZ1bmN0aW9uKHIsaSl7dmFyIHM9dCtyO3JldHVybiBpP3ZvaWQgaShhKHMsZSxuKSk6bmV3IG8odCtyLGUsbil9fWZ1bmN0aW9uIHModCxlLG4pe2Zvcih2YXIgcj0wLG89MCxpPXQubGVuZ3RoO2k+bztvKyspcis9dFtvXS5wYXRoLmxlbmd0aDtlPWUuc3Vic3RyKHIpO3ZhciBhPXtwYXRoOmUsaGFuZGxlcjpufTt0LnB1c2goYSl9ZnVuY3Rpb24gdSh0LGUsbixyKXt2YXIgbz1lLnJvdXRlcztmb3IodmFyIGkgaW4gbylpZihvLmhhc093blByb3BlcnR5KGkpKXt2YXIgYT10LnNsaWNlKCk7cyhhLGksb1tpXSksZS5jaGlsZHJlbltpXT91KGEsZS5jaGlsZHJlbltpXSxuLHIpOm4uY2FsbChyLGEpfX1mdW5jdGlvbiBjKHQpe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX1mdW5jdGlvbiBoKHQpe3RoaXMuc3RyaW5nPXR9ZnVuY3Rpb24gbCh0KXt0aGlzLm5hbWU9dH1mdW5jdGlvbiBmKHQpe3RoaXMubmFtZT10fWZ1bmN0aW9uIHAoKXt9ZnVuY3Rpb24gZCh0LGUsbil7XCIvXCI9PT10LmNoYXJBdCgwKSYmKHQ9dC5zdWJzdHIoMSkpO3ZhciByPXQuc3BsaXQoXCIvXCIpLG89W107bi52YWw9XCJcIjtmb3IodmFyIGk9MCxhPXIubGVuZ3RoO2E+aTtpKyspe3ZhciBzLHU9cltpXTsocz11Lm1hdGNoKC9eOihbXlxcL10rKSQvKSk/KG8ucHVzaChuZXcgbChzWzFdKSksZS5wdXNoKHNbMV0pLG4udmFsKz1cIjNcIik6KHM9dS5tYXRjaCgvXlxcKihbXlxcL10rKSQvKSk/KG8ucHVzaChuZXcgZihzWzFdKSksbi52YWwrPVwiMlwiLGUucHVzaChzWzFdKSk6XCJcIj09PXU/KG8ucHVzaChuZXcgcCksbi52YWwrPVwiMVwiKTooby5wdXNoKG5ldyBoKHUpKSxuLnZhbCs9XCI0XCIpfXJldHVybiBuLnZhbD0rbi52YWwsb31mdW5jdGlvbiB2KHQpe3RoaXMuY2hhclNwZWM9dCx0aGlzLm5leHRTdGF0ZXM9W119ZnVuY3Rpb24gZyh0KXtyZXR1cm4gdC5zb3J0KGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuc3BlY2lmaWNpdHkudmFsLXQuc3BlY2lmaWNpdHkudmFsfSl9ZnVuY3Rpb24geSh0LGUpe2Zvcih2YXIgbj1bXSxyPTAsbz10Lmxlbmd0aDtvPnI7cisrKXt2YXIgaT10W3JdO249bi5jb25jYXQoaS5tYXRjaChlKSl9cmV0dXJuIG59ZnVuY3Rpb24gbSh0KXt0aGlzLnF1ZXJ5UGFyYW1zPXR8fHt9fWZ1bmN0aW9uIF8odCxlLG4pe2Zvcih2YXIgcj10LmhhbmRsZXJzLG89dC5yZWdleCxpPWUubWF0Y2gobyksYT0xLHM9bmV3IG0obiksdT0wLGM9ci5sZW5ndGg7Yz51O3UrKyl7Zm9yKHZhciBoPXJbdV0sbD1oLm5hbWVzLGY9e30scD0wLGQ9bC5sZW5ndGg7ZD5wO3ArKylmW2xbcF1dPWlbYSsrXTtzLnB1c2goe2hhbmRsZXI6aC5oYW5kbGVyLHBhcmFtczpmLGlzRHluYW1pYzohIWwubGVuZ3RofSl9cmV0dXJuIHN9ZnVuY3Rpb24gdyh0LGUpe3JldHVybiBlLmVhY2hDaGFyKGZ1bmN0aW9uKGUpe3Q9dC5wdXQoZSl9KSx0fWZ1bmN0aW9uIGIodCl7cmV0dXJuIHQ9dC5yZXBsYWNlKC9cXCsvZ20sXCIlMjBcIiksZGVjb2RlVVJJQ29tcG9uZW50KHQpfW8ucHJvdG90eXBlPXt0bzpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZGVsZWdhdGU7aWYobiYmbi53aWxsQWRkUm91dGUmJih0PW4ud2lsbEFkZFJvdXRlKHRoaXMubWF0Y2hlci50YXJnZXQsdCkpLHRoaXMubWF0Y2hlci5hZGQodGhpcy5wYXRoLHQpLGUpe2lmKDA9PT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBoYXZlIGFuIGFyZ3VtZW50IGluIHRoZSBmdW5jdGlvbiBwYXNzZWQgdG8gYHRvYFwiKTt0aGlzLm1hdGNoZXIuYWRkQ2hpbGQodGhpcy5wYXRoLHQsZSx0aGlzLmRlbGVnYXRlKX1yZXR1cm4gdGhpc319LGkucHJvdG90eXBlPXthZGQ6ZnVuY3Rpb24odCxlKXt0aGlzLnJvdXRlc1t0XT1lfSxhZGRDaGlsZDpmdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uZXcgaShlKTt0aGlzLmNoaWxkcmVuW3RdPW87dmFyIHM9YSh0LG8scik7ciYmci5jb250ZXh0RW50ZXJlZCYmci5jb250ZXh0RW50ZXJlZChlLHMpLG4ocyl9fTt2YXIgeD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBpO3QoYShcIlwiLG4sdGhpcy5kZWxlZ2F0ZSkpLHUoW10sbixmdW5jdGlvbih0KXtlP2UodGhpcyx0KTp0aGlzLmFkZCh0KX0sdGhpcyl9LEM9W1wiL1wiLFwiLlwiLFwiKlwiLFwiK1wiLFwiP1wiLFwifFwiLFwiKFwiLFwiKVwiLFwiW1wiLFwiXVwiLFwie1wiLFwifVwiLFwiXFxcXFwiXSxSPW5ldyBSZWdFeHAoXCIoXFxcXFwiK0Muam9pbihcInxcXFxcXCIpK1wiKVwiLFwiZ1wiKTtoLnByb3RvdHlwZT17ZWFjaENoYXI6ZnVuY3Rpb24odCl7Zm9yKHZhciBlLG49dGhpcy5zdHJpbmcscj0wLG89bi5sZW5ndGg7bz5yO3IrKyllPW4uY2hhckF0KHIpLHQoe3ZhbGlkQ2hhcnM6ZX0pfSxyZWdleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0cmluZy5yZXBsYWNlKFIsXCJcXFxcJDFcIil9LGdlbmVyYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RyaW5nfX0sbC5wcm90b3R5cGU9e2VhY2hDaGFyOmZ1bmN0aW9uKHQpe3Qoe2ludmFsaWRDaGFyczpcIi9cIixyZXBlYXQ6ITB9KX0scmVnZXg6ZnVuY3Rpb24oKXtyZXR1cm5cIihbXi9dKylcIn0sZ2VuZXJhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRbdGhpcy5uYW1lXX19LGYucHJvdG90eXBlPXtlYWNoQ2hhcjpmdW5jdGlvbih0KXt0KHtpbnZhbGlkQ2hhcnM6XCJcIixyZXBlYXQ6ITB9KX0scmVnZXg6ZnVuY3Rpb24oKXtyZXR1cm5cIiguKylcIn0sZ2VuZXJhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRbdGhpcy5uYW1lXX19LHAucHJvdG90eXBlPXtlYWNoQ2hhcjpmdW5jdGlvbigpe30scmVnZXg6ZnVuY3Rpb24oKXtyZXR1cm5cIlwifSxnZW5lcmF0ZTpmdW5jdGlvbigpe3JldHVyblwiXCJ9fSx2LnByb3RvdHlwZT17Z2V0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLm5leHRTdGF0ZXMsbj0wLHI9ZS5sZW5ndGg7cj5uO24rKyl7dmFyIG89ZVtuXSxpPW8uY2hhclNwZWMudmFsaWRDaGFycz09PXQudmFsaWRDaGFycztpZihpPWkmJm8uY2hhclNwZWMuaW52YWxpZENoYXJzPT09dC5pbnZhbGlkQ2hhcnMpcmV0dXJuIG99fSxwdXQ6ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuKGU9dGhpcy5nZXQodCkpP2U6KGU9bmV3IHYodCksdGhpcy5uZXh0U3RhdGVzLnB1c2goZSksdC5yZXBlYXQmJmUubmV4dFN0YXRlcy5wdXNoKGUpLGUpfSxtYXRjaDpmdW5jdGlvbih0KXtmb3IodmFyIGUsbixyLG89dGhpcy5uZXh0U3RhdGVzLGk9W10sYT0wLHM9by5sZW5ndGg7cz5hO2ErKyllPW9bYV0sbj1lLmNoYXJTcGVjLFwidW5kZWZpbmVkXCIhPXR5cGVvZihyPW4udmFsaWRDaGFycyk/LTEhPT1yLmluZGV4T2YodCkmJmkucHVzaChlKTpcInVuZGVmaW5lZFwiIT10eXBlb2Yocj1uLmludmFsaWRDaGFycykmJi0xPT09ci5pbmRleE9mKHQpJiZpLnB1c2goZSk7cmV0dXJuIGl9fTt2YXIgUD1PYmplY3QuY3JlYXRlfHxmdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7fXJldHVybiBlLnByb3RvdHlwZT10LG5ldyBlfTttLnByb3RvdHlwZT1QKHtzcGxpY2U6QXJyYXkucHJvdG90eXBlLnNwbGljZSxzbGljZTpBcnJheS5wcm90b3R5cGUuc2xpY2UscHVzaDpBcnJheS5wcm90b3R5cGUucHVzaCxsZW5ndGg6MCxxdWVyeVBhcmFtczpudWxsfSk7dmFyIEU9ZnVuY3Rpb24oKXt0aGlzLnJvb3RTdGF0ZT1uZXcgdix0aGlzLm5hbWVzPXt9fTtFLnByb3RvdHlwZT17YWRkOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuLHI9dGhpcy5yb290U3RhdGUsbz1cIl5cIixpPXt9LGE9W10scz1bXSx1PSEwLGM9MCxoPXQubGVuZ3RoO2g+YztjKyspe3ZhciBsPXRbY10sZj1bXSx2PWQobC5wYXRoLGYsaSk7cz1zLmNvbmNhdCh2KTtmb3IodmFyIGc9MCx5PXYubGVuZ3RoO3k+ZztnKyspe3ZhciBtPXZbZ107bSBpbnN0YW5jZW9mIHB8fCh1PSExLHI9ci5wdXQoe3ZhbGlkQ2hhcnM6XCIvXCJ9KSxvKz1cIi9cIixyPXcocixtKSxvKz1tLnJlZ2V4KCkpfXZhciBfPXtoYW5kbGVyOmwuaGFuZGxlcixuYW1lczpmfTthLnB1c2goXyl9dSYmKHI9ci5wdXQoe3ZhbGlkQ2hhcnM6XCIvXCJ9KSxvKz1cIi9cIiksci5oYW5kbGVycz1hLHIucmVnZXg9bmV3IFJlZ0V4cChvK1wiJFwiKSxyLnNwZWNpZmljaXR5PWksKG49ZSYmZS5hcykmJih0aGlzLm5hbWVzW25dPXtzZWdtZW50czpzLGhhbmRsZXJzOmF9KX0saGFuZGxlcnNGb3I6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5uYW1lc1t0XSxuPVtdO2lmKCFlKXRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIHJvdXRlIG5hbWVkIFwiK3QpO2Zvcih2YXIgcj0wLG89ZS5oYW5kbGVycy5sZW5ndGg7bz5yO3IrKyluLnB1c2goZS5oYW5kbGVyc1tyXSk7cmV0dXJuIG59LGhhc1JvdXRlOmZ1bmN0aW9uKHQpe3JldHVybiEhdGhpcy5uYW1lc1t0XX0sZ2VuZXJhdGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLm5hbWVzW3RdLHI9XCJcIjtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyByb3V0ZSBuYW1lZCBcIit0KTtmb3IodmFyIG89bi5zZWdtZW50cyxpPTAsYT1vLmxlbmd0aDthPmk7aSsrKXt2YXIgcz1vW2ldO3MgaW5zdGFuY2VvZiBwfHwocis9XCIvXCIscis9cy5nZW5lcmF0ZShlKSl9cmV0dXJuXCIvXCIhPT1yLmNoYXJBdCgwKSYmKHI9XCIvXCIrciksZSYmZS5xdWVyeVBhcmFtcyYmKHIrPXRoaXMuZ2VuZXJhdGVRdWVyeVN0cmluZyhlLnF1ZXJ5UGFyYW1zLG4uaGFuZGxlcnMpKSxyfSxnZW5lcmF0ZVF1ZXJ5U3RyaW5nOmZ1bmN0aW9uKHQsZSl7dmFyIG49W10scj1bXTtmb3IodmFyIG8gaW4gdCl0Lmhhc093blByb3BlcnR5KG8pJiZyLnB1c2gobyk7ci5zb3J0KCk7Zm9yKHZhciBpPTAsYT1yLmxlbmd0aDthPmk7aSsrKXtvPXJbaV07dmFyIHM9dFtvXTtpZihudWxsIT1zKXt2YXIgdT1lbmNvZGVVUklDb21wb25lbnQobyk7aWYoYyhzKSlmb3IodmFyIGg9MCxsPXMubGVuZ3RoO2w+aDtoKyspe3ZhciBmPW8rXCJbXT1cIitlbmNvZGVVUklDb21wb25lbnQoc1toXSk7bi5wdXNoKGYpfWVsc2UgdSs9XCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KHMpLG4ucHVzaCh1KX19cmV0dXJuIDA9PT1uLmxlbmd0aD9cIlwiOlwiP1wiK24uam9pbihcIiZcIil9LHBhcnNlUXVlcnlTdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuc3BsaXQoXCImXCIpLG49e30scj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgbyxpPWVbcl0uc3BsaXQoXCI9XCIpLGE9YihpWzBdKSxzPWEubGVuZ3RoLHU9ITE7MT09PWkubGVuZ3RoP289XCJ0cnVlXCI6KHM+MiYmXCJbXVwiPT09YS5zbGljZShzLTIpJiYodT0hMCxhPWEuc2xpY2UoMCxzLTIpLG5bYV18fChuW2FdPVtdKSksbz1pWzFdP2IoaVsxXSk6XCJcIiksdT9uW2FdLnB1c2gobyk6blthXT1vfXJldHVybiBufSxyZWNvZ25pemU6ZnVuY3Rpb24odCl7dmFyIGUsbixyLG8saT1bdGhpcy5yb290U3RhdGVdLGE9e30scz0hMTtpZihvPXQuaW5kZXhPZihcIj9cIiksLTEhPT1vKXt2YXIgdT10LnN1YnN0cihvKzEsdC5sZW5ndGgpO3Q9dC5zdWJzdHIoMCxvKSxhPXRoaXMucGFyc2VRdWVyeVN0cmluZyh1KX1mb3IodD1kZWNvZGVVUkkodCksXCIvXCIhPT10LmNoYXJBdCgwKSYmKHQ9XCIvXCIrdCksZT10Lmxlbmd0aCxlPjEmJlwiL1wiPT09dC5jaGFyQXQoZS0xKSYmKHQ9dC5zdWJzdHIoMCxlLTEpLHM9ITApLG49MCxyPXQubGVuZ3RoO3I+biYmKGk9eShpLHQuY2hhckF0KG4pKSxpLmxlbmd0aCk7bisrKTt2YXIgYz1bXTtmb3Iobj0wLHI9aS5sZW5ndGg7cj5uO24rKylpW25dLmhhbmRsZXJzJiZjLnB1c2goaVtuXSk7aT1nKGMpO3ZhciBoPWNbMF07cmV0dXJuIGgmJmguaGFuZGxlcnM/KHMmJlwiKC4rKSRcIj09PWgucmVnZXguc291cmNlLnNsaWNlKC01KSYmKHQrPVwiL1wiKSxfKGgsdCxhKSk6dm9pZCAwfX0sRS5wcm90b3R5cGUubWFwPXgsRS5WRVJTSU9OPVwiMC4xLjlcIjt2YXIgQT1FO24oNikuYW1kPyhyPWZ1bmN0aW9uKCl7cmV0dXJuIEF9LmNhbGwoZSxuLGUsdCksISh2b2lkIDAhPT1yJiYodC5leHBvcnRzPXIpKSk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHQmJnQuZXhwb3J0cz90LmV4cG9ydHM9QTpcInVuZGVmaW5lZFwiIT10eXBlb2YgdGhpcyYmKHRoaXMuUm91dGVSZWNvZ25pemVyPUEpfSkuY2FsbCh0aGlzKX0pLmNhbGwoZSxuKDUpKHQpKX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHQud2VicGFja1BvbHlmaWxsfHwodC5kZXByZWNhdGU9ZnVuY3Rpb24oKXt9LHQucGF0aHM9W10sdC5jaGlsZHJlbj1bXSx0LndlYnBhY2tQb2x5ZmlsbD0xKSx0fX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3RcIil9fSxmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO2UuX19lc01vZHVsZT0hMCxlW1wiZGVmYXVsdFwiXT1mdW5jdGlvbih0KXt2YXIgZT10LnV0aWwsbj10LnByb3RvdHlwZS5faW5pdDt0LnByb3RvdHlwZS5faW5pdD1mdW5jdGlvbih0KXt2YXIgcj10Ll9wYXJlbnR8fHQucGFyZW50fHx0aGlzLG89ci4kcm91dGU7byYmKG8ucm91dGVyLl9jaGlsZHJlbi5wdXNoKHRoaXMpLHRoaXMuJHJvdXRlfHwodGhpcy5fZGVmaW5lTWV0YT90aGlzLl9kZWZpbmVNZXRhKFwiJHJvdXRlXCIsbyk6ZS5kZWZpbmVSZWFjdGl2ZSh0aGlzLFwiJHJvdXRlXCIsbykpKSxuLmNhbGwodGhpcyx0KX07dmFyIHI9dC5wcm90b3R5cGUuX2Rlc3Ryb3k7dC5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24oKXtpZighdGhpcy5faXNCZWluZ0Rlc3Ryb3llZCl7dmFyIHQ9dGhpcy4kcm9vdC4kcm91dGU7dCYmdC5yb3V0ZXIuX2NoaWxkcmVuLiRyZW1vdmUodGhpcyksci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fTt2YXIgbz10LmNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXMsaT0vXihkYXRhfGFjdGl2YXRlfGRlYWN0aXZhdGUpJC87byYmKG8ucm91dGU9ZnVuY3Rpb24odCxuKXtpZighbilyZXR1cm4gdDtpZighdClyZXR1cm4gbjt2YXIgcj17fTtlLmV4dGVuZChyLHQpO2Zvcih2YXIgbyBpbiBuKXt2YXIgYT1yW29dLHM9bltvXTthJiZpLnRlc3Qobyk/cltvXT0oZS5pc0FycmF5KGEpP2E6W2FdKS5jb25jYXQocyk6cltvXT1zfXJldHVybiByfSl9LHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMSlbXCJkZWZhdWx0XCJdLG89big5KVtcImRlZmF1bHRcIl07ZS5fX2VzTW9kdWxlPSEwO3ZhciBpPS9eKGNvbXBvbmVudHxzdWJSb3V0ZXMpJC8sYT1mdW5jdGlvbiBzKHQsZSl7dmFyIG49dGhpcztyKHRoaXMscyk7dmFyIGE9ZS5fcmVjb2duaXplci5yZWNvZ25pemUodCk7YSYmKFtdLmZvckVhY2guY2FsbChhLGZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0LmhhbmRsZXIpaS50ZXN0KGUpfHwobltlXT10LmhhbmRsZXJbZV0pfSksdGhpcy5xdWVyeT1hLnF1ZXJ5UGFyYW1zLHRoaXMucGFyYW1zPVtdLnJlZHVjZS5jYWxsKGEsZnVuY3Rpb24odCxlKXtpZihlLnBhcmFtcylmb3IodmFyIG4gaW4gZS5wYXJhbXMpdFtuXT1lLnBhcmFtc1tuXTtyZXR1cm4gdH0se30pKSx0aGlzLnBhdGg9dCx0aGlzLnJvdXRlcj1lLHRoaXMubWF0Y2hlZD1hfHxlLl9ub3RGb3VuZEhhbmRsZXIsbyh0aGlzKX07ZVtcImRlZmF1bHRcIl09YSx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9e1wiZGVmYXVsdFwiOm4oMTApLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih0LGUsbil7bigxMSksdC5leHBvcnRzPW4oMTYpLk9iamVjdC5mcmVlemV9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDEyKTtuKDEzKShcImZyZWV6ZVwiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdCYmcihlKT90KGUpOmV9fSl9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT09dCYmKFwib2JqZWN0XCI9PXR5cGVvZiB0fHxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KX19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgcj1uKDE0KSxvPShuKDE2KS5PYmplY3R8fHt9KVt0XXx8T2JqZWN0W3RdLGk9e307aVt0XT1lKG8pLHIoci5TK3IuRipuKDE3KShmdW5jdGlvbigpe28oMSl9KSxcIk9iamVjdFwiLGkpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTUpLG89bigxNiksaT1cInByb3RvdHlwZVwiLGE9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyl9fSxzPWZ1bmN0aW9uKHQsZSxuKXt2YXIgdSxjLGgsbCxmPXQmcy5HLHA9dCZzLlAsZD1mP3I6dCZzLlM/cltlXToocltlXXx8e30pW2ldLHY9Zj9vOm9bZV18fChvW2VdPXt9KTtmJiYobj1lKTtmb3IodSBpbiBuKWM9ISh0JnMuRikmJmQmJnUgaW4gZCxjJiZ1IGluIHZ8fChoPWM/ZFt1XTpuW3VdLGYmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGRbdV0/bD1uW3VdOnQmcy5CJiZjP2w9YShoLHIpOnQmcy5XJiZkW3VdPT1oPyFmdW5jdGlvbih0KXtsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzIGluc3RhbmNlb2YgdD9uZXcgdChlKTp0KGUpfSxsW2ldPXRbaV19KGgpOmw9cCYmXCJmdW5jdGlvblwiPT10eXBlb2YgaD9hKEZ1bmN0aW9uLmNhbGwsaCk6aCx2W3VdPWwscCYmKCh2W2ldfHwodltpXT17fSkpW3VdPWgpKX07cy5GPTEscy5HPTIscy5TPTQscy5QPTgscy5CPTE2LHMuVz0zMix0LmV4cG9ydHM9c30sZnVuY3Rpb24odCxlKXt2YXIgbj1cInVuZGVmaW5lZFwiLHI9dC5leHBvcnRzPXR5cGVvZiB3aW5kb3chPW4mJndpbmRvdy5NYXRoPT1NYXRoP3dpbmRvdzp0eXBlb2Ygc2VsZiE9biYmc2VsZi5NYXRoPT1NYXRoP3NlbGY6RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1wibnVtYmVyXCI9PXR5cGVvZiBfX2cmJihfX2c9cil9LGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5leHBvcnRzPXt9O1wibnVtYmVyXCI9PXR5cGVvZiBfX2UmJihfX2U9bil9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaChlKXtyZXR1cm4hMH19fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm5cIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpfXZhciBvPW4oMSlbXCJkZWZhdWx0XCJdO2UuX19lc01vZHVsZT0hMDt2YXIgaT1uKDMpLGE9bigxOSkscz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxuLHIpe28odGhpcyx0KSx0aGlzLnJvdXRlcj1lLHRoaXMudG89bix0aGlzLmZyb209cix0aGlzLm5leHQ9bnVsbCx0aGlzLmFib3J0ZWQ9ITEsdGhpcy5kb25lPSExLHRoaXMuZGVhY3RpdmF0ZVF1ZXVlPWUuX3ZpZXdzO3ZhciBpPW4ubWF0Y2hlZD9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuLm1hdGNoZWQpOltdO3RoaXMuYWN0aXZhdGVRdWV1ZT1pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5oYW5kbGVyfSl9cmV0dXJuIHQucHJvdG90eXBlLmFib3J0PWZ1bmN0aW9uKCl7aWYoIXRoaXMuYWJvcnRlZCl7dGhpcy5hYm9ydGVkPSEwO3ZhciB0PSF0aGlzLmZyb20ucGF0aCYmXCIvXCI9PT10aGlzLnRvLnBhdGg7dHx8dGhpcy5yb3V0ZXIucmVwbGFjZSh0aGlzLmZyb20ucGF0aHx8XCIvXCIpfX0sdC5wcm90b3R5cGUucmVkaXJlY3Q9ZnVuY3Rpb24odCl7dGhpcy5hYm9ydGVkfHwodGhpcy5hYm9ydGVkPSEwLFwic3RyaW5nXCI9PXR5cGVvZiB0P3Q9aS5tYXBQYXJhbXModCx0aGlzLnRvLnBhcmFtcyx0aGlzLnRvLnF1ZXJ5KToodC5wYXJhbXM9dGhpcy50by5wYXJhbXMsdC5xdWVyeT10aGlzLnRvLnF1ZXJ5KSx0aGlzLnJvdXRlci5yZXBsYWNlKHQpKX0sdC5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPXRoaXMuZGVhY3RpdmF0ZVF1ZXVlLHI9dGhpcy5hY3RpdmF0ZVF1ZXVlLG89bi5zbGljZSgpLnJldmVyc2UoKSxpPXZvaWQgMCxzPXZvaWQgMDtmb3Iocz0wO3M8by5sZW5ndGgmJmEuY2FuUmV1c2Uob1tzXSxyW3NdLGUpO3MrKyk7cz4wJiYoaT1vLnNsaWNlKDAscyksbj1vLnNsaWNlKHMpLnJldmVyc2UoKSxyPXIuc2xpY2UocykpLGUucnVuUXVldWUobixhLmNhbkRlYWN0aXZhdGUsZnVuY3Rpb24oKXtlLnJ1blF1ZXVlKHIsYS5jYW5BY3RpdmF0ZSxmdW5jdGlvbigpe2UucnVuUXVldWUobixhLmRlYWN0aXZhdGUsZnVuY3Rpb24oKXtpZihlLnJvdXRlci5fb25UcmFuc2l0aW9uVmFsaWRhdGVkKGUpLGkmJmkuZm9yRWFjaChmdW5jdGlvbih0KXthLnJldXNlKHQsZSl9KSxuLmxlbmd0aCl7dmFyIHI9bltuLmxlbmd0aC0xXSxvPWk/aS5sZW5ndGg6MDthLmFjdGl2YXRlKHIsZSxvLHQpfWVsc2UgdCgpfSl9KX0pfSx0LnByb3RvdHlwZS5ydW5RdWV1ZT1mdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcihpKXtpPj10Lmxlbmd0aD9uKCk6ZSh0W2ldLG8sZnVuY3Rpb24oKXtyKGkrMSl9KX12YXIgbz10aGlzO3IoMCl9LHQucHJvdG90eXBlLmNhbGxIb29rPWZ1bmN0aW9uKHQsZSxuKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPD0zfHx2b2lkIDA9PT1hcmd1bWVudHNbM10/e306YXJndW1lbnRzWzNdLGE9by5leHBlY3RCb29sZWFuLHM9dm9pZCAwPT09YT8hMTphLHU9by5leHBlY3REYXRhLGM9dm9pZCAwPT09dT8hMTp1LGg9by5jbGVhbnVwLGw9dGhpcyxmPSExLHA9ZnVuY3Rpb24oKXtoJiZoKCksbC5hYm9ydCgpfSxkPWZ1bmN0aW9uKHQpe2lmKGg/digpOnAoKSx0JiYhbC5yb3V0ZXIuX3N1cHByZXNzKXRocm93IGkud2FybihcIlVuY2F1Z2h0IGVycm9yIGR1cmluZyB0cmFuc2l0aW9uOiBcIiksdCBpbnN0YW5jZW9mIEVycm9yP3Q6bmV3IEVycm9yKHQpfSx2PWZ1bmN0aW9uKHQpe3JldHVybiBmP3ZvaWQgaS53YXJuKFwidHJhbnNpdGlvbi5uZXh0KCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuXCIpOihmPSEwLGwuYWJvcnRlZD92b2lkKGgmJmgoKSk6dm9pZChuJiZuKHQsZCkpKX0sZz17dG86bC50byxmcm9tOmwuZnJvbSxhYm9ydDpwLG5leHQ6dixyZWRpcmVjdDpmdW5jdGlvbigpe2wucmVkaXJlY3QuYXBwbHkobCxhcmd1bWVudHMpfX0seT12b2lkIDA7dHJ5e3k9dC5jYWxsKGUsZyl9Y2F0Y2gobSl7cmV0dXJuIGQobSl9dmFyIF89aS5pc1Byb21pc2UoeSk7cz9cImJvb2xlYW5cIj09dHlwZW9mIHk/eT92KCk6cCgpOl8/eS50aGVuKGZ1bmN0aW9uKHQpe3Q/digpOnAoKX0sZCk6dC5sZW5ndGh8fHYoeSk6Xz95LnRoZW4odixkKTooYyYmcih5KXx8IXQubGVuZ3RoKSYmdih5KX0sdC5wcm90b3R5cGUuY2FsbEhvb2tzPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXRoaXM7QXJyYXkuaXNBcnJheSh0KT8hZnVuY3Rpb24oKXt2YXIgaT1bXTtpLl9uZWVkTWVyZ2U9ITA7dmFyIGE9dm9pZCAwO28ucnVuUXVldWUodCxmdW5jdGlvbih0LG4sYSl7by5hYm9ydGVkfHxvLmNhbGxIb29rKHQsZSxmdW5jdGlvbih0LGUpe3QmJmkucHVzaCh0KSxlPWUsYSgpfSxyKX0sZnVuY3Rpb24oKXtuKGksYSl9KX0oKTp0aGlzLmNhbGxIb29rKHQsZSxuLHIpfSx0fSgpO2VbXCJkZWZhdWx0XCJdPXMsdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0LGUsbil7dmFyIHI9dC5jaGlsZFZNO2lmKCFyfHwhZSlyZXR1cm4hMTtpZih0LkNvbXBvbmVudCE9PWUuY29tcG9uZW50KXJldHVybiExO3ZhciBvPXAuZ2V0Um91dGVDb25maWcocixcImNhblJldXNlXCIpO3JldHVyblwiYm9vbGVhblwiPT10eXBlb2Ygbz9vOm8/by5jYWxsKHIse3RvOm4udG8sZnJvbTpuLmZyb219KTohMH1mdW5jdGlvbiBvKHQsZSxuKXt2YXIgcj10LmNoaWxkVk0sbz1wLmdldFJvdXRlQ29uZmlnKHIsXCJjYW5EZWFjdGl2YXRlXCIpO28/ZS5jYWxsSG9vayhvLHIsbix7ZXhwZWN0Qm9vbGVhbjohMH0pOm4oKX1mdW5jdGlvbiBpKHQsZSxuKXtwLnJlc29sdmVBc3luY0NvbXBvbmVudCh0LGZ1bmN0aW9uKHQpe2lmKCFlLmFib3J0ZWQpe3ZhciByPXAuZ2V0Um91dGVDb25maWcodCxcImNhbkFjdGl2YXRlXCIpO3I/ZS5jYWxsSG9vayhyLG51bGwsbix7ZXhwZWN0Qm9vbGVhbjohMH0pOm4oKX19KX1mdW5jdGlvbiBhKHQsZSxuKXt2YXIgcj10LmNoaWxkVk0sbz1wLmdldFJvdXRlQ29uZmlnKHIsXCJkZWFjdGl2YXRlXCIpO28/ZS5jYWxsSG9va3MobyxyLG4pOm4oKX1mdW5jdGlvbiBzKHQsZSxuLHIsbyl7dmFyIGk9ZS5hY3RpdmF0ZVF1ZXVlW25dO2lmKCFpKXJldHVybiB0Ll9ib3VuZCYmdC5zZXRDb21wb25lbnQobnVsbCksdm9pZChyJiZyKCkpO3ZhciBhPXQuQ29tcG9uZW50PWkuY29tcG9uZW50LHU9cC5nZXRSb3V0ZUNvbmZpZyhhLFwiYWN0aXZhdGVcIiksaD1wLmdldFJvdXRlQ29uZmlnKGEsXCJkYXRhXCIpLGw9cC5nZXRSb3V0ZUNvbmZpZyhhLFwid2FpdEZvckRhdGFcIik7dC5kZXB0aD1uLHQuYWN0aXZhdGVkPSExO3ZhciBmPXZvaWQgMCxkPSEoIWh8fGwpO2lmKG89byYmdC5jaGlsZFZNJiZ0LmNoaWxkVk0uY29uc3RydWN0b3I9PT1hKWY9dC5jaGlsZFZNLGYuJGxvYWRpbmdSb3V0ZURhdGE9ZDtlbHNle2lmKHQudW5idWlsZCghMCksdC5rZWVwQWxpdmUpe3ZhciB2PWUucm91dGVyLl92aWV3cyxnPXYuaW5kZXhPZih0KTtnPjAmJihlLnJvdXRlci5fdmlld3M9di5zbGljZShnKSx0LmNoaWxkVk0mJih0LmNoaWxkVk0uX3JvdXRlclZpZXdzPXYuc2xpY2UoMCxnKSkpfWlmKGY9dC5idWlsZCh7X21ldGE6eyRsb2FkaW5nUm91dGVEYXRhOmR9fSksdC5rZWVwQWxpdmUpe2YuJGxvYWRpbmdSb3V0ZURhdGE9ZDt2YXIgeT1mLl9yb3V0ZXJWaWV3czt5JiYoZS5yb3V0ZXIuX3ZpZXdzPXkuY29uY2F0KGUucm91dGVyLl92aWV3cyksdC5jaGlsZFZpZXc9eVt5Lmxlbmd0aC0xXSxmLl9yb3V0ZXJWaWV3cz1udWxsKX19dmFyIG09ZnVuY3Rpb24oKXtmLiRkZXN0cm95KCl9LF89ZnVuY3Rpb24oKXtpZihvKXJldHVybiB2b2lkKHImJnIoKSk7dmFyIG49ZS5yb3V0ZXI7bi5fcmVuZGVyZWR8fG4uX3RyYW5zaXRpb25PbkxvYWQ/dC50cmFuc2l0aW9uKGYpOih0LnNldEN1cnJlbnQ/dC5zZXRDdXJyZW50KGYpOnQuY2hpbGRWTT1mLGYuJGJlZm9yZSh0LmFuY2hvcixudWxsLCExKSksciYmcigpfSx3PWZ1bmN0aW9uKCl7dC5hY3RpdmF0ZWQ9ITAsdC5jaGlsZFZpZXcmJnModC5jaGlsZFZpZXcsZSxuKzEsbnVsbCxvfHx0LmtlZXBBbGl2ZSksaCYmbD9jKGYsZSxoLF8sbSk6KGgmJmMoZixlLGgpLF8oKSl9O3U/ZS5jYWxsSG9va3ModSxmLHcse2NsZWFudXA6bX0pOncoKX1mdW5jdGlvbiB1KHQsZSl7dmFyIG49dC5jaGlsZFZNLHI9cC5nZXRSb3V0ZUNvbmZpZyhuLFwiZGF0YVwiKTtyJiZjKG4sZSxyKX1mdW5jdGlvbiBjKHQsZSxuLHIsbyl7dC4kbG9hZGluZ1JvdXRlRGF0YT0hMCxlLmNhbGxIb29rcyhuLHQsZnVuY3Rpb24oZSxuKXtBcnJheS5pc0FycmF5KGUpJiZlLl9uZWVkTWVyZ2UmJihlPWUucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGgoZSkmJmwoZSkuZm9yRWFjaChmdW5jdGlvbihuKXt0W25dPWVbbl19KSx0fSxmKG51bGwpKSk7dmFyIG89W107aChlKSYmbChlKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe3ZhciByPWVbbl07cC5pc1Byb21pc2Uocik/by5wdXNoKHIudGhlbihmdW5jdGlvbihlKXt0LiRzZXQobixlKX0pKTp0LiRzZXQobixyKX0pLG8ubGVuZ3RoP29bMF0uY29uc3RydWN0b3IuYWxsKG8pLnRoZW4oZnVuY3Rpb24oZSl7dC4kbG9hZGluZ1JvdXRlRGF0YT0hMSxyJiZyKCl9LG4pOih0LiRsb2FkaW5nUm91dGVEYXRhPSExLHImJnIoKSl9LHtjbGVhbnVwOm8sZXhwZWN0RGF0YTohMH0pfWZ1bmN0aW9uIGgodCl7cmV0dXJuXCJbb2JqZWN0IE9iamVjdF1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX12YXIgbD1uKDIwKVtcImRlZmF1bHRcIl0sZj1uKDI1KVtcImRlZmF1bHRcIl07ZS5fX2VzTW9kdWxlPSEwLGUuY2FuUmV1c2U9cixlLmNhbkRlYWN0aXZhdGU9byxlLmNhbkFjdGl2YXRlPWksZS5kZWFjdGl2YXRlPWEsZS5hY3RpdmF0ZT1zLGUucmV1c2U9dTt2YXIgcD1uKDMpfSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPXtcImRlZmF1bHRcIjpuKDIxKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24odCxlLG4pe24oMjIpLHQuZXhwb3J0cz1uKDE2KS5PYmplY3Qua2V5c30sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMjMpO24oMTMpKFwia2V5c1wiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdChyKGUpKX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMjQpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0KHIodCkpfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodm9pZCAwPT10KXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIit0KTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9e1wiZGVmYXVsdFwiOm4oMjYpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigyNyk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIuY3JlYXRlKHQsZSl9fSxmdW5jdGlvbih0LGUpe3ZhciBuPU9iamVjdDt0LmV4cG9ydHM9e2NyZWF0ZTpuLmNyZWF0ZSxnZXRQcm90bzpuLmdldFByb3RvdHlwZU9mLGlzRW51bTp7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxnZXREZXNjOm4uZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLHNldERlc2M6bi5kZWZpbmVQcm9wZXJ0eSxzZXREZXNjczpuLmRlZmluZVByb3BlcnRpZXMsZ2V0S2V5czpuLmtleXMsZ2V0TmFtZXM6bi5nZXRPd25Qcm9wZXJ0eU5hbWVzLGdldFN5bWJvbHM6bi5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsZWFjaDpbXS5mb3JFYWNofX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuX19lc01vZHVsZT0hMDt2YXIgcj1uKDMpLG89bigxOSk7ZVtcImRlZmF1bHRcIl09ZnVuY3Rpb24odCl7dmFyIGU9dC51dGlsLG49dC5kaXJlY3RpdmUoXCJfY29tcG9uZW50XCIpfHx0LmludGVybmFsRGlyZWN0aXZlcy5jb21wb25lbnQsaT1lLmV4dGVuZCh7fSxuKTtlLmV4dGVuZChpLHtfaXNSb3V0ZXJWaWV3OiEwLGJpbmQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnZtLiRyb3V0ZTtpZighdClyZXR1cm4gdm9pZCByLndhcm4oXCI8cm91dGVyLXZpZXc+IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgcm91dGVyLWVuYWJsZWQgYXBwLlwiKTt0aGlzLl9pc0R5bmFtaWNMaXRlcmFsPSEwLG4uYmluZC5jYWxsKHRoaXMpO3ZhciBlPXRoaXMucm91dGVyPXQucm91dGVyO2UuX3ZpZXdzLnVuc2hpZnQodGhpcyk7dmFyIGk9ZS5fdmlld3NbMV07aSYmKGkuY2hpbGRWaWV3PXRoaXMpO3ZhciBhPXQucm91dGVyLl9jdXJyZW50VHJhbnNpdGlvbjtpZighaSYmYS5kb25lfHxpJiZpLmFjdGl2YXRlZCl7dmFyIHM9aT9pLmRlcHRoKzE6MDtvLmFjdGl2YXRlKHRoaXMsYSxzKX19LHVuYmluZDpmdW5jdGlvbigpe3RoaXMucm91dGVyLl92aWV3cy4kcmVtb3ZlKHRoaXMpLG4udW5iaW5kLmNhbGwodGhpcyl9fSksdC5lbGVtZW50RGlyZWN0aXZlKFwicm91dGVyLXZpZXdcIixpKX0sdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5fX2VzTW9kdWxlPSEwO3ZhciByPW4oMyksbz0vXFwvJC8saT0vWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO2VbXCJkZWZhdWx0XCJdPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cmV0dXJuIHQucHJvdG9jb2w9PT1sb2NhdGlvbi5wcm90b2NvbCYmdC5ob3N0bmFtZT09PWxvY2F0aW9uLmhvc3RuYW1lJiZ0LnBvcnQ9PT1sb2NhdGlvbi5wb3J0fXZhciBuPXQudXRpbDt0LmRpcmVjdGl2ZShcImxpbmtcIix7YmluZDpmdW5jdGlvbigpe3ZhciB0PXRoaXMsbz10aGlzLnZtO2lmKCFvLiRyb3V0ZSlyZXR1cm4gdm9pZCByLndhcm4oXCJ2LWxpbmsgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgYSByb3V0ZXItZW5hYmxlZCBhcHAuXCIpO3ZhciBpPW8uJHJvdXRlLnJvdXRlcjt0aGlzLmhhbmRsZXI9ZnVuY3Rpb24obil7aWYoIShuLm1ldGFLZXl8fG4uY3RybEtleXx8bi5zaGlmdEtleXx8bi5kZWZhdWx0UHJldmVudGVkfHwwIT09bi5idXR0b24pKXt2YXIgcj10LnRhcmdldCxvPWZ1bmN0aW9uKHQpe24ucHJldmVudERlZmF1bHQoKSxudWxsIT10JiZpLmdvKHQpfTtpZihcIkFcIj09PXQuZWwudGFnTmFtZXx8bi50YXJnZXQ9PT10LmVsKW8ocik7ZWxzZXtmb3IodmFyIGE9bi50YXJnZXQ7YSYmXCJBXCIhPT1hLnRhZ05hbWUmJmEhPT10LmVsOylhPWEucGFyZW50Tm9kZTtpZighYSlyZXR1cm47XCJBXCI9PT1hLnRhZ05hbWUmJmEuaHJlZj9lKGEpJiZvKHtwYXRoOmEucGF0aG5hbWUscmVwbGFjZTpyJiZyLnJlcGxhY2UsYXBwZW5kOnImJnIuYXBwZW5kfSk6byhyKX19fSx0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuaGFuZGxlciksdGhpcy51bndhdGNoPW8uJHdhdGNoKFwiJHJvdXRlLnBhdGhcIixuLmJpbmQodGhpcy51cGRhdGVDbGFzc2VzLHRoaXMpKX0sdXBkYXRlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMudm0uJHJvdXRlLnJvdXRlcixyPXZvaWQgMDt0aGlzLnRhcmdldD10LG4uaXNPYmplY3QodCkmJihyPXQuYXBwZW5kLHRoaXMuZXhhY3Q9dC5leGFjdCx0aGlzLnByZXZBY3RpdmVDbGFzcz10aGlzLmFjdGl2ZUNsYXNzLHRoaXMuYWN0aXZlQ2xhc3M9dC5hY3RpdmVDbGFzcyksdD10aGlzLnBhdGg9ZS5fc3RyaW5naWZ5UGF0aCh0KSx0aGlzLmFjdGl2ZVJFPXQmJiF0aGlzLmV4YWN0P25ldyBSZWdFeHAoXCJeXCIrdC5yZXBsYWNlKC9cXC8kLyxcIlwiKS5yZXBsYWNlKGksXCJcXFxcJCZcIikrXCIoXFxcXC98JClcIik6bnVsbCx0aGlzLnVwZGF0ZUNsYXNzZXModGhpcy52bS4kcm91dGUucGF0aCk7dmFyIG89XCIvXCI9PT10LmNoYXJBdCgwKSxhPXQmJihcImhhc2hcIj09PWUubW9kZXx8byk/ZS5oaXN0b3J5LmZvcm1hdFBhdGgodCxyKTp0O1wiQVwiPT09dGhpcy5lbC50YWdOYW1lJiYoYT90aGlzLmVsLmhyZWY9YTp0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShcImhyZWZcIikpfSx1cGRhdGVDbGFzc2VzOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZWwscj10aGlzLnBhdGgsaT10aGlzLnZtLiRyb3V0ZS5yb3V0ZXIsYT10aGlzLmFjdGl2ZUNsYXNzfHxpLl9saW5rQWN0aXZlQ2xhc3M7dGhpcy5wcmV2QWN0aXZlQ2xhc3MhPT1hJiZuLnJlbW92ZUNsYXNzKGUsdGhpcy5wcmV2QWN0aXZlQ2xhc3MpLHRoaXMuZXhhY3Q/cj09PXR8fFwiL1wiIT09ci5jaGFyQXQoci5sZW5ndGgtMSkmJnI9PT10LnJlcGxhY2UobyxcIlwiKT9uLmFkZENsYXNzKGUsYSk6bi5yZW1vdmVDbGFzcyhlLGEpOnRoaXMuYWN0aXZlUkUmJnRoaXMuYWN0aXZlUkUudGVzdCh0KT9uLmFkZENsYXNzKGUsYSk6bi5yZW1vdmVDbGFzcyhlLGEpfSx1bmJpbmQ6ZnVuY3Rpb24oKXt0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuaGFuZGxlciksdGhpcy51bndhdGNoJiZ0aGlzLnVud2F0Y2goKX19KX0sdC5leHBvcnRzPWVbXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigxKVtcImRlZmF1bHRcIl07ZS5fX2VzTW9kdWxlPSEwO3ZhciBvPW4oMyksaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7dmFyIG49ZS5vbkNoYW5nZTtyKHRoaXMsdCksdGhpcy5vbkNoYW5nZT1uLHRoaXMuY3VycmVudFBhdGg9XCIvXCJ9cmV0dXJuIHQucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7dGhpcy5vbkNoYW5nZShcIi9cIil9LHQucHJvdG90eXBlLnN0b3A9ZnVuY3Rpb24oKXt9LHQucHJvdG90eXBlLmdvPWZ1bmN0aW9uKHQsZSxuKXt0PXRoaXMuY3VycmVudFBhdGg9dGhpcy5mb3JtYXRQYXRoKHQsbiksdGhpcy5vbkNoYW5nZSh0KX0sdC5wcm90b3R5cGUuZm9ybWF0UGF0aD1mdW5jdGlvbih0LGUpe3JldHVyblwiL1wiPT09dC5jaGFyQXQoMCk/dDpvLnJlc29sdmVQYXRoKHRoaXMuY3VycmVudFBhdGgsdCxlKX0sdH0oKTtlW1wiZGVmYXVsdFwiXT1pLHQuZXhwb3J0cz1lW1wiZGVmYXVsdFwiXX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMSlbXCJkZWZhdWx0XCJdO2UuX19lc01vZHVsZT0hMDt2YXIgbz1uKDMpLGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe3ZhciBuPWUuaGFzaGJhbmcsbz1lLm9uQ2hhbmdlO3IodGhpcyx0KSx0aGlzLmhhc2hiYW5nPW4sdGhpcy5vbkNoYW5nZT1vfXJldHVybiB0LnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5saXN0ZW5lcj1mdW5jdGlvbigpe3ZhciBlPWxvY2F0aW9uLmhhc2gsbj1lLnJlcGxhY2UoL14jIT8vLFwiXCIpO1wiL1wiIT09bi5jaGFyQXQoMCkmJihuPVwiL1wiK24pO3ZhciByPXQuZm9ybWF0UGF0aChuKTtpZihyIT09ZSlyZXR1cm4gdm9pZCBsb2NhdGlvbi5yZXBsYWNlKHIpO3ZhciBvPWRlY29kZVVSSShlLnJlcGxhY2UoL14jIT8vLFwiXCIpK2xvY2F0aW9uLnNlYXJjaCk7dC5vbkNoYW5nZShvKX0sd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsdGhpcy5saXN0ZW5lciksdGhpcy5saXN0ZW5lcigpfSx0LnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsdGhpcy5saXN0ZW5lcil9LHQucHJvdG90eXBlLmdvPWZ1bmN0aW9uKHQsZSxuKXt0PXRoaXMuZm9ybWF0UGF0aCh0LG4pLGU/bG9jYXRpb24ucmVwbGFjZSh0KTpsb2NhdGlvbi5oYXNoPXR9LHQucHJvdG90eXBlLmZvcm1hdFBhdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj1cIi9cIj09PXQuY2hhckF0KDApLHI9XCIjXCIrKHRoaXMuaGFzaGJhbmc/XCIhXCI6XCJcIik7cmV0dXJuIG4/cit0OnIrby5yZXNvbHZlUGF0aChsb2NhdGlvbi5oYXNoLnJlcGxhY2UoL14jIT8vLFwiXCIpLHQsZSl9LHR9KCk7ZVtcImRlZmF1bHRcIl09aSx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDEpW1wiZGVmYXVsdFwiXTtlLl9fZXNNb2R1bGU9ITA7dmFyIG89bigzKSxpPS8jLiokLyxhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXt2YXIgbj1lLnJvb3Qsbz1lLm9uQ2hhbmdlO3IodGhpcyx0KSxuPyhcIi9cIiE9PW4uY2hhckF0KDApJiYobj1cIi9cIituKSx0aGlzLnJvb3Q9bi5yZXBsYWNlKC9cXC8kLyxcIlwiKSx0aGlzLnJvb3RSRT1uZXcgUmVnRXhwKFwiXlxcXFxcIit0aGlzLnJvb3QpKTp0aGlzLnJvb3Q9bnVsbCx0aGlzLm9uQ2hhbmdlPW87dmFyIGk9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJhc2VcIik7dGhpcy5iYXNlPWkmJmkuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKX1yZXR1cm4gdC5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMubGlzdGVuZXI9ZnVuY3Rpb24oZSl7dmFyIG49ZGVjb2RlVVJJKGxvY2F0aW9uLnBhdGhuYW1lK2xvY2F0aW9uLnNlYXJjaCk7dC5yb290JiYobj1uLnJlcGxhY2UodC5yb290UkUsXCJcIikpLHQub25DaGFuZ2UobixlJiZlLnN0YXRlLGxvY2F0aW9uLmhhc2gpfSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsdGhpcy5saXN0ZW5lciksdGhpcy5saXN0ZW5lcigpfSx0LnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLHRoaXMubGlzdGVuZXIpfSx0LnByb3RvdHlwZS5nbz1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcy5mb3JtYXRQYXRoKHQsbik7ZT9oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSxcIlwiLHIpOihoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7cG9zOnt4OndpbmRvdy5wYWdlWE9mZnNldCx5OndpbmRvdy5wYWdlWU9mZnNldH19LFwiXCIpLGhpc3RvcnkucHVzaFN0YXRlKHt9LFwiXCIscikpO3ZhciBvPXQubWF0Y2goaSksYT1vJiZvWzBdO3Q9ci5yZXBsYWNlKGksXCJcIikucmVwbGFjZSh0aGlzLnJvb3RSRSxcIlwiKSx0aGlzLm9uQ2hhbmdlKHQsbnVsbCxhKX0sdC5wcm90b3R5cGUuZm9ybWF0UGF0aD1mdW5jdGlvbih0LGUpe3JldHVyblwiL1wiPT09dC5jaGFyQXQoMCk/dGhpcy5yb290P3RoaXMucm9vdCtcIi9cIit0LnJlcGxhY2UoL15cXC8vLFwiXCIpOnQ6by5yZXNvbHZlUGF0aCh0aGlzLmJhc2V8fGxvY2F0aW9uLnBhdGhuYW1lLHQsZSl9LHR9KCk7ZVtcImRlZmF1bHRcIl09YSx0LmV4cG9ydHM9ZVtcImRlZmF1bHRcIl19XSl9KTsiLCIvKiEgQ29weXJpZ2h0IChjKSAyMDE2IE5hdWZhbCBSYWJiYW5pIChodHRwOi8vZ2l0aHViLmNvbS9Cb3NOYXVmYWwpXG4qIExpY2Vuc2VkIFVuZGVyIE1JVCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbipcbiogVnVlIFNpbXBsZSBTdG9yZSAtIHZlcnNpb25AMS4wLjBcbipcbiovXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIFZ1ZVNpbXBsZVN0b3JlID0ge1xuXG4gICAgaW5zdGFsbDogZnVuY3Rpb24oVnVlLCBvcHQpe1xuXG4gICAgICB2YXIgcGx1Z2luID0gdGhpcztcblxuICAgICAgaWYob3B0LmRlYnVnKSBjb25zb2xlLmluZm8oJ1tWdWUgU2ltcGxlIFN0b3JlXTogSW4gRGVidWcgTW9kZScpO1xuXG4gICAgICB2YXIgdGhlU3RvcmVzID0ge31cbiAgICAgIHZhciB0aGVTdGF0ZSA9IHt9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0LnN0b3Jlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIGlmKG9wdC5zdG9yZXNbaV0ubmFtZSA9PT0gdW5kZWZpbmVkKSBjb25zb2xlLndhcm4oXCJbVnVlIFNpbXBsZSBTdG9yZV06IFBsZWFzZSBhZGQgYSBTdG9yZSBOYW1lXCIsIG9wdC5zdG9yZXNbaV0pO1xuXG4gICAgICAgIC8vIE1ha2UgYSBnbG9iYWwgU3RvcmVzXG4gICAgICAgIHRoZVN0b3Jlc1tvcHQuc3RvcmVzW2ldLm5hbWVdID0gb3B0LnN0b3Jlc1tpXTtcblxuICAgICAgICAvLyBNYWtlIGEgZ2xvYmFsIHN0YXRlXG4gICAgICAgIGlmKG9wdC5zdG9yZXNbaV0uc3RhdGUgIT09IHVuZGVmaW5lZCkgdGhlU3RhdGVbb3B0LnN0b3Jlc1tpXS5uYW1lXSA9IG9wdC5zdG9yZXNbaV0uc3RhdGU7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBuYW1lXG4gICAgICAgIGRlbGV0ZSB0aGVTdG9yZXNbb3B0LnN0b3Jlc1tpXS5uYW1lXS5uYW1lO1xuICAgICAgfVxuXG4gICAgICBwbHVnaW4ubWl4aW4gPSB7fTtcblxuICAgICAgcGx1Z2luLm1peGluLmluaXQgPSBmdW5jdGlvbigpe1xuICAgICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLCdzdGF0ZScsdGhlU3RhdGUpO1xuICAgICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLCckYWN0aW9uJywgZnVuY3Rpb24oZXZlbnROYW1lLHZhbCl7XG5cbiAgICAgICAgICB2YXIgdGhlQ29sb24gPSBldmVudE5hbWUuc2VhcmNoKCc6Jyk7XG4gICAgICAgICAgdmFyIHN0b3JlTmFtZSA9IGV2ZW50TmFtZS5zdWJzdHIoMCx0aGVDb2xvbik7XG4gICAgICAgICAgdmFyIHRoZUV2ZW50ID0gZXZlbnROYW1lLnN1YnN0cih0aGVDb2xvbisxLGV2ZW50TmFtZS5sZW5ndGgpXG5cbiAgICAgICAgICBpZih0aGVTdG9yZXNbc3RvcmVOYW1lXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gY29uc29sZS53YXJuKFwiW1Z1ZSBTaW1wbGUgU3RvcmVdOiB0aGUgXCIrc3RvcmVOYW1lK1wiIHN0b3JlIGRvZXNuJ3QgZXhpc3RcIik7XG5cbiAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBzdG9yZVxuICAgICAgICAgIHRoZVN0b3Jlc1tzdG9yZU5hbWVdW3RoZUV2ZW50XSh2YWwpO1xuXG4gICAgICAgICAgaWYob3B0LmRlYnVnKXtcbiAgICAgICAgICAgIGlmKHZhbCA9PT0gdW5kZWZpbmVkKSBjb25zb2xlLmluZm8oZXZlbnROYW1lKTtcbiAgICAgICAgICAgIGVsc2UgY29uc29sZS5pbmZvKGV2ZW50TmFtZSx2YWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE1lcmdlIG1peGluIHRvIFZNIHZpYSB2dWUgb3B0aW9uc1xuICAgICAgVnVlLm9wdGlvbnMgPSBWdWUudXRpbC5tZXJnZU9wdGlvbnMoVnVlLm9wdGlvbnMsIHBsdWdpbi5taXhpbilcbiAgICB9XG5cbiAgfTtcblxuICAvLyBJZiBzdXBwb3J0IG5vZGUgLyBFUzYgbW9kdWxlXG4gIGlmKCB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApe1xuICAgIG1vZHVsZS5leHBvcnRzID0gVnVlU2ltcGxlU3RvcmVcbiAgfVxuICAvLyBpZiB1c2luZyByZXF1aXJlIGpzXG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSggZnVuY3Rpb24gKCkgeyByZXR1cm4gVnVlU2ltcGxlU3RvcmUgfSlcbiAgfVxuICAvLyBpZiBzY3JpcHQgbG9hZGVkIGJ5IHNjcmlwdCB0YWcgaW4gSFRNTCBmaWxlXG4gIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB3aW5kb3cuVnVlU2ltcGxlU3RvcmUgPSBWdWVTaW1wbGVTdG9yZVxuICB9XG5cbn0pKClcbiIsIi8qIVxuICogVnVlLmpzIHYxLjAuMThcbiAqIChjKSAyMDE2IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbC5WdWUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBzZXQob2JqLCBrZXksIHZhbCkge1xuICAgIGlmIChoYXNPd24ob2JqLCBrZXkpKSB7XG4gICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9iai5faXNWdWUpIHtcbiAgICAgIHNldChvYmouX2RhdGEsIGtleSwgdmFsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9iID0gb2JqLl9fb2JfXztcbiAgICBpZiAoIW9iKSB7XG4gICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb2IuY29udmVydChrZXksIHZhbCk7XG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIGlmIChvYi52bXMpIHtcbiAgICAgIHZhciBpID0gb2Iudm1zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIHZtID0gb2Iudm1zW2ldO1xuICAgICAgICB2bS5fcHJveHkoa2V5KTtcbiAgICAgICAgdm0uX2RpZ2VzdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKi9cblxuICBmdW5jdGlvbiBkZWwob2JqLCBrZXkpIHtcbiAgICBpZiAoIWhhc093bihvYmosIGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIG9ialtrZXldO1xuICAgIHZhciBvYiA9IG9iai5fX29iX187XG4gICAgaWYgKCFvYikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgaWYgKG9iLnZtcykge1xuICAgICAgdmFyIGkgPSBvYi52bXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgdm0gPSBvYi52bXNbaV07XG4gICAgICAgIHZtLl91bnByb3h5KGtleSk7XG4gICAgICAgIHZtLl9kaWdlc3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuICBmdW5jdGlvbiBoYXNPd24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gZXhwcmVzc2lvbiBpcyBhIGxpdGVyYWwgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cbiAgdmFyIGxpdGVyYWxWYWx1ZVJFID0gL15cXHM/KHRydWV8ZmFsc2V8LT9bXFxkXFwuXSt8J1teJ10qJ3xcIlteXCJdKlwiKVxccz8kLztcblxuICBmdW5jdGlvbiBpc0xpdGVyYWwoZXhwKSB7XG4gICAgcmV0dXJuIGxpdGVyYWxWYWx1ZVJFLnRlc3QoZXhwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuICBmdW5jdGlvbiBpc1Jlc2VydmVkKHN0cikge1xuICAgIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICAgIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUY7XG4gIH1cblxuICAvKipcbiAgICogR3VhcmQgdGV4dCBvdXRwdXQsIG1ha2Ugc3VyZSB1bmRlZmluZWQgb3V0cHV0c1xuICAgKiBlbXB0eSBzdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIF90b1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGFuZCBjb252ZXJ0IHBvc3NpYmxlIG51bWVyaWMgc3RyaW5ncyB0byBudW1iZXJzXG4gICAqIGJlZm9yZSBzZXR0aW5nIGJhY2sgdG8gZGF0YVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4geyp8TnVtYmVyfVxuICAgKi9cblxuICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJzZWQgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgcmV0dXJuIGlzTmFOKHBhcnNlZCkgPyB2YWx1ZSA6IHBhcnNlZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBzdHJpbmcgYm9vbGVhbiBsaXRlcmFscyBpbnRvIHJlYWwgYm9vbGVhbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7KnxCb29sZWFufVxuICAgKi9cblxuICBmdW5jdGlvbiB0b0Jvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09ICd0cnVlJyA/IHRydWUgOiB2YWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU3RyaXAgcXVvdGVzIGZyb20gYSBzdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcmV0dXJuIHtTdHJpbmcgfCBmYWxzZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gc3RyaXBRdW90ZXMoc3RyKSB7XG4gICAgdmFyIGEgPSBzdHIuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KHN0ci5sZW5ndGggLSAxKTtcbiAgICByZXR1cm4gYSA9PT0gYiAmJiAoYSA9PT0gMHgyMiB8fCBhID09PSAweDI3KSA/IHN0ci5zbGljZSgxLCAtMSkgOiBzdHI7XG4gIH1cblxuICAvKipcbiAgICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsbWl0ZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgdmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5cbiAgZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIHRvVXBwZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9VcHBlcihfLCBjKSB7XG4gICAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgdmFyIGh5cGhlbmF0ZVJFID0gLyhbYS16XFxkXSkoW0EtWl0pL2c7XG5cbiAgZnVuY3Rpb24gaHlwaGVuYXRlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBoeXBoZW4vdW5kZXJzY29yZS9zbGFzaCBkZWxpbWl0ZXJlZCBuYW1lcyBpbnRvXG4gICAqIGNhbWVsaXplZCBjbGFzc05hbWVzLlxuICAgKlxuICAgKiBlLmcuIG15LWNvbXBvbmVudCA9PiBNeUNvbXBvbmVudFxuICAgKiAgICAgIHNvbWVfZWxzZSAgICA9PiBTb21lRWxzZVxuICAgKiAgICAgIHNvbWUvY29tcCAgICA9PiBTb21lQ29tcFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9cXC9dKShcXHcpL2c7XG5cbiAgZnVuY3Rpb24gY2xhc3NpZnkoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIHRvVXBwZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gYmluZChmbiwgY3R4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICByZXR1cm4gbCA/IGwgPiAxID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpIDogZm4uY2FsbChjdHgsIGEpIDogZm4uY2FsbChjdHgpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXktbGlrZX0gbGlzdFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0XSAtIHN0YXJ0IGluZGV4XG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cblxuICBmdW5jdGlvbiB0b0FycmF5KGxpc3QsIHN0YXJ0KSB7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICAgKi9cblxuICBmdW5jdGlvbiBleHRlbmQodG8sIGZyb20pIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICAgIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdG9ba2V5c1tpXV0gPSBmcm9tW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdG87XG4gIH1cblxuICAvKipcbiAgICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gICAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAgICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG9ialxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAgICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBvYmpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cbiAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBPYmplY3RdJztcblxuICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkc7XG4gIH1cblxuICAvKipcbiAgICogQXJyYXkgdHlwZSBjaGVjay5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBvYmpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VudW1lcmFibGVdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGRlZihvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsLFxuICAgICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWJvdW5jZSBhIGZ1bmN0aW9uIHNvIGl0IG9ubHkgZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlXG4gICAqIGlucHV0IHN0b3BzIGFycml2aW5nIGFmdGVyIHRoZSBnaXZlbiB3YWl0IHBlcmlvZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgKiBAcGFyYW0ge051bWJlcn0gd2FpdFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gICAqL1xuXG4gIGZ1bmN0aW9uIF9kZWJvdW5jZShmdW5jLCB3YWl0KSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xuICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1hbnVhbCBpbmRleE9mIGJlY2F1c2UgaXQncyBzbGlnaHRseSBmYXN0ZXIgdGhhblxuICAgKiBuYXRpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgKiBAcGFyYW0geyp9IG9ialxuICAgKi9cblxuICBmdW5jdGlvbiBpbmRleE9mKGFyciwgb2JqKSB7XG4gICAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgY2FuY2VsbGFibGUgdmVyc2lvbiBvZiBhbiBhc3luYyBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNhbmNlbGxhYmxlKGZuKSB7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24gY2IoKSB7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNiLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gY2I7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gICAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAgICpcbiAgICogQHBhcmFtIHsqfSBhXG4gICAqIEBwYXJhbSB7Kn0gYlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuICBmdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgICByZXR1cm4gYSA9PSBiIHx8IChpc09iamVjdChhKSAmJiBpc09iamVjdChiKSA/IEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKSA6IGZhbHNlKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuICB9XG5cbiAgdmFyIGhhc1Byb3RvID0gKCdfX3Byb3RvX18nIGluIHt9KTtcblxuICAvLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG4gIHZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93KSAhPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbiAgLy8gZGV0ZWN0IGRldnRvb2xzXG4gIHZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuICAvLyBVQSBzbmlmZmluZyBmb3Igd29ya2luZyBhcm91bmQgYnJvd3Nlci1zcGVjaWZpYyBxdWlya3NcbiAgdmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIHZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xuICB2YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcblxuICB2YXIgdHJhbnNpdGlvblByb3AgPSB1bmRlZmluZWQ7XG4gIHZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSB1bmRlZmluZWQ7XG4gIHZhciBhbmltYXRpb25Qcm9wID0gdW5kZWZpbmVkO1xuICB2YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSB1bmRlZmluZWQ7XG5cbiAgLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xuICBpZiAoaW5Ccm93c2VyICYmICFpc0lFOSkge1xuICAgIHZhciBpc1dlYmtpdFRyYW5zID0gd2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaXNXZWJraXRBbmltID0gd2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiYgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWQ7XG4gICAgdHJhbnNpdGlvblByb3AgPSBpc1dlYmtpdFRyYW5zID8gJ1dlYmtpdFRyYW5zaXRpb24nIDogJ3RyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9IGlzV2Via2l0VHJhbnMgPyAnd2Via2l0VHJhbnNpdGlvbkVuZCcgOiAndHJhbnNpdGlvbmVuZCc7XG4gICAgYW5pbWF0aW9uUHJvcCA9IGlzV2Via2l0QW5pbSA/ICdXZWJraXRBbmltYXRpb24nIDogJ2FuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSBpc1dlYmtpdEFuaW0gPyAnd2Via2l0QW5pbWF0aW9uRW5kJyA6ICdhbmltYXRpb25lbmQnO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LiBJZGVhbGx5IHRoaXNcbiAgICogc2hvdWxkIGJlIGV4ZWN1dGVkIGFzIGEgbWljcm90YXNrLCBzbyB3ZSBsZXZlcmFnZVxuICAgKiBNdXRhdGlvbk9ic2VydmVyIGlmIGl0J3MgYXZhaWxhYmxlLCBhbmQgZmFsbGJhY2sgdG9cbiAgICogc2V0VGltZW91dCgwKS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICAgKi9cblxuICB2YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciB0aW1lckZ1bmM7XG4gICAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyKCkge1xuICAgICAgcGVuZGluZyA9IGZhbHNlO1xuICAgICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29waWVzW2ldKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvdW50ZXIpO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgICB0ZXh0Tm9kZS5kYXRhID0gY291bnRlcjtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlYnBhY2sgYXR0ZW1wdHMgdG8gaW5qZWN0IGEgc2hpbSBmb3Igc2V0SW1tZWRpYXRlXG4gICAgICAvLyBpZiBpdCBpcyB1c2VkIGFzIGEgZ2xvYmFsLCBzbyB3ZSBoYXZlIHRvIHdvcmsgYXJvdW5kIHRoYXQgdG9cbiAgICAgIC8vIGF2b2lkIGJ1bmRsaW5nIHVubmVjZXNzYXJ5IGNvZGUuXG4gICAgICB2YXIgY29udGV4dCA9IGluQnJvd3NlciA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDoge307XG4gICAgICB0aW1lckZ1bmMgPSBjb250ZXh0LnNldEltbWVkaWF0ZSB8fCBzZXRUaW1lb3V0O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGNiLCBjdHgpIHtcbiAgICAgIHZhciBmdW5jID0gY3R4ID8gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IDogY2I7XG4gICAgICBjYWxsYmFja3MucHVzaChmdW5jKTtcbiAgICAgIGlmIChwZW5kaW5nKSByZXR1cm47XG4gICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRpbWVyRnVuYyhuZXh0VGlja0hhbmRsZXIsIDApO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gQ2FjaGUobGltaXQpIHtcbiAgICB0aGlzLnNpemUgPSAwO1xuICAgIHRoaXMubGltaXQgPSBsaW1pdDtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fa2V5bWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIHZhciBwID0gQ2FjaGUucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBQdXQgPHZhbHVlPiBpbnRvIHRoZSBjYWNoZSBhc3NvY2lhdGVkIHdpdGggPGtleT4uXG4gICAqIFJldHVybnMgdGhlIGVudHJ5IHdoaWNoIHdhcyByZW1vdmVkIHRvIG1ha2Ugcm9vbSBmb3JcbiAgICogdGhlIG5ldyBlbnRyeS4gT3RoZXJ3aXNlIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAgICogKGkuZS4gaWYgdGhlcmUgd2FzIGVub3VnaCByb29tIGFscmVhZHkpLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7RW50cnl8dW5kZWZpbmVkfVxuICAgKi9cblxuICBwLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIHJlbW92ZWQ7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5saW1pdCkge1xuICAgICAgcmVtb3ZlZCA9IHRoaXMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICB2YXIgZW50cnkgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGVudHJ5ID0ge1xuICAgICAgICBrZXk6IGtleVxuICAgICAgfTtcbiAgICAgIHRoaXMuX2tleW1hcFtrZXldID0gZW50cnk7XG4gICAgICBpZiAodGhpcy50YWlsKSB7XG4gICAgICAgIHRoaXMudGFpbC5uZXdlciA9IGVudHJ5O1xuICAgICAgICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgfVxuICAgICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICB0aGlzLnNpemUrKztcbiAgICB9XG4gICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcblxuICAgIHJldHVybiByZW1vdmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdXJnZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCAob2xkZXN0KSBlbnRyeSBmcm9tIHRoZVxuICAgKiBjYWNoZS4gUmV0dXJucyB0aGUgcmVtb3ZlZCBlbnRyeSBvciB1bmRlZmluZWQgaWYgdGhlXG4gICAqIGNhY2hlIHdhcyBlbXB0eS5cbiAgICovXG5cbiAgcC5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmhlYWQ7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV3ZXI7XG4gICAgICB0aGlzLmhlYWQub2xkZXIgPSB1bmRlZmluZWQ7XG4gICAgICBlbnRyeS5uZXdlciA9IGVudHJ5Lm9sZGVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fa2V5bWFwW2VudHJ5LmtleV0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnNpemUtLTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW5kIHJlZ2lzdGVyIHJlY2VudCB1c2Ugb2YgPGtleT4uIFJldHVybnMgdGhlIHZhbHVlXG4gICAqIGFzc29jaWF0ZWQgd2l0aCA8a2V5PiBvciB1bmRlZmluZWQgaWYgbm90IGluIGNhY2hlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRW50cnlcbiAgICogQHJldHVybiB7RW50cnl8Kn1cbiAgICovXG5cbiAgcC5nZXQgPSBmdW5jdGlvbiAoa2V5LCByZXR1cm5FbnRyeSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuX2tleW1hcFtrZXldO1xuICAgIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgaWYgKGVudHJ5ID09PSB0aGlzLnRhaWwpIHtcbiAgICAgIHJldHVybiByZXR1cm5FbnRyeSA/IGVudHJ5IDogZW50cnkudmFsdWU7XG4gICAgfVxuICAgIC8vIEhFQUQtLS0tLS0tLS0tLS0tLVRBSUxcbiAgICAvLyAgIDwub2xkZXIgICAubmV3ZXI+XG4gICAgLy8gIDwtLS0gYWRkIGRpcmVjdGlvbiAtLVxuICAgIC8vICAgQSAgQiAgQyAgPEQ+ICBFXG4gICAgaWYgKGVudHJ5Lm5ld2VyKSB7XG4gICAgICBpZiAoZW50cnkgPT09IHRoaXMuaGVhZCkge1xuICAgICAgICB0aGlzLmhlYWQgPSBlbnRyeS5uZXdlcjtcbiAgICAgIH1cbiAgICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gZW50cnkub2xkZXI7IC8vIEMgPC0tIEUuXG4gICAgfVxuICAgIGlmIChlbnRyeS5vbGRlcikge1xuICAgICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjsgLy8gQy4gLS0+IEVcbiAgICB9XG4gICAgZW50cnkubmV3ZXIgPSB1bmRlZmluZWQ7IC8vIEQgLS14XG4gICAgZW50cnkub2xkZXIgPSB0aGlzLnRhaWw7IC8vIEQuIC0tPiBFXG4gICAgaWYgKHRoaXMudGFpbCkge1xuICAgICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnk7IC8vIEUuIDwtLSBEXG4gICAgfVxuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHJldHVybiByZXR1cm5FbnRyeSA/IGVudHJ5IDogZW50cnkudmFsdWU7XG4gIH07XG5cbiAgdmFyIGNhY2hlJDEgPSBuZXcgQ2FjaGUoMTAwMCk7XG4gIHZhciBmaWx0ZXJUb2tlblJFID0gL1teXFxzJ1wiXSt8J1teJ10qJ3xcIlteXCJdKlwiL2c7XG4gIHZhciByZXNlcnZlZEFyZ1JFID0gL15pbiR8Xi0/XFxkKy87XG5cbiAgLyoqXG4gICAqIFBhcnNlciBzdGF0ZVxuICAgKi9cblxuICB2YXIgc3RyO1xuICB2YXIgZGlyO1xuICB2YXIgYztcbiAgdmFyIHByZXY7XG4gIHZhciBpO1xuICB2YXIgbDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleDtcbiAgdmFyIGluU2luZ2xlO1xuICB2YXIgaW5Eb3VibGU7XG4gIHZhciBjdXJseTtcbiAgdmFyIHNxdWFyZTtcbiAgdmFyIHBhcmVuO1xuICAvKipcbiAgICogUHVzaCBhIGZpbHRlciB0byB0aGUgY3VycmVudCBkaXJlY3RpdmUgb2JqZWN0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIoKSB7XG4gICAgdmFyIGV4cCA9IHN0ci5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKTtcbiAgICB2YXIgZmlsdGVyO1xuICAgIGlmIChleHApIHtcbiAgICAgIGZpbHRlciA9IHt9O1xuICAgICAgdmFyIHRva2VucyA9IGV4cC5tYXRjaChmaWx0ZXJUb2tlblJFKTtcbiAgICAgIGZpbHRlci5uYW1lID0gdG9rZW5zWzBdO1xuICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZpbHRlci5hcmdzID0gdG9rZW5zLnNsaWNlKDEpLm1hcChwcm9jZXNzRmlsdGVyQXJnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbHRlcikge1xuICAgICAgKGRpci5maWx0ZXJzID0gZGlyLmZpbHRlcnMgfHwgW10pLnB1c2goZmlsdGVyKTtcbiAgICB9XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXJndW1lbnQgaXMgZHluYW1pYyBhbmQgc3RyaXAgcXVvdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXJnXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0ZpbHRlckFyZyhhcmcpIHtcbiAgICBpZiAocmVzZXJ2ZWRBcmdSRS50ZXN0KGFyZykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB0b051bWJlcihhcmcpLFxuICAgICAgICBkeW5hbWljOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0cmlwcGVkID0gc3RyaXBRdW90ZXMoYXJnKTtcbiAgICAgIHZhciBkeW5hbWljID0gc3RyaXBwZWQgPT09IGFyZztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBkeW5hbWljID8gYXJnIDogc3RyaXBwZWQsXG4gICAgICAgIGR5bmFtaWM6IGR5bmFtaWNcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgZGlyZWN0aXZlIHZhbHVlIGFuZCBleHRyYWN0IHRoZSBleHByZXNzaW9uXG4gICAqIGFuZCBpdHMgZmlsdGVycyBpbnRvIGEgZGVzY3JpcHRvci5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogXCJhICsgMSB8IHVwcGVyY2FzZVwiIHdpbGwgeWllbGQ6XG4gICAqIHtcbiAgICogICBleHByZXNzaW9uOiAnYSArIDEnLFxuICAgKiAgIGZpbHRlcnM6IFtcbiAgICogICAgIHsgbmFtZTogJ3VwcGVyY2FzZScsIGFyZ3M6IG51bGwgfVxuICAgKiAgIF1cbiAgICogfVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgZnVuY3Rpb24gcGFyc2VEaXJlY3RpdmUocykge1xuICAgIHZhciBoaXQgPSBjYWNoZSQxLmdldChzKTtcbiAgICBpZiAoaGl0KSB7XG4gICAgICByZXR1cm4gaGl0O1xuICAgIH1cblxuICAgIC8vIHJlc2V0IHBhcnNlciBzdGF0ZVxuICAgIHN0ciA9IHM7XG4gICAgaW5TaW5nbGUgPSBpbkRvdWJsZSA9IGZhbHNlO1xuICAgIGN1cmx5ID0gc3F1YXJlID0gcGFyZW4gPSAwO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gICAgZGlyID0ge307XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcHJldiA9IGM7XG4gICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgICAgLy8gY2hlY2sgc2luZ2xlIHF1b3RlXG4gICAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIGluU2luZ2xlID0gIWluU2luZ2xlO1xuICAgICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgICAvLyBjaGVjayBkb3VibGUgcXVvdGVcbiAgICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgaW5Eb3VibGUgPSAhaW5Eb3VibGU7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgc3RyLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmIHN0ci5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3Qykge1xuICAgICAgICBpZiAoZGlyLmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgICBkaXIuZXhwcmVzc2lvbiA9IHN0ci5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYWxyZWFkeSBoYXMgZmlsdGVyXG4gICAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICBjYXNlIDB4MjI6XG4gICAgICAgICAgICBpbkRvdWJsZSA9IHRydWU7YnJlYWs7IC8vIFwiXG4gICAgICAgICAgY2FzZSAweDI3OlxuICAgICAgICAgICAgaW5TaW5nbGUgPSB0cnVlO2JyZWFrOyAvLyAnXG4gICAgICAgICAgY2FzZSAweDI4OlxuICAgICAgICAgICAgcGFyZW4rKzticmVhazsgLy8gKFxuICAgICAgICAgIGNhc2UgMHgyOTpcbiAgICAgICAgICAgIHBhcmVuLS07YnJlYWs7IC8vIClcbiAgICAgICAgICBjYXNlIDB4NUI6XG4gICAgICAgICAgICBzcXVhcmUrKzticmVhazsgLy8gW1xuICAgICAgICAgIGNhc2UgMHg1RDpcbiAgICAgICAgICAgIHNxdWFyZS0tO2JyZWFrOyAvLyBdXG4gICAgICAgICAgY2FzZSAweDdCOlxuICAgICAgICAgICAgY3VybHkrKzticmVhazsgLy8ge1xuICAgICAgICAgIGNhc2UgMHg3RDpcbiAgICAgICAgICAgIGN1cmx5LS07YnJlYWs7IC8vIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXIuZXhwcmVzc2lvbiA9PSBudWxsKSB7XG4gICAgICBkaXIuZXhwcmVzc2lvbiA9IHN0ci5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICB9XG5cbiAgICBjYWNoZSQxLnB1dChzLCBkaXIpO1xuICAgIHJldHVybiBkaXI7XG4gIH1cblxudmFyIGRpcmVjdGl2ZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIHBhcnNlRGlyZWN0aXZlOiBwYXJzZURpcmVjdGl2ZVxuICB9KTtcblxuICB2YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG4gIHZhciBjYWNoZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHRhZ1JFID0gdW5kZWZpbmVkO1xuICB2YXIgaHRtbFJFID0gdW5kZWZpbmVkO1xuICAvKipcbiAgICogRXNjYXBlIGEgc3RyaW5nIHNvIGl0IGNhbiBiZSB1c2VkIGluIGEgUmVnRXhwXG4gICAqIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21waWxlUmVnZXgoKSB7XG4gICAgdmFyIG9wZW4gPSBlc2NhcGVSZWdleChjb25maWcuZGVsaW1pdGVyc1swXSk7XG4gICAgdmFyIGNsb3NlID0gZXNjYXBlUmVnZXgoY29uZmlnLmRlbGltaXRlcnNbMV0pO1xuICAgIHZhciB1bnNhZmVPcGVuID0gZXNjYXBlUmVnZXgoY29uZmlnLnVuc2FmZURlbGltaXRlcnNbMF0pO1xuICAgIHZhciB1bnNhZmVDbG9zZSA9IGVzY2FwZVJlZ2V4KGNvbmZpZy51bnNhZmVEZWxpbWl0ZXJzWzFdKTtcbiAgICB0YWdSRSA9IG5ldyBSZWdFeHAodW5zYWZlT3BlbiArICcoLis/KScgKyB1bnNhZmVDbG9zZSArICd8JyArIG9wZW4gKyAnKC4rPyknICsgY2xvc2UsICdnJyk7XG4gICAgaHRtbFJFID0gbmV3IFJlZ0V4cCgnXicgKyB1bnNhZmVPcGVuICsgJy4qJyArIHVuc2FmZUNsb3NlICsgJyQnKTtcbiAgICAvLyByZXNldCBjYWNoZVxuICAgIGNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgdGVtcGxhdGUgdGV4dCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB0b2tlbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4ge0FycmF5PE9iamVjdD4gfCBudWxsfVxuICAgKiAgICAgICAgICAgICAgIC0ge1N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgICAgICAgIC0ge1N0cmluZ30gdmFsdWVcbiAgICogICAgICAgICAgICAgICAtIHtCb29sZWFufSBbaHRtbF1cbiAgICogICAgICAgICAgICAgICAtIHtCb29sZWFufSBbb25lVGltZV1cbiAgICovXG5cbiAgZnVuY3Rpb24gcGFyc2VUZXh0KHRleHQpIHtcbiAgICBpZiAoIWNhY2hlKSB7XG4gICAgICBjb21waWxlUmVnZXgoKTtcbiAgICB9XG4gICAgdmFyIGhpdCA9IGNhY2hlLmdldCh0ZXh0KTtcbiAgICBpZiAoaGl0KSB7XG4gICAgICByZXR1cm4gaGl0O1xuICAgIH1cbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4vZywgJycpO1xuICAgIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbWF0Y2gsIGluZGV4LCBodG1sLCB2YWx1ZSwgZmlyc3QsIG9uZVRpbWU7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICB3aGlsZSAobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSB7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHZhbHVlOiB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gdGFnIHRva2VuXG4gICAgICBodG1sID0gaHRtbFJFLnRlc3QobWF0Y2hbMF0pO1xuICAgICAgdmFsdWUgPSBodG1sID8gbWF0Y2hbMV0gOiBtYXRjaFsyXTtcbiAgICAgIGZpcnN0ID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICAgIG9uZVRpbWUgPSBmaXJzdCA9PT0gNDI7IC8vICpcbiAgICAgIHZhbHVlID0gb25lVGltZSA/IHZhbHVlLnNsaWNlKDEpIDogdmFsdWU7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHRhZzogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLnRyaW0oKSxcbiAgICAgICAgaHRtbDogaHRtbCxcbiAgICAgICAgb25lVGltZTogb25lVGltZVxuICAgICAgfSk7XG4gICAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHZhbHVlOiB0ZXh0LnNsaWNlKGxhc3RJbmRleClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjYWNoZS5wdXQodGV4dCwgdG9rZW5zKTtcbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhIGxpc3Qgb2YgdG9rZW5zIGludG8gYW4gZXhwcmVzc2lvbi5cbiAgICogZS5nLiB0b2tlbnMgcGFyc2VkIGZyb20gJ2Ege3tifX0gYycgY2FuIGJlIHNlcmlhbGl6ZWRcbiAgICogaW50byBvbmUgc2luZ2xlIGV4cHJlc3Npb24gYXMgJ1wiYSBcIiArIGIgKyBcIiBjXCInLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSB0b2tlbnNcbiAgICogQHBhcmFtIHtWdWV9IFt2bV1cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBmdW5jdGlvbiB0b2tlbnNUb0V4cCh0b2tlbnMsIHZtKSB7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRva2VuKHRva2VuLCB2bSk7XG4gICAgICB9KS5qb2luKCcrJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmb3JtYXRUb2tlbih0b2tlbnNbMF0sIHZtLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0IGEgc2luZ2xlIHRva2VuLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9rZW5cbiAgICogQHBhcmFtIHtWdWV9IFt2bV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc2luZ2xlXVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFRva2VuKHRva2VuLCB2bSwgc2luZ2xlKSB7XG4gICAgcmV0dXJuIHRva2VuLnRhZyA/IHRva2VuLm9uZVRpbWUgJiYgdm0gPyAnXCInICsgdm0uJGV2YWwodG9rZW4udmFsdWUpICsgJ1wiJyA6IGlubGluZUZpbHRlcnModG9rZW4udmFsdWUsIHNpbmdsZSkgOiAnXCInICsgdG9rZW4udmFsdWUgKyAnXCInO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBhbiBhdHRyaWJ1dGUgd2l0aCBtdWx0aXBsZSBpbnRlcnBvbGF0aW9uIHRhZ3MsXG4gICAqIGUuZy4gYXR0cj1cInNvbWUte3t0aGluZyB8IGZpbHRlcn19XCIsIGluIG9yZGVyIHRvIGNvbWJpbmVcbiAgICogdGhlIHdob2xlIHRoaW5nIGludG8gYSBzaW5nbGUgd2F0Y2hhYmxlIGV4cHJlc3Npb24sIHdlXG4gICAqIGhhdmUgdG8gaW5saW5lIHRob3NlIGZpbHRlcnMuIFRoaXMgZnVuY3Rpb24gZG9lcyBleGFjdGx5XG4gICAqIHRoYXQuIFRoaXMgaXMgYSBiaXQgaGFja3kgYnV0IGl0IGF2b2lkcyBoZWF2eSBjaGFuZ2VzXG4gICAqIHRvIGRpcmVjdGl2ZSBwYXJzZXIgYW5kIHdhdGNoZXIgbWVjaGFuaXNtLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2luZ2xlXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgdmFyIGZpbHRlclJFID0gL1tefF1cXHxbXnxdLztcbiAgZnVuY3Rpb24gaW5saW5lRmlsdGVycyhleHAsIHNpbmdsZSkge1xuICAgIGlmICghZmlsdGVyUkUudGVzdChleHApKSB7XG4gICAgICByZXR1cm4gc2luZ2xlID8gZXhwIDogJygnICsgZXhwICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyID0gcGFyc2VEaXJlY3RpdmUoZXhwKTtcbiAgICAgIGlmICghZGlyLmZpbHRlcnMpIHtcbiAgICAgICAgcmV0dXJuICcoJyArIGV4cCArICcpJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAndGhpcy5fYXBwbHlGaWx0ZXJzKCcgKyBkaXIuZXhwcmVzc2lvbiArIC8vIHZhbHVlXG4gICAgICAgICcsbnVsbCwnICsgLy8gb2xkVmFsdWUgKG51bGwgZm9yIHJlYWQpXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGRpci5maWx0ZXJzKSArIC8vIGZpbHRlciBkZXNjcmlwdG9yc1xuICAgICAgICAnLGZhbHNlKSc7IC8vIHdyaXRlP1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG52YXIgdGV4dCA9IE9iamVjdC5mcmVlemUoe1xuICAgIGNvbXBpbGVSZWdleDogY29tcGlsZVJlZ2V4LFxuICAgIHBhcnNlVGV4dDogcGFyc2VUZXh0LFxuICAgIHRva2Vuc1RvRXhwOiB0b2tlbnNUb0V4cFxuICB9KTtcblxuICB2YXIgZGVsaW1pdGVycyA9IFsne3snLCAnfX0nXTtcbiAgdmFyIHVuc2FmZURlbGltaXRlcnMgPSBbJ3t7eycsICd9fX0nXTtcblxuICB2YXIgY29uZmlnID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoe1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBwcmludCBkZWJ1ZyBtZXNzYWdlcy5cbiAgICAgKiBBbHNvIGVuYWJsZXMgc3RhY2sgdHJhY2UgZm9yIHdhcm5pbmdzLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG5cbiAgICBkZWJ1ZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG5cbiAgICBzaWxlbnQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byB1c2UgYXN5bmMgcmVuZGVyaW5nLlxuICAgICAqL1xuXG4gICAgYXN5bmM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHdhcm4gYWdhaW5zdCBlcnJvcnMgY2F1Z2h0IHdoZW4gZXZhbHVhdGluZ1xuICAgICAqIGV4cHJlc3Npb25zLlxuICAgICAqL1xuXG4gICAgd2FybkV4cHJlc3Npb25FcnJvcnM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGFsbG93IGRldnRvb2xzIGluc3BlY3Rpb24uXG4gICAgICogRGlzYWJsZWQgYnkgZGVmYXVsdCBpbiBwcm9kdWN0aW9uIGJ1aWxkcy5cbiAgICAgKi9cblxuICAgIGRldnRvb2xzOiAnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIGluZGljYXRlIHRoZSBkZWxpbWl0ZXJzIGhhdmUgYmVlblxuICAgICAqIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cblxuICAgIF9kZWxpbWl0ZXJzQ2hhbmdlZDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYXNzZXQgdHlwZXMgdGhhdCBhIGNvbXBvbmVudCBjYW4gb3duLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuXG4gICAgX2Fzc2V0VHlwZXM6IFsnY29tcG9uZW50JywgJ2RpcmVjdGl2ZScsICdlbGVtZW50RGlyZWN0aXZlJywgJ2ZpbHRlcicsICd0cmFuc2l0aW9uJywgJ3BhcnRpYWwnXSxcblxuICAgIC8qKlxuICAgICAqIHByb3AgYmluZGluZyBtb2Rlc1xuICAgICAqL1xuXG4gICAgX3Byb3BCaW5kaW5nTW9kZXM6IHtcbiAgICAgIE9ORV9XQVk6IDAsXG4gICAgICBUV09fV0FZOiAxLFxuICAgICAgT05FX1RJTUU6IDJcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIGJhdGNoZXIgZmx1c2ggY3ljbGUuXG4gICAgICovXG5cbiAgICBfbWF4VXBkYXRlQ291bnQ6IDEwMFxuXG4gIH0sIHtcbiAgICBkZWxpbWl0ZXJzOiB7IC8qKlxuICAgICAgICAgICAgICAgICAgICogSW50ZXJwb2xhdGlvbiBkZWxpbWl0ZXJzLiBDaGFuZ2luZyB0aGVzZSB3b3VsZCB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgKiB0aGUgdGV4dCBwYXJzZXIgdG8gcmUtY29tcGlsZSB0aGUgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXk8U3RyaW5nPn1cbiAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGRlbGltaXRlcnM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICAgIGRlbGltaXRlcnMgPSB2YWw7XG4gICAgICAgIGNvbXBpbGVSZWdleCgpO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LFxuICAgIHVuc2FmZURlbGltaXRlcnM6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdW5zYWZlRGVsaW1pdGVycztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgICAgdW5zYWZlRGVsaW1pdGVycyA9IHZhbDtcbiAgICAgICAgY29tcGlsZVJlZ2V4KCk7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHdhcm4gPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCBlKSB7XG4gICAgICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCB8fCBjb25maWcuZGVidWcpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbVnVlIHdhcm5dOiAnICsgbXNnKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoY29uZmlnLmRlYnVnKSB7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKG5ldyBFcnJvcignV2FybmluZyBTdGFjayBUcmFjZScpLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgd2l0aCB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFwcGVuZFdpdGhUcmFuc2l0aW9uKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICAgIGFwcGx5VHJhbnNpdGlvbihlbCwgMSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9LCB2bSwgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydEJlZm9yZSB3aXRoIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgZnVuY3Rpb24gYmVmb3JlV2l0aFRyYW5zaXRpb24oZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gICAgYXBwbHlUcmFuc2l0aW9uKGVsLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgICBiZWZvcmUoZWwsIHRhcmdldCk7XG4gICAgfSwgdm0sIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgd2l0aCB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZVdpdGhUcmFuc2l0aW9uKGVsLCB2bSwgY2IpIHtcbiAgICBhcHBseVRyYW5zaXRpb24oZWwsIC0xLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmUoZWwpO1xuICAgIH0sIHZtLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgdHJhbnNpdGlvbnMgd2l0aCBhbiBvcGVyYXRpb24gY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvblxuICAgKiAgICAgICAgICAgICAgICAgIDE6IGVudGVyXG4gICAqICAgICAgICAgICAgICAgICAtMTogbGVhdmVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSB0aGUgYWN0dWFsIERPTSBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgZnVuY3Rpb24gYXBwbHlUcmFuc2l0aW9uKGVsLCBkaXJlY3Rpb24sIG9wLCB2bSwgY2IpIHtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IGVsLl9fdl90cmFucztcbiAgICBpZiAoIXRyYW5zaXRpb24gfHxcbiAgICAvLyBza2lwIGlmIHRoZXJlIGFyZSBubyBqcyBob29rcyBhbmQgQ1NTIHRyYW5zaXRpb24gaXNcbiAgICAvLyBub3Qgc3VwcG9ydGVkXG4gICAgIXRyYW5zaXRpb24uaG9va3MgJiYgIXRyYW5zaXRpb25FbmRFdmVudCB8fFxuICAgIC8vIHNraXAgdHJhbnNpdGlvbnMgZm9yIGluaXRpYWwgY29tcGlsZVxuICAgICF2bS5faXNDb21waWxlZCB8fFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBtYW5pcHVsYXRlZCBieSBhIHBhcmVudCBkaXJlY3RpdmVcbiAgICAvLyBkdXJpbmcgdGhlIHBhcmVudCdzIGNvbXBpbGF0aW9uIHBoYXNlLCBza2lwIHRoZVxuICAgIC8vIGFuaW1hdGlvbi5cbiAgICB2bS4kcGFyZW50ICYmICF2bS4kcGFyZW50Ll9pc0NvbXBpbGVkKSB7XG4gICAgICBvcCgpO1xuICAgICAgaWYgKGNiKSBjYigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYWN0aW9uID0gZGlyZWN0aW9uID4gMCA/ICdlbnRlcicgOiAnbGVhdmUnO1xuICAgIHRyYW5zaXRpb25bYWN0aW9uXShvcCwgY2IpO1xuICB9XG5cbnZhciB0cmFuc2l0aW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgYXBwZW5kV2l0aFRyYW5zaXRpb246IGFwcGVuZFdpdGhUcmFuc2l0aW9uLFxuICAgIGJlZm9yZVdpdGhUcmFuc2l0aW9uOiBiZWZvcmVXaXRoVHJhbnNpdGlvbixcbiAgICByZW1vdmVXaXRoVHJhbnNpdGlvbjogcmVtb3ZlV2l0aFRyYW5zaXRpb24sXG4gICAgYXBwbHlUcmFuc2l0aW9uOiBhcHBseVRyYW5zaXRpb25cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cblxuICBmdW5jdGlvbiBxdWVyeShlbCkge1xuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBlbDtcbiAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgICdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAgICogTm90ZTogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zIHNob3VsZCB3b3JrIGhlcmVcbiAgICogYnV0IGFsd2F5cyByZXR1cm5zIGZhbHNlIGZvciBjb21tZW50IG5vZGVzIGluIHBoYW50b21qcyxcbiAgICogbWFraW5nIHVuaXQgdGVzdHMgZGlmZmljdWx0LiBUaGlzIGlzIGZpeGVkIGJ5IGRvaW5nIHRoZVxuICAgKiBjb250YWlucygpIGNoZWNrIG9uIHRoZSBub2RlJ3MgcGFyZW50Tm9kZSBpbnN0ZWFkIG9mXG4gICAqIHRoZSBub2RlIGl0c2VsZi5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluRG9jKG5vZGUpIHtcbiAgICB2YXIgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBwYXJlbnQgPSBub2RlICYmIG5vZGUucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gZG9jID09PSBub2RlIHx8IGRvYyA9PT0gcGFyZW50IHx8ICEhKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IDEgJiYgZG9jLmNvbnRhaW5zKHBhcmVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbmQgcmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBfYXR0clxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRBdHRyKG5vZGUsIF9hdHRyKSB7XG4gICAgdmFyIHZhbCA9IG5vZGUuZ2V0QXR0cmlidXRlKF9hdHRyKTtcbiAgICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShfYXR0cik7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGF0dHJpYnV0ZSB3aXRoIGNvbG9uIG9yIHYtYmluZDogcHJlZml4LlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldEJpbmRBdHRyKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgdmFsID0gZ2V0QXR0cihub2RlLCAnOicgKyBuYW1lKTtcbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICB2YWwgPSBnZXRBdHRyKG5vZGUsICd2LWJpbmQ6JyArIG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBwcmVzZW5jZSBvZiBhIGJpbmQgYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gaGFzQmluZEF0dHIobm9kZSwgbmFtZSkge1xuICAgIHJldHVybiBub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSB8fCBub2RlLmhhc0F0dHJpYnV0ZSgnOicgKyBuYW1lKSB8fCBub2RlLmhhc0F0dHJpYnV0ZSgndi1iaW5kOicgKyBuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgZWwgYmVmb3JlIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJlZm9yZShlbCwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCB0YXJnZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBlbCBhZnRlciB0YXJnZXRcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICAgKi9cblxuICBmdW5jdGlvbiBhZnRlcihlbCwgdGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5uZXh0U2libGluZykge1xuICAgICAgYmVmb3JlKGVsLCB0YXJnZXQubmV4dFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBlbCBmcm9tIERPTVxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZShlbCkge1xuICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBlbmQgZWwgdG8gdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICovXG5cbiAgZnVuY3Rpb24gcHJlcGVuZChlbCwgdGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5maXJzdENoaWxkKSB7XG4gICAgICBiZWZvcmUoZWwsIHRhcmdldC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0YXJnZXQgd2l0aCBlbFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlcGxhY2UodGFyZ2V0LCBlbCkge1xuICAgIHZhciBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGVsLCB0YXJnZXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZXZlbnQgbGlzdGVuZXIgc2hvcnRoYW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXVxuICAgKi9cblxuICBmdW5jdGlvbiBvbihlbCwgZXZlbnQsIGNiLCB1c2VDYXB0dXJlKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2IsIHVzZUNhcHR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lciBzaG9ydGhhbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9mZihlbCwgZXZlbnQsIGNiKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluIElFOSwgc2V0QXR0cmlidXRlKCdjbGFzcycpIHdpbGwgcmVzdWx0IGluIGVtcHR5IGNsYXNzXG4gICAqIGlmIHRoZSBlbGVtZW50IGFsc28gaGFzIHRoZSA6Y2xhc3MgYXR0cmlidXRlOyBIb3dldmVyIGluXG4gICAqIFBoYW50b21KUywgc2V0dGluZyBgY2xhc3NOYW1lYCBkb2VzIG5vdCB3b3JrIG9uIFNWRyBlbGVtZW50cy4uLlxuICAgKiBTbyB3ZSBoYXZlIHRvIGRvIGEgY29uZGl0aW9uYWwgY2hlY2sgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNldENsYXNzKGVsLCBjbHMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNJRTkgJiYgIS9zdmckLy50ZXN0KGVsLm5hbWVzcGFjZVVSSSkpIHtcbiAgICAgIGVsLmNsYXNzTmFtZSA9IGNscztcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIElFICYgU1ZHXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICAgKi9cblxuICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xzKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3VyID0gJyAnICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyAnICc7XG4gICAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgICAgc2V0Q2xhc3MoZWwsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIElFICYgU1ZHXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xzKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3VyID0gJyAnICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyAnICc7XG4gICAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgICB9XG4gICAgICBzZXRDbGFzcyhlbCwgY3VyLnRyaW0oKSk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NOYW1lKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgcmF3IGNvbnRlbnQgaW5zaWRlIGFuIGVsZW1lbnQgaW50byBhIHRlbXBvcmFyeVxuICAgKiBjb250YWluZXIgZGl2XG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtCb29sZWFufSBhc0ZyYWdtZW50XG4gICAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAgICovXG5cbiAgZnVuY3Rpb24gZXh0cmFjdENvbnRlbnQoZWwsIGFzRnJhZ21lbnQpIHtcbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIHJhd0NvbnRlbnQ7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzVGVtcGxhdGUoZWwpICYmIGlzRnJhZ21lbnQoZWwuY29udGVudCkpIHtcbiAgICAgIGVsID0gZWwuY29udGVudDtcbiAgICB9XG4gICAgaWYgKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgdHJpbU5vZGUoZWwpO1xuICAgICAgcmF3Q29udGVudCA9IGFzRnJhZ21lbnQgPyBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgICB3aGlsZSAoY2hpbGQgPSBlbC5maXJzdENoaWxkKSB7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICAgICAgcmF3Q29udGVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYXdDb250ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaW0gcG9zc2libGUgZW1wdHkgaGVhZC90YWlsIHRleHQgYW5kIGNvbW1lbnRcbiAgICogbm9kZXMgaW5zaWRlIGEgcGFyZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICovXG5cbiAgZnVuY3Rpb24gdHJpbU5vZGUobm9kZSkge1xuICAgIHZhciBjaGlsZDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZXF1ZW5jZXMgKi9cbiAgICB3aGlsZSAoKGNoaWxkID0gbm9kZS5maXJzdENoaWxkLCBpc1RyaW1tYWJsZShjaGlsZCkpKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgd2hpbGUgKChjaGlsZCA9IG5vZGUubGFzdENoaWxkLCBpc1RyaW1tYWJsZShjaGlsZCkpKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1zZXF1ZW5jZXMgKi9cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVHJpbW1hYmxlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gMyAmJiAhbm9kZS5kYXRhLnRyaW0oKSB8fCBub2RlLm5vZGVUeXBlID09PSA4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGEgdGVtcGxhdGUgdGFnLlxuICAgKiBOb3RlIGlmIHRoZSB0ZW1wbGF0ZSBhcHBlYXJzIGluc2lkZSBhbiBTVkcgaXRzIHRhZ05hbWVcbiAgICogd2lsbCBiZSBpbiBsb3dlcmNhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cbiAgZnVuY3Rpb24gaXNUZW1wbGF0ZShlbCkge1xuICAgIHJldHVybiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RlbXBsYXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gXCJhbmNob3JcIiBmb3IgcGVyZm9ybWluZyBkb20gaW5zZXJ0aW9uL3JlbW92YWxzLlxuICAgKiBUaGlzIGlzIHVzZWQgaW4gYSBudW1iZXIgb2Ygc2NlbmFyaW9zOlxuICAgKiAtIGZyYWdtZW50IGluc3RhbmNlXG4gICAqIC0gdi1odG1sXG4gICAqIC0gdi1pZlxuICAgKiAtIHYtZm9yXG4gICAqIC0gY29tcG9uZW50XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVyc2lzdCAtIElFIHRyYXNoZXMgZW1wdHkgdGV4dE5vZGVzIG9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lTm9kZSh0cnVlKSwgc28gaW4gY2VydGFpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlcyB0aGUgYW5jaG9yIG5lZWRzIHRvIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbi1lbXB0eSB0byBiZSBwZXJzaXN0ZWQgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLlxuICAgKiBAcmV0dXJuIHtDb21tZW50fFRleHR9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFuY2hvcihjb250ZW50LCBwZXJzaXN0KSB7XG4gICAgdmFyIGFuY2hvciA9IGNvbmZpZy5kZWJ1ZyA/IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudCkgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwZXJzaXN0ID8gJyAnIDogJycpO1xuICAgIGFuY2hvci5fX3ZfYW5jaG9yID0gdHJ1ZTtcbiAgICByZXR1cm4gYW5jaG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYSBjb21wb25lbnQgcmVmIGF0dHJpYnV0ZSB0aGF0IHN0YXJ0cyB3aXRoICQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd8dW5kZWZpbmVkfVxuICAgKi9cblxuICB2YXIgcmVmUkUgPSAvXnYtcmVmOi87XG5cbiAgZnVuY3Rpb24gZmluZFJlZihub2RlKSB7XG4gICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICAgIGlmIChyZWZSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbWVsaXplKG5hbWUucmVwbGFjZShyZWZSRSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXAgYSBmdW5jdGlvbiB0byBhIHJhbmdlIG9mIG5vZGVzIC5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7Tm9kZX0gZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1hcE5vZGVSYW5nZShub2RlLCBlbmQsIG9wKSB7XG4gICAgdmFyIG5leHQ7XG4gICAgd2hpbGUgKG5vZGUgIT09IGVuZCkge1xuICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICBvcChub2RlKTtcbiAgICAgIG5vZGUgPSBuZXh0O1xuICAgIH1cbiAgICBvcChlbmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHJhbmdlIG9mIG5vZGVzIHdpdGggdHJhbnNpdGlvbiwgc3RvcmVcbiAgICogdGhlIG5vZGVzIGluIGEgZnJhZ21lbnQgd2l0aCBjb3JyZWN0IG9yZGVyaW5nLFxuICAgKiBhbmQgY2FsbCBjYWxsYmFjayB3aGVuIGRvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gc3RhcnRcbiAgICogQHBhcmFtIHtOb2RlfSBlbmRcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlUmFuZ2Uoc3RhcnQsIGVuZCwgdm0sIGZyYWcsIGNiKSB7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICB2YXIgcmVtb3ZlZCA9IDA7XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgbWFwTm9kZVJhbmdlKHN0YXJ0LCBlbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gZW5kKSBkb25lID0gdHJ1ZTtcbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICByZW1vdmVXaXRoVHJhbnNpdGlvbihub2RlLCB2bSwgb25SZW1vdmVkKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBvblJlbW92ZWQoKSB7XG4gICAgICByZW1vdmVkKys7XG4gICAgICBpZiAoZG9uZSAmJiByZW1vdmVkID49IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChub2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBub2RlIGlzIGEgRG9jdW1lbnRGcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGlzRnJhZ21lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IDExO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gICAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MKGVsKSB7XG4gICAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgICAgcmV0dXJuIGVsLm91dGVySFRNTDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTDtcbiAgICB9XG4gIH1cblxuICB2YXIgdWlkJDEgPSAwO1xuXG4gIC8qKlxuICAgKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAgICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBEZXAoKSB7XG4gICAgdGhpcy5pZCA9IHVpZCQxKys7XG4gICAgdGhpcy5zdWJzID0gW107XG4gIH1cblxuICAvLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4gIC8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbiAgLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG4gIERlcC50YXJnZXQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBBZGQgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAgICpcbiAgICogQHBhcmFtIHtEaXJlY3RpdmV9IHN1YlxuICAgKi9cblxuICBEZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIChzdWIpIHtcbiAgICB0aGlzLnN1YnMucHVzaChzdWIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAgICpcbiAgICogQHBhcmFtIHtEaXJlY3RpdmV9IHN1YlxuICAgKi9cblxuICBEZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIChzdWIpIHtcbiAgICB0aGlzLnN1YnMuJHJlbW92ZShzdWIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgc2VsZiBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRhcmdldCB3YXRjaGVyLlxuICAgKi9cblxuICBEZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogTm90aWZ5IGFsbCBzdWJzY3JpYmVycyBvZiBhIG5ldyB2YWx1ZS5cbiAgICovXG5cbiAgRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc3RhYmxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICAgIHZhciBzdWJzID0gdG9BcnJheSh0aGlzLnN1YnMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuICB2YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKVxuXG4gIC8qKlxuICAgKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAgICovXG5cbiAgO1sncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAndW5zaGlmdCcsICdzcGxpY2UnLCAnc29ydCcsICdyZXZlcnNlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gICAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICAgIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvcigpIHtcbiAgICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgICAgLy8gaHR0cDovL2pzcGVyZi5jb20vY2xvc3VyZS13aXRoLWFyZ3VtZW50c1xuICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICAgIHZhciBpbnNlcnRlZDtcbiAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChpbnNlcnRlZCkgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTtcbiAgICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTd2FwIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleCB3aXRoIGEgbmV3IHZhbHVlXG4gICAqIGFuZCBlbWl0cyBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHsqfSB2YWxcbiAgICogQHJldHVybiB7Kn0gLSByZXBsYWNlZCBlbGVtZW50XG4gICAqL1xuXG4gIGRlZihhcnJheVByb3RvLCAnJHNldCcsIGZ1bmN0aW9uICRzZXQoaW5kZXgsIHZhbCkge1xuICAgIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgdGhpcy5sZW5ndGggPSBOdW1iZXIoaW5kZXgpICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAxLCB2YWwpWzBdO1xuICB9KTtcblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBhdCBnaXZlbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAqL1xuXG4gIGRlZihhcnJheVByb3RvLCAnJHJlbW92ZScsIGZ1bmN0aW9uICRyZW1vdmUoaXRlbSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdGhpcy5sZW5ndGgpIHJldHVybjtcbiAgICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMsIGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbiAgLyoqXG4gICAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAgICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gICAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gICAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSB2YWx1ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG5cbiAgZnVuY3Rpb24gT2JzZXJ2ZXIodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gICAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvID8gcHJvdG9BdWdtZW50IDogY29weUF1Z21lbnQ7XG4gICAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5zdGFuY2UgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAgICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gICAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqL1xuXG4gIE9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLmNvbnZlcnQoa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICAgKi9cblxuICBPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIHByb3BlcnR5IGludG8gZ2V0dGVyL3NldHRlciBzbyB3ZSBjYW4gZW1pdFxuICAgKiB0aGUgZXZlbnRzIHdoZW4gdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkL2NoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWxcbiAgICovXG5cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh0aGlzLnZhbHVlLCBrZXksIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBvd25lciB2bSwgc28gdGhhdCB3aGVuICRzZXQvJGRlbGV0ZSBtdXRhdGlvbnNcbiAgICogaGFwcGVuIHdlIGNhbiBub3RpZnkgb3duZXIgdm1zIHRvIHByb3h5IHRoZSBrZXlzIGFuZFxuICAgKiBkaWdlc3QgdGhlIHdhdGNoZXJzLiBUaGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdGhlIG9iamVjdFxuICAgKiBpcyBvYnNlcnZlZCBhcyBhbiBpbnN0YW5jZSdzIHJvb3QgJGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKi9cblxuICBPYnNlcnZlci5wcm90b3R5cGUuYWRkVm0gPSBmdW5jdGlvbiAodm0pIHtcbiAgICAodGhpcy52bXMgfHwgKHRoaXMudm1zID0gW10pKS5wdXNoKHZtKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIG93bmVyIHZtLiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBvYmplY3QgaXNcbiAgICogc3dhcHBlZCBvdXQgYXMgYW4gaW5zdGFuY2UncyAkZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKi9cblxuICBPYnNlcnZlci5wcm90b3R5cGUucmVtb3ZlVm0gPSBmdW5jdGlvbiAodm0pIHtcbiAgICB0aGlzLnZtcy4kcmVtb3ZlKHZtKTtcbiAgfTtcblxuICAvLyBoZWxwZXJzXG5cbiAgLyoqXG4gICAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAgICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHRhcmdldFxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG9cbiAgICovXG5cbiAgZnVuY3Rpb24gcHJvdG9BdWdtZW50KHRhcmdldCwgc3JjKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbiAgfVxuXG4gIC8qKlxuICAgKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAgICogaGlkZGVuIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB0YXJnZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNvcHlBdWdtZW50KHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gICAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gICAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gICAqIEByZXR1cm4ge09ic2VydmVyfHVuZGVmaW5lZH1cbiAgICogQHN0YXRpY1xuICAgKi9cblxuICBmdW5jdGlvbiBvYnNlcnZlKHZhbHVlLCB2bSkge1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb2I7XG4gICAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgICB9IGVsc2UgaWYgKChpc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiYgIXZhbHVlLl9pc1Z1ZSkge1xuICAgICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAob2IgJiYgdm0pIHtcbiAgICAgIG9iLmFkZFZtKHZtKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZG9Ob3RPYnNlcnZlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5LCB2YWwsIGRvTm90T2JzZXJ2ZSkge1xuICAgIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICAgIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gICAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICAgIC8vIGlmIGRvTm90T2JzZXJ2ZSBpcyB0cnVlLCBvbmx5IHVzZSB0aGUgY2hpbGQgdmFsdWUgb2JzZXJ2ZXJcbiAgICAvLyBpZiBpdCBhbHJlYWR5IGV4aXN0cywgYW5kIGRvIG5vdCBhdHRlbXB0IHRvIGNyZWF0ZSBpdC5cbiAgICAvLyB0aGlzIGFsbG93cyBmcmVlemluZyBhIGxhcmdlIG9iamVjdCBmcm9tIHRoZSByb290IGFuZFxuICAgIC8vIGF2b2lkIHVubmVjZXNzYXJ5IG9ic2VydmF0aW9uIGluc2lkZSB2LWZvciBmcmFnbWVudHMuXG4gICAgdmFyIGNoaWxkT2IgPSBkb05vdE9ic2VydmUgPyBpc09iamVjdCh2YWwpICYmIHZhbC5fX29iX18gOiBvYnNlcnZlKHZhbCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlcigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGUsIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIGUgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyKG5ld1ZhbCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZE9iID0gZG9Ob3RPYnNlcnZlID8gaXNPYmplY3QobmV3VmFsKSAmJiBuZXdWYWwuX19vYl9fIDogb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgICBkZXAubm90aWZ5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY29tbW9uVGFnUkUgPSAvXihkaXZ8cHxzcGFufGltZ3xhfGJ8aXxicnx1bHxvbHxsaXxoMXxoMnxoM3xoNHxoNXxoNnxjb2RlfHByZXx0YWJsZXx0aHx0ZHx0cnxmb3JtfGxhYmVsfGlucHV0fHNlbGVjdHxvcHRpb258bmF2fGFydGljbGV8c2VjdGlvbnxoZWFkZXJ8Zm9vdGVyKSQvaTtcbiAgdmFyIHJlc2VydmVkVGFnUkUgPSAvXihzbG90fHBhcnRpYWx8Y29tcG9uZW50KSQvaTtcblxuICB2YXIgaXNVbmtub3duRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgaWYgKCdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVW5rbm93bkVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIHRhZykge1xuICAgICAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgICAgIHJldHVybiBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fCBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpICYmXG4gICAgICAgICAgLy8gQ2hyb21lIHJldHVybnMgdW5rbm93biBmb3Igc2V2ZXJhbCBIVE1MNSBlbGVtZW50cy5cbiAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTQwNTI2XG4gICAgICAgICAgIS9eKGRhdGF8dGltZXxydGN8cmIpJC8udGVzdCh0YWcpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGEgY29tcG9uZW50LCBpZiB5ZXMgcmV0dXJuIGl0c1xuICAgKiBjb21wb25lbnQgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAgICovXG5cbiAgZnVuY3Rpb24gY2hlY2tDb21wb25lbnRBdHRyKGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgaGFzQXR0cnMgPSBlbC5oYXNBdHRyaWJ1dGVzKCk7XG4gICAgaWYgKCFjb21tb25UYWdSRS50ZXN0KHRhZykgJiYgIXJlc2VydmVkVGFnUkUudGVzdCh0YWcpKSB7XG4gICAgICBpZiAocmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkge1xuICAgICAgICByZXR1cm4geyBpZDogdGFnIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXMgPSBoYXNBdHRycyAmJiBnZXRJc0JpbmRpbmcoZWwpO1xuICAgICAgICBpZiAoaXMpIHtcbiAgICAgICAgICByZXR1cm4gaXM7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGV4cGVjdGVkVGFnID0gb3B0aW9ucy5fY29tcG9uZW50TmFtZU1hcCAmJiBvcHRpb25zLl9jb21wb25lbnROYW1lTWFwW3RhZ107XG4gICAgICAgICAgaWYgKGV4cGVjdGVkVGFnKSB7XG4gICAgICAgICAgICB3YXJuKCdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gJyArICdkaWQgeW91IG1lYW4gPCcgKyBleHBlY3RlZFRhZyArICc+PyAnICsgJ0hUTUwgaXMgY2FzZS1pbnNlbnNpdGl2ZSwgcmVtZW1iZXIgdG8gdXNlIGtlYmFiLWNhc2UgaW4gdGVtcGxhdGVzLicpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNVbmtub3duRWxlbWVudChlbCwgdGFnKSkge1xuICAgICAgICAgICAgd2FybignVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICsgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNBdHRycykge1xuICAgICAgcmV0dXJuIGdldElzQmluZGluZyhlbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBcImlzXCIgYmluZGluZyBmcm9tIGFuIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0SXNCaW5kaW5nKGVsKSB7XG4gICAgLy8gZHluYW1pYyBzeW50YXhcbiAgICB2YXIgZXhwID0gZ2V0QXR0cihlbCwgJ2lzJyk7XG4gICAgaWYgKGV4cCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4geyBpZDogZXhwIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cCA9IGdldEJpbmRBdHRyKGVsLCAnaXMnKTtcbiAgICAgIGlmIChleHAgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geyBpZDogZXhwLCBkeW5hbWljOiB0cnVlIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIHByb3AncyBpbml0aWFsIHZhbHVlIG9uIGEgdm0gYW5kIGl0cyBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG5cbiAgZnVuY3Rpb24gaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKSB7XG4gICAgdmFyIGtleSA9IHByb3AucGF0aDtcbiAgICB2YWx1ZSA9IGNvZXJjZVByb3AocHJvcCwgdmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3Aub3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChhc3NlcnRQcm9wKHByb3AsIHZhbHVlKSkge1xuICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgdmFsdWUsIHRydWUgLyogZG9Ob3RPYnNlcnZlICovKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUodm0sIG9wdGlvbnMpIHtcbiAgICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gICAgaWYgKCFoYXNPd24ob3B0aW9ucywgJ2RlZmF1bHQnKSkge1xuICAgICAgLy8gYWJzZW50IGJvb2xlYW4gdmFsdWUgZGVmYXVsdHMgdG8gZmFsc2VcbiAgICAgIHJldHVybiBvcHRpb25zLnR5cGUgPT09IEJvb2xlYW4gPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIGRlZiA9IG9wdGlvbnNbJ2RlZmF1bHQnXTtcbiAgICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gICAgaWYgKGlzT2JqZWN0KGRlZikpIHtcbiAgICAgICdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdPYmplY3QvQXJyYXkgYXMgZGVmYXVsdCBwcm9wIHZhbHVlcyB3aWxsIGJlIHNoYXJlZCAnICsgJ2Fjcm9zcyBtdWx0aXBsZSBpbnN0YW5jZXMuIFVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLnR5cGUgIT09IEZ1bmN0aW9uID8gZGVmLmNhbGwodm0pIDogZGVmO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRQcm9wKHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKCFwcm9wLm9wdGlvbnMucmVxdWlyZWQgJiYgKCAvLyBub24tcmVxdWlyZWRcbiAgICBwcm9wLnJhdyA9PT0gbnVsbCB8fCAvLyBhYnNjZW50XG4gICAgdmFsdWUgPT0gbnVsbCkgLy8gbnVsbCBvciB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnM7XG4gICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgICB2YXIgZXhwZWN0ZWRUeXBlO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gU3RyaW5nKSB7XG4gICAgICAgIGV4cGVjdGVkVHlwZSA9ICdzdHJpbmcnO1xuICAgICAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBOdW1iZXIpIHtcbiAgICAgICAgZXhwZWN0ZWRUeXBlID0gJ251bWJlcic7XG4gICAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQm9vbGVhbikge1xuICAgICAgICBleHBlY3RlZFR5cGUgPSAnYm9vbGVhbic7XG4gICAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEZ1bmN0aW9uKSB7XG4gICAgICAgIGV4cGVjdGVkVHlwZSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBPYmplY3QpIHtcbiAgICAgICAgZXhwZWN0ZWRUeXBlID0gJ29iamVjdCc7XG4gICAgICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEFycmF5KSB7XG4gICAgICAgIGV4cGVjdGVkVHlwZSA9ICdhcnJheSc7XG4gICAgICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yICcgKyBwcm9wLnBhdGggKyAnPVwiJyArIHByb3AucmF3ICsgJ1wiLicgKyAnIEV4cGVjdGVkICcgKyBmb3JtYXRUeXBlKGV4cGVjdGVkVHlwZSkgKyAnLCBnb3QgJyArIGZvcm1hdFZhbHVlKHZhbHVlKSArICcuJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB2YWxpZGF0b3IgPSBvcHRpb25zLnZhbGlkYXRvcjtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgICAgJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yICcgKyBwcm9wLnBhdGggKyAnPVwiJyArIHByb3AucmF3ICsgJ1wiJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgcGFyc2luZyB2YWx1ZSB3aXRoIGNvZXJjZSBvcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cbiAgZnVuY3Rpb24gY29lcmNlUHJvcChwcm9wLCB2YWx1ZSkge1xuICAgIHZhciBjb2VyY2UgPSBwcm9wLm9wdGlvbnMuY29lcmNlO1xuICAgIGlmICghY29lcmNlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8vIGNvZXJjZSBpcyBhIGZ1bmN0aW9uXG4gICAgcmV0dXJuIGNvZXJjZSh2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRUeXBlKHZhbCkge1xuICAgIHJldHVybiB2YWwgPyB2YWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2YWwuc2xpY2UoMSkgOiAnY3VzdG9tIHR5cGUnO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpLnNsaWNlKDgsIC0xKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gICAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gICAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICAgKlxuICAgKiBBbGwgc3RyYXRlZ3kgZnVuY3Rpb25zIGZvbGxvdyB0aGUgc2FtZSBzaWduYXR1cmU6XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gcGFyZW50VmFsXG4gICAqIEBwYXJhbSB7Kn0gY2hpbGRWYWxcbiAgICogQHBhcmFtIHtWdWV9IFt2bV1cbiAgICovXG5cbiAgdmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAgICovXG5cbiAgZnVuY3Rpb24gbWVyZ2VEYXRhKHRvLCBmcm9tKSB7XG4gICAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gICAgZm9yIChrZXkgaW4gZnJvbSkge1xuICAgICAgdG9WYWwgPSB0b1trZXldO1xuICAgICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodG9WYWwpICYmIGlzT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0bztcbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhXG4gICAqL1xuXG4gIHN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgKyAnZGVmaW5pdGlvbnMuJyk7XG4gICAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgICB9XG4gICAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgICByZXR1cm4gY2hpbGRWYWw7XG4gICAgICB9XG4gICAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoY2hpbGRWYWwuY2FsbCh0aGlzKSwgcGFyZW50VmFsLmNhbGwodGhpcykpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuKCkge1xuICAgICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh2bSkgOiBjaGlsZFZhbDtcbiAgICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHZtKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRWxcbiAgICovXG5cbiAgc3RyYXRzLmVsID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gICAgaWYgKCF2bSAmJiBjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdUaGUgXCJlbFwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArICdkZWZpbml0aW9ucy4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJldCA9IGNoaWxkVmFsIHx8IHBhcmVudFZhbDtcbiAgICAvLyBpbnZva2UgdGhlIGVsZW1lbnQgZmFjdG9yeSBpZiB0aGlzIGlzIGluc3RhbmNlIG1lcmdlXG4gICAgcmV0dXJuIHZtICYmIHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgPyByZXQuY2FsbCh2bSkgOiByZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhvb2tzIGFuZCBwYXJhbSBhdHRyaWJ1dGVzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICAgKi9cblxuICBzdHJhdHMuaW5pdCA9IHN0cmF0cy5jcmVhdGVkID0gc3RyYXRzLnJlYWR5ID0gc3RyYXRzLmF0dGFjaGVkID0gc3RyYXRzLmRldGFjaGVkID0gc3RyYXRzLmJlZm9yZUNvbXBpbGUgPSBzdHJhdHMuY29tcGlsZWQgPSBzdHJhdHMuYmVmb3JlRGVzdHJveSA9IHN0cmF0cy5kZXN0cm95ZWQgPSBzdHJhdHMuYWN0aXZhdGUgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBjaGlsZFZhbCA/IHBhcmVudFZhbCA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpIDogaXNBcnJheShjaGlsZFZhbCkgPyBjaGlsZFZhbCA6IFtjaGlsZFZhbF0gOiBwYXJlbnRWYWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIDAuMTEgZGVwcmVjYXRpb24gd2FybmluZ1xuICAgKi9cblxuICBzdHJhdHMucGFyYW1BdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1wicGFyYW1BdHRyaWJ1dGVzXCIgb3B0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gMC4xMi4gJyArICdVc2UgXCJwcm9wc1wiIGluc3RlYWQuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFzc2V0c1xuICAgKlxuICAgKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gICAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAgICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1lcmdlQXNzZXRzKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwpO1xuICAgIHJldHVybiBjaGlsZFZhbCA/IGV4dGVuZChyZXMsIGd1YXJkQXJyYXlBc3NldHMoY2hpbGRWYWwpKSA6IHJlcztcbiAgfVxuXG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBFdmVudHMgJiBXYXRjaGVycy5cbiAgICpcbiAgICogRXZlbnRzICYgd2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICAgKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAgICovXG5cbiAgc3RyYXRzLndhdGNoID0gc3RyYXRzLmV2ZW50cyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgaWYgKCFjaGlsZFZhbCkgcmV0dXJuIHBhcmVudFZhbDtcbiAgICBpZiAoIXBhcmVudFZhbCkgcmV0dXJuIGNoaWxkVmFsO1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICAgIGlmIChwYXJlbnQgJiYgIWlzQXJyYXkocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICAgIH1cbiAgICAgIHJldFtrZXldID0gcGFyZW50ID8gcGFyZW50LmNvbmNhdChjaGlsZCkgOiBbY2hpbGRdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICAgKi9cblxuICBzdHJhdHMucHJvcHMgPSBzdHJhdHMubWV0aG9kcyA9IHN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgaWYgKCFjaGlsZFZhbCkgcmV0dXJuIHBhcmVudFZhbDtcbiAgICBpZiAoIXBhcmVudFZhbCkgcmV0dXJuIGNoaWxkVmFsO1xuICAgIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gICAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gICAqL1xuXG4gIHZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiBkZWZhdWx0U3RyYXQocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkID8gcGFyZW50VmFsIDogY2hpbGRWYWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2Ugc3VyZSBjb21wb25lbnQgb3B0aW9ucyBnZXQgY29udmVydGVkIHRvIGFjdHVhbFxuICAgKiBjb25zdHJ1Y3RvcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGd1YXJkQ29tcG9uZW50cyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSBvcHRpb25zLmNvbXBvbmVudHMgPSBndWFyZEFycmF5QXNzZXRzKG9wdGlvbnMuY29tcG9uZW50cyk7XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMoY29tcG9uZW50cyk7XG4gICAgICB2YXIgZGVmO1xuICAgICAgaWYgKCdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgbWFwID0gb3B0aW9ucy5fY29tcG9uZW50TmFtZU1hcCA9IHt9O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBpZHNbaV07XG4gICAgICAgIGlmIChjb21tb25UYWdSRS50ZXN0KGtleSkgfHwgcmVzZXJ2ZWRUYWdSRS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICsgJ2lkOiAnICsga2V5KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWNvcmQgYSBhbGwgbG93ZXJjYXNlIDwtPiBrZWJhYi1jYXNlIG1hcHBpbmcgZm9yXG4gICAgICAgIC8vIHBvc3NpYmxlIGN1c3RvbSBlbGVtZW50IGNhc2UgZXJyb3Igd2FybmluZ1xuICAgICAgICBpZiAoJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgbWFwW2tleS5yZXBsYWNlKC8tL2csICcnKS50b0xvd2VyQ2FzZSgpXSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGRlZiA9IGNvbXBvbmVudHNba2V5XTtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QoZGVmKSkge1xuICAgICAgICAgIGNvbXBvbmVudHNba2V5XSA9IFZ1ZS5leHRlbmQoZGVmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAgICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG5cbiAgZnVuY3Rpb24gZ3VhcmRQcm9wcyhvcHRpb25zKSB7XG4gICAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgICB2YXIgaSwgdmFsO1xuICAgIGlmIChpc0FycmF5KHByb3BzKSkge1xuICAgICAgb3B0aW9ucy5wcm9wcyA9IHt9O1xuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG9wdGlvbnMucHJvcHNbdmFsXSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsLm5hbWUpIHtcbiAgICAgICAgICBvcHRpb25zLnByb3BzW3ZhbC5uYW1lXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgICAgaSA9IGtleXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YWwgPSBwcm9wc1trZXlzW2ldXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBwcm9wc1trZXlzW2ldXSA9IHsgdHlwZTogdmFsIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR3VhcmQgYW4gQXJyYXktZm9ybWF0IGFzc2V0cyBvcHRpb24gYW5kIGNvbnZlcnRlZCBpdFxuICAgKiBpbnRvIHRoZSBrZXktdmFsdWUgT2JqZWN0IGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGFzc2V0c1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGd1YXJkQXJyYXlBc3NldHMoYXNzZXRzKSB7XG4gICAgaWYgKGlzQXJyYXkoYXNzZXRzKSkge1xuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgdmFyIGkgPSBhc3NldHMubGVuZ3RoO1xuICAgICAgdmFyIGFzc2V0O1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBhc3NldCA9IGFzc2V0c1tpXTtcbiAgICAgICAgdmFyIGlkID0gdHlwZW9mIGFzc2V0ID09PSAnZnVuY3Rpb24nID8gYXNzZXQub3B0aW9ucyAmJiBhc3NldC5vcHRpb25zLm5hbWUgfHwgYXNzZXQuaWQgOiBhc3NldC5uYW1lIHx8IGFzc2V0LmlkO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0FycmF5LXN5bnRheCBhc3NldHMgbXVzdCBwcm92aWRlIGEgXCJuYW1lXCIgb3IgXCJpZFwiIGZpZWxkLicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc1tpZF0gPSBhc3NldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIGFzc2V0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gICAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoaWxkXG4gICAqIEBwYXJhbSB7VnVlfSBbdm1dIC0gaWYgdm0gaXMgcHJlc2VudCwgaW5kaWNhdGVzIHRoaXMgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICBhbiBpbnN0YW50aWF0aW9uIG1lcmdlLlxuICAgKi9cblxuICBmdW5jdGlvbiBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZCwgdm0pIHtcbiAgICBndWFyZENvbXBvbmVudHMoY2hpbGQpO1xuICAgIGd1YXJkUHJvcHMoY2hpbGQpO1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdmFyIGtleTtcbiAgICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWVyZ2VGaWVsZChrZXkpIHtcbiAgICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSBhbiBhc3NldC5cbiAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gICAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAqIEByZXR1cm4ge09iamVjdHxGdW5jdGlvbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsIHR5cGUsIGlkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gICAgdmFyIGNhbWVsaXplZElkO1xuICAgIHJldHVybiBhc3NldHNbaWRdIHx8XG4gICAgLy8gY2FtZWxDYXNlIElEXG4gICAgYXNzZXRzW2NhbWVsaXplZElkID0gY2FtZWxpemUoaWQpXSB8fFxuICAgIC8vIFBhc2NhbCBDYXNlIElEXG4gICAgYXNzZXRzW2NhbWVsaXplZElkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2FtZWxpemVkSWQuc2xpY2UoMSldO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VydCBhc3NldCBleGlzdHNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0QXNzZXQodmFsLCB0eXBlLCBpZCkge1xuICAgIGlmICghdmFsKSB7XG4gICAgICAnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUgKyAnOiAnICsgaWQpO1xuICAgIH1cbiAgfVxuXG5cblxuICB2YXIgdXRpbCA9IE9iamVjdC5mcmVlemUoe1xuICBcdGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSxcbiAgXHRzZXQ6IHNldCxcbiAgXHRkZWw6IGRlbCxcbiAgXHRoYXNPd246IGhhc093bixcbiAgXHRpc0xpdGVyYWw6IGlzTGl0ZXJhbCxcbiAgXHRpc1Jlc2VydmVkOiBpc1Jlc2VydmVkLFxuICBcdF90b1N0cmluZzogX3RvU3RyaW5nLFxuICBcdHRvTnVtYmVyOiB0b051bWJlcixcbiAgXHR0b0Jvb2xlYW46IHRvQm9vbGVhbixcbiAgXHRzdHJpcFF1b3Rlczogc3RyaXBRdW90ZXMsXG4gIFx0Y2FtZWxpemU6IGNhbWVsaXplLFxuICBcdGh5cGhlbmF0ZTogaHlwaGVuYXRlLFxuICBcdGNsYXNzaWZ5OiBjbGFzc2lmeSxcbiAgXHRiaW5kOiBiaW5kLFxuICBcdHRvQXJyYXk6IHRvQXJyYXksXG4gIFx0ZXh0ZW5kOiBleHRlbmQsXG4gIFx0aXNPYmplY3Q6IGlzT2JqZWN0LFxuICBcdGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIFx0ZGVmOiBkZWYsXG4gIFx0ZGVib3VuY2U6IF9kZWJvdW5jZSxcbiAgXHRpbmRleE9mOiBpbmRleE9mLFxuICBcdGNhbmNlbGxhYmxlOiBjYW5jZWxsYWJsZSxcbiAgXHRsb29zZUVxdWFsOiBsb29zZUVxdWFsLFxuICBcdGlzQXJyYXk6IGlzQXJyYXksXG4gIFx0aGFzUHJvdG86IGhhc1Byb3RvLFxuICBcdGluQnJvd3NlcjogaW5Ccm93c2VyLFxuICBcdGRldnRvb2xzOiBkZXZ0b29scyxcbiAgXHRpc0lFOTogaXNJRTksXG4gIFx0aXNBbmRyb2lkOiBpc0FuZHJvaWQsXG4gIFx0Z2V0IHRyYW5zaXRpb25Qcm9wICgpIHsgcmV0dXJuIHRyYW5zaXRpb25Qcm9wOyB9LFxuICBcdGdldCB0cmFuc2l0aW9uRW5kRXZlbnQgKCkgeyByZXR1cm4gdHJhbnNpdGlvbkVuZEV2ZW50OyB9LFxuICBcdGdldCBhbmltYXRpb25Qcm9wICgpIHsgcmV0dXJuIGFuaW1hdGlvblByb3A7IH0sXG4gIFx0Z2V0IGFuaW1hdGlvbkVuZEV2ZW50ICgpIHsgcmV0dXJuIGFuaW1hdGlvbkVuZEV2ZW50OyB9LFxuICBcdG5leHRUaWNrOiBuZXh0VGljayxcbiAgXHRxdWVyeTogcXVlcnksXG4gIFx0aW5Eb2M6IGluRG9jLFxuICBcdGdldEF0dHI6IGdldEF0dHIsXG4gIFx0Z2V0QmluZEF0dHI6IGdldEJpbmRBdHRyLFxuICBcdGhhc0JpbmRBdHRyOiBoYXNCaW5kQXR0cixcbiAgXHRiZWZvcmU6IGJlZm9yZSxcbiAgXHRhZnRlcjogYWZ0ZXIsXG4gIFx0cmVtb3ZlOiByZW1vdmUsXG4gIFx0cHJlcGVuZDogcHJlcGVuZCxcbiAgXHRyZXBsYWNlOiByZXBsYWNlLFxuICBcdG9uOiBvbixcbiAgXHRvZmY6IG9mZixcbiAgXHRzZXRDbGFzczogc2V0Q2xhc3MsXG4gIFx0YWRkQ2xhc3M6IGFkZENsYXNzLFxuICBcdHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgXHRleHRyYWN0Q29udGVudDogZXh0cmFjdENvbnRlbnQsXG4gIFx0dHJpbU5vZGU6IHRyaW1Ob2RlLFxuICBcdGlzVGVtcGxhdGU6IGlzVGVtcGxhdGUsXG4gIFx0Y3JlYXRlQW5jaG9yOiBjcmVhdGVBbmNob3IsXG4gIFx0ZmluZFJlZjogZmluZFJlZixcbiAgXHRtYXBOb2RlUmFuZ2U6IG1hcE5vZGVSYW5nZSxcbiAgXHRyZW1vdmVOb2RlUmFuZ2U6IHJlbW92ZU5vZGVSYW5nZSxcbiAgXHRpc0ZyYWdtZW50OiBpc0ZyYWdtZW50LFxuICBcdGdldE91dGVySFRNTDogZ2V0T3V0ZXJIVE1MLFxuICBcdG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICBcdHJlc29sdmVBc3NldDogcmVzb2x2ZUFzc2V0LFxuICBcdGFzc2VydEFzc2V0OiBhc3NlcnRBc3NldCxcbiAgXHRjaGVja0NvbXBvbmVudEF0dHI6IGNoZWNrQ29tcG9uZW50QXR0cixcbiAgXHRpbml0UHJvcDogaW5pdFByb3AsXG4gIFx0YXNzZXJ0UHJvcDogYXNzZXJ0UHJvcCxcbiAgXHRjb2VyY2VQcm9wOiBjb2VyY2VQcm9wLFxuICBcdGNvbW1vblRhZ1JFOiBjb21tb25UYWdSRSxcbiAgXHRyZXNlcnZlZFRhZ1JFOiByZXNlcnZlZFRhZ1JFLFxuICBcdGdldCB3YXJuICgpIHsgcmV0dXJuIHdhcm47IH1cbiAgfSk7XG5cbiAgdmFyIHVpZCA9IDA7XG5cbiAgZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBpbml0IHNlcXVlbmNlLiBUaGlzIGlzIGNhbGxlZCBmb3IgZXZlcnlcbiAgICAgKiBpbnN0YW5jZSwgaW5jbHVkaW5nIG9uZXMgdGhhdCBhcmUgY3JlYXRlZCBmcm9tIGV4dGVuZGVkXG4gICAgICogY29uc3RydWN0b3JzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGlzIG9wdGlvbnMgb2JqZWN0IHNob3VsZCBiZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlc3VsdCBvZiBtZXJnaW5nIGNsYXNzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zIGFuZCB0aGUgb3B0aW9ucyBwYXNzZWRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICAgIHRoaXMuJHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgICAgdGhpcy4kcm9vdCA9IHRoaXMuJHBhcmVudCA/IHRoaXMuJHBhcmVudC4kcm9vdCA6IHRoaXM7XG4gICAgICB0aGlzLiRjaGlsZHJlbiA9IFtdO1xuICAgICAgdGhpcy4kcmVmcyA9IHt9OyAvLyBjaGlsZCB2bSByZWZlcmVuY2VzXG4gICAgICB0aGlzLiRlbHMgPSB7fTsgLy8gZWxlbWVudCByZWZlcmVuY2VzXG4gICAgICB0aGlzLl93YXRjaGVycyA9IFtdOyAvLyBhbGwgd2F0Y2hlcnMgYXMgYW4gYXJyYXlcbiAgICAgIHRoaXMuX2RpcmVjdGl2ZXMgPSBbXTsgLy8gYWxsIGRpcmVjdGl2ZXNcblxuICAgICAgLy8gYSB1aWRcbiAgICAgIHRoaXMuX3VpZCA9IHVpZCsrO1xuXG4gICAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgICAgdGhpcy5faXNWdWUgPSB0cnVlO1xuXG4gICAgICAvLyBldmVudHMgYm9va2tlZXBpbmdcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9OyAvLyByZWdpc3RlcmVkIGNhbGxiYWNrc1xuICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSB7fTsgLy8gZm9yICRicm9hZGNhc3Qgb3B0aW1pemF0aW9uXG5cbiAgICAgIC8vIGZyYWdtZW50IGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICAgIHRoaXMuX2lzRnJhZ21lbnQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2ZyYWdtZW50ID0gLy8gQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9XG4gICAgICB0aGlzLl9mcmFnbWVudFN0YXJ0ID0gLy8gQHR5cGUge1RleHR8Q29tbWVudH1cbiAgICAgIHRoaXMuX2ZyYWdtZW50RW5kID0gbnVsbDsgLy8gQHR5cGUge1RleHR8Q29tbWVudH1cblxuICAgICAgLy8gbGlmZWN5Y2xlIHN0YXRlXG4gICAgICB0aGlzLl9pc0NvbXBpbGVkID0gdGhpcy5faXNEZXN0cm95ZWQgPSB0aGlzLl9pc1JlYWR5ID0gdGhpcy5faXNBdHRhY2hlZCA9IHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgPSB0aGlzLl92Rm9yUmVtb3ZpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3VubGlua0ZuID0gbnVsbDtcblxuICAgICAgLy8gY29udGV4dDpcbiAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGNvbnRleHRcbiAgICAgIC8vIHdpbGwgYmUgdGhlIGNvbW1vbiBwYXJlbnQgdm0gb2YgdGhpcyBpbnN0YW5jZVxuICAgICAgLy8gYW5kIGl0cyBob3N0LlxuICAgICAgdGhpcy5fY29udGV4dCA9IG9wdGlvbnMuX2NvbnRleHQgfHwgdGhpcy4kcGFyZW50O1xuXG4gICAgICAvLyBzY29wZTpcbiAgICAgIC8vIGlmIHRoaXMgaXMgaW5zaWRlIGFuIGlubGluZSB2LWZvciwgdGhlIHNjb3BlXG4gICAgICAvLyB3aWxsIGJlIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgY3JlYXRlZCBmb3IgdGhpc1xuICAgICAgLy8gcmVwZWF0IGZyYWdtZW50LiB0aGlzIGlzIHVzZWQgZm9yIGxpbmtpbmcgcHJvcHNcbiAgICAgIC8vIGFuZCBjb250YWluZXIgZGlyZWN0aXZlcy5cbiAgICAgIHRoaXMuX3Njb3BlID0gb3B0aW9ucy5fc2NvcGU7XG5cbiAgICAgIC8vIGZyYWdtZW50OlxuICAgICAgLy8gaWYgdGhpcyBpbnN0YW5jZSBpcyBjb21waWxlZCBpbnNpZGUgYSBGcmFnbWVudCwgaXRcbiAgICAgIC8vIG5lZWRzIHRvIHJlaWdzdGVyIGl0c2VsZiBhcyBhIGNoaWxkIG9mIHRoYXQgZnJhZ21lbnRcbiAgICAgIC8vIGZvciBhdHRhY2gvZGV0YWNoIHRvIHdvcmsgcHJvcGVybHkuXG4gICAgICB0aGlzLl9mcmFnID0gb3B0aW9ucy5fZnJhZztcbiAgICAgIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgICAgIHRoaXMuX2ZyYWcuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHVzaCBzZWxmIGludG8gcGFyZW50IC8gdHJhbnNjbHVzaW9uIGhvc3RcbiAgICAgIGlmICh0aGlzLiRwYXJlbnQpIHtcbiAgICAgICAgdGhpcy4kcGFyZW50LiRjaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBtZXJnZSBvcHRpb25zLlxuICAgICAgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5jb25zdHJ1Y3Rvci5vcHRpb25zLCBvcHRpb25zLCB0aGlzKTtcblxuICAgICAgLy8gc2V0IHJlZlxuICAgICAgdGhpcy5fdXBkYXRlUmVmKCk7XG5cbiAgICAgIC8vIGluaXRpYWxpemUgZGF0YSBhcyBlbXB0eSBvYmplY3QuXG4gICAgICAvLyBpdCB3aWxsIGJlIGZpbGxlZCB1cCBpbiBfaW5pdFNjb3BlKCkuXG4gICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgIC8vIHNhdmUgcmF3IGNvbnN0cnVjdG9yIGRhdGEgYmVmb3JlIG1lcmdlXG4gICAgICAvLyBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcGVydGllcyBhcmUgcHJvdmlkZWQgYXRcbiAgICAgIC8vIGluc3RhbnRpYXRpb24uXG4gICAgICB0aGlzLl9ydW50aW1lRGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAgICAgLy8gY2FsbCBpbml0IGhvb2tcbiAgICAgIHRoaXMuX2NhbGxIb29rKCdpbml0Jyk7XG5cbiAgICAgIC8vIGluaXRpYWxpemUgZGF0YSBvYnNlcnZhdGlvbiBhbmQgc2NvcGUgaW5oZXJpdGFuY2UuXG4gICAgICB0aGlzLl9pbml0U3RhdGUoKTtcblxuICAgICAgLy8gc2V0dXAgZXZlbnQgc3lzdGVtIGFuZCBvcHRpb24gZXZlbnRzLlxuICAgICAgdGhpcy5faW5pdEV2ZW50cygpO1xuXG4gICAgICAvLyBjYWxsIGNyZWF0ZWQgaG9va1xuICAgICAgdGhpcy5fY2FsbEhvb2soJ2NyZWF0ZWQnKTtcblxuICAgICAgLy8gaWYgYGVsYCBvcHRpb24gaXMgcGFzc2VkLCBzdGFydCBjb21waWxhdGlvbi5cbiAgICAgIGlmIChvcHRpb25zLmVsKSB7XG4gICAgICAgIHRoaXMuJG1vdW50KG9wdGlvbnMuZWwpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgcGF0aENhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG4gIC8vIGFjdGlvbnNcbiAgdmFyIEFQUEVORCA9IDA7XG4gIHZhciBQVVNIID0gMTtcbiAgdmFyIElOQ19TVUJfUEFUSF9ERVBUSCA9IDI7XG4gIHZhciBQVVNIX1NVQl9QQVRIID0gMztcblxuICAvLyBzdGF0ZXNcbiAgdmFyIEJFRk9SRV9QQVRIID0gMDtcbiAgdmFyIElOX1BBVEggPSAxO1xuICB2YXIgQkVGT1JFX0lERU5UID0gMjtcbiAgdmFyIElOX0lERU5UID0gMztcbiAgdmFyIElOX1NVQl9QQVRIID0gNDtcbiAgdmFyIElOX1NJTkdMRV9RVU9URSA9IDU7XG4gIHZhciBJTl9ET1VCTEVfUVVPVEUgPSA2O1xuICB2YXIgQUZURVJfUEFUSCA9IDc7XG4gIHZhciBFUlJPUiA9IDg7XG5cbiAgdmFyIHBhdGhTdGF0ZU1hY2hpbmUgPSBbXTtcblxuICBwYXRoU3RhdGVNYWNoaW5lW0JFRk9SRV9QQVRIXSA9IHtcbiAgICAnd3MnOiBbQkVGT1JFX1BBVEhdLFxuICAgICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgICAnWyc6IFtJTl9TVUJfUEFUSF0sXG4gICAgJ2VvZic6IFtBRlRFUl9QQVRIXVxuICB9O1xuXG4gIHBhdGhTdGF0ZU1hY2hpbmVbSU5fUEFUSF0gPSB7XG4gICAgJ3dzJzogW0lOX1BBVEhdLFxuICAgICcuJzogW0JFRk9SRV9JREVOVF0sXG4gICAgJ1snOiBbSU5fU1VCX1BBVEhdLFxuICAgICdlb2YnOiBbQUZURVJfUEFUSF1cbiAgfTtcblxuICBwYXRoU3RhdGVNYWNoaW5lW0JFRk9SRV9JREVOVF0gPSB7XG4gICAgJ3dzJzogW0JFRk9SRV9JREVOVF0sXG4gICAgJ2lkZW50JzogW0lOX0lERU5ULCBBUFBFTkRdXG4gIH07XG5cbiAgcGF0aFN0YXRlTWFjaGluZVtJTl9JREVOVF0gPSB7XG4gICAgJ2lkZW50JzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAgICcwJzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAgICdudW1iZXInOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICAgJ3dzJzogW0lOX1BBVEgsIFBVU0hdLFxuICAgICcuJzogW0JFRk9SRV9JREVOVCwgUFVTSF0sXG4gICAgJ1snOiBbSU5fU1VCX1BBVEgsIFBVU0hdLFxuICAgICdlb2YnOiBbQUZURVJfUEFUSCwgUFVTSF1cbiAgfTtcblxuICBwYXRoU3RhdGVNYWNoaW5lW0lOX1NVQl9QQVRIXSA9IHtcbiAgICBcIidcIjogW0lOX1NJTkdMRV9RVU9URSwgQVBQRU5EXSxcbiAgICAnXCInOiBbSU5fRE9VQkxFX1FVT1RFLCBBUFBFTkRdLFxuICAgICdbJzogW0lOX1NVQl9QQVRILCBJTkNfU1VCX1BBVEhfREVQVEhdLFxuICAgICddJzogW0lOX1BBVEgsIFBVU0hfU1VCX1BBVEhdLFxuICAgICdlb2YnOiBFUlJPUixcbiAgICAnZWxzZSc6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXVxuICB9O1xuXG4gIHBhdGhTdGF0ZU1hY2hpbmVbSU5fU0lOR0xFX1FVT1RFXSA9IHtcbiAgICBcIidcIjogW0lOX1NVQl9QQVRILCBBUFBFTkRdLFxuICAgICdlb2YnOiBFUlJPUixcbiAgICAnZWxzZSc6IFtJTl9TSU5HTEVfUVVPVEUsIEFQUEVORF1cbiAgfTtcblxuICBwYXRoU3RhdGVNYWNoaW5lW0lOX0RPVUJMRV9RVU9URV0gPSB7XG4gICAgJ1wiJzogW0lOX1NVQl9QQVRILCBBUFBFTkRdLFxuICAgICdlb2YnOiBFUlJPUixcbiAgICAnZWxzZSc6IFtJTl9ET1VCTEVfUVVPVEUsIEFQUEVORF1cbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgY2hhcmFjdGVyIGluIGEga2V5cGF0aC5cbiAgICpcbiAgICogQHBhcmFtIHtDaGFyfSBjaFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0UGF0aENoYXJUeXBlKGNoKSB7XG4gICAgaWYgKGNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAnZW9mJztcbiAgICB9XG5cbiAgICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG5cbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgMHg1QjogLy8gW1xuICAgICAgY2FzZSAweDVEOiAvLyBdXG4gICAgICBjYXNlIDB4MkU6IC8vIC5cbiAgICAgIGNhc2UgMHgyMjogLy8gXCJcbiAgICAgIGNhc2UgMHgyNzogLy8gJ1xuICAgICAgY2FzZSAweDMwOlxuICAgICAgICAvLyAwXG4gICAgICAgIHJldHVybiBjaDtcblxuICAgICAgY2FzZSAweDVGOiAvLyBfXG4gICAgICBjYXNlIDB4MjQ6XG4gICAgICAgIC8vICRcbiAgICAgICAgcmV0dXJuICdpZGVudCc7XG5cbiAgICAgIGNhc2UgMHgyMDogLy8gU3BhY2VcbiAgICAgIGNhc2UgMHgwOTogLy8gVGFiXG4gICAgICBjYXNlIDB4MEE6IC8vIE5ld2xpbmVcbiAgICAgIGNhc2UgMHgwRDogLy8gUmV0dXJuXG4gICAgICBjYXNlIDB4QTA6IC8vIE5vLWJyZWFrIHNwYWNlXG4gICAgICBjYXNlIDB4RkVGRjogLy8gQnl0ZSBPcmRlciBNYXJrXG4gICAgICBjYXNlIDB4MjAyODogLy8gTGluZSBTZXBhcmF0b3JcbiAgICAgIGNhc2UgMHgyMDI5OlxuICAgICAgICAvLyBQYXJhZ3JhcGggU2VwYXJhdG9yXG4gICAgICAgIHJldHVybiAnd3MnO1xuICAgIH1cblxuICAgIC8vIGEteiwgQS1aXG4gICAgaWYgKGNvZGUgPj0gMHg2MSAmJiBjb2RlIDw9IDB4N0EgfHwgY29kZSA+PSAweDQxICYmIGNvZGUgPD0gMHg1QSkge1xuICAgICAgcmV0dXJuICdpZGVudCc7XG4gICAgfVxuXG4gICAgLy8gMS05XG4gICAgaWYgKGNvZGUgPj0gMHgzMSAmJiBjb2RlIDw9IDB4MzkpIHtcbiAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ2Vsc2UnO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhIHN1YlBhdGgsIHJldHVybiBpdHMgcGxhaW4gZm9ybSBpZiBpdCBpc1xuICAgKiBhIGxpdGVyYWwgc3RyaW5nIG9yIG51bWJlci4gT3RoZXJ3aXNlIHByZXBlbmQgdGhlXG4gICAqIGR5bmFtaWMgaW5kaWNhdG9yICgqKS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBmdW5jdGlvbiBmb3JtYXRTdWJQYXRoKHBhdGgpIHtcbiAgICB2YXIgdHJpbW1lZCA9IHBhdGgudHJpbSgpO1xuICAgIC8vIGludmFsaWQgbGVhZGluZyAwXG4gICAgaWYgKHBhdGguY2hhckF0KDApID09PSAnMCcgJiYgaXNOYU4ocGF0aCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTGl0ZXJhbCh0cmltbWVkKSA/IHN0cmlwUXVvdGVzKHRyaW1tZWQpIDogJyonICsgdHJpbW1lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHN0cmluZyBwYXRoIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICAgKi9cblxuICBmdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAtMTtcbiAgICB2YXIgbW9kZSA9IEJFRk9SRV9QQVRIO1xuICAgIHZhciBzdWJQYXRoRGVwdGggPSAwO1xuICAgIHZhciBjLCBuZXdDaGFyLCBrZXksIHR5cGUsIHRyYW5zaXRpb24sIGFjdGlvbiwgdHlwZU1hcDtcblxuICAgIHZhciBhY3Rpb25zID0gW107XG5cbiAgICBhY3Rpb25zW1BVU0hdID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGFjdGlvbnNbQVBQRU5EXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXkgPSBuZXdDaGFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ICs9IG5ld0NoYXI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGFjdGlvbnNbSU5DX1NVQl9QQVRIX0RFUFRIXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdGlvbnNbQVBQRU5EXSgpO1xuICAgICAgc3ViUGF0aERlcHRoKys7XG4gICAgfTtcblxuICAgIGFjdGlvbnNbUFVTSF9TVUJfUEFUSF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc3ViUGF0aERlcHRoID4gMCkge1xuICAgICAgICBzdWJQYXRoRGVwdGgtLTtcbiAgICAgICAgbW9kZSA9IElOX1NVQl9QQVRIO1xuICAgICAgICBhY3Rpb25zW0FQUEVORF0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YlBhdGhEZXB0aCA9IDA7XG4gICAgICAgIGtleSA9IGZvcm1hdFN1YlBhdGgoa2V5KTtcbiAgICAgICAgaWYgKGtleSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0aW9uc1tQVVNIXSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1heWJlVW5lc2NhcGVRdW90ZSgpIHtcbiAgICAgIHZhciBuZXh0Q2hhciA9IHBhdGhbaW5kZXggKyAxXTtcbiAgICAgIGlmIChtb2RlID09PSBJTl9TSU5HTEVfUVVPVEUgJiYgbmV4dENoYXIgPT09IFwiJ1wiIHx8IG1vZGUgPT09IElOX0RPVUJMRV9RVU9URSAmJiBuZXh0Q2hhciA9PT0gJ1wiJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBuZXdDaGFyID0gJ1xcXFwnICsgbmV4dENoYXI7XG4gICAgICAgIGFjdGlvbnNbQVBQRU5EXSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAobW9kZSAhPSBudWxsKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgYyA9IHBhdGhbaW5kZXhdO1xuXG4gICAgICBpZiAoYyA9PT0gJ1xcXFwnICYmIG1heWJlVW5lc2NhcGVRdW90ZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gZ2V0UGF0aENoYXJUeXBlKGMpO1xuICAgICAgdHlwZU1hcCA9IHBhdGhTdGF0ZU1hY2hpbmVbbW9kZV07XG4gICAgICB0cmFuc2l0aW9uID0gdHlwZU1hcFt0eXBlXSB8fCB0eXBlTWFwWydlbHNlJ10gfHwgRVJST1I7XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uID09PSBFUlJPUikge1xuICAgICAgICByZXR1cm47IC8vIHBhcnNlIGVycm9yXG4gICAgICB9XG5cbiAgICAgIG1vZGUgPSB0cmFuc2l0aW9uWzBdO1xuICAgICAgYWN0aW9uID0gYWN0aW9uc1t0cmFuc2l0aW9uWzFdXTtcbiAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgbmV3Q2hhciA9IHRyYW5zaXRpb25bMl07XG4gICAgICAgIG5ld0NoYXIgPSBuZXdDaGFyID09PSB1bmRlZmluZWQgPyBjIDogbmV3Q2hhcjtcbiAgICAgICAgaWYgKGFjdGlvbigpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSA9PT0gQUZURVJfUEFUSCkge1xuICAgICAgICBrZXlzLnJhdyA9IHBhdGg7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlcm5hbCBwYXJzZSB0aGF0IGNoZWNrIGZvciBhIGNhY2hlIGhpdCBmaXJzdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcmV0dXJuIHtBcnJheXx1bmRlZmluZWR9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gICAgdmFyIGhpdCA9IHBhdGhDYWNoZS5nZXQocGF0aCk7XG4gICAgaWYgKCFoaXQpIHtcbiAgICAgIGhpdCA9IHBhcnNlKHBhdGgpO1xuICAgICAgaWYgKGhpdCkge1xuICAgICAgICBwYXRoQ2FjaGUucHV0KHBhdGgsIGhpdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoaXQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGZyb20gYW4gb2JqZWN0IGZyb20gYSBwYXRoIHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFBhdGgob2JqLCBwYXRoKSB7XG4gICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbihwYXRoKS5nZXQob2JqKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYXJuIGFnYWluc3Qgc2V0dGluZyBub24tZXhpc3RlbnQgcm9vdCBwYXRoIG9uIGEgdm0uXG4gICAqL1xuXG4gIHZhciB3YXJuTm9uRXhpc3RlbnQ7XG4gIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuTm9uRXhpc3RlbnQgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgd2FybignWW91IGFyZSBzZXR0aW5nIGEgbm9uLWV4aXN0ZW50IHBhdGggXCInICsgcGF0aC5yYXcgKyAnXCIgJyArICdvbiBhIHZtIGluc3RhbmNlLiBDb25zaWRlciBwcmUtaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eSAnICsgJ3dpdGggdGhlIFwiZGF0YVwiIG9wdGlvbiBmb3IgbW9yZSByZWxpYWJsZSByZWFjdGl2aXR5ICcgKyAnYW5kIGJldHRlciBwZXJmb3JtYW5jZS4nKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBvbiBhbiBvYmplY3QgZnJvbSBhIHBhdGhcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBwYXRoXG4gICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNldFBhdGgob2JqLCBwYXRoLCB2YWwpIHtcbiAgICB2YXIgb3JpZ2luYWwgPSBvYmo7XG4gICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgcGF0aCA9IHBhcnNlKHBhdGgpO1xuICAgIH1cbiAgICBpZiAoIXBhdGggfHwgIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGxhc3QsIGtleTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGgubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsYXN0ID0gb2JqO1xuICAgICAga2V5ID0gcGF0aFtpXTtcbiAgICAgIGlmIChrZXkuY2hhckF0KDApID09PSAnKicpIHtcbiAgICAgICAga2V5ID0gcGFyc2VFeHByZXNzaW9uKGtleS5zbGljZSgxKSkuZ2V0LmNhbGwob3JpZ2luYWwsIG9yaWdpbmFsKTtcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgbCAtIDEpIHtcbiAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICAgIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgbGFzdC5faXNWdWUpIHtcbiAgICAgICAgICAgIHdhcm5Ob25FeGlzdGVudChwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0KGxhc3QsIGtleSwgb2JqKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgIG9iai4kc2V0KGtleSwgdmFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiBvYmouX2lzVnVlKSB7XG4gICAgICAgICAgICB3YXJuTm9uRXhpc3RlbnQocGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldChvYmosIGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG52YXIgcGF0aCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHBhcnNlUGF0aDogcGFyc2VQYXRoLFxuICAgIGdldFBhdGg6IGdldFBhdGgsXG4gICAgc2V0UGF0aDogc2V0UGF0aFxuICB9KTtcblxuICB2YXIgZXhwcmVzc2lvbkNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG4gIHZhciBhbGxvd2VkS2V5d29yZHMgPSAnTWF0aCxEYXRlLHRoaXMsdHJ1ZSxmYWxzZSxudWxsLHVuZGVmaW5lZCxJbmZpbml0eSxOYU4sJyArICdpc05hTixpc0Zpbml0ZSxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSwnICsgJ2VuY29kZVVSSUNvbXBvbmVudCxwYXJzZUludCxwYXJzZUZsb2F0JztcbiAgdmFyIGFsbG93ZWRLZXl3b3Jkc1JFID0gbmV3IFJlZ0V4cCgnXignICsgYWxsb3dlZEtleXdvcmRzLnJlcGxhY2UoLywvZywgJ1xcXFxifCcpICsgJ1xcXFxiKScpO1xuXG4gIC8vIGtleXdvcmRzIHRoYXQgZG9uJ3QgbWFrZSBzZW5zZSBpbnNpZGUgZXhwcmVzc2lvbnNcbiAgdmFyIGltcHJvcGVyS2V5d29yZHMgPSAnYnJlYWssY2FzZSxjbGFzcyxjYXRjaCxjb25zdCxjb250aW51ZSxkZWJ1Z2dlcixkZWZhdWx0LCcgKyAnZGVsZXRlLGRvLGVsc2UsZXhwb3J0LGV4dGVuZHMsZmluYWxseSxmb3IsZnVuY3Rpb24saWYsJyArICdpbXBvcnQsaW4saW5zdGFuY2VvZixsZXQscmV0dXJuLHN1cGVyLHN3aXRjaCx0aHJvdyx0cnksJyArICd2YXIsd2hpbGUsd2l0aCx5aWVsZCxlbnVtLGF3YWl0LGltcGxlbWVudHMscGFja2FnZSwnICsgJ3Byb3RlY3RlZCxzdGF0aWMsaW50ZXJmYWNlLHByaXZhdGUscHVibGljJztcbiAgdmFyIGltcHJvcGVyS2V5d29yZHNSRSA9IG5ldyBSZWdFeHAoJ14oJyArIGltcHJvcGVyS2V5d29yZHMucmVwbGFjZSgvLC9nLCAnXFxcXGJ8JykgKyAnXFxcXGIpJyk7XG5cbiAgdmFyIHdzUkUgPSAvXFxzL2c7XG4gIHZhciBuZXdsaW5lUkUgPSAvXFxuL2c7XG4gIHZhciBzYXZlUkUgPSAvW1xceyxdXFxzKltcXHdcXCRfXStcXHMqOnwoJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmApfG5ldyB8dHlwZW9mIHx2b2lkIC9nO1xuICB2YXIgcmVzdG9yZVJFID0gL1wiKFxcZCspXCIvZztcbiAgdmFyIHBhdGhUZXN0UkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPydcXF18XFxbXCIuKj9cIlxcXXxcXFtcXGQrXFxdfFxcW1tBLVphLXpfJF1bXFx3JF0qXFxdKSokLztcbiAgdmFyIGlkZW50UkUgPSAvW15cXHckXFwuXSg/OltBLVphLXpfJF1bXFx3JF0qKS9nO1xuICB2YXIgYm9vbGVhbkxpdGVyYWxSRSA9IC9eKD86dHJ1ZXxmYWxzZSkkLztcblxuICAvKipcbiAgICogU2F2ZSAvIFJld3JpdGUgLyBSZXN0b3JlXG4gICAqXG4gICAqIFdoZW4gcmV3cml0aW5nIHBhdGhzIGZvdW5kIGluIGFuIGV4cHJlc3Npb24sIGl0IGlzXG4gICAqIHBvc3NpYmxlIGZvciB0aGUgc2FtZSBsZXR0ZXIgc2VxdWVuY2VzIHRvIGJlIGZvdW5kIGluXG4gICAqIHN0cmluZ3MgYW5kIE9iamVjdCBsaXRlcmFsIHByb3BlcnR5IGtleXMuIFRoZXJlZm9yZSB3ZVxuICAgKiByZW1vdmUgYW5kIHN0b3JlIHRoZXNlIHBhcnRzIGluIGEgdGVtcG9yYXJ5IGFycmF5LCBhbmRcbiAgICogcmVzdG9yZSB0aGVtIGFmdGVyIHRoZSBwYXRoIHJld3JpdGUuXG4gICAqL1xuXG4gIHZhciBzYXZlZCA9IFtdO1xuXG4gIC8qKlxuICAgKiBTYXZlIHJlcGxhY2VyXG4gICAqXG4gICAqIFRoZSBzYXZlIHJlZ2V4IGNhbiBtYXRjaCB0d28gcG9zc2libGUgY2FzZXM6XG4gICAqIDEuIEFuIG9wZW5pbmcgb2JqZWN0IGxpdGVyYWxcbiAgICogMi4gQSBzdHJpbmdcbiAgICogSWYgbWF0Y2hlZCBhcyBhIHBsYWluIHN0cmluZywgd2UgbmVlZCB0byBlc2NhcGUgaXRzXG4gICAqIG5ld2xpbmVzLCBzaW5jZSB0aGUgc3RyaW5nIG5lZWRzIHRvIGJlIHByZXNlcnZlZCB3aGVuXG4gICAqIGdlbmVyYXRpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlzU3RyaW5nIC0gc3RyIGlmIG1hdGNoZWQgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7U3RyaW5nfSAtIHBsYWNlaG9sZGVyIHdpdGggaW5kZXhcbiAgICovXG5cbiAgZnVuY3Rpb24gc2F2ZShzdHIsIGlzU3RyaW5nKSB7XG4gICAgdmFyIGkgPSBzYXZlZC5sZW5ndGg7XG4gICAgc2F2ZWRbaV0gPSBpc1N0cmluZyA/IHN0ci5yZXBsYWNlKG5ld2xpbmVSRSwgJ1xcXFxuJykgOiBzdHI7XG4gICAgcmV0dXJuICdcIicgKyBpICsgJ1wiJztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRoIHJld3JpdGUgcmVwbGFjZXJcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJhd1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJld3JpdGUocmF3KSB7XG4gICAgdmFyIGMgPSByYXcuY2hhckF0KDApO1xuICAgIHZhciBwYXRoID0gcmF3LnNsaWNlKDEpO1xuICAgIGlmIChhbGxvd2VkS2V5d29yZHNSRS50ZXN0KHBhdGgpKSB7XG4gICAgICByZXR1cm4gcmF3O1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gcGF0aC5pbmRleE9mKCdcIicpID4gLTEgPyBwYXRoLnJlcGxhY2UocmVzdG9yZVJFLCByZXN0b3JlKSA6IHBhdGg7XG4gICAgICByZXR1cm4gYyArICdzY29wZS4nICsgcGF0aDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSByZXBsYWNlclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpIC0gbWF0Y2hlZCBzYXZlIGluZGV4XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVzdG9yZShzdHIsIGkpIHtcbiAgICByZXR1cm4gc2F2ZWRbaV07XG4gIH1cblxuICAvKipcbiAgICogUmV3cml0ZSBhbiBleHByZXNzaW9uLCBwcmVmaXhpbmcgYWxsIHBhdGggYWNjZXNzb3JzIHdpdGhcbiAgICogYHNjb3BlLmAgYW5kIGdlbmVyYXRlIGdldHRlci9zZXR0ZXIgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBmdW5jdGlvbiBjb21waWxlR2V0dGVyKGV4cCkge1xuICAgIGlmIChpbXByb3BlcktleXdvcmRzUkUudGVzdChleHApKSB7XG4gICAgICAnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignQXZvaWQgdXNpbmcgcmVzZXJ2ZWQga2V5d29yZHMgaW4gZXhwcmVzc2lvbjogJyArIGV4cCk7XG4gICAgfVxuICAgIC8vIHJlc2V0IHN0YXRlXG4gICAgc2F2ZWQubGVuZ3RoID0gMDtcbiAgICAvLyBzYXZlIHN0cmluZ3MgYW5kIG9iamVjdCBsaXRlcmFsIGtleXNcbiAgICB2YXIgYm9keSA9IGV4cC5yZXBsYWNlKHNhdmVSRSwgc2F2ZSkucmVwbGFjZSh3c1JFLCAnJyk7XG4gICAgLy8gcmV3cml0ZSBhbGwgcGF0aHNcbiAgICAvLyBwYWQgMSBzcGFjZSBoZXJlIGJlY2F1ZSB0aGUgcmVnZXggbWF0Y2hlcyAxIGV4dHJhIGNoYXJcbiAgICBib2R5ID0gKCcgJyArIGJvZHkpLnJlcGxhY2UoaWRlbnRSRSwgcmV3cml0ZSkucmVwbGFjZShyZXN0b3JlUkUsIHJlc3RvcmUpO1xuICAgIHJldHVybiBtYWtlR2V0dGVyRm4oYm9keSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSBnZXR0ZXIgZnVuY3Rpb24uIFJlcXVpcmVzIGV2YWwuXG4gICAqXG4gICAqIFdlIGlzb2xhdGUgdGhlIHRyeS9jYXRjaCBzbyBpdCBkb2Vzbid0IGFmZmVjdCB0aGVcbiAgICogb3B0aW1pemF0aW9uIG9mIHRoZSBwYXJzZSBmdW5jdGlvbiB3aGVuIGl0IGlzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBib2R5XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICovXG5cbiAgZnVuY3Rpb24gbWFrZUdldHRlckZuKGJvZHkpIHtcbiAgICB0cnkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMgKi9cbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3Njb3BlJywgJ3JldHVybiAnICsgYm9keSArICc7Jyk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldy1mdW5jICovXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgZXhwcmVzc2lvbi4gJyArICdHZW5lcmF0ZWQgZnVuY3Rpb24gYm9keTogJyArIGJvZHkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21waWxlIGEgc2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNvbXBpbGVTZXR0ZXIoZXhwKSB7XG4gICAgdmFyIHBhdGggPSBwYXJzZVBhdGgoZXhwKTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgdmFsKSB7XG4gICAgICAgIHNldFBhdGgoc2NvcGUsIHBhdGgsIHZhbCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBzZXR0ZXIgZXhwcmVzc2lvbjogJyArIGV4cCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGV4cHJlc3Npb24gaW50byByZS13cml0dGVuIGdldHRlci9zZXR0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVlZFNldFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGV4cCwgbmVlZFNldCkge1xuICAgIGV4cCA9IGV4cC50cmltKCk7XG4gICAgLy8gdHJ5IGNhY2hlXG4gICAgdmFyIGhpdCA9IGV4cHJlc3Npb25DYWNoZS5nZXQoZXhwKTtcbiAgICBpZiAoaGl0KSB7XG4gICAgICBpZiAobmVlZFNldCAmJiAhaGl0LnNldCkge1xuICAgICAgICBoaXQuc2V0ID0gY29tcGlsZVNldHRlcihoaXQuZXhwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoaXQ7XG4gICAgfVxuICAgIHZhciByZXMgPSB7IGV4cDogZXhwIH07XG4gICAgcmVzLmdldCA9IGlzU2ltcGxlUGF0aChleHApICYmIGV4cC5pbmRleE9mKCdbJykgPCAwXG4gICAgLy8gb3B0aW1pemVkIHN1cGVyIHNpbXBsZSBnZXR0ZXJcbiAgICA/IG1ha2VHZXR0ZXJGbignc2NvcGUuJyArIGV4cClcbiAgICAvLyBkeW5hbWljIGdldHRlclxuICAgIDogY29tcGlsZUdldHRlcihleHApO1xuICAgIGlmIChuZWVkU2V0KSB7XG4gICAgICByZXMuc2V0ID0gY29tcGlsZVNldHRlcihleHApO1xuICAgIH1cbiAgICBleHByZXNzaW9uQ2FjaGUucHV0KGV4cCwgcmVzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGV4cHJlc3Npb24gaXMgYSBzaW1wbGUgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuICBmdW5jdGlvbiBpc1NpbXBsZVBhdGgoZXhwKSB7XG4gICAgcmV0dXJuIHBhdGhUZXN0UkUudGVzdChleHApICYmXG4gICAgLy8gZG9uJ3QgdHJlYXQgdHJ1ZS9mYWxzZSBhcyBwYXRoc1xuICAgICFib29sZWFuTGl0ZXJhbFJFLnRlc3QoZXhwKSAmJlxuICAgIC8vIE1hdGggY29uc3RhbnRzIGUuZy4gTWF0aC5QSSwgTWF0aC5FIGV0Yy5cbiAgICBleHAuc2xpY2UoMCwgNSkgIT09ICdNYXRoLic7XG4gIH1cblxudmFyIGV4cHJlc3Npb24gPSBPYmplY3QuZnJlZXplKHtcbiAgICBwYXJzZUV4cHJlc3Npb246IHBhcnNlRXhwcmVzc2lvbixcbiAgICBpc1NpbXBsZVBhdGg6IGlzU2ltcGxlUGF0aFxuICB9KTtcblxuICAvLyB3ZSBoYXZlIHR3byBzZXBhcmF0ZSBxdWV1ZXM6IG9uZSBmb3IgZGlyZWN0aXZlIHVwZGF0ZXNcbiAgLy8gYW5kIG9uZSBmb3IgdXNlciB3YXRjaGVyIHJlZ2lzdGVyZWQgdmlhICR3YXRjaCgpLlxuICAvLyB3ZSB3YW50IHRvIGd1YXJhbnRlZSBkaXJlY3RpdmUgdXBkYXRlcyB0byBiZSBjYWxsZWRcbiAgLy8gYmVmb3JlIHVzZXIgd2F0Y2hlcnMgc28gdGhhdCB3aGVuIHVzZXIgd2F0Y2hlcnMgYXJlXG4gIC8vIHRyaWdnZXJlZCwgdGhlIERPTSB3b3VsZCBoYXZlIGFscmVhZHkgYmVlbiBpbiB1cGRhdGVkXG4gIC8vIHN0YXRlLlxuXG4gIHZhciBxdWV1ZUluZGV4O1xuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIHVzZXJRdWV1ZSA9IFtdO1xuICB2YXIgaGFzID0ge307XG4gIHZhciBjaXJjdWxhciA9IHt9O1xuICB2YXIgd2FpdGluZyA9IGZhbHNlO1xuICB2YXIgaW50ZXJuYWxRdWV1ZURlcGxldGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBiYXRjaGVyJ3Mgc3RhdGUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlc2V0QmF0Y2hlclN0YXRlKCkge1xuICAgIHF1ZXVlID0gW107XG4gICAgdXNlclF1ZXVlID0gW107XG4gICAgaGFzID0ge307XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgICB3YWl0aW5nID0gaW50ZXJuYWxRdWV1ZURlcGxldGVkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGZsdXNoQmF0Y2hlclF1ZXVlKCkge1xuICAgIHJ1bkJhdGNoZXJRdWV1ZShxdWV1ZSk7XG4gICAgaW50ZXJuYWxRdWV1ZURlcGxldGVkID0gdHJ1ZTtcbiAgICBydW5CYXRjaGVyUXVldWUodXNlclF1ZXVlKTtcbiAgICAvLyBkZXYgdG9vbCBob29rXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgICB9XG4gICAgcmVzZXRCYXRjaGVyU3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gdGhlIHdhdGNoZXJzIGluIGEgc2luZ2xlIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBxdWV1ZVxuICAgKi9cblxuICBmdW5jdGlvbiBydW5CYXRjaGVyUXVldWUocXVldWUpIHtcbiAgICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgICBmb3IgKHF1ZXVlSW5kZXggPSAwOyBxdWV1ZUluZGV4IDwgcXVldWUubGVuZ3RoOyBxdWV1ZUluZGV4KyspIHtcbiAgICAgIHZhciB3YXRjaGVyID0gcXVldWVbcXVldWVJbmRleF07XG4gICAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICAgICAgaGFzW2lkXSA9IG51bGw7XG4gICAgICB3YXRjaGVyLnJ1bigpO1xuICAgICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgICAgaWYgKCdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBjb25maWcuX21heFVwZGF0ZUNvdW50KSB7XG4gICAgICAgICAgcXVldWUuc3BsaWNlKGhhc1tpZF0sIDEpO1xuICAgICAgICAgIHdhcm4oJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCBmb3Igd2F0Y2hlciAnICsgJ3dpdGggZXhwcmVzc2lvbjogJyArIHdhdGNoZXIuZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAgICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gICAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1dhdGNoZXJ9IHdhdGNoZXJcbiAgICogICBwcm9wZXJ0aWVzOlxuICAgKiAgIC0ge051bWJlcn0gaWRcbiAgICogICAtIHtGdW5jdGlvbn0gcnVuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHB1c2hXYXRjaGVyKHdhdGNoZXIpIHtcbiAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgJiYgIXdhdGNoZXIudXNlcikge1xuICAgICAgICAvLyBhbiBpbnRlcm5hbCB3YXRjaGVyIHRyaWdnZXJlZCBieSBhIHVzZXIgd2F0Y2hlci4uLlxuICAgICAgICAvLyBsZXQncyBydW4gaXQgaW1tZWRpYXRlbHkgYWZ0ZXIgY3VycmVudCB1c2VyIHdhdGNoZXIgaXMgZG9uZS5cbiAgICAgICAgdXNlclF1ZXVlLnNwbGljZShxdWV1ZUluZGV4ICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwdXNoIHdhdGNoZXIgaW50byBhcHByb3ByaWF0ZSBxdWV1ZVxuICAgICAgICB2YXIgcSA9IHdhdGNoZXIudXNlciA/IHVzZXJRdWV1ZSA6IHF1ZXVlO1xuICAgICAgICBoYXNbaWRdID0gcS5sZW5ndGg7XG4gICAgICAgIHEucHVzaCh3YXRjaGVyKTtcbiAgICAgICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgICAgIGlmICghd2FpdGluZykge1xuICAgICAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgICAgIG5leHRUaWNrKGZsdXNoQmF0Y2hlclF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1aWQkMiA9IDA7XG5cbiAgLyoqXG4gICAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICAgKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICAgKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICAgICAgICAgICAtIHtBcnJheX0gZmlsdGVyc1xuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gdHdvV2F5XG4gICAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBkZWVwXG4gICAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB1c2VyXG4gICAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBzeW5jXG4gICAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBsYXp5XG4gICAqICAgICAgICAgICAgICAgICAtIHtGdW5jdGlvbn0gW3ByZVByb2Nlc3NdXG4gICAqICAgICAgICAgICAgICAgICAtIHtGdW5jdGlvbn0gW3Bvc3RQcm9jZXNzXVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKSB7XG4gICAgLy8gbWl4IGluIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB2YXIgaXNGbiA9IHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nO1xuICAgIHRoaXMudm0gPSB2bTtcbiAgICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuO1xuICAgIHRoaXMuY2IgPSBjYjtcbiAgICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICAgIHRoaXMuZGVwcyA9IFtdO1xuICAgIHRoaXMubmV3RGVwcyA9IFtdO1xuICAgIHRoaXMuZGVwSWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLm5ld0RlcElkcyA9IG51bGw7XG4gICAgdGhpcy5wcmV2RXJyb3IgPSBudWxsOyAvLyBmb3IgYXN5bmMgZXJyb3Igc3RhY2tzXG4gICAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyL3NldHRlclxuICAgIGlmIChpc0ZuKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gICAgICB0aGlzLnNldHRlciA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlcyA9IHBhcnNlRXhwcmVzc2lvbihleHBPckZuLCB0aGlzLnR3b1dheSk7XG4gICAgICB0aGlzLmdldHRlciA9IHJlcy5nZXQ7XG4gICAgICB0aGlzLnNldHRlciA9IHJlcy5zZXQ7XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLmxhenkgPyB1bmRlZmluZWQgOiB0aGlzLmdldCgpO1xuICAgIC8vIHN0YXRlIGZvciBhdm9pZGluZyBmYWxzZSB0cmlnZ2VycyBmb3IgZGVlcCBhbmQgQXJyYXlcbiAgICAvLyB3YXRjaGVycyBkdXJpbmcgdm0uX2RpZ2VzdCgpXG4gICAgdGhpcy5xdWV1ZWQgPSB0aGlzLnNoYWxsb3cgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gICAqL1xuXG4gIFdhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJlZm9yZUdldCgpO1xuICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bTtcbiAgICB2YXIgdmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbChzY29wZSwgc2NvcGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLndhcm5FeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICAgIHdhcm4oJ0Vycm9yIHdoZW4gZXZhbHVhdGluZyBleHByZXNzaW9uIFwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIi4gJyArIChjb25maWcuZGVidWcgPyAnJyA6ICdUdXJuIG9uIGRlYnVnIG1vZGUgdG8gc2VlIHN0YWNrIHRyYWNlLicpLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcmVQcm9jZXNzKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucHJlUHJvY2Vzcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICAgIHZhbHVlID0gc2NvcGUuX2FwcGx5RmlsdGVycyh2YWx1ZSwgbnVsbCwgdGhpcy5maWx0ZXJzLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBvc3RQcm9jZXNzKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucG9zdFByb2Nlc3ModmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLmFmdGVyR2V0KCk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgd2l0aCB0aGUgc2V0dGVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuXG4gIFdhdGNoZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bTtcbiAgICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgICB2YWx1ZSA9IHNjb3BlLl9hcHBseUZpbHRlcnModmFsdWUsIHRoaXMudmFsdWUsIHRoaXMuZmlsdGVycywgdHJ1ZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnNldHRlci5jYWxsKHNjb3BlLCBzY29wZSwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLndhcm5FeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICAgIHdhcm4oJ0Vycm9yIHdoZW4gZXZhbHVhdGluZyBzZXR0ZXIgXCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiJywgZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHR3by13YXkgc3luYyBmb3Igdi1mb3IgYWxpYXNcbiAgICB2YXIgZm9yQ29udGV4dCA9IHNjb3BlLiRmb3JDb250ZXh0O1xuICAgIGlmIChmb3JDb250ZXh0ICYmIGZvckNvbnRleHQuYWxpYXMgPT09IHRoaXMuZXhwcmVzc2lvbikge1xuICAgICAgaWYgKGZvckNvbnRleHQuZmlsdGVycykge1xuICAgICAgICAnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0d28td2F5IGJpbmRpbmcgb24gJyArICdhIHYtZm9yIGFsaWFzICgnICsgdGhpcy5leHByZXNzaW9uICsgJyksIGFuZCB0aGUgJyArICd2LWZvciBoYXMgZmlsdGVycy4gVGhpcyB3aWxsIG5vdCB3b3JrIHByb3Blcmx5LiAnICsgJ0VpdGhlciByZW1vdmUgdGhlIGZpbHRlcnMgb3IgdXNlIGFuIGFycmF5IG9mICcgKyAnb2JqZWN0cyBhbmQgYmluZCB0byBvYmplY3QgcHJvcGVydGllcyBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3JDb250ZXh0Ll93aXRoTG9jayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzY29wZS4ka2V5KSB7XG4gICAgICAgICAgLy8gb3JpZ2luYWwgaXMgYW4gb2JqZWN0XG4gICAgICAgICAgZm9yQ29udGV4dC5yYXdWYWx1ZVtzY29wZS4ka2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvckNvbnRleHQucmF3VmFsdWUuJHNldChzY29wZS4kaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQcmVwYXJlIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gICAqL1xuXG4gIFdhdGNoZXIucHJvdG90eXBlLmJlZm9yZUdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBEZXAudGFyZ2V0ID0gdGhpcztcbiAgICB0aGlzLm5ld0RlcElkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RGVwfSBkZXBcbiAgICovXG5cbiAgV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gKGRlcCkge1xuICAgIHZhciBpZCA9IGRlcC5pZDtcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzW2lkXSkge1xuICAgICAgdGhpcy5uZXdEZXBJZHNbaWRdID0gdHJ1ZTtcbiAgICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgICBpZiAoIXRoaXMuZGVwSWRzW2lkXSkge1xuICAgICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAgICovXG5cbiAgV2F0Y2hlci5wcm90b3R5cGUuYWZ0ZXJHZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgRGVwLnRhcmdldCA9IG51bGw7XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBkZXAgPSB0aGlzLmRlcHNbaV07XG4gICAgICBpZiAoIXRoaXMubmV3RGVwSWRzW2RlcC5pZF0pIHtcbiAgICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgICB2YXIgdG1wID0gdGhpcy5kZXBzO1xuICAgIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICAgKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNoYWxsb3dcbiAgICovXG5cbiAgV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHNoYWxsb3cpIHtcbiAgICBpZiAodGhpcy5sYXp5KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3luYyB8fCAhY29uZmlnLmFzeW5jKSB7XG4gICAgICB0aGlzLnJ1bigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBxdWV1ZWQsIG9ubHkgb3ZlcndyaXRlIHNoYWxsb3cgd2l0aCBub24tc2hhbGxvdyxcbiAgICAgIC8vIGJ1dCBub3QgdGhlIG90aGVyIHdheSBhcm91bmQuXG4gICAgICB0aGlzLnNoYWxsb3cgPSB0aGlzLnF1ZXVlZCA/IHNoYWxsb3cgPyB0aGlzLnNoYWxsb3cgOiBmYWxzZSA6ICEhc2hhbGxvdztcbiAgICAgIHRoaXMucXVldWVkID0gdHJ1ZTtcbiAgICAgIC8vIHJlY29yZCBiZWZvcmUtcHVzaCBlcnJvciBzdGFjayBpbiBkZWJ1ZyBtb2RlXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLmRlYnVnKSB7XG4gICAgICAgIHRoaXMucHJldkVycm9yID0gbmV3IEVycm9yKCdbdnVlXSBhc3luYyBzdGFjayB0cmFjZScpO1xuICAgICAgfVxuICAgICAgcHVzaFdhdGNoZXIodGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBCYXRjaGVyIGpvYiBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBiYXRjaGVyLlxuICAgKi9cblxuICBXYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZDsgYnV0IG9ubHkgZG8gc28gaWYgdGhpcyBpcyBhXG4gICAgICAvLyBub24tc2hhbGxvdyB1cGRhdGUgKGNhdXNlZCBieSBhIHZtIGRpZ2VzdCkuXG4gICAgICAoaXNPYmplY3QodmFsdWUpIHx8IHRoaXMuZGVlcCkgJiYgIXRoaXMuc2hhbGxvdykge1xuICAgICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgLy8gaW4gZGVidWcgKyBhc3luYyBtb2RlLCB3aGVuIGEgd2F0Y2hlciBjYWxsYmFja3NcbiAgICAgICAgLy8gdGhyb3dzLCB3ZSBhbHNvIHRocm93IHRoZSBzYXZlZCBiZWZvcmUtcHVzaCBlcnJvclxuICAgICAgICAvLyBzbyB0aGUgZnVsbCBjcm9zcy10aWNrIHN0YWNrIHRyYWNlIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgdmFyIHByZXZFcnJvciA9IHRoaXMucHJldkVycm9yO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcuZGVidWcgJiYgcHJldkVycm9yKSB7XG4gICAgICAgICAgdGhpcy5wcmV2RXJyb3IgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRocm93IHByZXZFcnJvcjtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gICAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAgICovXG5cbiAgV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gYXZvaWQgb3ZlcndyaXRpbmcgYW5vdGhlciB3YXRjaGVyIHRoYXQgaXMgYmVpbmdcbiAgICAvLyBjb2xsZWN0ZWQuXG4gICAgdmFyIGN1cnJlbnQgPSBEZXAudGFyZ2V0O1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICBEZXAudGFyZ2V0ID0gY3VycmVudDtcbiAgfTtcblxuICAvKipcbiAgICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gICAqL1xuXG4gIFdhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJjcmliZXIgbGlzdC5cbiAgICovXG5cbiAgV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkIG9yIGlzIHBlcmZvcm1pbmcgYSB2LWZvclxuICAgICAgLy8gcmUtcmVuZGVyICh0aGUgd2F0Y2hlciBsaXN0IGlzIHRoZW4gZmlsdGVyZWQgYnkgdi1mb3IpLlxuICAgICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkICYmICF0aGlzLnZtLl92Rm9yUmVtb3ZpbmcpIHtcbiAgICAgICAgdGhpcy52bS5fd2F0Y2hlcnMuJHJlbW92ZSh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLnZtID0gdGhpcy5jYiA9IHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVjcnVzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAgICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAgICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWxcbiAgICovXG5cbiAgZnVuY3Rpb24gdHJhdmVyc2UodmFsKSB7XG4gICAgdmFyIGksIGtleXM7XG4gICAgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB0cmF2ZXJzZSh2YWxbaV0pO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB0cmF2ZXJzZSh2YWxba2V5c1tpXV0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0ZXh0JDEgPSB7XG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgdGhpcy5hdHRyID0gdGhpcy5lbC5ub2RlVHlwZSA9PT0gMyA/ICdkYXRhJyA6ICd0ZXh0Q29udGVudCc7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgICB0aGlzLmVsW3RoaXMuYXR0cl0gPSBfdG9TdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdGVtcGxhdGVDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcbiAgdmFyIGlkU2VsZWN0b3JDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcblxuICB2YXIgbWFwID0ge1xuICAgIGVmYXVsdDogWzAsICcnLCAnJ10sXG4gICAgbGVnZW5kOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgICB0cjogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG4gICAgY29sOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXVxuICB9O1xuXG4gIG1hcC50ZCA9IG1hcC50aCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG4gIG1hcC5vcHRpb24gPSBtYXAub3B0Z3JvdXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPicsICc8L3NlbGVjdD4nXTtcblxuICBtYXAudGhlYWQgPSBtYXAudGJvZHkgPSBtYXAuY29sZ3JvdXAgPSBtYXAuY2FwdGlvbiA9IG1hcC50Zm9vdCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xuXG4gIG1hcC5nID0gbWFwLmRlZnMgPSBtYXAuc3ltYm9sID0gbWFwLnVzZSA9IG1hcC5pbWFnZSA9IG1hcC50ZXh0ID0gbWFwLmNpcmNsZSA9IG1hcC5lbGxpcHNlID0gbWFwLmxpbmUgPSBtYXAucGF0aCA9IG1hcC5wb2x5Z29uID0gbWFwLnBvbHlsaW5lID0gbWFwLnJlY3QgPSBbMSwgJzxzdmcgJyArICd4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiAnICsgJ3htbG5zOmV2PVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS94bWwtZXZlbnRzXCInICsgJ3ZlcnNpb249XCIxLjFcIj4nLCAnPC9zdmc+J107XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIHN1cHBvcnRlZCB0ZW1wbGF0ZSBub2RlIHdpdGggYVxuICAgKiBEb2N1bWVudEZyYWdtZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuICBmdW5jdGlvbiBpc1JlYWxUZW1wbGF0ZShub2RlKSB7XG4gICAgcmV0dXJuIGlzVGVtcGxhdGUobm9kZSkgJiYgaXNGcmFnbWVudChub2RlLmNvbnRlbnQpO1xuICB9XG5cbiAgdmFyIHRhZ1JFJDEgPSAvPChbXFx3Oi1dKykvO1xuICB2YXIgZW50aXR5UkUgPSAvJiM/XFx3Kz87LztcblxuICAvKipcbiAgICogQ29udmVydCBhIHN0cmluZyB0ZW1wbGF0ZSB0byBhIERvY3VtZW50RnJhZ21lbnQuXG4gICAqIERldGVybWluZXMgY29ycmVjdCB3cmFwcGluZyBieSB0YWcgdHlwZXMuIFdyYXBwaW5nXG4gICAqIHN0cmF0ZWd5IGZvdW5kIGluIGpRdWVyeSAmIGNvbXBvbmVudC9kb21pZnkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVN0cmluZ1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJhd1xuICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICAgKi9cblxuICBmdW5jdGlvbiBzdHJpbmdUb0ZyYWdtZW50KHRlbXBsYXRlU3RyaW5nLCByYXcpIHtcbiAgICAvLyB0cnkgYSBjYWNoZSBoaXQgZmlyc3RcbiAgICB2YXIgY2FjaGVLZXkgPSByYXcgPyB0ZW1wbGF0ZVN0cmluZyA6IHRlbXBsYXRlU3RyaW5nLnRyaW0oKTtcbiAgICB2YXIgaGl0ID0gdGVtcGxhdGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmIChoaXQpIHtcbiAgICAgIHJldHVybiBoaXQ7XG4gICAgfVxuXG4gICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdmFyIHRhZ01hdGNoID0gdGVtcGxhdGVTdHJpbmcubWF0Y2godGFnUkUkMSk7XG4gICAgdmFyIGVudGl0eU1hdGNoID0gZW50aXR5UkUudGVzdCh0ZW1wbGF0ZVN0cmluZyk7XG5cbiAgICBpZiAoIXRhZ01hdGNoICYmICFlbnRpdHlNYXRjaCkge1xuICAgICAgLy8gdGV4dCBvbmx5LCByZXR1cm4gYSBzaW5nbGUgdGV4dCBub2RlLlxuICAgICAgZnJhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZW1wbGF0ZVN0cmluZykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFnID0gdGFnTWF0Y2ggJiYgdGFnTWF0Y2hbMV07XG4gICAgICB2YXIgd3JhcCA9IG1hcFt0YWddIHx8IG1hcC5lZmF1bHQ7XG4gICAgICB2YXIgZGVwdGggPSB3cmFwWzBdO1xuICAgICAgdmFyIHByZWZpeCA9IHdyYXBbMV07XG4gICAgICB2YXIgc3VmZml4ID0gd3JhcFsyXTtcbiAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIG5vZGUuaW5uZXJIVE1MID0gcHJlZml4ICsgdGVtcGxhdGVTdHJpbmcgKyBzdWZmaXg7XG4gICAgICB3aGlsZSAoZGVwdGgtLSkge1xuICAgICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgICB3aGlsZSAoY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyYXcpIHtcbiAgICAgIHRyaW1Ob2RlKGZyYWcpO1xuICAgIH1cbiAgICB0ZW1wbGF0ZUNhY2hlLnB1dChjYWNoZUtleSwgZnJhZyk7XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHRlbXBsYXRlIG5vZGUgdG8gYSBEb2N1bWVudEZyYWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICovXG5cbiAgZnVuY3Rpb24gbm9kZVRvRnJhZ21lbnQobm9kZSkge1xuICAgIC8vIGlmIGl0cyBhIHRlbXBsYXRlIHRhZyBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQsXG4gICAgLy8gaXRzIGNvbnRlbnQgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LlxuICAgIGlmIChpc1JlYWxUZW1wbGF0ZShub2RlKSkge1xuICAgICAgdHJpbU5vZGUobm9kZS5jb250ZW50KTtcbiAgICAgIHJldHVybiBub2RlLmNvbnRlbnQ7XG4gICAgfVxuICAgIC8vIHNjcmlwdCB0ZW1wbGF0ZVxuICAgIGlmIChub2RlLnRhZ05hbWUgPT09ICdTQ1JJUFQnKSB7XG4gICAgICByZXR1cm4gc3RyaW5nVG9GcmFnbWVudChub2RlLnRleHRDb250ZW50KTtcbiAgICB9XG4gICAgLy8gbm9ybWFsIG5vZGUsIGNsb25lIGl0IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbFxuICAgIHZhciBjbG9uZWROb2RlID0gY2xvbmVOb2RlKG5vZGUpO1xuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBjaGlsZDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIHdoaWxlIChjaGlsZCA9IGNsb25lZE5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICAgIHRyaW1Ob2RlKGZyYWcpO1xuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSBTYWZhcmkgdGVtcGxhdGUgY2xvbmluZyBidWdcbiAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd3VnLmNnaT9pZD0xMzc3NTVcbiAgdmFyIGhhc0Jyb2tlblRlbXBsYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbkJyb3dzZXIpIHtcbiAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBhLmlubmVySFRNTCA9ICc8dGVtcGxhdGU+MTwvdGVtcGxhdGU+JztcbiAgICAgIHJldHVybiAhYS5jbG9uZU5vZGUodHJ1ZSkuZmlyc3RDaGlsZC5pbm5lckhUTUw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgLy8gVGVzdCBmb3IgSUUxMC8xMSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBjbG9uZSBidWdcbiAgdmFyIGhhc1RleHRhcmVhQ2xvbmVCdWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3Nlcikge1xuICAgICAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgdC5wbGFjZWhvbGRlciA9ICd0JztcbiAgICAgIHJldHVybiB0LmNsb25lTm9kZSh0cnVlKS52YWx1ZSA9PT0gJ3QnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAxLiBEZWFsIHdpdGggU2FmYXJpIGNsb25pbmcgbmVzdGVkIDx0ZW1wbGF0ZT4gYnVnIGJ5XG4gICAqICAgIG1hbnVhbGx5IGNsb25pbmcgYWxsIHRlbXBsYXRlIGluc3RhbmNlcy5cbiAgICogMi4gRGVhbCB3aXRoIElFMTAvMTEgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnIGJ5IHNldHRpbmdcbiAgICogICAgdGhlIGNvcnJlY3QgdmFsdWUgYWZ0ZXIgY2xvbmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IG5vZGVcbiAgICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICAgKi9cblxuICBmdW5jdGlvbiBjbG9uZU5vZGUobm9kZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghbm9kZS5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUoKTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuICAgIHZhciBpLCBvcmlnaW5hbCwgY2xvbmVkO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChoYXNCcm9rZW5UZW1wbGF0ZSkge1xuICAgICAgdmFyIHRlbXBDbG9uZSA9IHJlcztcbiAgICAgIGlmIChpc1JlYWxUZW1wbGF0ZShub2RlKSkge1xuICAgICAgICBub2RlID0gbm9kZS5jb250ZW50O1xuICAgICAgICB0ZW1wQ2xvbmUgPSByZXMuY29udGVudDtcbiAgICAgIH1cbiAgICAgIG9yaWdpbmFsID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZW1wbGF0ZScpO1xuICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCkge1xuICAgICAgICBjbG9uZWQgPSB0ZW1wQ2xvbmUucXVlcnlTZWxlY3RvckFsbCgndGVtcGxhdGUnKTtcbiAgICAgICAgaSA9IGNsb25lZC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjbG9uZWRbaV0ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY2xvbmVOb2RlKG9yaWdpbmFsW2ldKSwgY2xvbmVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaGFzVGV4dGFyZWFDbG9uZUJ1Zykge1xuICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgICByZXMudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3JpZ2luYWwgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHRhcmVhJyk7XG4gICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGgpIHtcbiAgICAgICAgICBjbG9uZWQgPSByZXMucXVlcnlTZWxlY3RvckFsbCgndGV4dGFyZWEnKTtcbiAgICAgICAgICBpID0gY2xvbmVkLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjbG9uZWRbaV0udmFsdWUgPSBvcmlnaW5hbFtpXS52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSB0ZW1wbGF0ZSBvcHRpb24gYW5kIG5vcm1hbGl6ZXMgaXQgaW50byBhXG4gICAqIGEgRG9jdW1lbnRGcmFnbWVudCB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgcGFydGlhbCBvciBhXG4gICAqIGluc3RhbmNlIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHRlbXBsYXRlXG4gICAqICAgICAgICBQb3NzaWJsZSB2YWx1ZXMgaW5jbHVkZTpcbiAgICogICAgICAgIC0gRG9jdW1lbnRGcmFnbWVudCBvYmplY3RcbiAgICogICAgICAgIC0gTm9kZSBvYmplY3Qgb2YgdHlwZSBUZW1wbGF0ZVxuICAgKiAgICAgICAgLSBpZCBzZWxlY3RvcjogJyNzb21lLXRlbXBsYXRlLWlkJ1xuICAgKiAgICAgICAgLSB0ZW1wbGF0ZSBzdHJpbmc6ICc8ZGl2PjxzcGFuPnt7bXNnfX08L3NwYW4+PC9kaXY+J1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZENsb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmF3XG4gICAqICAgICAgICBpbmxpbmUgSFRNTCBpbnRlcnBvbGF0aW9uLiBEbyBub3QgY2hlY2sgZm9yIGlkXG4gICAqICAgICAgICBzZWxlY3RvciBhbmQga2VlcCB3aGl0ZXNwYWNlIGluIHRoZSBzdHJpbmcuXG4gICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR8dW5kZWZpbmVkfVxuICAgKi9cblxuICBmdW5jdGlvbiBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCBzaG91bGRDbG9uZSwgcmF3KSB7XG4gICAgdmFyIG5vZGUsIGZyYWc7XG5cbiAgICAvLyBpZiB0aGUgdGVtcGxhdGUgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LFxuICAgIC8vIGRvIG5vdGhpbmdcbiAgICBpZiAoaXNGcmFnbWVudCh0ZW1wbGF0ZSkpIHtcbiAgICAgIHRyaW1Ob2RlKHRlbXBsYXRlKTtcbiAgICAgIHJldHVybiBzaG91bGRDbG9uZSA/IGNsb25lTm9kZSh0ZW1wbGF0ZSkgOiB0ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gaWQgc2VsZWN0b3JcbiAgICAgIGlmICghcmF3ICYmIHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgIC8vIGlkIHNlbGVjdG9yIGNhbiBiZSBjYWNoZWQgdG9vXG4gICAgICAgIGZyYWcgPSBpZFNlbGVjdG9yQ2FjaGUuZ2V0KHRlbXBsYXRlKTtcbiAgICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRlbXBsYXRlLnNsaWNlKDEpKTtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgZnJhZyA9IG5vZGVUb0ZyYWdtZW50KG5vZGUpO1xuICAgICAgICAgICAgLy8gc2F2ZSBzZWxlY3RvciB0byBjYWNoZVxuICAgICAgICAgICAgaWRTZWxlY3RvckNhY2hlLnB1dCh0ZW1wbGF0ZSwgZnJhZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3JtYWwgc3RyaW5nIHRlbXBsYXRlXG4gICAgICAgIGZyYWcgPSBzdHJpbmdUb0ZyYWdtZW50KHRlbXBsYXRlLCByYXcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgIC8vIGEgZGlyZWN0IG5vZGVcbiAgICAgIGZyYWcgPSBub2RlVG9GcmFnbWVudCh0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWcgJiYgc2hvdWxkQ2xvbmUgPyBjbG9uZU5vZGUoZnJhZykgOiBmcmFnO1xuICB9XG5cbnZhciB0ZW1wbGF0ZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIGNsb25lTm9kZTogY2xvbmVOb2RlLFxuICAgIHBhcnNlVGVtcGxhdGU6IHBhcnNlVGVtcGxhdGVcbiAgfSk7XG5cbiAgdmFyIGh0bWwgPSB7XG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgLy8gYSBjb21tZW50IG5vZGUgbWVhbnMgdGhpcyBpcyBhIGJpbmRpbmcgZm9yXG4gICAgICAvLyB7e3sgaW5saW5lIHVuZXNjYXBlZCBodG1sIH19fVxuICAgICAgaWYgKHRoaXMuZWwubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgICAgLy8gaG9sZCBub2Rlc1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIHdpdGggcHJvcGVyIGFuY2hvclxuICAgICAgICB0aGlzLmFuY2hvciA9IGNyZWF0ZUFuY2hvcigndi1odG1sJyk7XG4gICAgICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBfdG9TdHJpbmcodmFsdWUpO1xuICAgICAgaWYgKHRoaXMubm9kZXMpIHtcbiAgICAgICAgdGhpcy5zd2FwKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN3YXA6IGZ1bmN0aW9uIHN3YXAodmFsdWUpIHtcbiAgICAgIC8vIHJlbW92ZSBvbGQgbm9kZXNcbiAgICAgIHZhciBpID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLm5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbnZlcnQgbmV3IHZhbHVlIHRvIGEgZnJhZ21lbnRcbiAgICAgIC8vIGRvIG5vdCBhdHRlbXB0IHRvIHJldHJpZXZlIGZyb20gaWQgc2VsZWN0b3JcbiAgICAgIHZhciBmcmFnID0gcGFyc2VUZW1wbGF0ZSh2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAvLyBzYXZlIGEgcmVmZXJlbmNlIHRvIHRoZXNlIG5vZGVzIHNvIHdlIGNhbiByZW1vdmUgbGF0ZXJcbiAgICAgIHRoaXMubm9kZXMgPSB0b0FycmF5KGZyYWcuY2hpbGROb2Rlcyk7XG4gICAgICBiZWZvcmUoZnJhZywgdGhpcy5hbmNob3IpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWJzdHJhY3Rpb24gZm9yIGEgcGFydGlhbGx5LWNvbXBpbGVkIGZyYWdtZW50LlxuICAgKiBDYW4gb3B0aW9uYWxseSBjb21waWxlIGNvbnRlbnQgd2l0aCBhIGNoaWxkIHNjb3BlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rZXJcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gICAqL1xuICBmdW5jdGlvbiBGcmFnbWVudChsaW5rZXIsIHZtLCBmcmFnLCBob3N0LCBzY29wZSwgcGFyZW50RnJhZykge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLmNoaWxkRnJhZ3MgPSBbXTtcbiAgICB0aGlzLnZtID0gdm07XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudEZyYWcgPSBwYXJlbnRGcmFnO1xuICAgIGlmIChwYXJlbnRGcmFnKSB7XG4gICAgICBwYXJlbnRGcmFnLmNoaWxkRnJhZ3MucHVzaCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy51bmxpbmsgPSBsaW5rZXIodm0sIGZyYWcsIGhvc3QsIHNjb3BlLCB0aGlzKTtcbiAgICB2YXIgc2luZ2xlID0gdGhpcy5zaW5nbGUgPSBmcmFnLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmXG4gICAgLy8gZG8gbm90IGdvIHNpbmdsZSBtb2RlIGlmIHRoZSBvbmx5IG5vZGUgaXMgYW4gYW5jaG9yXG4gICAgIWZyYWcuY2hpbGROb2Rlc1swXS5fX3ZfYW5jaG9yO1xuICAgIGlmIChzaW5nbGUpIHtcbiAgICAgIHRoaXMubm9kZSA9IGZyYWcuY2hpbGROb2Rlc1swXTtcbiAgICAgIHRoaXMuYmVmb3JlID0gc2luZ2xlQmVmb3JlO1xuICAgICAgdGhpcy5yZW1vdmUgPSBzaW5nbGVSZW1vdmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9kZSA9IGNyZWF0ZUFuY2hvcignZnJhZ21lbnQtc3RhcnQnKTtcbiAgICAgIHRoaXMuZW5kID0gY3JlYXRlQW5jaG9yKCdmcmFnbWVudC1lbmQnKTtcbiAgICAgIHRoaXMuZnJhZyA9IGZyYWc7XG4gICAgICBwcmVwZW5kKHRoaXMubm9kZSwgZnJhZyk7XG4gICAgICBmcmFnLmFwcGVuZENoaWxkKHRoaXMuZW5kKTtcbiAgICAgIHRoaXMuYmVmb3JlID0gbXVsdGlCZWZvcmU7XG4gICAgICB0aGlzLnJlbW92ZSA9IG11bHRpUmVtb3ZlO1xuICAgIH1cbiAgICB0aGlzLm5vZGUuX192X2ZyYWcgPSB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYXR0YWNoL2RldGFjaCBmb3IgYWxsIGNvbXBvbmVudHMgY29udGFpbmVkIHdpdGhpblxuICAgKiB0aGlzIGZyYWdtZW50LiBBbHNvIGRvIHNvIHJlY3Vyc2l2ZWx5IGZvciBhbGwgY2hpbGRcbiAgICogZnJhZ21lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gICAqL1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZS5jYWxsSG9vayA9IGZ1bmN0aW9uIChob29rKSB7XG4gICAgdmFyIGksIGw7XG4gICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuY2hpbGRGcmFnc1tpXS5jYWxsSG9vayhob29rKTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBob29rKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICAgKi9cblxuICBmdW5jdGlvbiBzaW5nbGVCZWZvcmUodGFyZ2V0LCB3aXRoVHJhbnNpdGlvbikge1xuICAgIHRoaXMuaW5zZXJ0ZWQgPSB0cnVlO1xuICAgIHZhciBtZXRob2QgPSB3aXRoVHJhbnNpdGlvbiAhPT0gZmFsc2UgPyBiZWZvcmVXaXRoVHJhbnNpdGlvbiA6IGJlZm9yZTtcbiAgICBtZXRob2QodGhpcy5ub2RlLCB0YXJnZXQsIHRoaXMudm0pO1xuICAgIGlmIChpbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgICB0aGlzLmNhbGxIb29rKGF0dGFjaCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBmcmFnbWVudCwgc2luZ2xlIG5vZGUgdmVyc2lvblxuICAgKi9cblxuICBmdW5jdGlvbiBzaW5nbGVSZW1vdmUoKSB7XG4gICAgdGhpcy5pbnNlcnRlZCA9IGZhbHNlO1xuICAgIHZhciBzaG91bGRDYWxsUmVtb3ZlID0gaW5Eb2ModGhpcy5ub2RlKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcbiAgICByZW1vdmVXaXRoVHJhbnNpdGlvbih0aGlzLm5vZGUsIHRoaXMudm0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzaG91bGRDYWxsUmVtb3ZlKSB7XG4gICAgICAgIHNlbGYuY2FsbEhvb2soZGV0YWNoKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZGVzdHJveSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBmcmFnbWVudCBiZWZvcmUgdGFyZ2V0LCBtdWx0aS1ub2RlcyB2ZXJzaW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFRyYW5zaXRpb25cbiAgICovXG5cbiAgZnVuY3Rpb24gbXVsdGlCZWZvcmUodGFyZ2V0LCB3aXRoVHJhbnNpdGlvbikge1xuICAgIHRoaXMuaW5zZXJ0ZWQgPSB0cnVlO1xuICAgIHZhciB2bSA9IHRoaXMudm07XG4gICAgdmFyIG1ldGhvZCA9IHdpdGhUcmFuc2l0aW9uICE9PSBmYWxzZSA/IGJlZm9yZVdpdGhUcmFuc2l0aW9uIDogYmVmb3JlO1xuICAgIG1hcE5vZGVSYW5nZSh0aGlzLm5vZGUsIHRoaXMuZW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgbWV0aG9kKG5vZGUsIHRhcmdldCwgdm0pO1xuICAgIH0pO1xuICAgIGlmIChpbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgICB0aGlzLmNhbGxIb29rKGF0dGFjaCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBmcmFnbWVudCwgbXVsdGktbm9kZXMgdmVyc2lvblxuICAgKi9cblxuICBmdW5jdGlvbiBtdWx0aVJlbW92ZSgpIHtcbiAgICB0aGlzLmluc2VydGVkID0gZmFsc2U7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzaG91bGRDYWxsUmVtb3ZlID0gaW5Eb2ModGhpcy5ub2RlKTtcbiAgICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xuICAgIHJlbW92ZU5vZGVSYW5nZSh0aGlzLm5vZGUsIHRoaXMuZW5kLCB0aGlzLnZtLCB0aGlzLmZyYWcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzaG91bGRDYWxsUmVtb3ZlKSB7XG4gICAgICAgIHNlbGYuY2FsbEhvb2soZGV0YWNoKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZGVzdHJveSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmUgdGhlIGZyYWdtZW50IGZvciByZW1vdmFsLlxuICAgKi9cblxuICBGcmFnbWVudC5wcm90b3R5cGUuYmVmb3JlUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLCBsO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAvLyBjYWxsIHRoZSBzYW1lIG1ldGhvZCByZWN1cnNpdmVseSBvbiBjaGlsZFxuICAgICAgLy8gZnJhZ21lbnRzLCBkZXB0aC1maXJzdFxuICAgICAgdGhpcy5jaGlsZEZyYWdzW2ldLmJlZm9yZVJlbW92ZShmYWxzZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgLy8gQ2FsbCBkZXN0cm95IGZvciBhbGwgY29udGFpbmVkIGluc3RhbmNlcyxcbiAgICAgIC8vIHdpdGggcmVtb3ZlOmZhbHNlIGFuZCBkZWZlcjp0cnVlLlxuICAgICAgLy8gRGVmZXIgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgbmVlZCB0b1xuICAgICAgLy8ga2VlcCB0aGUgY2hpbGRyZW4gdG8gY2FsbCBkZXRhY2ggaG9va3NcbiAgICAgIC8vIG9uIHRoZW0uXG4gICAgICB0aGlzLmNoaWxkcmVuW2ldLiRkZXN0cm95KGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gICAgdmFyIGRpcnMgPSB0aGlzLnVubGluay5kaXJzO1xuICAgIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgLy8gZGlzYWJsZSB0aGUgd2F0Y2hlcnMgb24gYWxsIHRoZSBkaXJlY3RpdmVzXG4gICAgICAvLyBzbyB0aGF0IHRoZSByZW5kZXJlZCBjb250ZW50IHN0YXlzIHRoZSBzYW1lXG4gICAgICAvLyBkdXJpbmcgcmVtb3ZhbC5cbiAgICAgIGRpcnNbaV0uX3dhdGNoZXIgJiYgZGlyc1tpXS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgZnJhZ21lbnQuXG4gICAqL1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBhcmVudEZyYWcpIHtcbiAgICAgIHRoaXMucGFyZW50RnJhZy5jaGlsZEZyYWdzLiRyZW1vdmUodGhpcyk7XG4gICAgfVxuICAgIHRoaXMubm9kZS5fX3ZfZnJhZyA9IG51bGw7XG4gICAgdGhpcy51bmxpbmsoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCBhdHRhY2ggaG9vayBmb3IgYSBWdWUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICAgKi9cblxuICBmdW5jdGlvbiBhdHRhY2goY2hpbGQpIHtcbiAgICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkICYmIGluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICAgIGNoaWxkLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBkZXRhY2ggaG9vayBmb3IgYSBWdWUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICAgKi9cblxuICBmdW5jdGlvbiBkZXRhY2goY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQuX2lzQXR0YWNoZWQgJiYgIWluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGlua2VyQ2FjaGUgPSBuZXcgQ2FjaGUoNTAwMCk7XG5cbiAgLyoqXG4gICAqIEEgZmFjdG9yeSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgYVxuICAgKiBmcmFnbWVudC4gQ2FjaGVzIHRoZSBjb21waWxlZCBsaW5rZXIgaWYgcG9zc2libGUuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbFxuICAgKi9cbiAgZnVuY3Rpb24gRnJhZ21lbnRGYWN0b3J5KHZtLCBlbCkge1xuICAgIHRoaXMudm0gPSB2bTtcbiAgICB2YXIgdGVtcGxhdGU7XG4gICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIGVsID09PSAnc3RyaW5nJztcbiAgICBpZiAoaXNTdHJpbmcgfHwgaXNUZW1wbGF0ZShlbCkpIHtcbiAgICAgIHRlbXBsYXRlID0gcGFyc2VUZW1wbGF0ZShlbCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgdGVtcGxhdGUuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgLy8gbGlua2VyIGNhbiBiZSBjYWNoZWQsIGJ1dCBvbmx5IGZvciBjb21wb25lbnRzXG4gICAgdmFyIGxpbmtlcjtcbiAgICB2YXIgY2lkID0gdm0uY29uc3RydWN0b3IuY2lkO1xuICAgIGlmIChjaWQgPiAwKSB7XG4gICAgICB2YXIgY2FjaGVJZCA9IGNpZCArIChpc1N0cmluZyA/IGVsIDogZ2V0T3V0ZXJIVE1MKGVsKSk7XG4gICAgICBsaW5rZXIgPSBsaW5rZXJDYWNoZS5nZXQoY2FjaGVJZCk7XG4gICAgICBpZiAoIWxpbmtlcikge1xuICAgICAgICBsaW5rZXIgPSBjb21waWxlKHRlbXBsYXRlLCB2bS4kb3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGxpbmtlckNhY2hlLnB1dChjYWNoZUlkLCBsaW5rZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5rZXIgPSBjb21waWxlKHRlbXBsYXRlLCB2bS4kb3B0aW9ucywgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMubGlua2VyID0gbGlua2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZyYWdtZW50IGluc3RhbmNlIHdpdGggZ2l2ZW4gaG9zdCBhbmQgc2NvcGUuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSBob3N0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBwYXJlbnRGcmFnXG4gICAqL1xuXG4gIEZyYWdtZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gICAgdmFyIGZyYWcgPSBjbG9uZU5vZGUodGhpcy50ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmxpbmtlciwgdGhpcy52bSwgZnJhZywgaG9zdCwgc2NvcGUsIHBhcmVudEZyYWcpO1xuICB9O1xuXG4gIHZhciBPTiA9IDcwMDtcbiAgdmFyIE1PREVMID0gODAwO1xuICB2YXIgQklORCA9IDg1MDtcbiAgdmFyIFRSQU5TSVRJT04gPSAxMTAwO1xuICB2YXIgRUwgPSAxNTAwO1xuICB2YXIgQ09NUE9ORU5UID0gMTUwMDtcbiAgdmFyIFBBUlRJQUwgPSAxNzUwO1xuICB2YXIgRk9SID0gMjAwMDtcbiAgdmFyIElGID0gMjAwMDtcbiAgdmFyIFNMT1QgPSAyMTAwO1xuXG4gIHZhciB1aWQkMyA9IDA7XG5cbiAgdmFyIHZGb3IgPSB7XG5cbiAgICBwcmlvcml0eTogRk9SLFxuXG4gICAgcGFyYW1zOiBbJ3RyYWNrLWJ5JywgJ3N0YWdnZXInLCAnZW50ZXItc3RhZ2dlcicsICdsZWF2ZS1zdGFnZ2VyJ10sXG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgLy8gc3VwcG9ydCBcIml0ZW0gaW4vb2YgaXRlbXNcIiBzeW50YXhcbiAgICAgIHZhciBpbk1hdGNoID0gdGhpcy5leHByZXNzaW9uLm1hdGNoKC8oLiopICg/OmlufG9mKSAoLiopLyk7XG4gICAgICBpZiAoaW5NYXRjaCkge1xuICAgICAgICB2YXIgaXRNYXRjaCA9IGluTWF0Y2hbMV0ubWF0Y2goL1xcKCguKiksKC4qKVxcKS8pO1xuICAgICAgICBpZiAoaXRNYXRjaCkge1xuICAgICAgICAgIHRoaXMuaXRlcmF0b3IgPSBpdE1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgICB0aGlzLmFsaWFzID0gaXRNYXRjaFsyXS50cmltKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGluTWF0Y2hbMl07XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5hbGlhcykge1xuICAgICAgICAnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignQWxpYXMgaXMgcmVxdWlyZWQgaW4gdi1mb3IuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdWlkIGFzIGEgY2FjaGUgaWRlbnRpZmllclxuICAgICAgdGhpcy5pZCA9ICdfX3YtZm9yX18nICsgKyt1aWQkMztcblxuICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhbiBvcHRpb24gbGlzdCxcbiAgICAgIC8vIHNvIHRoYXQgd2Uga25vdyBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgPHNlbGVjdD4nc1xuICAgICAgLy8gdi1tb2RlbCB3aGVuIHRoZSBvcHRpb24gbGlzdCBoYXMgY2hhbmdlZC5cbiAgICAgIC8vIGJlY2F1c2Ugdi1tb2RlbCBoYXMgYSBsb3dlciBwcmlvcml0eSB0aGFuIHYtZm9yLFxuICAgICAgLy8gdGhlIHYtbW9kZWwgaXMgbm90IGJvdW5kIGhlcmUgeWV0LCBzbyB3ZSBoYXZlIHRvXG4gICAgICAvLyByZXRyaXZlIGl0IGluIHRoZSBhY3R1YWwgdXBkYXRlTW9kZWwoKSBmdW5jdGlvbi5cbiAgICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgICB0aGlzLmlzT3B0aW9uID0gKHRhZyA9PT0gJ09QVElPTicgfHwgdGFnID09PSAnT1BUR1JPVVAnKSAmJiB0aGlzLmVsLnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCc7XG5cbiAgICAgIC8vIHNldHVwIGFuY2hvciBub2Rlc1xuICAgICAgdGhpcy5zdGFydCA9IGNyZWF0ZUFuY2hvcigndi1mb3Itc3RhcnQnKTtcbiAgICAgIHRoaXMuZW5kID0gY3JlYXRlQW5jaG9yKCd2LWZvci1lbmQnKTtcbiAgICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5lbmQpO1xuICAgICAgYmVmb3JlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcblxuICAgICAgLy8gY2FjaGVcbiAgICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAvLyBmcmFnbWVudCBmYWN0b3J5XG4gICAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIHRoaXMuZWwpO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShkYXRhKSB7XG4gICAgICB0aGlzLmRpZmYoZGF0YSk7XG4gICAgICB0aGlzLnVwZGF0ZVJlZigpO1xuICAgICAgdGhpcy51cGRhdGVNb2RlbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaWZmLCBiYXNlZCBvbiBuZXcgZGF0YSBhbmQgb2xkIGRhdGEsIGRldGVybWluZSB0aGVcbiAgICAgKiBtaW5pbXVtIGFtb3VudCBvZiBET00gbWFuaXB1bGF0aW9ucyBuZWVkZWQgdG8gbWFrZSB0aGVcbiAgICAgKiBET00gcmVmbGVjdCB0aGUgbmV3IGRhdGEgQXJyYXkuXG4gICAgICpcbiAgICAgKiBUaGUgYWxnb3JpdGhtIGRpZmZzIHRoZSBuZXcgZGF0YSBBcnJheSBieSBzdG9yaW5nIGFcbiAgICAgKiBoaWRkZW4gcmVmZXJlbmNlIHRvIGFuIG93bmVyIHZtIGluc3RhbmNlIG9uIHByZXZpb3VzbHlcbiAgICAgKiBzZWVuIGRhdGEuIFRoaXMgYWxsb3dzIHVzIHRvIGFjaGlldmUgTyhuKSB3aGljaCBpc1xuICAgICAqIGJldHRlciB0aGFuIGEgbGV2ZW5zaHRlaW4gZGlzdGFuY2UgYmFzZWQgYWxnb3JpdGhtLFxuICAgICAqIHdoaWNoIGlzIE8obSAqIG4pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YVxuICAgICAqL1xuXG4gICAgZGlmZjogZnVuY3Rpb24gZGlmZihkYXRhKSB7XG4gICAgICAvLyBjaGVjayBpZiB0aGUgQXJyYXkgd2FzIGNvbnZlcnRlZCBmcm9tIGFuIE9iamVjdFxuICAgICAgdmFyIGl0ZW0gPSBkYXRhWzBdO1xuICAgICAgdmFyIGNvbnZlcnRlZEZyb21PYmplY3QgPSB0aGlzLmZyb21PYmplY3QgPSBpc09iamVjdChpdGVtKSAmJiBoYXNPd24oaXRlbSwgJyRrZXknKSAmJiBoYXNPd24oaXRlbSwgJyR2YWx1ZScpO1xuXG4gICAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgICB2YXIgb2xkRnJhZ3MgPSB0aGlzLmZyYWdzO1xuICAgICAgdmFyIGZyYWdzID0gdGhpcy5mcmFncyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICB2YXIgYWxpYXMgPSB0aGlzLmFsaWFzO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcjtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG4gICAgICB2YXIgaW5Eb2N1bWVudCA9IGluRG9jKHN0YXJ0KTtcbiAgICAgIHZhciBpbml0ID0gIW9sZEZyYWdzO1xuICAgICAgdmFyIGksIGwsIGZyYWcsIGtleSwgdmFsdWUsIHByaW1pdGl2ZTtcblxuICAgICAgLy8gRmlyc3QgcGFzcywgZ28gdGhyb3VnaCB0aGUgbmV3IEFycmF5IGFuZCBmaWxsIHVwXG4gICAgICAvLyB0aGUgbmV3IGZyYWdzIGFycmF5LiBJZiBhIHBpZWNlIG9mIGRhdGEgaGFzIGEgY2FjaGVkXG4gICAgICAvLyBpbnN0YW5jZSBmb3IgaXQsIHdlIHJldXNlIGl0LiBPdGhlcndpc2UgYnVpbGQgYSBuZXdcbiAgICAgIC8vIGluc3RhbmNlLlxuICAgICAgZm9yIChpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBkYXRhW2ldO1xuICAgICAgICBrZXkgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4ka2V5IDogbnVsbDtcbiAgICAgICAgdmFsdWUgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4kdmFsdWUgOiBpdGVtO1xuICAgICAgICBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgICAgICBmcmFnID0gIWluaXQgJiYgdGhpcy5nZXRDYWNoZWRGcmFnKHZhbHVlLCBpLCBrZXkpO1xuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgIC8vIHJldXNhYmxlIGZyYWdtZW50XG4gICAgICAgICAgZnJhZy5yZXVzZWQgPSB0cnVlO1xuICAgICAgICAgIC8vIHVwZGF0ZSAkaW5kZXhcbiAgICAgICAgICBmcmFnLnNjb3BlLiRpbmRleCA9IGk7XG4gICAgICAgICAgLy8gdXBkYXRlICRrZXlcbiAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBmcmFnLnNjb3BlLiRrZXkgPSBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHVwZGF0ZSBpdGVyYXRvclxuICAgICAgICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICAgICAgZnJhZy5zY29wZVtpdGVyYXRvcl0gPSBrZXkgIT09IG51bGwgPyBrZXkgOiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB1cGRhdGUgZGF0YSBmb3IgdHJhY2stYnksIG9iamVjdCByZXBlYXQgJlxuICAgICAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZXMuXG4gICAgICAgICAgaWYgKHRyYWNrQnlLZXkgfHwgY29udmVydGVkRnJvbU9iamVjdCB8fCBwcmltaXRpdmUpIHtcbiAgICAgICAgICAgIGZyYWcuc2NvcGVbYWxpYXNdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5ldyBpc250YW5jZVxuICAgICAgICAgIGZyYWcgPSB0aGlzLmNyZWF0ZSh2YWx1ZSwgYWxpYXMsIGksIGtleSk7XG4gICAgICAgICAgZnJhZy5mcmVzaCA9ICFpbml0O1xuICAgICAgICB9XG4gICAgICAgIGZyYWdzW2ldID0gZnJhZztcbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICBmcmFnLmJlZm9yZShlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHdlJ3JlIGRvbmUgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAgIGlmIChpbml0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU2Vjb25kIHBhc3MsIGdvIHRocm91Z2ggdGhlIG9sZCBmcmFnbWVudHMgYW5kXG4gICAgICAvLyBkZXN0cm95IHRob3NlIHdobyBhcmUgbm90IHJldXNlZCAoYW5kIHJlbW92ZSB0aGVtXG4gICAgICAvLyBmcm9tIGNhY2hlKVxuICAgICAgdmFyIHJlbW92YWxJbmRleCA9IDA7XG4gICAgICB2YXIgdG90YWxSZW1vdmVkID0gb2xkRnJhZ3MubGVuZ3RoIC0gZnJhZ3MubGVuZ3RoO1xuICAgICAgLy8gd2hlbiByZW1vdmluZyBhIGxhcmdlIG51bWJlciBvZiBmcmFnbWVudHMsIHdhdGNoZXIgcmVtb3ZhbFxuICAgICAgLy8gdHVybnMgb3V0IHRvIGJlIGEgcGVyZiBib3R0bGVuZWNrLCBzbyB3ZSBiYXRjaCB0aGUgd2F0Y2hlclxuICAgICAgLy8gcmVtb3ZhbHMgaW50byBhIHNpbmdsZSBmaWx0ZXIgY2FsbCFcbiAgICAgIHRoaXMudm0uX3ZGb3JSZW1vdmluZyA9IHRydWU7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gb2xkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGZyYWcgPSBvbGRGcmFnc1tpXTtcbiAgICAgICAgaWYgKCFmcmFnLnJldXNlZCkge1xuICAgICAgICAgIHRoaXMuZGVsZXRlQ2FjaGVkRnJhZyhmcmFnKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZShmcmFnLCByZW1vdmFsSW5kZXgrKywgdG90YWxSZW1vdmVkLCBpbkRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy52bS5fdkZvclJlbW92aW5nID0gZmFsc2U7XG4gICAgICBpZiAocmVtb3ZhbEluZGV4KSB7XG4gICAgICAgIHRoaXMudm0uX3dhdGNoZXJzID0gdGhpcy52bS5fd2F0Y2hlcnMuZmlsdGVyKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgcmV0dXJuIHcuYWN0aXZlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluYWwgcGFzcywgbW92ZS9pbnNlcnQgbmV3IGZyYWdtZW50cyBpbnRvIHRoZVxuICAgICAgLy8gcmlnaHQgcGxhY2UuXG4gICAgICB2YXIgdGFyZ2V0UHJldiwgcHJldkVsLCBjdXJyZW50UHJldjtcbiAgICAgIHZhciBpbnNlcnRpb25JbmRleCA9IDA7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gZnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGZyYWcgPSBmcmFnc1tpXTtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZnJhZyB0aGF0IHdlIHNob3VsZCBiZSBhZnRlclxuICAgICAgICB0YXJnZXRQcmV2ID0gZnJhZ3NbaSAtIDFdO1xuICAgICAgICBwcmV2RWwgPSB0YXJnZXRQcmV2ID8gdGFyZ2V0UHJldi5zdGFnZ2VyQ2IgPyB0YXJnZXRQcmV2LnN0YWdnZXJBbmNob3IgOiB0YXJnZXRQcmV2LmVuZCB8fCB0YXJnZXRQcmV2Lm5vZGUgOiBzdGFydDtcbiAgICAgICAgaWYgKGZyYWcucmV1c2VkICYmICFmcmFnLnN0YWdnZXJDYikge1xuICAgICAgICAgIGN1cnJlbnRQcmV2ID0gZmluZFByZXZGcmFnKGZyYWcsIHN0YXJ0LCB0aGlzLmlkKTtcbiAgICAgICAgICBpZiAoY3VycmVudFByZXYgIT09IHRhcmdldFByZXYgJiYgKCFjdXJyZW50UHJldiB8fFxuICAgICAgICAgIC8vIG9wdGltaXphdGlvbiBmb3IgbW92aW5nIGEgc2luZ2xlIGl0ZW0uXG4gICAgICAgICAgLy8gdGhhbmtzIHRvIHN1Z2dlc3Rpb25zIGJ5IEBsaXZvcmFzIGluICMxODA3XG4gICAgICAgICAgZmluZFByZXZGcmFnKGN1cnJlbnRQcmV2LCBzdGFydCwgdGhpcy5pZCkgIT09IHRhcmdldFByZXYpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmUoZnJhZywgcHJldkVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbmV3IGluc3RhbmNlLCBvciBzdGlsbCBpbiBzdGFnZ2VyLlxuICAgICAgICAgIC8vIGluc2VydCB3aXRoIHVwZGF0ZWQgc3RhZ2dlciBpbmRleC5cbiAgICAgICAgICB0aGlzLmluc2VydChmcmFnLCBpbnNlcnRpb25JbmRleCsrLCBwcmV2RWwsIGluRG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGZyYWcucmV1c2VkID0gZnJhZy5mcmVzaCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFsaWFzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAgICogQHJldHVybiB7RnJhZ21lbnR9XG4gICAgICovXG5cbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgYWxpYXMsIGluZGV4LCBrZXkpIHtcbiAgICAgIHZhciBob3N0ID0gdGhpcy5faG9zdDtcbiAgICAgIC8vIGNyZWF0ZSBpdGVyYXRpb24gc2NvcGVcbiAgICAgIHZhciBwYXJlbnRTY29wZSA9IHRoaXMuX3Njb3BlIHx8IHRoaXMudm07XG4gICAgICB2YXIgc2NvcGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlKTtcbiAgICAgIC8vIHJlZiBob2xkZXIgZm9yIHRoZSBzY29wZVxuICAgICAgc2NvcGUuJHJlZnMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlLiRyZWZzKTtcbiAgICAgIHNjb3BlLiRlbHMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlLiRlbHMpO1xuICAgICAgLy8gbWFrZSBzdXJlIHBvaW50ICRwYXJlbnQgdG8gcGFyZW50IHNjb3BlXG4gICAgICBzY29wZS4kcGFyZW50ID0gcGFyZW50U2NvcGU7XG4gICAgICAvLyBmb3IgdHdvLXdheSBiaW5kaW5nIG9uIGFsaWFzXG4gICAgICBzY29wZS4kZm9yQ29udGV4dCA9IHRoaXM7XG4gICAgICAvLyBkZWZpbmUgc2NvcGUgcHJvcGVydGllc1xuICAgICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsIGFsaWFzLCB2YWx1ZSwgdHJ1ZSAvKiBkbyBub3Qgb2JzZXJ2ZSAqLyk7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgJyRpbmRleCcsIGluZGV4KTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsICcka2V5Jywga2V5KTtcbiAgICAgIH0gZWxzZSBpZiAoc2NvcGUuJGtleSkge1xuICAgICAgICAvLyBhdm9pZCBhY2NpZGVudGFsIGZhbGxiYWNrXG4gICAgICAgIGRlZihzY29wZSwgJyRrZXknLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLml0ZXJhdG9yKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCB0aGlzLml0ZXJhdG9yLCBrZXkgIT09IG51bGwgPyBrZXkgOiBpbmRleCk7XG4gICAgICB9XG4gICAgICB2YXIgZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUoaG9zdCwgc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgICAgZnJhZy5mb3JJZCA9IHRoaXMuaWQ7XG4gICAgICB0aGlzLmNhY2hlRnJhZyh2YWx1ZSwgZnJhZywgaW5kZXgsIGtleSk7XG4gICAgICByZXR1cm4gZnJhZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB2LXJlZiBvbiBvd25lciB2bS5cbiAgICAgKi9cblxuICAgIHVwZGF0ZVJlZjogZnVuY3Rpb24gdXBkYXRlUmVmKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXMuZGVzY3JpcHRvci5yZWY7XG4gICAgICBpZiAoIXJlZikgcmV0dXJuO1xuICAgICAgdmFyIGhhc2ggPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHJlZnM7XG4gICAgICB2YXIgcmVmcztcbiAgICAgIGlmICghdGhpcy5mcm9tT2JqZWN0KSB7XG4gICAgICAgIHJlZnMgPSB0aGlzLmZyYWdzLm1hcChmaW5kVm1Gcm9tRnJhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZzID0ge307XG4gICAgICAgIHRoaXMuZnJhZ3MuZm9yRWFjaChmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICAgIHJlZnNbZnJhZy5zY29wZS4ka2V5XSA9IGZpbmRWbUZyb21GcmFnKGZyYWcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGhhc2hbcmVmXSA9IHJlZnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvciBvcHRpb24gbGlzdHMsIHVwZGF0ZSB0aGUgY29udGFpbmluZyB2LW1vZGVsIG9uXG4gICAgICogcGFyZW50IDxzZWxlY3Q+LlxuICAgICAqL1xuXG4gICAgdXBkYXRlTW9kZWw6IGZ1bmN0aW9uIHVwZGF0ZU1vZGVsKCkge1xuICAgICAgaWYgKHRoaXMuaXNPcHRpb24pIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuc3RhcnQucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIG1vZGVsID0gcGFyZW50ICYmIHBhcmVudC5fX3ZfbW9kZWw7XG4gICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgIG1vZGVsLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgZnJhZ21lbnQuIEhhbmRsZXMgc3RhZ2dlcmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge05vZGV9IHByZXZFbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5Eb2N1bWVudFxuICAgICAqL1xuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoZnJhZywgaW5kZXgsIHByZXZFbCwgaW5Eb2N1bWVudCkge1xuICAgICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiLmNhbmNlbCgpO1xuICAgICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgc3RhZ2dlckFtb3VudCA9IHRoaXMuZ2V0U3RhZ2dlcihmcmFnLCBpbmRleCwgbnVsbCwgJ2VudGVyJyk7XG4gICAgICBpZiAoaW5Eb2N1bWVudCAmJiBzdGFnZ2VyQW1vdW50KSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhbiBhbmNob3IgYW5kIGluc2VydCBpdCBzeW5jaHJvbm91c2x5LFxuICAgICAgICAvLyBzbyB0aGF0IHdlIGNhbiByZXNvbHZlIHRoZSBjb3JyZWN0IG9yZGVyIHdpdGhvdXRcbiAgICAgICAgLy8gd29ycnlpbmcgYWJvdXQgc29tZSBlbGVtZW50cyBub3QgaW5zZXJ0ZWQgeWV0XG4gICAgICAgIHZhciBhbmNob3IgPSBmcmFnLnN0YWdnZXJBbmNob3I7XG4gICAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgICAgYW5jaG9yID0gZnJhZy5zdGFnZ2VyQW5jaG9yID0gY3JlYXRlQW5jaG9yKCdzdGFnZ2VyLWFuY2hvcicpO1xuICAgICAgICAgIGFuY2hvci5fX3ZfZnJhZyA9IGZyYWc7XG4gICAgICAgIH1cbiAgICAgICAgYWZ0ZXIoYW5jaG9yLCBwcmV2RWwpO1xuICAgICAgICB2YXIgb3AgPSBmcmFnLnN0YWdnZXJDYiA9IGNhbmNlbGxhYmxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgICAgICAgZnJhZy5iZWZvcmUoYW5jaG9yKTtcbiAgICAgICAgICByZW1vdmUoYW5jaG9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQob3AsIHN0YWdnZXJBbW91bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZy5iZWZvcmUocHJldkVsLm5leHRTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZnJhZ21lbnQuIEhhbmRsZXMgc3RhZ2dlcmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG90YWxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluRG9jdW1lbnRcbiAgICAgKi9cblxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGZyYWcsIGluZGV4LCB0b3RhbCwgaW5Eb2N1bWVudCkge1xuICAgICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiLmNhbmNlbCgpO1xuICAgICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgICAgIC8vIGl0J3Mgbm90IHBvc3NpYmxlIGZvciB0aGUgc2FtZSBmcmFnIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgLy8gdHdpY2UsIHNvIGlmIHdlIGhhdmUgYSBwZW5kaW5nIHN0YWdnZXIgY2FsbGJhY2ssXG4gICAgICAgIC8vIGl0IG1lYW5zIHRoaXMgZnJhZyBpcyBxdWV1ZWQgZm9yIGVudGVyIGJ1dCByZW1vdmVkXG4gICAgICAgIC8vIGJlZm9yZSBpdHMgdHJhbnNpdGlvbiBzdGFydGVkLiBTaW5jZSBpdCBpcyBhbHJlYWR5XG4gICAgICAgIC8vIGRlc3Ryb3llZCwgd2UgY2FuIGp1c3QgbGVhdmUgaXQgaW4gZGV0YWNoZWQgc3RhdGUuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdGFnZ2VyQW1vdW50ID0gdGhpcy5nZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCB0b3RhbCwgJ2xlYXZlJyk7XG4gICAgICBpZiAoaW5Eb2N1bWVudCAmJiBzdGFnZ2VyQW1vdW50KSB7XG4gICAgICAgIHZhciBvcCA9IGZyYWcuc3RhZ2dlckNiID0gY2FuY2VsbGFibGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICAgICAgICBmcmFnLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0VGltZW91dChvcCwgc3RhZ2dlckFtb3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIGEgZnJhZ21lbnQgdG8gYSBuZXcgcG9zaXRpb24uXG4gICAgICogRm9yY2Ugbm8gdHJhbnNpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICAgKiBAcGFyYW0ge05vZGV9IHByZXZFbFxuICAgICAqL1xuXG4gICAgbW92ZTogZnVuY3Rpb24gbW92ZShmcmFnLCBwcmV2RWwpIHtcbiAgICAgIC8vIGZpeCBhIGNvbW1vbiBpc3N1ZSB3aXRoIFNvcnRhYmxlOlxuICAgICAgLy8gaWYgcHJldkVsIGRvZXNuJ3QgaGF2ZSBuZXh0U2libGluZywgdGhpcyBtZWFucyBpdCdzXG4gICAgICAvLyBiZWVuIGRyYWdnZWQgYWZ0ZXIgdGhlIGVuZCBhbmNob3IuIEp1c3QgcmUtcG9zaXRpb25cbiAgICAgIC8vIHRoZSBlbmQgYW5jaG9yIHRvIHRoZSBlbmQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFwcmV2RWwubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdGhpcy5lbmQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmVuZCk7XG4gICAgICB9XG4gICAgICBmcmFnLmJlZm9yZShwcmV2RWwubmV4dFNpYmxpbmcsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FjaGUgYSBmcmFnbWVudCB1c2luZyB0cmFjay1ieSBvciB0aGUgb2JqZWN0IGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAgICovXG5cbiAgICBjYWNoZUZyYWc6IGZ1bmN0aW9uIGNhY2hlRnJhZyh2YWx1ZSwgZnJhZywgaW5kZXgsIGtleSkge1xuICAgICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgICAgdmFyIGlkO1xuICAgICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgICBpZCA9IHRyYWNrQnlLZXkgPyB0cmFja0J5S2V5ID09PSAnJGluZGV4JyA/IGluZGV4IDogdmFsdWVbdHJhY2tCeUtleV0gOiBrZXkgfHwgdmFsdWU7XG4gICAgICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICAgICAgY2FjaGVbaWRdID0gZnJhZztcbiAgICAgICAgfSBlbHNlIGlmICh0cmFja0J5S2V5ICE9PSAnJGluZGV4Jykge1xuICAgICAgICAgICdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZCA9IHRoaXMuaWQ7XG4gICAgICAgIGlmIChoYXNPd24odmFsdWUsIGlkKSkge1xuICAgICAgICAgIGlmICh2YWx1ZVtpZF0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlW2lkXSA9IGZyYWc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWYodmFsdWUsIGlkLCBmcmFnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnJhZy5yYXcgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgY2FjaGVkIGZyYWdtZW50IGZyb20gdGhlIHZhbHVlL2luZGV4L2tleVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAgICAgKi9cblxuICAgIGdldENhY2hlZEZyYWc6IGZ1bmN0aW9uIGdldENhY2hlZEZyYWcodmFsdWUsIGluZGV4LCBrZXkpIHtcbiAgICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgICAgdmFyIGZyYWc7XG4gICAgICBpZiAoa2V5IHx8IHRyYWNrQnlLZXkgfHwgcHJpbWl0aXZlKSB7XG4gICAgICAgIHZhciBpZCA9IHRyYWNrQnlLZXkgPyB0cmFja0J5S2V5ID09PSAnJGluZGV4JyA/IGluZGV4IDogdmFsdWVbdHJhY2tCeUtleV0gOiBrZXkgfHwgdmFsdWU7XG4gICAgICAgIGZyYWcgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWcgPSB2YWx1ZVt0aGlzLmlkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnICYmIChmcmFnLnJldXNlZCB8fCBmcmFnLmZyZXNoKSkge1xuICAgICAgICAnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBmcmFnbWVudCBmcm9tIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgICAqL1xuXG4gICAgZGVsZXRlQ2FjaGVkRnJhZzogZnVuY3Rpb24gZGVsZXRlQ2FjaGVkRnJhZyhmcmFnKSB7XG4gICAgICB2YXIgdmFsdWUgPSBmcmFnLnJhdztcbiAgICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICAgIHZhciBzY29wZSA9IGZyYWcuc2NvcGU7XG4gICAgICB2YXIgaW5kZXggPSBzY29wZS4kaW5kZXg7XG4gICAgICAvLyBmaXggIzk0ODogYXZvaWQgYWNjaWRlbnRhbGx5IGZhbGwgdGhyb3VnaCB0b1xuICAgICAgLy8gYSBwYXJlbnQgcmVwZWF0ZXIgd2hpY2ggaGFwcGVucyB0byBoYXZlICRrZXkuXG4gICAgICB2YXIga2V5ID0gaGFzT3duKHNjb3BlLCAnJGtleScpICYmIHNjb3BlLiRrZXk7XG4gICAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICh0cmFja0J5S2V5IHx8IGtleSB8fCBwcmltaXRpdmUpIHtcbiAgICAgICAgdmFyIGlkID0gdHJhY2tCeUtleSA/IHRyYWNrQnlLZXkgPT09ICckaW5kZXgnID8gaW5kZXggOiB2YWx1ZVt0cmFja0J5S2V5XSA6IGtleSB8fCB2YWx1ZTtcbiAgICAgICAgdGhpcy5jYWNoZVtpZF0gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVbdGhpcy5pZF0gPSBudWxsO1xuICAgICAgICBmcmFnLnJhdyA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhZ2dlciBhbW91bnQgZm9yIGFuIGluc2VydGlvbi9yZW1vdmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICovXG5cbiAgICBnZXRTdGFnZ2VyOiBmdW5jdGlvbiBnZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCB0b3RhbCwgdHlwZSkge1xuICAgICAgdHlwZSA9IHR5cGUgKyAnU3RhZ2dlcic7XG4gICAgICB2YXIgdHJhbnMgPSBmcmFnLm5vZGUuX192X3RyYW5zO1xuICAgICAgdmFyIGhvb2tzID0gdHJhbnMgJiYgdHJhbnMuaG9va3M7XG4gICAgICB2YXIgaG9vayA9IGhvb2tzICYmIChob29rc1t0eXBlXSB8fCBob29rcy5zdGFnZ2VyKTtcbiAgICAgIHJldHVybiBob29rID8gaG9vay5jYWxsKGZyYWcsIGluZGV4LCB0b3RhbCkgOiBpbmRleCAqIHBhcnNlSW50KHRoaXMucGFyYW1zW3R5cGVdIHx8IHRoaXMucGFyYW1zLnN0YWdnZXIsIDEwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlLXByb2Nlc3MgdGhlIHZhbHVlIGJlZm9yZSBwaXBpbmcgaXQgdGhyb3VnaCB0aGVcbiAgICAgKiBmaWx0ZXJzLiBUaGlzIGlzIHBhc3NlZCB0byBhbmQgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyLlxuICAgICAqL1xuXG4gICAgX3ByZVByb2Nlc3M6IGZ1bmN0aW9uIF9wcmVQcm9jZXNzKHZhbHVlKSB7XG4gICAgICAvLyByZWdhcmRsZXNzIG9mIHR5cGUsIHN0b3JlIHRoZSB1bi1maWx0ZXJlZCByYXcgdmFsdWUuXG4gICAgICB0aGlzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBvc3QtcHJvY2VzcyB0aGUgdmFsdWUgYWZ0ZXIgaXQgaGFzIGJlZW4gcGlwZWQgdGhyb3VnaFxuICAgICAqIHRoZSBmaWx0ZXJzLiBUaGlzIGlzIHBhc3NlZCB0byBhbmQgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyLlxuICAgICAqXG4gICAgICogSXQgaXMgbmVjZXNzYXJ5IGZvciB0aGlzIHRvIGJlIGNhbGxlZCBkdXJpbmcgdGhlXG4gICAgICogd2F0aGNlcidzIGRlcGVuZGVuY3kgY29sbGVjdGlvbiBwaGFzZSBiZWNhdXNlIHdlIHdhbnRcbiAgICAgKiB0aGUgdi1mb3IgdG8gdXBkYXRlIHdoZW4gdGhlIHNvdXJjZSBPYmplY3QgaXMgbXV0YXRlZC5cbiAgICAgKi9cblxuICAgIF9wb3N0UHJvY2VzczogZnVuY3Rpb24gX3Bvc3RQcm9jZXNzKHZhbHVlKSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAvLyBjb252ZXJ0IHBsYWluIG9iamVjdCB0byBhcnJheS5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIHJlc1tpXSA9IHtcbiAgICAgICAgICAgICRrZXk6IGtleSxcbiAgICAgICAgICAgICR2YWx1ZTogdmFsdWVba2V5XVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHJhbmdlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgfHwgW107XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgICAgaWYgKHRoaXMuZGVzY3JpcHRvci5yZWYpIHtcbiAgICAgICAgKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRyZWZzW3RoaXMuZGVzY3JpcHRvci5yZWZdID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZyYWdzKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5mcmFncy5sZW5ndGg7XG4gICAgICAgIHZhciBmcmFnO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgZnJhZyA9IHRoaXMuZnJhZ3NbaV07XG4gICAgICAgICAgdGhpcy5kZWxldGVDYWNoZWRGcmFnKGZyYWcpO1xuICAgICAgICAgIGZyYWcuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZmluZCB0aGUgcHJldmlvdXMgZWxlbWVudCB0aGF0IGlzIGEgZnJhZ21lbnRcbiAgICogYW5jaG9yLiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGEgZGVzdHJveWVkIGZyYWcnc1xuICAgKiBlbGVtZW50IGNvdWxkIHN0aWxsIGJlIGxpbmdlcmluZyBpbiB0aGUgRE9NIGJlZm9yZSBpdHNcbiAgICogbGVhdmluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLCBidXQgaXRzIGluc2VydGVkIGZsYWdcbiAgICogc2hvdWxkIGhhdmUgYmVlbiBzZXQgdG8gZmFsc2Ugc28gd2UgY2FuIHNraXAgdGhlbS5cbiAgICpcbiAgICogSWYgdGhpcyBpcyBhIGJsb2NrIHJlcGVhdCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2Ugb25seVxuICAgKiByZXR1cm4gZnJhZyB0aGF0IGlzIGJvdW5kIHRvIHRoaXMgdi1mb3IuIChzZWUgIzkyOSlcbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge0NvbW1lbnR8VGV4dH0gYW5jaG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAgICovXG5cbiAgZnVuY3Rpb24gZmluZFByZXZGcmFnKGZyYWcsIGFuY2hvciwgaWQpIHtcbiAgICB2YXIgZWwgPSBmcmFnLm5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICBmcmFnID0gZWwuX192X2ZyYWc7XG4gICAgd2hpbGUgKCghZnJhZyB8fCBmcmFnLmZvcklkICE9PSBpZCB8fCAhZnJhZy5pbnNlcnRlZCkgJiYgZWwgIT09IGFuY2hvcikge1xuICAgICAgZWwgPSBlbC5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghZWwpIHJldHVybjtcbiAgICAgIGZyYWcgPSBlbC5fX3ZfZnJhZztcbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhIHZtIGZyb20gYSBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcmV0dXJuIHtWdWV8dW5kZWZpbmVkfVxuICAgKi9cblxuICBmdW5jdGlvbiBmaW5kVm1Gcm9tRnJhZyhmcmFnKSB7XG4gICAgdmFyIG5vZGUgPSBmcmFnLm5vZGU7XG4gICAgLy8gaGFuZGxlIG11bHRpLW5vZGUgZnJhZ1xuICAgIGlmIChmcmFnLmVuZCkge1xuICAgICAgd2hpbGUgKCFub2RlLl9fdnVlX18gJiYgbm9kZSAhPT0gZnJhZy5lbmQgJiYgbm9kZS5uZXh0U2libGluZykge1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGUuX192dWVfXztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByYW5nZSBhcnJheSBmcm9tIGdpdmVuIG51bWJlci5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJhbmdlKG4pIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkoTWF0aC5mbG9vcihuKSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHJldFtpXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAoJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdkZvci53YXJuRHVwbGljYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB3YXJuKCdEdXBsaWNhdGUgdmFsdWUgZm91bmQgaW4gdi1mb3I9XCInICsgdGhpcy5kZXNjcmlwdG9yLnJhdyArICdcIjogJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcuIFVzZSB0cmFjay1ieT1cIiRpbmRleFwiIGlmICcgKyAneW91IGFyZSBleHBlY3RpbmcgZHVwbGljYXRlIHZhbHVlcy4nKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHZJZiA9IHtcblxuICAgIHByaW9yaXR5OiBJRixcblxuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgaWYgKCFlbC5fX3Z1ZV9fKSB7XG4gICAgICAgIC8vIGNoZWNrIGVsc2UgYmxvY2tcbiAgICAgICAgdmFyIG5leHQgPSBlbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGlmIChuZXh0ICYmIGdldEF0dHIobmV4dCwgJ3YtZWxzZScpICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVtb3ZlKG5leHQpO1xuICAgICAgICAgIHRoaXMuZWxzZUVsID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBtYWluIGJsb2NrXG4gICAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LWlmJyk7XG4gICAgICAgIHJlcGxhY2UoZWwsIHRoaXMuYW5jaG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LWlmPVwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiBjYW5ub3QgYmUgJyArICd1c2VkIG9uIGFuIGluc3RhbmNlIHJvb3QgZWxlbWVudC4nKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmludmFsaWQpIHJldHVybjtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuZnJhZykge1xuICAgICAgICAgIHRoaXMuaW5zZXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KCkge1xuICAgICAgaWYgKHRoaXMuZWxzZUZyYWcpIHtcbiAgICAgICAgdGhpcy5lbHNlRnJhZy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5lbHNlRnJhZyA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBsYXp5IGluaXQgZmFjdG9yeVxuICAgICAgaWYgKCF0aGlzLmZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUodGhpcy5faG9zdCwgdGhpcy5fc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgICAgdGhpcy5mcmFnLmJlZm9yZSh0aGlzLmFuY2hvcik7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgaWYgKHRoaXMuZnJhZykge1xuICAgICAgICB0aGlzLmZyYWcucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbHNlRWwgJiYgIXRoaXMuZWxzZUZyYWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsc2VGYWN0b3J5KSB7XG4gICAgICAgICAgdGhpcy5lbHNlRmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy5lbHNlRWwuX2NvbnRleHQgfHwgdGhpcy52bSwgdGhpcy5lbHNlRWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxzZUZyYWcgPSB0aGlzLmVsc2VGYWN0b3J5LmNyZWF0ZSh0aGlzLl9ob3N0LCB0aGlzLl9zY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgICAgIHRoaXMuZWxzZUZyYWcuYmVmb3JlKHRoaXMuYW5jaG9yKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICBpZiAodGhpcy5mcmFnKSB7XG4gICAgICAgIHRoaXMuZnJhZy5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbHNlRnJhZykge1xuICAgICAgICB0aGlzLmVsc2VGcmFnLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHNob3cgPSB7XG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgLy8gY2hlY2sgZWxzZSBibG9ja1xuICAgICAgdmFyIG5leHQgPSB0aGlzLmVsLm5leHRFbGVtZW50U2libGluZztcbiAgICAgIGlmIChuZXh0ICYmIGdldEF0dHIobmV4dCwgJ3YtZWxzZScpICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZWxzZUVsID0gbmV4dDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuYXBwbHkodGhpcy5lbCwgdmFsdWUpO1xuICAgICAgaWYgKHRoaXMuZWxzZUVsKSB7XG4gICAgICAgIHRoaXMuYXBwbHkodGhpcy5lbHNlRWwsICF2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFwcGx5OiBmdW5jdGlvbiBhcHBseShlbCwgdmFsdWUpIHtcbiAgICAgIGlmIChpbkRvYyhlbCkpIHtcbiAgICAgICAgYXBwbHlUcmFuc2l0aW9uKGVsLCB2YWx1ZSA/IDEgOiAtMSwgdG9nZ2xlLCB0aGlzLnZtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvZ2dsZSgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyAnJyA6ICdub25lJztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHRleHQkMiA9IHtcblxuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgdmFyIGlzUmFuZ2UgPSBlbC50eXBlID09PSAncmFuZ2UnO1xuICAgICAgdmFyIGxhenkgPSB0aGlzLnBhcmFtcy5sYXp5O1xuICAgICAgdmFyIG51bWJlciA9IHRoaXMucGFyYW1zLm51bWJlcjtcbiAgICAgIHZhciBkZWJvdW5jZSA9IHRoaXMucGFyYW1zLmRlYm91bmNlO1xuXG4gICAgICAvLyBoYW5kbGUgY29tcG9zaXRpb24gZXZlbnRzLlxuICAgICAgLy8gICBodHRwOi8vYmxvZy5ldmFueW91Lm1lLzIwMTQvMDEvMDMvY29tcG9zaXRpb24tZXZlbnQvXG4gICAgICAvLyBza2lwIHRoaXMgZm9yIEFuZHJvaWQgYmVjYXVzZSBpdCBoYW5kbGVzIGNvbXBvc2l0aW9uXG4gICAgICAvLyBldmVudHMgcXVpdGUgZGlmZmVyZW50bHkuIEFuZHJvaWQgZG9lc24ndCB0cmlnZ2VyXG4gICAgICAvLyBjb21wb3NpdGlvbiBldmVudHMgZm9yIGxhbmd1YWdlIGlucHV0IG1ldGhvZHMgZS5nLlxuICAgICAgLy8gQ2hpbmVzZSwgYnV0IGluc3RlYWQgdHJpZ2dlcnMgdGhlbSBmb3Igc3BlbGxpbmdcbiAgICAgIC8vIHN1Z2dlc3Rpb25zLi4uIChzZWUgRGlzY3Vzc2lvbi8jMTYyKVxuICAgICAgdmFyIGNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgaWYgKCFpc0FuZHJvaWQgJiYgIWlzUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5vbignY29tcG9zaXRpb25zdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb21wb3NpbmcgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbignY29tcG9zaXRpb25lbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgICAgLy8gaW4gSUUxMSB0aGUgXCJjb21wb3NpdGlvbmVuZFwiIGV2ZW50IGZpcmVzIEFGVEVSXG4gICAgICAgICAgLy8gdGhlIFwiaW5wdXRcIiBldmVudCwgc28gdGhlIGlucHV0IGhhbmRsZXIgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGF0IHRoZSBlbmQuLi4gaGF2ZSB0byBjYWxsIGl0IGhlcmUuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAjMTMyNzogaW4gbGF6eSBtb2RlIHRoaXMgaXMgdW5lY2Vzc2FyeS5cbiAgICAgICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgICAgIHNlbGYubGlzdGVuZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBwcmV2ZW50IG1lc3Npbmcgd2l0aCB0aGUgaW5wdXQgd2hlbiB1c2VyIGlzIHR5cGluZyxcbiAgICAgIC8vIGFuZCBmb3JjZSB1cGRhdGUgb24gYmx1ci5cbiAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgaWYgKCFpc1JhbmdlICYmICFsYXp5KSB7XG4gICAgICAgIHRoaXMub24oJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCdibHVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIC8vIGRvIG5vdCBzeW5jIHZhbHVlIGFmdGVyIGZyYWdtZW50IHJlbW92YWwgKCMyMDE3KVxuICAgICAgICAgIGlmICghc2VsZi5fZnJhZyB8fCBzZWxmLl9mcmFnLmluc2VydGVkKSB7XG4gICAgICAgICAgICBzZWxmLnJhd0xpc3RlbmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93IGF0dGFjaCB0aGUgbWFpbiBsaXN0ZW5lclxuICAgICAgdGhpcy5saXN0ZW5lciA9IHRoaXMucmF3TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjb21wb3NpbmcgfHwgIXNlbGYuX2JvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWwgPSBudW1iZXIgfHwgaXNSYW5nZSA/IHRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgICAgICBzZWxmLnNldCh2YWwpO1xuICAgICAgICAvLyBmb3JjZSB1cGRhdGUgb24gbmV4dCB0aWNrIHRvIGF2b2lkIGxvY2sgJiBzYW1lIHZhbHVlXG4gICAgICAgIC8vIGFsc28gb25seSB1cGRhdGUgd2hlbiB1c2VyIGlzIG5vdCB0eXBpbmdcbiAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChzZWxmLl9ib3VuZCAmJiAhc2VsZi5mb2N1c2VkKSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZShzZWxmLl93YXRjaGVyLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gYXBwbHkgZGVib3VuY2VcbiAgICAgIGlmIChkZWJvdW5jZSkge1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gX2RlYm91bmNlKHRoaXMubGlzdGVuZXIsIGRlYm91bmNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3VwcG9ydCBqUXVlcnkgZXZlbnRzLCBzaW5jZSBqUXVlcnkudHJpZ2dlcigpIGRvZXNuJ3RcbiAgICAgIC8vIHRyaWdnZXIgbmF0aXZlIGV2ZW50cyBpbiBzb21lIGNhc2VzIGFuZCBzb21lIHBsdWdpbnNcbiAgICAgIC8vIHJlbHkgb24gJC50cmlnZ2VyKClcbiAgICAgIC8vXG4gICAgICAvLyBXZSB3YW50IHRvIG1ha2Ugc3VyZSBpZiBhIGxpc3RlbmVyIGlzIGF0dGFjaGVkIHVzaW5nXG4gICAgICAvLyBqUXVlcnksIGl0IGlzIGFsc28gcmVtb3ZlZCB3aXRoIGpRdWVyeSwgdGhhdCdzIHdoeVxuICAgICAgLy8gd2UgZG8gdGhlIGNoZWNrIGZvciBlYWNoIGRpcmVjdGl2ZSBpbnN0YW5jZSBhbmRcbiAgICAgIC8vIHN0b3JlIHRoYXQgY2hlY2sgcmVzdWx0IG9uIGl0c2VsZi4gVGhpcyBhbHNvIGFsbG93c1xuICAgICAgLy8gZWFzaWVyIHRlc3QgY292ZXJhZ2UgY29udHJvbCBieSB1bnNldHRpbmcgdGhlIGdsb2JhbFxuICAgICAgLy8galF1ZXJ5IHZhcmlhYmxlIGluIHRlc3RzLlxuICAgICAgdGhpcy5oYXNqUXVlcnkgPSB0eXBlb2YgalF1ZXJ5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgaWYgKHRoaXMuaGFzalF1ZXJ5KSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBqUXVlcnkuZm4ub24gPyAnb24nIDogJ2JpbmQnO1xuICAgICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2NoYW5nZScsIHRoaXMucmF3TGlzdGVuZXIpO1xuICAgICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2lucHV0JywgdGhpcy5saXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMucmF3TGlzdGVuZXIpO1xuICAgICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgICB0aGlzLm9uKCdpbnB1dCcsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElFOSBkb2Vzbid0IGZpcmUgaW5wdXQgZXZlbnQgb24gYmFja3NwYWNlL2RlbC9jdXRcbiAgICAgIGlmICghbGF6eSAmJiBpc0lFOSkge1xuICAgICAgICB0aGlzLm9uKCdjdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbmV4dFRpY2soc2VsZi5saXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCdrZXl1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gNDYgfHwgZS5rZXlDb2RlID09PSA4KSB7XG4gICAgICAgICAgICBzZWxmLmxpc3RlbmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGluaXRpYWwgdmFsdWUgaWYgcHJlc2VudFxuICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSB8fCBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmIGVsLnZhbHVlLnRyaW0oKSkge1xuICAgICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgICB0aGlzLmVsLnZhbHVlID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgaWYgKHRoaXMuaGFzalF1ZXJ5KSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBqUXVlcnkuZm4ub2ZmID8gJ29mZicgOiAndW5iaW5kJztcbiAgICAgICAgalF1ZXJ5KGVsKVttZXRob2RdKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgICAgalF1ZXJ5KGVsKVttZXRob2RdKCdpbnB1dCcsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcmFkaW8gPSB7XG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdmFsdWUgb3ZlcndyaXRlIHZpYSB2LWJpbmQ6dmFsdWVcbiAgICAgICAgaWYgKGVsLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSkge1xuICAgICAgICAgIHJldHVybiBlbC5fdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbCA9IGVsLnZhbHVlO1xuICAgICAgICBpZiAoc2VsZi5wYXJhbXMubnVtYmVyKSB7XG4gICAgICAgICAgdmFsID0gdG9OdW1iZXIodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5zZXQoc2VsZi5nZXRWYWx1ZSgpKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcblxuICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG4gICAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzZWxlY3QgPSB7XG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgICAgLy8gbWV0aG9kIHRvIGZvcmNlIHVwZGF0ZSBET00gdXNpbmcgbGF0ZXN0IHZhbHVlLlxuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYuX3dhdGNoZXIpIHtcbiAgICAgICAgICBzZWxmLnVwZGF0ZShzZWxmLl93YXRjaGVyLmdldCgpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIG11bHRpcGxlIHNlbGVjdFxuICAgICAgdmFyIG11bHRpcGxlID0gdGhpcy5tdWx0aXBsZSA9IGVsLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKTtcblxuICAgICAgLy8gYXR0YWNoIGxpc3RlbmVyXG4gICAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShlbCwgbXVsdGlwbGUpO1xuICAgICAgICB2YWx1ZSA9IHNlbGYucGFyYW1zLm51bWJlciA/IGlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKHRvTnVtYmVyKSA6IHRvTnVtYmVyKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICBzZWxmLnNldCh2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG5cbiAgICAgIC8vIGlmIGhhcyBpbml0aWFsIHZhbHVlLCBzZXQgYWZ0ZXJCaW5kXG4gICAgICB2YXIgaW5pdFZhbHVlID0gZ2V0VmFsdWUoZWwsIG11bHRpcGxlLCB0cnVlKTtcbiAgICAgIGlmIChtdWx0aXBsZSAmJiBpbml0VmFsdWUubGVuZ3RoIHx8ICFtdWx0aXBsZSAmJiBpbml0VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IEZpcmVmb3ggcmVzZXRzXG4gICAgICAvLyBzZWxlY3RlZEluZGV4IHdpdGggdmFsdWUgLTEgdG8gMCB3aGVuIHRoZSBlbGVtZW50XG4gICAgICAvLyBpcyBhcHBlbmRlZCB0byBhIG5ldyBwYXJlbnQsIHRoZXJlZm9yZSB3ZSBoYXZlIHRvXG4gICAgICAvLyBmb3JjZSBhIERPTSB1cGRhdGUgd2hlbmV2ZXIgdGhhdCBoYXBwZW5zLi4uXG4gICAgICB0aGlzLnZtLiRvbignaG9vazphdHRhY2hlZCcsIHRoaXMuZm9yY2VVcGRhdGUpO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgIHZhciBtdWx0aSA9IHRoaXMubXVsdGlwbGUgJiYgaXNBcnJheSh2YWx1ZSk7XG4gICAgICB2YXIgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gICAgICB2YXIgaSA9IG9wdGlvbnMubGVuZ3RoO1xuICAgICAgdmFyIG9wLCB2YWw7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIG9wID0gb3B0aW9uc1tpXTtcbiAgICAgICAgdmFsID0gb3AuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpID8gb3AuX3ZhbHVlIDogb3AudmFsdWU7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICAgICAgICBvcC5zZWxlY3RlZCA9IG11bHRpID8gaW5kZXhPZiQxKHZhbHVlLCB2YWwpID4gLTEgOiBsb29zZUVxdWFsKHZhbHVlLCB2YWwpO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB0aGlzLnZtLiRvZmYoJ2hvb2s6YXR0YWNoZWQnLCB0aGlzLmZvcmNlVXBkYXRlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBzZWxlY3QgdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHtTZWxlY3RFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG11bHRpXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICAgKiBAcmV0dXJuIHtBcnJheXwqfVxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRWYWx1ZShlbCwgbXVsdGksIGluaXQpIHtcbiAgICB2YXIgcmVzID0gbXVsdGkgPyBbXSA6IG51bGw7XG4gICAgdmFyIG9wLCB2YWwsIHNlbGVjdGVkO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG9wID0gZWwub3B0aW9uc1tpXTtcbiAgICAgIHNlbGVjdGVkID0gaW5pdCA/IG9wLmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSA6IG9wLnNlbGVjdGVkO1xuICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgIHZhbCA9IG9wLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSA/IG9wLl92YWx1ZSA6IG9wLnZhbHVlO1xuICAgICAgICBpZiAobXVsdGkpIHtcbiAgICAgICAgICByZXMucHVzaCh2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBOYXRpdmUgQXJyYXkuaW5kZXhPZiB1c2VzIHN0cmljdCBlcXVhbCwgYnV0IGluIHRoaXNcbiAgICogY2FzZSB3ZSBuZWVkIHRvIG1hdGNoIHN0cmluZy9udW1iZXJzIHdpdGggY3VzdG9tIGVxdWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICogQHBhcmFtIHsqfSB2YWxcbiAgICovXG5cbiAgZnVuY3Rpb24gaW5kZXhPZiQxKGFyciwgdmFsKSB7XG4gICAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdmFyIGNoZWNrYm94ID0ge1xuXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlbC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykgPyBlbC5fdmFsdWUgOiBzZWxmLnBhcmFtcy5udW1iZXIgPyB0b051bWJlcihlbC52YWx1ZSkgOiBlbC52YWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGdldEJvb2xlYW5WYWx1ZSgpIHtcbiAgICAgICAgdmFyIHZhbCA9IGVsLmNoZWNrZWQ7XG4gICAgICAgIGlmICh2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICAgIHJldHVybiBlbC5fdHJ1ZVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsICYmIGVsLmhhc093blByb3BlcnR5KCdfZmFsc2VWYWx1ZScpKSB7XG4gICAgICAgICAgcmV0dXJuIGVsLl9mYWxzZVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHNlbGYuX3dhdGNoZXIudmFsdWU7XG4gICAgICAgIGlmIChpc0FycmF5KG1vZGVsKSkge1xuICAgICAgICAgIHZhciB2YWwgPSBzZWxmLmdldFZhbHVlKCk7XG4gICAgICAgICAgaWYgKGVsLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleE9mKG1vZGVsLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgICBtb2RlbC5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZGVsLiRyZW1vdmUodmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5zZXQoZ2V0Qm9vbGVhblZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSBpbmRleE9mKHZhbHVlLCB0aGlzLmdldFZhbHVlKCkpID4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBlbC5fdHJ1ZVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbC5jaGVja2VkID0gISF2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlcnMgPSB7XG4gICAgdGV4dDogdGV4dCQyLFxuICAgIHJhZGlvOiByYWRpbyxcbiAgICBzZWxlY3Q6IHNlbGVjdCxcbiAgICBjaGVja2JveDogY2hlY2tib3hcbiAgfTtcblxuICB2YXIgbW9kZWwgPSB7XG5cbiAgICBwcmlvcml0eTogTU9ERUwsXG4gICAgdHdvV2F5OiB0cnVlLFxuICAgIGhhbmRsZXJzOiBoYW5kbGVycyxcbiAgICBwYXJhbXM6IFsnbGF6eScsICdudW1iZXInLCAnZGVib3VuY2UnXSxcblxuICAgIC8qKlxuICAgICAqIFBvc3NpYmxlIGVsZW1lbnRzOlxuICAgICAqICAgPHNlbGVjdD5cbiAgICAgKiAgIDx0ZXh0YXJlYT5cbiAgICAgKiAgIDxpbnB1dCB0eXBlPVwiKlwiPlxuICAgICAqICAgICAtIHRleHRcbiAgICAgKiAgICAgLSBjaGVja2JveFxuICAgICAqICAgICAtIHJhZGlvXG4gICAgICogICAgIC0gbnVtYmVyXG4gICAgICovXG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgLy8gZnJpZW5kbHkgd2FybmluZy4uLlxuICAgICAgdGhpcy5jaGVja0ZpbHRlcnMoKTtcbiAgICAgIGlmICh0aGlzLmhhc1JlYWQgJiYgIXRoaXMuaGFzV3JpdGUpIHtcbiAgICAgICAgJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgYSByZWFkLW9ubHkgZmlsdGVyIHdpdGggJyArICd2LW1vZGVsLiBZb3UgbWlnaHQgd2FudCB0byB1c2UgYSB0d28td2F5IGZpbHRlciAnICsgJ3RvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yLicpO1xuICAgICAgfVxuICAgICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAgIHZhciB0YWcgPSBlbC50YWdOYW1lO1xuICAgICAgdmFyIGhhbmRsZXI7XG4gICAgICBpZiAodGFnID09PSAnSU5QVVQnKSB7XG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyc1tlbC50eXBlXSB8fCBoYW5kbGVycy50ZXh0O1xuICAgICAgfSBlbHNlIGlmICh0YWcgPT09ICdTRUxFQ1QnKSB7XG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVycy5zZWxlY3Q7XG4gICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgICBoYW5kbGVyID0gaGFuZGxlcnMudGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LW1vZGVsIGRvZXMgbm90IHN1cHBvcnQgZWxlbWVudCB0eXBlOiAnICsgdGFnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWwuX192X21vZGVsID0gdGhpcztcbiAgICAgIGhhbmRsZXIuYmluZC5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy51cGRhdGUgPSBoYW5kbGVyLnVwZGF0ZTtcbiAgICAgIHRoaXMuX3VuYmluZCA9IGhhbmRsZXIudW5iaW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayByZWFkL3dyaXRlIGZpbHRlciBzdGF0cy5cbiAgICAgKi9cblxuICAgIGNoZWNrRmlsdGVyczogZnVuY3Rpb24gY2hlY2tGaWx0ZXJzKCkge1xuICAgICAgdmFyIGZpbHRlcnMgPSB0aGlzLmZpbHRlcnM7XG4gICAgICBpZiAoIWZpbHRlcnMpIHJldHVybjtcbiAgICAgIHZhciBpID0gZmlsdGVycy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBmaWx0ZXIgPSByZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBmaWx0ZXJzW2ldLm5hbWUpO1xuICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fCBmaWx0ZXIucmVhZCkge1xuICAgICAgICAgIHRoaXMuaGFzUmVhZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlci53cml0ZSkge1xuICAgICAgICAgIHRoaXMuaGFzV3JpdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgICAgdGhpcy5lbC5fX3ZfbW9kZWwgPSBudWxsO1xuICAgICAgdGhpcy5fdW5iaW5kICYmIHRoaXMuX3VuYmluZCgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBrZXlDb2RlIGFsaWFzZXNcbiAgdmFyIGtleUNvZGVzID0ge1xuICAgIGVzYzogMjcsXG4gICAgdGFiOiA5LFxuICAgIGVudGVyOiAxMyxcbiAgICBzcGFjZTogMzIsXG4gICAgJ2RlbGV0ZSc6IFs4LCA0Nl0sXG4gICAgdXA6IDM4LFxuICAgIGxlZnQ6IDM3LFxuICAgIHJpZ2h0OiAzOSxcbiAgICBkb3duOiA0MFxuICB9O1xuXG4gIGZ1bmN0aW9uIGtleUZpbHRlcihoYW5kbGVyLCBrZXlzKSB7XG4gICAgdmFyIGNvZGVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGNoYXJDb2RlID0ga2V5LmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoY2hhckNvZGUgPiA0NyAmJiBjaGFyQ29kZSA8IDU4KSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChrZXksIDEwKTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNoYXJDb2RlID0ga2V5LnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKGNoYXJDb2RlID4gNjQgJiYgY2hhckNvZGUgPCA5MSkge1xuICAgICAgICAgIHJldHVybiBjaGFyQ29kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGtleUNvZGVzW2tleV07XG4gICAgfSk7XG4gICAgY29kZXMgPSBbXS5jb25jYXQuYXBwbHkoW10sIGNvZGVzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ga2V5SGFuZGxlcihlKSB7XG4gICAgICBpZiAoY29kZXMuaW5kZXhPZihlLmtleUNvZGUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3RvcEZpbHRlcihoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BIYW5kbGVyKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwcmV2ZW50RmlsdGVyKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEhhbmRsZXIoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZkZpbHRlcihoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNlbGZIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBvbiQxID0ge1xuXG4gICAgcHJpb3JpdHk6IE9OLFxuICAgIGFjY2VwdFN0YXRlbWVudDogdHJ1ZSxcbiAgICBrZXlDb2Rlczoga2V5Q29kZXMsXG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgLy8gZGVhbCB3aXRoIGlmcmFtZXNcbiAgICAgIGlmICh0aGlzLmVsLnRhZ05hbWUgPT09ICdJRlJBTUUnICYmIHRoaXMuYXJnICE9PSAnbG9hZCcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmlmcmFtZUJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb24oc2VsZi5lbC5jb250ZW50V2luZG93LCBzZWxmLmFyZywgc2VsZi5oYW5kbGVyLCBzZWxmLm1vZGlmaWVycy5jYXB0dXJlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbignbG9hZCcsIHRoaXMuaWZyYW1lQmluZCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGhhbmRsZXIpIHtcbiAgICAgIC8vIHN0dWIgYSBub29wIGZvciB2LW9uIHdpdGggbm8gdmFsdWUsXG4gICAgICAvLyBlLmcuIEBtb3VzZWRvd24ucHJldmVudFxuICAgICAgaWYgKCF0aGlzLmRlc2NyaXB0b3IucmF3KSB7XG4gICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LW9uOicgKyB0aGlzLmFyZyArICc9XCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiIGV4cGVjdHMgYSBmdW5jdGlvbiB2YWx1ZSwgJyArICdnb3QgJyArIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IG1vZGlmaWVyc1xuICAgICAgaWYgKHRoaXMubW9kaWZpZXJzLnN0b3ApIHtcbiAgICAgICAgaGFuZGxlciA9IHN0b3BGaWx0ZXIoaGFuZGxlcik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tb2RpZmllcnMucHJldmVudCkge1xuICAgICAgICBoYW5kbGVyID0gcHJldmVudEZpbHRlcihoYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1vZGlmaWVycy5zZWxmKSB7XG4gICAgICAgIGhhbmRsZXIgPSBzZWxmRmlsdGVyKGhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgLy8ga2V5IGZpbHRlclxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm1vZGlmaWVycykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSAhPT0gJ3N0b3AnICYmIGtleSAhPT0gJ3ByZXZlbnQnICYmIGtleSAhPT0gJ3NlbGYnO1xuICAgICAgfSk7XG4gICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgaGFuZGxlciA9IGtleUZpbHRlcihoYW5kbGVyLCBrZXlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcblxuICAgICAgaWYgKHRoaXMuaWZyYW1lQmluZCkge1xuICAgICAgICB0aGlzLmlmcmFtZUJpbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uKHRoaXMuZWwsIHRoaXMuYXJnLCB0aGlzLmhhbmRsZXIsIHRoaXMubW9kaWZpZXJzLmNhcHR1cmUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmlmcmFtZUJpbmQgPyB0aGlzLmVsLmNvbnRlbnRXaW5kb3cgOiB0aGlzLmVsO1xuICAgICAgaWYgKHRoaXMuaGFuZGxlcikge1xuICAgICAgICBvZmYoZWwsIHRoaXMuYXJnLCB0aGlzLmhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctbXMtJ107XG4gIHZhciBjYW1lbFByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG4gIHZhciBpbXBvcnRhbnRSRSA9IC8haW1wb3J0YW50Oz8kLztcbiAgdmFyIHByb3BDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgdmFyIHRlc3RFbCA9IG51bGw7XG5cbiAgdmFyIHN0eWxlID0ge1xuXG4gICAgZGVlcDogdHJ1ZSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmVsLnN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUucmVkdWNlKGV4dGVuZCwge30pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlIHx8IHt9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlT2JqZWN0OiBmdW5jdGlvbiBoYW5kbGVPYmplY3QodmFsdWUpIHtcbiAgICAgIC8vIGNhY2hlIG9iamVjdCBzdHlsZXMgc28gdGhhdCBvbmx5IGNoYW5nZWQgcHJvcHNcbiAgICAgIC8vIGFyZSBhY3R1YWxseSB1cGRhdGVkLlxuICAgICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZSB8fCAodGhpcy5jYWNoZSA9IHt9KTtcbiAgICAgIHZhciBuYW1lLCB2YWw7XG4gICAgICBmb3IgKG5hbWUgaW4gY2FjaGUpIHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZShuYW1lLCBudWxsKTtcbiAgICAgICAgICBkZWxldGUgY2FjaGVbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICB2YWwgPSB2YWx1ZVtuYW1lXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gY2FjaGVbbmFtZV0pIHtcbiAgICAgICAgICBjYWNoZVtuYW1lXSA9IHZhbDtcbiAgICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZShuYW1lLCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZVNpbmdsZTogZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm9wID0gbm9ybWFsaXplKHByb3ApO1xuICAgICAgaWYgKCFwcm9wKSByZXR1cm47IC8vIHVuc3VwcG9ydGVkIHByb3BcbiAgICAgIC8vIGNhc3QgcG9zc2libGUgbnVtYmVycy9ib29sZWFucyBpbnRvIHN0cmluZ3NcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZSArPSAnJztcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgaXNJbXBvcnRhbnQgPSBpbXBvcnRhbnRSRS50ZXN0KHZhbHVlKSA/ICdpbXBvcnRhbnQnIDogJyc7XG4gICAgICAgIGlmIChpc0ltcG9ydGFudCkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIHZhbHVlLCBpc0ltcG9ydGFudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3ApO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYSBDU1MgcHJvcGVydHkgbmFtZS5cbiAgICogLSBjYWNoZSByZXN1bHRcbiAgICogLSBhdXRvIHByZWZpeFxuICAgKiAtIGNhbWVsQ2FzZSAtPiBkYXNoLWNhc2VcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBmdW5jdGlvbiBub3JtYWxpemUocHJvcCkge1xuICAgIGlmIChwcm9wQ2FjaGVbcHJvcF0pIHtcbiAgICAgIHJldHVybiBwcm9wQ2FjaGVbcHJvcF07XG4gICAgfVxuICAgIHZhciByZXMgPSBwcmVmaXgocHJvcCk7XG4gICAgcHJvcENhY2hlW3Byb3BdID0gcHJvcENhY2hlW3Jlc10gPSByZXM7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBdXRvIGRldGVjdCB0aGUgYXBwcm9wcmlhdGUgcHJlZml4IGZvciBhIENTUyBwcm9wZXJ0eS5cbiAgICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzUyMzY5MlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHByZWZpeChwcm9wKSB7XG4gICAgcHJvcCA9IGh5cGhlbmF0ZShwcm9wKTtcbiAgICB2YXIgY2FtZWwgPSBjYW1lbGl6ZShwcm9wKTtcbiAgICB2YXIgdXBwZXIgPSBjYW1lbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsLnNsaWNlKDEpO1xuICAgIGlmICghdGVzdEVsKSB7XG4gICAgICB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB9XG4gICAgdmFyIGkgPSBwcmVmaXhlcy5sZW5ndGg7XG4gICAgdmFyIHByZWZpeGVkO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHByZWZpeGVkID0gY2FtZWxQcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgICByZXR1cm4gcHJlZml4ZXNbaV0gKyBwcm9wO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2FtZWwgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9XG4gIH1cblxuICAvLyB4bGlua1xuICB2YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbiAgdmFyIHhsaW5rUkUgPSAvXnhsaW5rOi87XG5cbiAgLy8gY2hlY2sgZm9yIGF0dHJpYnV0ZXMgdGhhdCBwcm9oaWJpdCBpbnRlcnBvbGF0aW9uc1xuICB2YXIgZGlzYWxsb3dlZEludGVycEF0dHJSRSA9IC9edi18Xjp8XkB8Xig/OmlzfHRyYW5zaXRpb258dHJhbnNpdGlvbi1tb2RlfGRlYm91bmNlfHRyYWNrLWJ5fHN0YWdnZXJ8ZW50ZXItc3RhZ2dlcnxsZWF2ZS1zdGFnZ2VyKSQvO1xuICAvLyB0aGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBhbHNvIHNldCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXNcbiAgLy8gYmVjYXVzZSB0aGV5IG9ubHkgYWZmZWN0IHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBlbGVtZW50XG4gIHZhciBhdHRyV2l0aFByb3BzUkUgPSAvXig/OnZhbHVlfGNoZWNrZWR8c2VsZWN0ZWR8bXV0ZWQpJC87XG4gIC8vIHRoZXNlIGF0dHJpYnV0ZXMgZXhwZWN0IGVudW1yYXRlZCB2YWx1ZXMgb2YgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiXG4gIC8vIGJ1dCBhcmUgbm90IGJvb2xlYW4gYXR0cmlidXRlc1xuICB2YXIgZW51bWVyYXRlZEF0dHJSRSA9IC9eKD86ZHJhZ2dhYmxlfGNvbnRlbnRlZGl0YWJsZXxzcGVsbGNoZWNrKSQvO1xuXG4gIC8vIHRoZXNlIGF0dHJpYnV0ZXMgc2hvdWxkIHNldCBhIGhpZGRlbiBwcm9wZXJ0eSBmb3JcbiAgLy8gYmluZGluZyB2LW1vZGVsIHRvIG9iamVjdCB2YWx1ZXNcbiAgdmFyIG1vZGVsUHJvcHMgPSB7XG4gICAgdmFsdWU6ICdfdmFsdWUnLFxuICAgICd0cnVlLXZhbHVlJzogJ190cnVlVmFsdWUnLFxuICAgICdmYWxzZS12YWx1ZSc6ICdfZmFsc2VWYWx1ZSdcbiAgfTtcblxuICB2YXIgYmluZCQxID0ge1xuXG4gICAgcHJpb3JpdHk6IEJJTkQsXG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgdmFyIGF0dHIgPSB0aGlzLmFyZztcbiAgICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgICAvLyBzaG91bGQgYmUgZGVlcCB3YXRjaCBvbiBvYmplY3QgbW9kZVxuICAgICAgaWYgKCFhdHRyKSB7XG4gICAgICAgIHRoaXMuZGVlcCA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyBoYW5kbGUgaW50ZXJwb2xhdGlvbiBiaW5kaW5nc1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSB0aGlzLmRlc2NyaXB0b3I7XG4gICAgICB2YXIgdG9rZW5zID0gZGVzY3JpcHRvci5pbnRlcnA7XG4gICAgICBpZiAodG9rZW5zKSB7XG4gICAgICAgIC8vIGhhbmRsZSBpbnRlcnBvbGF0aW9ucyB3aXRoIG9uZS10aW1lIHRva2Vuc1xuICAgICAgICBpZiAoZGVzY3JpcHRvci5oYXNPbmVUaW1lKSB7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gdG9rZW5zVG9FeHAodG9rZW5zLCB0aGlzLl9zY29wZSB8fCB0aGlzLnZtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgYWxsb3cgYmluZGluZyBvbiBuYXRpdmUgYXR0cmlidXRlc1xuICAgICAgICBpZiAoZGlzYWxsb3dlZEludGVycEF0dHJSRS50ZXN0KGF0dHIpIHx8IGF0dHIgPT09ICduYW1lJyAmJiAodGFnID09PSAnUEFSVElBTCcgfHwgdGFnID09PSAnU0xPVCcpKSB7XG4gICAgICAgICAgJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oYXR0ciArICc9XCInICsgZGVzY3JpcHRvci5yYXcgKyAnXCI6ICcgKyAnYXR0cmlidXRlIGludGVycG9sYXRpb24gaXMgbm90IGFsbG93ZWQgaW4gVnVlLmpzICcgKyAnZGlyZWN0aXZlcyBhbmQgc3BlY2lhbCBhdHRyaWJ1dGVzLicpO1xuICAgICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciByYXcgPSBhdHRyICsgJz1cIicgKyBkZXNjcmlwdG9yLnJhdyArICdcIjogJztcbiAgICAgICAgICAvLyB3YXJuIHNyY1xuICAgICAgICAgIGlmIChhdHRyID09PSAnc3JjJykge1xuICAgICAgICAgICAgd2FybihyYXcgKyAnaW50ZXJwb2xhdGlvbiBpbiBcInNyY1wiIGF0dHJpYnV0ZSB3aWxsIGNhdXNlICcgKyAnYSA0MDQgcmVxdWVzdC4gVXNlIHYtYmluZDpzcmMgaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB3YXJuIHN0eWxlXG4gICAgICAgICAgaWYgKGF0dHIgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIHdhcm4ocmF3ICsgJ2ludGVycG9sYXRpb24gaW4gXCJzdHlsZVwiIGF0dHJpYnV0ZSB3aWxsIGNhdXNlICcgKyAndGhlIGF0dHJpYnV0ZSB0byBiZSBkaXNjYXJkZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIuICcgKyAnVXNlIHYtYmluZDpzdHlsZSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYXR0ciA9IHRoaXMuYXJnO1xuICAgICAgaWYgKHRoaXMuYXJnKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2luZ2xlKGF0dHIsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlIHx8IHt9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gc2hhcmUgb2JqZWN0IGhhbmRsZXIgd2l0aCB2LWJpbmQ6Y2xhc3NcbiAgICBoYW5kbGVPYmplY3Q6IHN0eWxlLmhhbmRsZU9iamVjdCxcblxuICAgIGhhbmRsZVNpbmdsZTogZnVuY3Rpb24gaGFuZGxlU2luZ2xlKGF0dHIsIHZhbHVlKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgdmFyIGludGVycCA9IHRoaXMuZGVzY3JpcHRvci5pbnRlcnA7XG4gICAgICBpZiAodGhpcy5tb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgICAgYXR0ciA9IGNhbWVsaXplKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKCFpbnRlcnAgJiYgYXR0cldpdGhQcm9wc1JFLnRlc3QoYXR0cikgJiYgYXR0ciBpbiBlbCkge1xuICAgICAgICBlbFthdHRyXSA9IGF0dHIgPT09ICd2YWx1ZScgPyB2YWx1ZSA9PSBudWxsIC8vIElFOSB3aWxsIHNldCBpbnB1dC52YWx1ZSB0byBcIm51bGxcIiBmb3IgbnVsbC4uLlxuICAgICAgICA/ICcnIDogdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCBtb2RlbCBwcm9wc1xuICAgICAgdmFyIG1vZGVsUHJvcCA9IG1vZGVsUHJvcHNbYXR0cl07XG4gICAgICBpZiAoIWludGVycCAmJiBtb2RlbFByb3ApIHtcbiAgICAgICAgZWxbbW9kZWxQcm9wXSA9IHZhbHVlO1xuICAgICAgICAvLyB1cGRhdGUgdi1tb2RlbCBpZiBwcmVzZW50XG4gICAgICAgIHZhciBtb2RlbCA9IGVsLl9fdl9tb2RlbDtcbiAgICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgICAgbW9kZWwubGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZG8gbm90IHNldCB2YWx1ZSBhdHRyaWJ1dGUgZm9yIHRleHRhcmVhXG4gICAgICBpZiAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gdXBkYXRlIGF0dHJpYnV0ZVxuICAgICAgaWYgKGVudW1lcmF0ZWRBdHRyUkUudGVzdChhdHRyKSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGF0dHIgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAvLyBoYW5kbGUgZWRnZSBjYXNlICMxOTYwOlxuICAgICAgICAgIC8vIGNsYXNzIGludGVycG9sYXRpb24gc2hvdWxkIG5vdCBvdmVyd3JpdGUgVnVlIHRyYW5zaXRpb24gY2xhc3NcbiAgICAgICAgICBpZiAoZWwuX192X3RyYW5zKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSAnICcgKyBlbC5fX3ZfdHJhbnMuaWQgKyAnLXRyYW5zaXRpb24nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRDbGFzcyhlbCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHhsaW5rUkUudGVzdChhdHRyKSkge1xuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGF0dHIsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGVsID0ge1xuXG4gICAgcHJpb3JpdHk6IEVMLFxuXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCF0aGlzLmFyZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaWQgPSB0aGlzLmlkID0gY2FtZWxpemUodGhpcy5hcmcpO1xuICAgICAgdmFyIHJlZnMgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJGVscztcbiAgICAgIGlmIChoYXNPd24ocmVmcywgaWQpKSB7XG4gICAgICAgIHJlZnNbaWRdID0gdGhpcy5lbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHJlZnMsIGlkLCB0aGlzLmVsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kZWxzO1xuICAgICAgaWYgKHJlZnNbdGhpcy5pZF0gPT09IHRoaXMuZWwpIHtcbiAgICAgICAgcmVmc1t0aGlzLmlkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciByZWYgPSB7XG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgICdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LXJlZjonICsgdGhpcy5hcmcgKyAnIG11c3QgYmUgdXNlZCBvbiBhIGNoaWxkICcgKyAnY29tcG9uZW50LiBGb3VuZCBvbiA8JyArIHRoaXMuZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgJz4uJyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjbG9hayA9IHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAgIHRoaXMudm0uJG9uY2UoJ3ByZS1ob29rOmNvbXBpbGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3YtY2xvYWsnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBtdXN0IGV4cG9ydCBwbGFpbiBvYmplY3RcbiAgdmFyIGRpcmVjdGl2ZXMgPSB7XG4gICAgdGV4dDogdGV4dCQxLFxuICAgIGh0bWw6IGh0bWwsXG4gICAgJ2Zvcic6IHZGb3IsXG4gICAgJ2lmJzogdklmLFxuICAgIHNob3c6IHNob3csXG4gICAgbW9kZWw6IG1vZGVsLFxuICAgIG9uOiBvbiQxLFxuICAgIGJpbmQ6IGJpbmQkMSxcbiAgICBlbDogZWwsXG4gICAgcmVmOiByZWYsXG4gICAgY2xvYWs6IGNsb2FrXG4gIH07XG5cbiAgdmFyIHZDbGFzcyA9IHtcblxuICAgIGRlZXA6IHRydWUsXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVPYmplY3Qoc3RyaW5nVG9PYmplY3QodmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aGlzLmhhbmRsZUFycmF5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVPYmplY3Q6IGZ1bmN0aW9uIGhhbmRsZU9iamVjdCh2YWx1ZSkge1xuICAgICAgdGhpcy5jbGVhbnVwKHZhbHVlKTtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5wcmV2S2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy5lbCwga2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZUFycmF5OiBmdW5jdGlvbiBoYW5kbGVBcnJheSh2YWx1ZSkge1xuICAgICAgdGhpcy5jbGVhbnVwKHZhbHVlKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICh2YWx1ZVtpXSkge1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMuZWwsIHZhbHVlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wcmV2S2V5cyA9IHZhbHVlLnNsaWNlKCk7XG4gICAgfSxcblxuICAgIGNsZWFudXA6IGZ1bmN0aW9uIGNsZWFudXAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLnByZXZLZXlzKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5wcmV2S2V5cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICB2YXIga2V5ID0gdGhpcy5wcmV2S2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ICYmICghdmFsdWUgfHwgIWNvbnRhaW5zKHZhbHVlLCBrZXkpKSkge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwga2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gc3RyaW5nVG9PYmplY3QodmFsdWUpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGtleXMgPSB2YWx1ZS50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHJlc1trZXlzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb250YWlucyh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUuaW5kZXhPZihrZXkpID4gLTEgOiBoYXNPd24odmFsdWUsIGtleSk7XG4gIH1cblxuICB2YXIgY29tcG9uZW50ID0ge1xuXG4gICAgcHJpb3JpdHk6IENPTVBPTkVOVCxcblxuICAgIHBhcmFtczogWydrZWVwLWFsaXZlJywgJ3RyYW5zaXRpb24tbW9kZScsICdpbmxpbmUtdGVtcGxhdGUnXSxcblxuICAgIC8qKlxuICAgICAqIFNldHVwLiBUd28gcG9zc2libGUgdXNhZ2VzOlxuICAgICAqXG4gICAgICogLSBzdGF0aWM6XG4gICAgICogICA8Y29tcD4gb3IgPGRpdiB2LWNvbXBvbmVudD1cImNvbXBcIj5cbiAgICAgKlxuICAgICAqIC0gZHluYW1pYzpcbiAgICAgKiAgIDxjb21wb25lbnQgOmlzPVwidmlld1wiPlxuICAgICAqL1xuXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIGlmICghdGhpcy5lbC5fX3Z1ZV9fKSB7XG4gICAgICAgIC8vIGtlZXAtYWxpdmUgY2FjaGVcbiAgICAgICAgdGhpcy5rZWVwQWxpdmUgPSB0aGlzLnBhcmFtcy5rZWVwQWxpdmU7XG4gICAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGVcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmlubGluZVRlbXBsYXRlKSB7XG4gICAgICAgICAgLy8gZXh0cmFjdCBpbmxpbmUgdGVtcGxhdGUgYXMgYSBEb2N1bWVudEZyYWdtZW50XG4gICAgICAgICAgdGhpcy5pbmxpbmVUZW1wbGF0ZSA9IGV4dHJhY3RDb250ZW50KHRoaXMuZWwsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXBvbmVudCByZXNvbHV0aW9uIHJlbGF0ZWQgc3RhdGVcbiAgICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSB0aGlzLkNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIC8vIHRyYW5zaXRpb24gcmVsYXRlZCBzdGF0ZVxuICAgICAgICB0aGlzLnBlbmRpbmdSZW1vdmFscyA9IDA7XG4gICAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxDYiA9IG51bGw7XG4gICAgICAgIC8vIGNyZWF0ZSBhIHJlZiBhbmNob3JcbiAgICAgICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtY29tcG9uZW50Jyk7XG4gICAgICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgICAgICAvLyByZW1vdmUgaXMgYXR0cmlidXRlLlxuICAgICAgICAvLyB0aGlzIGlzIHJlbW92ZWQgZHVyaW5nIGNvbXBpbGF0aW9uLCBidXQgYmVjYXVzZSBjb21waWxhdGlvbiBpc1xuICAgICAgICAvLyBjYWNoZWQsIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB1c2VkIGVsc2V3aGVyZSB0aGlzIGF0dHJpYnV0ZVxuICAgICAgICAvLyB3aWxsIHJlbWFpbiBhdCBsaW5rIHRpbWUuXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdpcycpO1xuICAgICAgICAvLyByZW1vdmUgcmVmLCBzYW1lIGFzIGFib3ZlXG4gICAgICAgIGlmICh0aGlzLmRlc2NyaXB0b3IucmVmKSB7XG4gICAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ3YtcmVmOicgKyBoeXBoZW5hdGUodGhpcy5kZXNjcmlwdG9yLnJlZikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHN0YXRpYywgYnVpbGQgcmlnaHQgbm93LlxuICAgICAgICBpZiAodGhpcy5saXRlcmFsKSB7XG4gICAgICAgICAgdGhpcy5zZXRDb21wb25lbnQodGhpcy5leHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ2Nhbm5vdCBtb3VudCBjb21wb25lbnQgXCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiICcgKyAnb24gYWxyZWFkeSBtb3VudGVkIGVsZW1lbnQ6ICcgKyB0aGlzLmVsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHVibGljIHVwZGF0ZSwgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyIGluIHRoZSBkeW5hbWljXG4gICAgICogbGl0ZXJhbCBzY2VuYXJpbywgZS5nLiA8Y29tcG9uZW50IDppcz1cInZpZXdcIj5cbiAgICAgKi9cblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMubGl0ZXJhbCkge1xuICAgICAgICB0aGlzLnNldENvbXBvbmVudCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN3aXRjaCBkeW5hbWljIGNvbXBvbmVudHMuIE1heSByZXNvbHZlIHRoZSBjb21wb25lbnRcbiAgICAgKiBhc3luY2hyb25vdXNseSwgYW5kIHBlcmZvcm0gdHJhbnNpdGlvbiBiYXNlZCBvblxuICAgICAqIHNwZWNpZmllZCB0cmFuc2l0aW9uIG1vZGUuIEFjY2VwdHMgYSBmZXcgYWRkaXRpb25hbFxuICAgICAqIGFyZ3VtZW50cyBzcGVjaWZpY2FsbHkgZm9yIHZ1ZS1yb3V0ZXIuXG4gICAgICpcbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIGZ1bGwgdHJhbnNpdGlvbiBpc1xuICAgICAqIGZpbmlzaGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgICAqL1xuXG4gICAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiBzZXRDb21wb25lbnQodmFsdWUsIGNiKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGVQZW5kaW5nKCk7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIC8vIGp1c3QgcmVtb3ZlIGN1cnJlbnRcbiAgICAgICAgdGhpcy51bmJ1aWxkKHRydWUpO1xuICAgICAgICB0aGlzLnJlbW92ZSh0aGlzLmNoaWxkVk0sIGNiKTtcbiAgICAgICAgdGhpcy5jaGlsZFZNID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNvbHZlQ29tcG9uZW50KHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5tb3VudENvbXBvbmVudChjYik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IgdG8gdXNlIHdoZW4gY3JlYXRpbmdcbiAgICAgKiB0aGUgY2hpbGQgdm0uXG4gICAgICovXG5cbiAgICByZXNvbHZlQ29tcG9uZW50OiBmdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KGlkLCBjYikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gICAgICAgIHNlbGYuQ29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5vcHRpb25zLm5hbWUgfHwgaWQ7XG4gICAgICAgIHNlbGYuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgICAgICBjYigpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnZtLl9yZXNvbHZlQ29tcG9uZW50KGlkLCB0aGlzLnBlbmRpbmdDb21wb25lbnRDYik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSB1c2luZyB0aGUgY3VycmVudCBjb25zdHJ1Y3RvciBhbmRcbiAgICAgKiByZXBsYWNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS4gVGhpcyBtZXRob2QgZG9lc24ndCBjYXJlXG4gICAgICogd2hldGhlciB0aGUgbmV3IGNvbXBvbmVudCBhbmQgdGhlIG9sZCBvbmUgYXJlIGFjdHVhbGx5XG4gICAgICogdGhlIHNhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAgICovXG5cbiAgICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gbW91bnRDb21wb25lbnQoY2IpIHtcbiAgICAgIC8vIGFjdHVhbCBtb3VudFxuICAgICAgdGhpcy51bmJ1aWxkKHRydWUpO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFjdGl2YXRlSG9va3MgPSB0aGlzLkNvbXBvbmVudC5vcHRpb25zLmFjdGl2YXRlO1xuICAgICAgdmFyIGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGVkKCk7XG4gICAgICB2YXIgbmV3Q29tcG9uZW50ID0gdGhpcy5idWlsZCgpO1xuICAgICAgaWYgKGFjdGl2YXRlSG9va3MgJiYgIWNhY2hlZCkge1xuICAgICAgICB0aGlzLndhaXRpbmdGb3IgPSBuZXdDb21wb25lbnQ7XG4gICAgICAgIGNhbGxBY3RpdmF0ZUhvb2tzKGFjdGl2YXRlSG9va3MsIG5ld0NvbXBvbmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChzZWxmLndhaXRpbmdGb3IgIT09IG5ld0NvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLndhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgICAgIHNlbGYudHJhbnNpdGlvbihuZXdDb21wb25lbnQsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgcmVmIGZvciBrZXB0LWFsaXZlIGNvbXBvbmVudFxuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgbmV3Q29tcG9uZW50Ll91cGRhdGVSZWYoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zaXRpb24obmV3Q29tcG9uZW50LCBjYik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIGNvbXBvbmVudCBjaGFuZ2VzIG9yIHVuYmluZHMgYmVmb3JlIGFuIGFzeW5jXG4gICAgICogY29uc3RydWN0b3IgaXMgcmVzb2x2ZWQsIHdlIG5lZWQgdG8gaW52YWxpZGF0ZSBpdHNcbiAgICAgKiBwZW5kaW5nIGNhbGxiYWNrLlxuICAgICAqL1xuXG4gICAgaW52YWxpZGF0ZVBlbmRpbmc6IGZ1bmN0aW9uIGludmFsaWRhdGVQZW5kaW5nKCkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ0NvbXBvbmVudENiKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlL2luc2VydCBhIG5ldyBjaGlsZCB2bS5cbiAgICAgKiBJZiBrZWVwIGFsaXZlIGFuZCBoYXMgY2FjaGVkIGluc3RhbmNlLCBpbnNlcnQgdGhhdFxuICAgICAqIGluc3RhbmNlOyBvdGhlcndpc2UgYnVpbGQgYSBuZXcgb25lIGFuZCBjYWNoZSBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0cmFPcHRpb25zXVxuICAgICAqIEByZXR1cm4ge1Z1ZX0gLSB0aGUgY3JlYXRlZCBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKGV4dHJhT3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGVkKCk7XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5Db21wb25lbnQpIHtcbiAgICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIG5hbWU6IHRoaXMuQ29tcG9uZW50TmFtZSxcbiAgICAgICAgICBlbDogY2xvbmVOb2RlKHRoaXMuZWwpLFxuICAgICAgICAgIHRlbXBsYXRlOiB0aGlzLmlubGluZVRlbXBsYXRlLFxuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byBhZGQgdGhlIGNoaWxkIHdpdGggY29ycmVjdCBwYXJlbnRcbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBpdHMgcGFyZW50XG4gICAgICAgICAgLy8gc2hvdWxkIGJlIHRoZSB0cmFuc2NsdXNpb24gaG9zdC5cbiAgICAgICAgICBwYXJlbnQ6IHRoaXMuX2hvc3QgfHwgdGhpcy52bSxcbiAgICAgICAgICAvLyBpZiBubyBpbmxpbmUtdGVtcGxhdGUsIHRoZW4gdGhlIGNvbXBpbGVkXG4gICAgICAgICAgLy8gbGlua2VyIGNhbiBiZSBjYWNoZWQgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICAgICAgICBfbGlua2VyQ2FjaGFibGU6ICF0aGlzLmlubGluZVRlbXBsYXRlLFxuICAgICAgICAgIF9yZWY6IHRoaXMuZGVzY3JpcHRvci5yZWYsXG4gICAgICAgICAgX2FzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgICAgIF9pc1JvdXRlclZpZXc6IHRoaXMuX2lzUm91dGVyVmlldyxcbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBjb250ZXh0XG4gICAgICAgICAgLy8gd2lsbCBiZSB0aGUgY29tbW9uIHBhcmVudCB2bSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICAgICAgLy8gYW5kIGl0cyBob3N0LlxuICAgICAgICAgIF9jb250ZXh0OiB0aGlzLnZtLFxuICAgICAgICAgIC8vIGlmIHRoaXMgaXMgaW5zaWRlIGFuIGlubGluZSB2LWZvciwgdGhlIHNjb3BlXG4gICAgICAgICAgLy8gd2lsbCBiZSB0aGUgaW50ZXJtZWRpYXRlIHNjb3BlIGNyZWF0ZWQgZm9yIHRoaXNcbiAgICAgICAgICAvLyByZXBlYXQgZnJhZ21lbnQuIHRoaXMgaXMgdXNlZCBmb3IgbGlua2luZyBwcm9wc1xuICAgICAgICAgIC8vIGFuZCBjb250YWluZXIgZGlyZWN0aXZlcy5cbiAgICAgICAgICBfc2NvcGU6IHRoaXMuX3Njb3BlLFxuICAgICAgICAgIC8vIHBhc3MgaW4gdGhlIG93bmVyIGZyYWdtZW50IG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IHNvIHRoYXQgdGhlIGZyYWdtZW50IGNhbiBrZWVwXG4gICAgICAgICAgLy8gdHJhY2sgb2YgaXRzIGNvbnRhaW5lZCBjb21wb25lbnRzIGluIG9yZGVyIHRvXG4gICAgICAgICAgLy8gY2FsbCBhdHRhY2gvZGV0YWNoIGhvb2tzIGZvciB0aGVtLlxuICAgICAgICAgIF9mcmFnOiB0aGlzLl9mcmFnXG4gICAgICAgIH07XG4gICAgICAgIC8vIGV4dHJhIG9wdGlvbnNcbiAgICAgICAgLy8gaW4gMS4wLjAgdGhpcyBpcyB1c2VkIGJ5IHZ1ZS1yb3V0ZXIgb25seVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGV4dHJhT3B0aW9ucykge1xuICAgICAgICAgIGV4dGVuZChvcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZCA9IG5ldyB0aGlzLkNvbXBvbmVudChvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgICAgdGhpcy5jYWNoZVt0aGlzLkNvbXBvbmVudC5jaWRdID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy5lbC5oYXNBdHRyaWJ1dGUoJ3RyYW5zaXRpb24nKSAmJiBjaGlsZC5faXNGcmFnbWVudCkge1xuICAgICAgICAgIHdhcm4oJ1RyYW5zaXRpb25zIHdpbGwgbm90IHdvcmsgb24gYSBmcmFnbWVudCBpbnN0YW5jZS4gJyArICdUZW1wbGF0ZTogJyArIGNoaWxkLiRvcHRpb25zLnRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyeSB0byBnZXQgYSBjYWNoZWQgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7VnVlfHVuZGVmaW5lZH1cbiAgICAgKi9cblxuICAgIGdldENhY2hlZDogZnVuY3Rpb24gZ2V0Q2FjaGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMua2VlcEFsaXZlICYmIHRoaXMuY2FjaGVbdGhpcy5Db21wb25lbnQuY2lkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGVhcmRvd24gdGhlIGN1cnJlbnQgY2hpbGQsIGJ1dCBkZWZlcnMgY2xlYW51cCBzb1xuICAgICAqIHRoYXQgd2UgY2FuIHNlcGFyYXRlIHRoZSBkZXN0cm95IGFuZCByZW1vdmFsIHN0ZXBzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkZWZlclxuICAgICAqL1xuXG4gICAgdW5idWlsZDogZnVuY3Rpb24gdW5idWlsZChkZWZlcikge1xuICAgICAgaWYgKHRoaXMud2FpdGluZ0Zvcikge1xuICAgICAgICB0aGlzLndhaXRpbmdGb3IuJGRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy53YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRWTTtcbiAgICAgIGlmICghY2hpbGQgfHwgdGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHJlZlxuICAgICAgICAgIGNoaWxkLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgY2hpbGQuX3VwZGF0ZVJlZih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyB0aGUgc29sZSBwdXJwb3NlIG9mIGBkZWZlckNsZWFudXBgIGlzIHNvIHRoYXQgd2UgY2FuXG4gICAgICAvLyBcImRlYWN0aXZhdGVcIiB0aGUgdm0gcmlnaHQgbm93IGFuZCBwZXJmb3JtIERPTSByZW1vdmFsXG4gICAgICAvLyBsYXRlci5cbiAgICAgIGNoaWxkLiRkZXN0cm95KGZhbHNlLCBkZWZlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBjdXJyZW50IGRlc3Ryb3llZCBjaGlsZCBhbmQgbWFudWFsbHkgZG9cbiAgICAgKiB0aGUgY2xlYW51cCBhZnRlciByZW1vdmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKi9cblxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNoaWxkLCBjYikge1xuICAgICAgdmFyIGtlZXBBbGl2ZSA9IHRoaXMua2VlcEFsaXZlO1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIC8vIHdlIG1heSBoYXZlIGEgY29tcG9uZW50IHN3aXRjaCB3aGVuIGEgcHJldmlvdXNcbiAgICAgICAgLy8gY29tcG9uZW50IGlzIHN0aWxsIGJlaW5nIHRyYW5zaXRpb25lZCBvdXQuXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gdHJpZ2dlciBvbmx5IG9uZSBsYXN0ZXN0IGluc2VydGlvbiBjYlxuICAgICAgICAvLyB3aGVuIHRoZSBleGlzdGluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLiAoIzExMTkpXG4gICAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxzKys7XG4gICAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxDYiA9IGNiO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNoaWxkLiRyZW1vdmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYucGVuZGluZ1JlbW92YWxzLS07XG4gICAgICAgICAgaWYgKCFrZWVwQWxpdmUpIGNoaWxkLl9jbGVhbnVwKCk7XG4gICAgICAgICAgaWYgKCFzZWxmLnBlbmRpbmdSZW1vdmFscyAmJiBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IpIHtcbiAgICAgICAgICAgIHNlbGYucGVuZGluZ1JlbW92YWxDYigpO1xuICAgICAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbENiID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBY3R1YWxseSBzd2FwIHRoZSBjb21wb25lbnRzLCBkZXBlbmRpbmcgb24gdGhlXG4gICAgICogdHJhbnNpdGlvbiBtb2RlLiBEZWZhdWx0cyB0byBzaW11bHRhbmVvdXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Z1ZX0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgICAqL1xuXG4gICAgdHJhbnNpdGlvbjogZnVuY3Rpb24gdHJhbnNpdGlvbih0YXJnZXQsIGNiKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuY2hpbGRWTTtcbiAgICAgIC8vIGZvciBkZXZ0b29sIGluc3BlY3Rpb25cbiAgICAgIGlmIChjdXJyZW50KSBjdXJyZW50Ll9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICB0YXJnZXQuX2luYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLmNoaWxkVk0gPSB0YXJnZXQ7XG4gICAgICBzd2l0Y2ggKHNlbGYucGFyYW1zLnRyYW5zaXRpb25Nb2RlKSB7XG4gICAgICAgIGNhc2UgJ2luLW91dCc6XG4gICAgICAgICAgdGFyZ2V0LiRiZWZvcmUoc2VsZi5hbmNob3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQsIGNiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb3V0LWluJzpcbiAgICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgY2IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQpO1xuICAgICAgICAgIHRhcmdldC4kYmVmb3JlKHNlbGYuYW5jaG9yLCBjYik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuYmluZC5cbiAgICAgKi9cblxuICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlUGVuZGluZygpO1xuICAgICAgLy8gRG8gbm90IGRlZmVyIGNsZWFudXAgd2hlbiB1bmJpbmRpbmdcbiAgICAgIHRoaXMudW5idWlsZCgpO1xuICAgICAgLy8gZGVzdHJveSBhbGwga2VlcC1hbGl2ZSBjYWNoZWQgaW5zdGFuY2VzXG4gICAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgICAgIHRoaXMuY2FjaGVba2V5XS4kZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCBhY3RpdmF0ZSBob29rcyBpbiBvcmRlciAoYXN5bmNocm9ub3VzKVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBob29rc1xuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgZnVuY3Rpb24gY2FsbEFjdGl2YXRlSG9va3MoaG9va3MsIHZtLCBjYikge1xuICAgIHZhciB0b3RhbCA9IGhvb2tzLmxlbmd0aDtcbiAgICB2YXIgY2FsbGVkID0gMDtcbiAgICBob29rc1swXS5jYWxsKHZtLCBuZXh0KTtcbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaWYgKCsrY2FsbGVkID49IHRvdGFsKSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob29rc1tjYWxsZWRdLmNhbGwodm0sIG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBiaW5kaW5nTW9kZXMgPSBjb25maWcuX3Byb3BCaW5kaW5nTW9kZXM7XG5cbiAgdmFyIHByb3BEZWYgPSB7XG5cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy52bTtcbiAgICAgIHZhciBwYXJlbnQgPSBjaGlsZC5fY29udGV4dDtcbiAgICAgIC8vIHBhc3NlZCBpbiBmcm9tIGNvbXBpbGVyIGRpcmVjdGx5XG4gICAgICB2YXIgcHJvcCA9IHRoaXMuZGVzY3JpcHRvci5wcm9wO1xuICAgICAgdmFyIGNoaWxkS2V5ID0gcHJvcC5wYXRoO1xuICAgICAgdmFyIHBhcmVudEtleSA9IHByb3AucGFyZW50UGF0aDtcbiAgICAgIHZhciB0d29XYXkgPSBwcm9wLm1vZGUgPT09IGJpbmRpbmdNb2Rlcy5UV09fV0FZO1xuXG4gICAgICB2YXIgcGFyZW50V2F0Y2hlciA9IHRoaXMucGFyZW50V2F0Y2hlciA9IG5ldyBXYXRjaGVyKHBhcmVudCwgcGFyZW50S2V5LCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhbCA9IGNvZXJjZVByb3AocHJvcCwgdmFsKTtcbiAgICAgICAgaWYgKGFzc2VydFByb3AocHJvcCwgdmFsKSkge1xuICAgICAgICAgIGNoaWxkW2NoaWxkS2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0d29XYXk6IHR3b1dheSxcbiAgICAgICAgZmlsdGVyczogcHJvcC5maWx0ZXJzLFxuICAgICAgICAvLyBpbXBvcnRhbnQ6IHByb3BzIG5lZWQgdG8gYmUgb2JzZXJ2ZWQgb24gdGhlXG4gICAgICAgIC8vIHYtZm9yIHNjb3BlIGlmIHByZXNlbnRcbiAgICAgICAgc2NvcGU6IHRoaXMuX3Njb3BlXG4gICAgICB9KTtcblxuICAgICAgLy8gc2V0IHRoZSBjaGlsZCBpbml0aWFsIHZhbHVlLlxuICAgICAgaW5pdFByb3AoY2hpbGQsIHByb3AsIHBhcmVudFdhdGNoZXIudmFsdWUpO1xuXG4gICAgICAvLyBzZXR1cCB0d28td2F5IGJpbmRpbmdcbiAgICAgIGlmICh0d29XYXkpIHtcbiAgICAgICAgLy8gaW1wb3J0YW50OiBkZWZlciB0aGUgY2hpbGQgd2F0Y2hlciBjcmVhdGlvbiB1bnRpbFxuICAgICAgICAvLyB0aGUgY3JlYXRlZCBob29rIChhZnRlciBkYXRhIG9ic2VydmF0aW9uKVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNoaWxkLiRvbmNlKCdwcmUtaG9vazpjcmVhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuY2hpbGRXYXRjaGVyID0gbmV3IFdhdGNoZXIoY2hpbGQsIGNoaWxkS2V5LCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBwYXJlbnRXYXRjaGVyLnNldCh2YWwpO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBzeW5jIHVwd2FyZCBiZWZvcmUgcGFyZW50IHN5bmMgZG93bi5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGluIGNhc2VzIGUuZy4gdGhlIGNoaWxkXG4gICAgICAgICAgICAvLyBtdXRhdGVzIGEgcHJvcCBhcnJheSwgdGhlbiByZXBsYWNlcyBpdC4gKCMxNjgzKVxuICAgICAgICAgICAgc3luYzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICB0aGlzLnBhcmVudFdhdGNoZXIudGVhcmRvd24oKTtcbiAgICAgIGlmICh0aGlzLmNoaWxkV2F0Y2hlcikge1xuICAgICAgICB0aGlzLmNoaWxkV2F0Y2hlci50ZWFyZG93bigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcXVldWUkMSA9IFtdO1xuICB2YXIgcXVldWVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFB1c2ggYSBqb2IgaW50byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYlxuICAgKi9cblxuICBmdW5jdGlvbiBwdXNoSm9iKGpvYikge1xuICAgIHF1ZXVlJDEucHVzaChqb2IpO1xuICAgIGlmICghcXVldWVkKSB7XG4gICAgICBxdWV1ZWQgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2gpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCB0aGUgcXVldWUsIGFuZCBkbyBvbmUgZm9yY2VkIHJlZmxvdyBiZWZvcmVcbiAgICogdHJpZ2dlcmluZyB0cmFuc2l0aW9ucy5cbiAgICovXG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgLy8gRm9yY2UgbGF5b3V0XG4gICAgdmFyIGYgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUkMS5sZW5ndGg7IGkrKykge1xuICAgICAgcXVldWUkMVtpXSgpO1xuICAgIH1cbiAgICBxdWV1ZSQxID0gW107XG4gICAgcXVldWVkID0gZmFsc2U7XG4gICAgLy8gZHVtbXkgcmV0dXJuLCBzbyBqcyBsaW50ZXJzIGRvbid0IGNvbXBsYWluIGFib3V0XG4gICAgLy8gdW51c2VkIHZhcmlhYmxlIGZcbiAgICByZXR1cm4gZjtcbiAgfVxuXG4gIHZhciBUWVBFX1RSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG4gIHZhciBUWVBFX0FOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuICB2YXIgdHJhbnNEdXJhdGlvblByb3AgPSB0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbic7XG4gIHZhciBhbmltRHVyYXRpb25Qcm9wID0gYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbic7XG5cbiAgLyoqXG4gICAqIEEgVHJhbnNpdGlvbiBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgdGhlIHN0YXRlIGFuZCBsb2dpY1xuICAgKiBvZiB0aGUgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGhvb2tzXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKi9cbiAgZnVuY3Rpb24gVHJhbnNpdGlvbihlbCwgaWQsIGhvb2tzLCB2bSkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy5lbnRlckNsYXNzID0gaG9va3MgJiYgaG9va3MuZW50ZXJDbGFzcyB8fCBpZCArICctZW50ZXInO1xuICAgIHRoaXMubGVhdmVDbGFzcyA9IGhvb2tzICYmIGhvb2tzLmxlYXZlQ2xhc3MgfHwgaWQgKyAnLWxlYXZlJztcbiAgICB0aGlzLmhvb2tzID0gaG9va3M7XG4gICAgdGhpcy52bSA9IHZtO1xuICAgIC8vIGFzeW5jIHN0YXRlXG4gICAgdGhpcy5wZW5kaW5nQ3NzRXZlbnQgPSB0aGlzLnBlbmRpbmdDc3NDYiA9IHRoaXMuY2FuY2VsID0gdGhpcy5wZW5kaW5nSnNDYiA9IHRoaXMub3AgPSB0aGlzLmNiID0gbnVsbDtcbiAgICB0aGlzLmp1c3RFbnRlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5lbnRlcmVkID0gdGhpcy5sZWZ0ID0gZmFsc2U7XG4gICAgdGhpcy50eXBlQ2FjaGUgPSB7fTtcbiAgICAvLyBjaGVjayBjc3MgdHJhbnNpdGlvbiB0eXBlXG4gICAgdGhpcy50eXBlID0gaG9va3MgJiYgaG9va3MudHlwZTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodGhpcy50eXBlICYmIHRoaXMudHlwZSAhPT0gVFlQRV9UUkFOU0lUSU9OICYmIHRoaXMudHlwZSAhPT0gVFlQRV9BTklNQVRJT04pIHtcbiAgICAgICAgd2FybignaW52YWxpZCBDU1MgdHJhbnNpdGlvbiB0eXBlIGZvciB0cmFuc2l0aW9uPVwiJyArIHRoaXMuaWQgKyAnXCI6ICcgKyB0aGlzLnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBiaW5kXG4gICAgdmFyIHNlbGYgPSB0aGlzO1snZW50ZXJOZXh0VGljaycsICdlbnRlckRvbmUnLCAnbGVhdmVOZXh0VGljaycsICdsZWF2ZURvbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICBzZWxmW21dID0gYmluZChzZWxmW21dLCBzZWxmKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwJDEgPSBUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogU3RhcnQgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogMS4gZW50ZXIgdHJhbnNpdGlvbiB0cmlnZ2VyZWRcbiAgICogMi4gY2FsbCBiZWZvcmVFbnRlciBob29rXG4gICAqIDMuIGFkZCBlbnRlciBjbGFzc1xuICAgKiA0LiBpbnNlcnQvc2hvdyBlbGVtZW50XG4gICAqIDUuIGNhbGwgZW50ZXIgaG9vayAod2l0aCBwb3NzaWJsZSBleHBsaWNpdCBqcyBjYWxsYmFjaylcbiAgICogNi4gcmVmbG93XG4gICAqIDcuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAgICogICAgLSB0cmFuc2l0aW9uOlxuICAgKiAgICAgICAgcmVtb3ZlIGNsYXNzIG5vdywgd2FpdCBmb3IgdHJhbnNpdGlvbmVuZCxcbiAgICogICAgICAgIHRoZW4gZG9uZSBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICAgKiAgICAtIGFuaW1hdGlvbjpcbiAgICogICAgICAgIHdhaXQgZm9yIGFuaW1hdGlvbmVuZCwgcmVtb3ZlIGNsYXNzLFxuICAgKiAgICAgICAgdGhlbiBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gICAqICAgIC0gbm8gY3NzIHRyYW5zaXRpb246XG4gICAqICAgICAgICBkb25lIG5vdyBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICAgKiA4LiB3YWl0IGZvciBlaXRoZXIgZG9uZSBvciBqcyBjYWxsYmFjaywgdGhlbiBjYWxsXG4gICAqICAgIGFmdGVyRW50ZXIgaG9vay5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSBpbnNlcnQvc2hvdyB0aGUgZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIHAkMS5lbnRlciA9IGZ1bmN0aW9uIChvcCwgY2IpIHtcbiAgICB0aGlzLmNhbmNlbFBlbmRpbmcoKTtcbiAgICB0aGlzLmNhbGxIb29rKCdiZWZvcmVFbnRlcicpO1xuICAgIHRoaXMuY2IgPSBjYjtcbiAgICBhZGRDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICAgIG9wKCk7XG4gICAgdGhpcy5lbnRlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5jYWxsSG9va1dpdGhDYignZW50ZXInKTtcbiAgICBpZiAodGhpcy5lbnRlcmVkKSB7XG4gICAgICByZXR1cm47IC8vIHVzZXIgY2FsbGVkIGRvbmUgc3luY2hyb25vdXNseS5cbiAgICB9XG4gICAgdGhpcy5jYW5jZWwgPSB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MuZW50ZXJDYW5jZWxsZWQ7XG4gICAgcHVzaEpvYih0aGlzLmVudGVyTmV4dFRpY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgXCJuZXh0VGlja1wiIHBoYXNlIG9mIGFuIGVudGVyaW5nIHRyYW5zaXRpb24sIHdoaWNoIGlzXG4gICAqIHRvIGJlIHB1c2hlZCBpbnRvIGEgcXVldWUgYW5kIGV4ZWN1dGVkIGFmdGVyIGEgcmVmbG93IHNvXG4gICAqIHRoYXQgcmVtb3ZpbmcgdGhlIGNsYXNzIGNhbiB0cmlnZ2VyIGEgQ1NTIHRyYW5zaXRpb24uXG4gICAqL1xuXG4gIHAkMS5lbnRlck5leHRUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEltcG9ydGFudCBoYWNrOlxuICAgIC8vIGluIENocm9tZSwgaWYgYSBqdXN0LWVudGVyZWQgZWxlbWVudCBpcyBhcHBsaWVkIHRoZVxuICAgIC8vIGxlYXZlIGNsYXNzIHdoaWxlIGl0cyBpbnRlcnBvbGF0ZWQgcHJvcGVydHkgc3RpbGwgaGFzXG4gICAgLy8gYSB2ZXJ5IHNtYWxsIHZhbHVlICh3aXRoaW4gb25lIGZyYW1lKSwgQ2hyb21lIHdpbGxcbiAgICAvLyBza2lwIHRoZSBsZWF2ZSB0cmFuc2l0aW9uIGVudGlyZWx5IGFuZCBub3QgZmlyaW5nIHRoZVxuICAgIC8vIHRyYW5zdGlvbmVuZCBldmVudC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gcHJvdGVjdGVkXG4gICAgLy8gYWdhaW5zdCBzdWNoIGNhc2VzIHVzaW5nIGEgb25lLWZyYW1lIHRpbWVvdXQuXG4gICAgdGhpcy5qdXN0RW50ZXJlZCA9IHRydWU7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5qdXN0RW50ZXJlZCA9IGZhbHNlO1xuICAgIH0sIDE3KTtcblxuICAgIHZhciBlbnRlckRvbmUgPSB0aGlzLmVudGVyRG9uZTtcbiAgICB2YXIgdHlwZSA9IHRoaXMuZ2V0Q3NzVHJhbnNpdGlvblR5cGUodGhpcy5lbnRlckNsYXNzKTtcbiAgICBpZiAoIXRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICAgIGlmICh0eXBlID09PSBUWVBFX1RSQU5TSVRJT04pIHtcbiAgICAgICAgLy8gdHJpZ2dlciB0cmFuc2l0aW9uIGJ5IHJlbW92aW5nIGVudGVyIGNsYXNzIG5vd1xuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICAgICAgICB0aGlzLnNldHVwQ3NzQ2IodHJhbnNpdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUWVBFX0FOSU1BVElPTikge1xuICAgICAgICB0aGlzLnNldHVwQ3NzQ2IoYW5pbWF0aW9uRW5kRXZlbnQsIGVudGVyRG9uZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRlckRvbmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTikge1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBcImNsZWFudXBcIiBwaGFzZSBvZiBhbiBlbnRlcmluZyB0cmFuc2l0aW9uLlxuICAgKi9cblxuICBwJDEuZW50ZXJEb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW50ZXJlZCA9IHRydWU7XG4gICAgdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbDtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICAgIHRoaXMuY2FsbEhvb2soJ2FmdGVyRW50ZXInKTtcbiAgICBpZiAodGhpcy5jYikgdGhpcy5jYigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCBhIGxlYXZpbmcgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogMS4gbGVhdmUgdHJhbnNpdGlvbiB0cmlnZ2VyZWQuXG4gICAqIDIuIGNhbGwgYmVmb3JlTGVhdmUgaG9va1xuICAgKiAzLiBhZGQgbGVhdmUgY2xhc3MgKHRyaWdnZXIgY3NzIHRyYW5zaXRpb24pXG4gICAqIDQuIGNhbGwgbGVhdmUgaG9vayAod2l0aCBwb3NzaWJsZSBleHBsaWNpdCBqcyBjYWxsYmFjaylcbiAgICogNS4gcmVmbG93IGlmIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gICAqIDYuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAgICogICAgLSB0cmFuc2l0aW9uIG9yIGFuaW1hdGlvbjpcbiAgICogICAgICAgIHdhaXQgZm9yIGVuZCBldmVudCwgcmVtb3ZlIGNsYXNzLCB0aGVuIGRvbmUgaWZcbiAgICogICAgICAgIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gICAqICAgIC0gbm8gY3NzIHRyYW5zaXRpb246XG4gICAqICAgICAgICBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gICAqIDcuIHdhaXQgZm9yIGVpdGhlciBkb25lIG9yIGpzIGNhbGxiYWNrLCB0aGVuIGNhbGxcbiAgICogICAgYWZ0ZXJMZWF2ZSBob29rLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHJlbW92ZS9oaWRlIHRoZSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgcCQxLmxlYXZlID0gZnVuY3Rpb24gKG9wLCBjYikge1xuICAgIHRoaXMuY2FuY2VsUGVuZGluZygpO1xuICAgIHRoaXMuY2FsbEhvb2soJ2JlZm9yZUxlYXZlJyk7XG4gICAgdGhpcy5vcCA9IG9wO1xuICAgIHRoaXMuY2IgPSBjYjtcbiAgICBhZGRDbGFzcyh0aGlzLmVsLCB0aGlzLmxlYXZlQ2xhc3MpO1xuICAgIHRoaXMubGVmdCA9IGZhbHNlO1xuICAgIHRoaXMuY2FsbEhvb2tXaXRoQ2IoJ2xlYXZlJyk7XG4gICAgaWYgKHRoaXMubGVmdCkge1xuICAgICAgcmV0dXJuOyAvLyB1c2VyIGNhbGxlZCBkb25lIHN5bmNocm9ub3VzbHkuXG4gICAgfVxuICAgIHRoaXMuY2FuY2VsID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmxlYXZlQ2FuY2VsbGVkO1xuICAgIC8vIG9ubHkgbmVlZCB0byBoYW5kbGUgbGVhdmVEb25lIGlmXG4gICAgLy8gMS4gdGhlIHRyYW5zaXRpb24gaXMgYWxyZWFkeSBkb25lIChzeW5jaHJvbm91c2x5IGNhbGxlZFxuICAgIC8vICAgIGJ5IHRoZSB1c2VyLCB3aGljaCBjYXVzZXMgdGhpcy5vcCBzZXQgdG8gbnVsbClcbiAgICAvLyAyLiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrXG4gICAgaWYgKHRoaXMub3AgJiYgIXRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICAgIC8vIGlmIGEgQ1NTIHRyYW5zaXRpb24gbGVhdmVzIGltbWVkaWF0ZWx5IGFmdGVyIGVudGVyLFxuICAgICAgLy8gdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQgbmV2ZXIgZmlyZXMuIHRoZXJlZm9yZSB3ZVxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGVuZCB0aGUgbGVhdmUgaW1tZWRpYXRlbHkuXG4gICAgICBpZiAodGhpcy5qdXN0RW50ZXJlZCkge1xuICAgICAgICB0aGlzLmxlYXZlRG9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEpvYih0aGlzLmxlYXZlTmV4dFRpY2spO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhlIFwibmV4dFRpY2tcIiBwaGFzZSBvZiBhIGxlYXZpbmcgdHJhbnNpdGlvbi5cbiAgICovXG5cbiAgcCQxLmxlYXZlTmV4dFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLmdldENzc1RyYW5zaXRpb25UeXBlKHRoaXMubGVhdmVDbGFzcyk7XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIHZhciBldmVudCA9IHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICAgICAgdGhpcy5zZXR1cENzc0NiKGV2ZW50LCB0aGlzLmxlYXZlRG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVhdmVEb25lKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgXCJjbGVhbnVwXCIgcGhhc2Ugb2YgYSBsZWF2aW5nIHRyYW5zaXRpb24uXG4gICAqL1xuXG4gIHAkMS5sZWF2ZURvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sZWZ0ID0gdHJ1ZTtcbiAgICB0aGlzLmNhbmNlbCA9IHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsO1xuICAgIHRoaXMub3AoKTtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmxlYXZlQ2xhc3MpO1xuICAgIHRoaXMuY2FsbEhvb2soJ2FmdGVyTGVhdmUnKTtcbiAgICBpZiAodGhpcy5jYikgdGhpcy5jYigpO1xuICAgIHRoaXMub3AgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYW5jZWwgYW55IHBlbmRpbmcgY2FsbGJhY2tzIGZyb20gYSBwcmV2aW91c2x5IHJ1bm5pbmdcbiAgICogYnV0IG5vdCBmaW5pc2hlZCB0cmFuc2l0aW9uLlxuICAgKi9cblxuICBwJDEuY2FuY2VsUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9wID0gdGhpcy5jYiA9IG51bGw7XG4gICAgdmFyIGhhc1BlbmRpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ3NzQ2IpIHtcbiAgICAgIGhhc1BlbmRpbmcgPSB0cnVlO1xuICAgICAgb2ZmKHRoaXMuZWwsIHRoaXMucGVuZGluZ0Nzc0V2ZW50LCB0aGlzLnBlbmRpbmdDc3NDYik7XG4gICAgICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICAgIGhhc1BlbmRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5wZW5kaW5nSnNDYi5jYW5jZWwoKTtcbiAgICAgIHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoaGFzUGVuZGluZykge1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNhbmNlbCkge1xuICAgICAgdGhpcy5jYW5jZWwuY2FsbCh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgICAgIHRoaXMuY2FuY2VsID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGwgYSB1c2VyLXByb3ZpZGVkIHN5bmNocm9ub3VzIGhvb2sgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqL1xuXG4gIHAkMS5jYWxsSG9vayA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0eXBlXSkge1xuICAgICAgdGhpcy5ob29rc1t0eXBlXS5jYWxsKHRoaXMudm0sIHRoaXMuZWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCBhIHVzZXItcHJvdmlkZWQsIHBvdGVudGlhbGx5LWFzeW5jIGhvb2sgZnVuY3Rpb24uXG4gICAqIFdlIGNoZWNrIGZvciB0aGUgbGVuZ3RoIG9mIGFyZ3VtZW50cyB0byBzZWUgaWYgdGhlIGhvb2tcbiAgICogZXhwZWN0cyBhIGBkb25lYCBjYWxsYmFjay4gSWYgdHJ1ZSwgdGhlIHRyYW5zaXRpb24ncyBlbmRcbiAgICogd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHdoZW4gdGhlIHVzZXIgY2FsbHMgdGhhdCBjYWxsYmFjaztcbiAgICogb3RoZXJ3aXNlLCB0aGUgZW5kIGlzIGRldGVybWluZWQgYnkgdGhlIENTUyB0cmFuc2l0aW9uIG9yXG4gICAqIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICovXG5cbiAgcCQxLmNhbGxIb29rV2l0aENiID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgaG9vayA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0eXBlXTtcbiAgICBpZiAoaG9vaykge1xuICAgICAgaWYgKGhvb2subGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdKc0NiID0gY2FuY2VsbGFibGUodGhpc1t0eXBlICsgJ0RvbmUnXSk7XG4gICAgICB9XG4gICAgICBob29rLmNhbGwodGhpcy52bSwgdGhpcy5lbCwgdGhpcy5wZW5kaW5nSnNDYik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gZWxlbWVudCdzIHRyYW5zaXRpb24gdHlwZSBiYXNlZCBvbiB0aGVcbiAgICogY2FsY3VsYXRlZCBzdHlsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cblxuICBwJDEuZ2V0Q3NzVHJhbnNpdGlvblR5cGUgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0cmFuc2l0aW9uRW5kRXZlbnQgfHxcbiAgICAvLyBza2lwIENTUyB0cmFuc2l0aW9ucyBpZiBwYWdlIGlzIG5vdCB2aXNpYmxlIC1cbiAgICAvLyB0aGlzIHNvbHZlcyB0aGUgaXNzdWUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHMgbm90XG4gICAgLy8gZmlyaW5nIHVudGlsIHRoZSBwYWdlIGlzIHZpc2libGUgYWdhaW4uXG4gICAgLy8gcGFnZVZpc2liaWxpdHkgQVBJIGlzIHN1cHBvcnRlZCBpbiBJRTEwKywgc2FtZSBhc1xuICAgIC8vIENTUyB0cmFuc2l0aW9ucy5cbiAgICBkb2N1bWVudC5oaWRkZW4gfHxcbiAgICAvLyBleHBsaWNpdCBqcy1vbmx5IHRyYW5zaXRpb25cbiAgICB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3MuY3NzID09PSBmYWxzZSB8fFxuICAgIC8vIGVsZW1lbnQgaXMgaGlkZGVuXG4gICAgaXNIaWRkZW4odGhpcy5lbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGUgfHwgdGhpcy50eXBlQ2FjaGVbY2xhc3NOYW1lXTtcbiAgICBpZiAodHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgdmFyIGlubGluZVN0eWxlcyA9IHRoaXMuZWwuc3R5bGU7XG4gICAgdmFyIGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbCk7XG4gICAgdmFyIHRyYW5zRHVyYXRpb24gPSBpbmxpbmVTdHlsZXNbdHJhbnNEdXJhdGlvblByb3BdIHx8IGNvbXB1dGVkU3R5bGVzW3RyYW5zRHVyYXRpb25Qcm9wXTtcbiAgICBpZiAodHJhbnNEdXJhdGlvbiAmJiB0cmFuc0R1cmF0aW9uICE9PSAnMHMnKSB7XG4gICAgICB0eXBlID0gVFlQRV9UUkFOU0lUSU9OO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYW5pbUR1cmF0aW9uID0gaW5saW5lU3R5bGVzW2FuaW1EdXJhdGlvblByb3BdIHx8IGNvbXB1dGVkU3R5bGVzW2FuaW1EdXJhdGlvblByb3BdO1xuICAgICAgaWYgKGFuaW1EdXJhdGlvbiAmJiBhbmltRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICAgICAgdHlwZSA9IFRZUEVfQU5JTUFUSU9OO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSkge1xuICAgICAgdGhpcy50eXBlQ2FjaGVbY2xhc3NOYW1lXSA9IHR5cGU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXR1cCBhIENTUyB0cmFuc2l0aW9uZW5kL2FuaW1hdGlvbmVuZCBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqL1xuXG4gIHAkMS5zZXR1cENzc0NiID0gZnVuY3Rpb24gKGV2ZW50LCBjYikge1xuICAgIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID0gZXZlbnQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIG9uRW5kID0gdGhpcy5wZW5kaW5nQ3NzQ2IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgICBvZmYoZWwsIGV2ZW50LCBvbkVuZCk7XG4gICAgICAgIHNlbGYucGVuZGluZ0Nzc0V2ZW50ID0gc2VsZi5wZW5kaW5nQ3NzQ2IgPSBudWxsO1xuICAgICAgICBpZiAoIXNlbGYucGVuZGluZ0pzQ2IgJiYgY2IpIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBvbihlbCwgZXZlbnQsIG9uRW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBoaWRkZW4gLSBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3RcbiAgICogc2tpcCB0aGUgdHJhbnNpdGlvbiBhbGx0b2dldGhlci5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuICBmdW5jdGlvbiBpc0hpZGRlbihlbCkge1xuICAgIGlmICgvc3ZnJC8udGVzdChlbC5uYW1lc3BhY2VVUkkpKSB7XG4gICAgICAvLyBTVkcgZWxlbWVudHMgZG8gbm90IGhhdmUgb2Zmc2V0KFdpZHRofEhlaWdodClcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGhlIGNsaWVudCByZWN0XG4gICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuICEocmVjdC53aWR0aCB8fCByZWN0LmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAhKGVsLm9mZnNldFdpZHRoIHx8IGVsLm9mZnNldEhlaWdodCB8fCBlbC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRyYW5zaXRpb24kMSA9IHtcblxuICAgIHByaW9yaXR5OiBUUkFOU0lUSU9OLFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoaWQsIG9sZElkKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgLy8gcmVzb2x2ZSBvbiBvd25lciB2bVxuICAgICAgdmFyIGhvb2tzID0gcmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICd0cmFuc2l0aW9ucycsIGlkKTtcbiAgICAgIGlkID0gaWQgfHwgJ3YnO1xuICAgICAgZWwuX192X3RyYW5zID0gbmV3IFRyYW5zaXRpb24oZWwsIGlkLCBob29rcywgdGhpcy52bSk7XG4gICAgICBpZiAob2xkSWQpIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsIG9sZElkICsgJy10cmFuc2l0aW9uJyk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhlbCwgaWQgKyAnLXRyYW5zaXRpb24nKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGludGVybmFsRGlyZWN0aXZlcyA9IHtcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgJ2NsYXNzJzogdkNsYXNzLFxuICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgIHByb3A6IHByb3BEZWYsXG4gICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiQxXG4gIH07XG5cbiAgdmFyIHByb3BCaW5kaW5nTW9kZXMgPSBjb25maWcuX3Byb3BCaW5kaW5nTW9kZXM7XG4gIHZhciBlbXB0eSA9IHt9O1xuXG4gIC8vIHJlZ2V4ZXNcbiAgdmFyIGlkZW50UkUkMSA9IC9eWyRfYS16QS1aXStbXFx3JF0qJC87XG4gIHZhciBzZXR0YWJsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooXFwuW0EtWmEtel8kXVtcXHckXSp8XFxbW15cXFtcXF1dK1xcXSkqJC87XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgcHJvcHMgb24gYSByb290IGVsZW1lbnQgYW5kIHJldHVyblxuICAgKiBhIHByb3BzIGxpbmsgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wT3B0aW9uc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJvcHNMaW5rRm5cbiAgICovXG5cbiAgZnVuY3Rpb24gY29tcGlsZVByb3BzKGVsLCBwcm9wT3B0aW9ucykge1xuICAgIHZhciBwcm9wcyA9IFtdO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHByb3BPcHRpb25zKTtcbiAgICB2YXIgaSA9IG5hbWVzLmxlbmd0aDtcbiAgICB2YXIgb3B0aW9ucywgbmFtZSwgYXR0ciwgdmFsdWUsIHBhdGgsIHBhcnNlZCwgcHJvcDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICBvcHRpb25zID0gcHJvcE9wdGlvbnNbbmFtZV0gfHwgZW1wdHk7XG5cbiAgICAgIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJyRkYXRhJykge1xuICAgICAgICB3YXJuKCdEbyBub3QgdXNlICRkYXRhIGFzIHByb3AuJyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBwcm9wcyBjb3VsZCBjb250YWluIGRhc2hlcywgd2hpY2ggd2lsbCBiZVxuICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgbWludXMgY2FsY3VsYXRpb25zIGJ5IHRoZSBwYXJzZXJcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gY2FtZWxpemUgdGhlIHBhdGggaGVyZVxuICAgICAgcGF0aCA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgaWYgKCFpZGVudFJFJDEudGVzdChwYXRoKSkge1xuICAgICAgICAnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBwcm9wIGtleTogXCInICsgbmFtZSArICdcIi4gUHJvcCBrZXlzICcgKyAnbXVzdCBiZSB2YWxpZCBpZGVudGlmaWVycy4nKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHByb3AgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIG1vZGU6IHByb3BCaW5kaW5nTW9kZXMuT05FX1dBWSxcbiAgICAgICAgcmF3OiBudWxsXG4gICAgICB9O1xuXG4gICAgICBhdHRyID0gaHlwaGVuYXRlKG5hbWUpO1xuICAgICAgLy8gZmlyc3QgY2hlY2sgZHluYW1pYyB2ZXJzaW9uXG4gICAgICBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIpKSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIgKyAnLnN5bmMnKSkgIT09IG51bGwpIHtcbiAgICAgICAgICBwcm9wLm1vZGUgPSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVk7XG4gICAgICAgIH0gZWxzZSBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIgKyAnLm9uY2UnKSkgIT09IG51bGwpIHtcbiAgICAgICAgICBwcm9wLm1vZGUgPSBwcm9wQmluZGluZ01vZGVzLk9ORV9USU1FO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gaGFzIGR5bmFtaWMgYmluZGluZyFcbiAgICAgICAgcHJvcC5yYXcgPSB2YWx1ZTtcbiAgICAgICAgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUodmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlZC5leHByZXNzaW9uO1xuICAgICAgICBwcm9wLmZpbHRlcnMgPSBwYXJzZWQuZmlsdGVycztcbiAgICAgICAgLy8gY2hlY2sgYmluZGluZyB0eXBlXG4gICAgICAgIGlmIChpc0xpdGVyYWwodmFsdWUpICYmICFwYXJzZWQuZmlsdGVycykge1xuICAgICAgICAgIC8vIGZvciBleHByZXNzaW9ucyBjb250YWluaW5nIGxpdGVyYWwgbnVtYmVycyBhbmRcbiAgICAgICAgICAvLyBib29sZWFucywgdGhlcmUncyBubyBuZWVkIHRvIHNldHVwIGEgcHJvcCBiaW5kaW5nLFxuICAgICAgICAgIC8vIHNvIHdlIGNhbiBvcHRpbWl6ZSB0aGVtIGFzIGEgb25lLXRpbWUgc2V0LlxuICAgICAgICAgIHByb3Aub3B0aW1pemVkTGl0ZXJhbCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcC5keW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAvLyBjaGVjayBub24tc2V0dGFibGUgcGF0aCBmb3IgdHdvLXdheSBiaW5kaW5nc1xuICAgICAgICAgIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgcHJvcC5tb2RlID09PSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVkgJiYgIXNldHRhYmxlUGF0aFJFLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICBwcm9wLm1vZGUgPSBwcm9wQmluZGluZ01vZGVzLk9ORV9XQVk7XG4gICAgICAgICAgICB3YXJuKCdDYW5ub3QgYmluZCB0d28td2F5IHByb3Agd2l0aCBub24tc2V0dGFibGUgJyArICdwYXJlbnQgcGF0aDogJyArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvcC5wYXJlbnRQYXRoID0gdmFsdWU7XG5cbiAgICAgICAgLy8gd2FybiByZXF1aXJlZCB0d28td2F5XG4gICAgICAgIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy50d29XYXkgJiYgcHJvcC5tb2RlICE9PSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVkpIHtcbiAgICAgICAgICB3YXJuKCdQcm9wIFwiJyArIG5hbWUgKyAnXCIgZXhwZWN0cyBhIHR3by13YXkgYmluZGluZyB0eXBlLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCh2YWx1ZSA9IGdldEF0dHIoZWwsIGF0dHIpKSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBoYXMgbGl0ZXJhbCBiaW5kaW5nIVxuICAgICAgICBwcm9wLnJhdyA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gY2hlY2sgcG9zc2libGUgY2FtZWxDYXNlIHByb3AgdXNhZ2VcbiAgICAgICAgdmFyIGxvd2VyQ2FzZU5hbWUgPSBwYXRoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhbHVlID0gL1tBLVpcXC1dLy50ZXN0KG5hbWUpICYmIChlbC5nZXRBdHRyaWJ1dGUobG93ZXJDYXNlTmFtZSkgfHwgZWwuZ2V0QXR0cmlidXRlKCc6JyArIGxvd2VyQ2FzZU5hbWUpIHx8IGVsLmdldEF0dHJpYnV0ZSgndi1iaW5kOicgKyBsb3dlckNhc2VOYW1lKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJzonICsgbG93ZXJDYXNlTmFtZSArICcub25jZScpIHx8IGVsLmdldEF0dHJpYnV0ZSgndi1iaW5kOicgKyBsb3dlckNhc2VOYW1lICsgJy5vbmNlJykgfHwgZWwuZ2V0QXR0cmlidXRlKCc6JyArIGxvd2VyQ2FzZU5hbWUgKyAnLnN5bmMnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3YtYmluZDonICsgbG93ZXJDYXNlTmFtZSArICcuc3luYycpKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgd2FybignUG9zc2libGUgdXNhZ2UgZXJyb3IgZm9yIHByb3AgYCcgKyBsb3dlckNhc2VOYW1lICsgJ2AgLSAnICsgJ2RpZCB5b3UgbWVhbiBgJyArIGF0dHIgKyAnYD8gSFRNTCBpcyBjYXNlLWluc2Vuc2l0aXZlLCByZW1lbWJlciB0byB1c2UgJyArICdrZWJhYi1jYXNlIGZvciBwcm9wcyBpbiB0ZW1wbGF0ZXMuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlZCkge1xuICAgICAgICAgIC8vIHdhcm4gbWlzc2luZyByZXF1aXJlZFxuICAgICAgICAgIHdhcm4oJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogJyArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBwdXNoIHByb3BcbiAgICAgIHByb3BzLnB1c2gocHJvcCk7XG4gICAgfVxuICAgIHJldHVybiBtYWtlUHJvcHNMaW5rRm4ocHJvcHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgZnVuY3Rpb24gdGhhdCBhcHBsaWVzIHByb3BzIHRvIGEgdm0uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBwcm9wc0xpbmtGblxuICAgKi9cblxuICBmdW5jdGlvbiBtYWtlUHJvcHNMaW5rRm4ocHJvcHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcHJvcHNMaW5rRm4odm0sIHNjb3BlKSB7XG4gICAgICAvLyBzdG9yZSByZXNvbHZlZCBwcm9wcyBpbmZvXG4gICAgICB2bS5fcHJvcHMgPSB7fTtcbiAgICAgIHZhciBpID0gcHJvcHMubGVuZ3RoO1xuICAgICAgdmFyIHByb3AsIHBhdGgsIG9wdGlvbnMsIHZhbHVlLCByYXc7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgcmF3ID0gcHJvcC5yYXc7XG4gICAgICAgIHBhdGggPSBwcm9wLnBhdGg7XG4gICAgICAgIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnM7XG4gICAgICAgIHZtLl9wcm9wc1twYXRoXSA9IHByb3A7XG4gICAgICAgIGlmIChyYXcgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBpbml0aWFsaXplIGFic2VudCBwcm9wXG4gICAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICAgICAgLy8gZHluYW1pYyBwcm9wXG4gICAgICAgICAgaWYgKHByb3AubW9kZSA9PT0gcHJvcEJpbmRpbmdNb2Rlcy5PTkVfVElNRSkge1xuICAgICAgICAgICAgLy8gb25lIHRpbWUgYmluZGluZ1xuICAgICAgICAgICAgdmFsdWUgPSAoc2NvcGUgfHwgdm0uX2NvbnRleHQgfHwgdm0pLiRnZXQocHJvcC5wYXJlbnRQYXRoKTtcbiAgICAgICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2bS5fY29udGV4dCkge1xuICAgICAgICAgICAgICAvLyBkeW5hbWljIGJpbmRpbmdcbiAgICAgICAgICAgICAgdm0uX2JpbmREaXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdwcm9wJyxcbiAgICAgICAgICAgICAgICBkZWY6IHByb3BEZWYsXG4gICAgICAgICAgICAgICAgcHJvcDogcHJvcFxuICAgICAgICAgICAgICB9LCBudWxsLCBudWxsLCBzY29wZSk7IC8vIGVsLCBob3N0LCBzY29wZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByb290IGluc3RhbmNlXG4gICAgICAgICAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZtLiRnZXQocHJvcC5wYXJlbnRQYXRoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcC5vcHRpbWl6ZWRMaXRlcmFsKSB7XG4gICAgICAgICAgLy8gb3B0aW1pemVkIGxpdGVyYWwsIGNhc3QgaXQgYW5kIGp1c3Qgc2V0IG9uY2VcbiAgICAgICAgICB2YXIgc3RyaXBwZWQgPSBzdHJpcFF1b3RlcyhyYXcpO1xuICAgICAgICAgIHZhbHVlID0gc3RyaXBwZWQgPT09IHJhdyA/IHRvQm9vbGVhbih0b051bWJlcihyYXcpKSA6IHN0cmlwcGVkO1xuICAgICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc3RyaW5nIGxpdGVyYWwsIGJ1dCB3ZSBuZWVkIHRvIGNhdGVyIGZvclxuICAgICAgICAgIC8vIEJvb2xlYW4gcHJvcHMgd2l0aCBubyB2YWx1ZVxuICAgICAgICAgIHZhbHVlID0gb3B0aW9ucy50eXBlID09PSBCb29sZWFuICYmIHJhdyA9PT0gJycgPyB0cnVlIDogcmF3O1xuICAgICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gc3BlY2lhbCBiaW5kaW5nIHByZWZpeGVzXG4gIHZhciBiaW5kUkUgPSAvXnYtYmluZDp8XjovO1xuICB2YXIgb25SRSA9IC9edi1vbjp8XkAvO1xuICB2YXIgZGlyQXR0clJFID0gL152LShbXjpdKykoPzokfDooLiopJCkvO1xuICB2YXIgbW9kaWZpZXJSRSA9IC9cXC5bXlxcLl0rL2c7XG4gIHZhciB0cmFuc2l0aW9uUkUgPSAvXih2LWJpbmQ6fDopP3RyYW5zaXRpb24kLztcblxuICAvLyB0ZXJtaW5hbCBkaXJlY3RpdmVzXG4gIHZhciB0ZXJtaW5hbERpcmVjdGl2ZXMgPSBbJ2ZvcicsICdpZiddO1xuXG4gIC8vIGRlZmF1bHQgZGlyZWN0aXZlIHByaW9yaXR5XG4gIHZhciBERUZBVUxUX1BSSU9SSVRZID0gMTAwMDtcblxuICAvKipcbiAgICogQ29tcGlsZSBhIHRlbXBsYXRlIGFuZCByZXR1cm4gYSByZXVzYWJsZSBjb21wb3NpdGUgbGlua1xuICAgKiBmdW5jdGlvbiwgd2hpY2ggcmVjdXJzaXZlbHkgY29udGFpbnMgbW9yZSBsaW5rIGZ1bmN0aW9uc1xuICAgKiBpbnNpZGUuIFRoaXMgdG9wIGxldmVsIGNvbXBpbGUgZnVuY3Rpb24gd291bGQgbm9ybWFsbHlcbiAgICogYmUgY2FsbGVkIG9uIGluc3RhbmNlIHJvb3Qgbm9kZXMsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkXG4gICAqIGZvciBwYXJ0aWFsIGNvbXBpbGF0aW9uIGlmIHRoZSBwYXJ0aWFsIGFyZ3VtZW50IGlzIHRydWUuXG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBjb21wb3NpdGUgbGluayBmdW5jdGlvbiwgd2hlbiBjYWxsZWQsIHdpbGxcbiAgICogcmV0dXJuIGFuIHVubGluayBmdW5jdGlvbiB0aGF0IHRlYXJzZG93biBhbGwgZGlyZWN0aXZlc1xuICAgKiBjcmVhdGVkIGR1cmluZyB0aGUgbGlua2luZyBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFydGlhbFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gY29tcGlsZShlbCwgb3B0aW9ucywgcGFydGlhbCkge1xuICAgIC8vIGxpbmsgZnVuY3Rpb24gZm9yIHRoZSBub2RlIGl0c2VsZi5cbiAgICB2YXIgbm9kZUxpbmtGbiA9IHBhcnRpYWwgfHwgIW9wdGlvbnMuX2FzQ29tcG9uZW50ID8gY29tcGlsZU5vZGUoZWwsIG9wdGlvbnMpIDogbnVsbDtcbiAgICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgY2hpbGROb2Rlc1xuICAgIHZhciBjaGlsZExpbmtGbiA9ICEobm9kZUxpbmtGbiAmJiBub2RlTGlua0ZuLnRlcm1pbmFsKSAmJiBlbC50YWdOYW1lICE9PSAnU0NSSVBUJyAmJiBlbC5oYXNDaGlsZE5vZGVzKCkgPyBjb21waWxlTm9kZUxpc3QoZWwuY2hpbGROb2Rlcywgb3B0aW9ucykgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBjb21wb3NpdGUgbGlua2VyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhIGFscmVhZHlcbiAgICAgKiBjb21waWxlZCBwaWVjZSBvZiBET00sIHdoaWNoIGluc3RhbnRpYXRlcyBhbGwgZGlyZWN0aXZlXG4gICAgICogaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gICAgICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIGhvc3Qgdm0gb2YgdHJhbnNjbHVkZWQgY29udGVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAgICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ10gLSBsaW5rIGNvbnRleHQgZnJhZ21lbnRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAgICovXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcG9zaXRlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAgIC8vIGNhY2hlIGNoaWxkTm9kZXMgYmVmb3JlIGxpbmtpbmcgcGFyZW50LCBmaXggIzY1N1xuICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0b0FycmF5KGVsLmNoaWxkTm9kZXMpO1xuICAgICAgLy8gbGlua1xuICAgICAgdmFyIGRpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiBjb21wb3NpdGVMaW5rQ2FwdHVyZXIoKSB7XG4gICAgICAgIGlmIChub2RlTGlua0ZuKSBub2RlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgICAgICBpZiAoY2hpbGRMaW5rRm4pIGNoaWxkTGlua0ZuKHZtLCBjaGlsZE5vZGVzLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgICB9LCB2bSk7XG4gICAgICByZXR1cm4gbWFrZVVubGlua0ZuKHZtLCBkaXJzKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgbGlua2VyIHRvIGEgdm0vZWxlbWVudCBwYWlyIGFuZCBjYXB0dXJlIHRoZVxuICAgKiBkaXJlY3RpdmVzIGNyZWF0ZWQgZHVyaW5nIHRoZSBwcm9jZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rZXJcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGxpbmtBbmRDYXB0dXJlKGxpbmtlciwgdm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoJ2RldmVsb3BtZW50JyA9PT0gJ3Byb2R1Y3Rpb24nKSB7fVxuICAgIHZhciBvcmlnaW5hbERpckNvdW50ID0gdm0uX2RpcmVjdGl2ZXMubGVuZ3RoO1xuICAgIGxpbmtlcigpO1xuICAgIHZhciBkaXJzID0gdm0uX2RpcmVjdGl2ZXMuc2xpY2Uob3JpZ2luYWxEaXJDb3VudCk7XG4gICAgZGlycy5zb3J0KGRpcmVjdGl2ZUNvbXBhcmF0b3IpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGRpcnNbaV0uX2JpbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpcnM7XG4gIH1cblxuICAvKipcbiAgICogRGlyZWN0aXZlIHByaW9yaXR5IHNvcnQgY29tcGFyYXRvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYVxuICAgKiBAcGFyYW0ge09iamVjdH0gYlxuICAgKi9cblxuICBmdW5jdGlvbiBkaXJlY3RpdmVDb21wYXJhdG9yKGEsIGIpIHtcbiAgICBhID0gYS5kZXNjcmlwdG9yLmRlZi5wcmlvcml0eSB8fCBERUZBVUxUX1BSSU9SSVRZO1xuICAgIGIgPSBiLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFk7XG4gICAgcmV0dXJuIGEgPiBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG4gIH1cblxuICAvKipcbiAgICogTGlua2VyIGZ1bmN0aW9ucyByZXR1cm4gYW4gdW5saW5rIGZ1bmN0aW9uIHRoYXRcbiAgICogdGVhcnNkb3duIGFsbCBkaXJlY3RpdmVzIGluc3RhbmNlcyBnZW5lcmF0ZWQgZHVyaW5nXG4gICAqIHRoZSBwcm9jZXNzLlxuICAgKlxuICAgKiBXZSBjcmVhdGUgdW5saW5rIGZ1bmN0aW9ucyB3aXRoIG9ubHkgdGhlIG5lY2Vzc2FyeVxuICAgKiBpbmZvcm1hdGlvbiB0byBhdm9pZCByZXRhaW5pbmcgYWRkaXRpb25hbCBjbG9zdXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRpcnNcbiAgICogQHBhcmFtIHtWdWV9IFtjb250ZXh0XVxuICAgKiBAcGFyYW0ge0FycmF5fSBbY29udGV4dERpcnNdXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBmdW5jdGlvbiBtYWtlVW5saW5rRm4odm0sIGRpcnMsIGNvbnRleHQsIGNvbnRleHREaXJzKSB7XG4gICAgZnVuY3Rpb24gdW5saW5rKGRlc3Ryb3lpbmcpIHtcbiAgICAgIHRlYXJkb3duRGlycyh2bSwgZGlycywgZGVzdHJveWluZyk7XG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0RGlycykge1xuICAgICAgICB0ZWFyZG93bkRpcnMoY29udGV4dCwgY29udGV4dERpcnMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBleHBvc2UgbGlua2VkIGRpcmVjdGl2ZXNcbiAgICB1bmxpbmsuZGlycyA9IGRpcnM7XG4gICAgcmV0dXJuIHVubGluaztcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWFyZG93biBwYXJ0aWFsIGxpbmtlZCBkaXJlY3RpdmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtBcnJheX0gZGlyc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlc3Ryb3lpbmdcbiAgICovXG5cbiAgZnVuY3Rpb24gdGVhcmRvd25EaXJzKHZtLCBkaXJzLCBkZXN0cm95aW5nKSB7XG4gICAgdmFyIGkgPSBkaXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBkaXJzW2ldLl90ZWFyZG93bigpO1xuICAgICAgaWYgKCdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiAhZGVzdHJveWluZykge1xuICAgICAgICB2bS5fZGlyZWN0aXZlcy4kcmVtb3ZlKGRpcnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21waWxlIGxpbmsgcHJvcHMgb24gYW4gaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gY29tcGlsZUFuZExpbmtQcm9wcyh2bSwgZWwsIHByb3BzLCBzY29wZSkge1xuICAgIHZhciBwcm9wc0xpbmtGbiA9IGNvbXBpbGVQcm9wcyhlbCwgcHJvcHMpO1xuICAgIHZhciBwcm9wRGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb3BzTGlua0ZuKHZtLCBzY29wZSk7XG4gICAgfSwgdm0pO1xuICAgIHJldHVybiBtYWtlVW5saW5rRm4odm0sIHByb3BEaXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoZSByb290IGVsZW1lbnQgb2YgYW4gaW5zdGFuY2UuXG4gICAqXG4gICAqIDEuIGF0dHJzIG9uIGNvbnRleHQgY29udGFpbmVyIChjb250ZXh0IHNjb3BlKVxuICAgKiAyLiBhdHRycyBvbiB0aGUgY29tcG9uZW50IHRlbXBsYXRlIHJvb3Qgbm9kZSwgaWZcbiAgICogICAgcmVwbGFjZTp0cnVlIChjaGlsZCBzY29wZSlcbiAgICpcbiAgICogSWYgdGhpcyBpcyBhIGZyYWdtZW50IGluc3RhbmNlLCB3ZSBvbmx5IG5lZWQgdG8gY29tcGlsZSAxLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0T3B0aW9uc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gY29tcGlsZVJvb3QoZWwsIG9wdGlvbnMsIGNvbnRleHRPcHRpb25zKSB7XG4gICAgdmFyIGNvbnRhaW5lckF0dHJzID0gb3B0aW9ucy5fY29udGFpbmVyQXR0cnM7XG4gICAgdmFyIHJlcGxhY2VyQXR0cnMgPSBvcHRpb25zLl9yZXBsYWNlckF0dHJzO1xuICAgIHZhciBjb250ZXh0TGlua0ZuLCByZXBsYWNlckxpbmtGbjtcblxuICAgIC8vIG9ubHkgbmVlZCB0byBjb21waWxlIG90aGVyIGF0dHJpYnV0ZXMgZm9yXG4gICAgLy8gbm9uLWZyYWdtZW50IGluc3RhbmNlc1xuICAgIGlmIChlbC5ub2RlVHlwZSAhPT0gMTEpIHtcbiAgICAgIC8vIGZvciBjb21wb25lbnRzLCBjb250YWluZXIgYW5kIHJlcGxhY2VyIG5lZWQgdG8gYmVcbiAgICAgIC8vIGNvbXBpbGVkIHNlcGFyYXRlbHkgYW5kIGxpbmtlZCBpbiBkaWZmZXJlbnQgc2NvcGVzLlxuICAgICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIDIuIGNvbnRhaW5lciBhdHRyaWJ1dGVzXG4gICAgICAgIGlmIChjb250YWluZXJBdHRycyAmJiBjb250ZXh0T3B0aW9ucykge1xuICAgICAgICAgIGNvbnRleHRMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhjb250YWluZXJBdHRycywgY29udGV4dE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBsYWNlckF0dHJzKSB7XG4gICAgICAgICAgLy8gMy4gcmVwbGFjZXIgYXR0cmlidXRlc1xuICAgICAgICAgIHJlcGxhY2VyTGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMocmVwbGFjZXJBdHRycywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vbi1jb21wb25lbnQsIGp1c3QgY29tcGlsZSBhcyBhIG5vcm1hbCBlbGVtZW50LlxuICAgICAgICByZXBsYWNlckxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKGVsLmF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbnRhaW5lckF0dHJzKSB7XG4gICAgICAvLyB3YXJuIGNvbnRhaW5lciBkaXJlY3RpdmVzIGZvciBmcmFnbWVudCBpbnN0YW5jZXNcbiAgICAgIHZhciBuYW1lcyA9IGNvbnRhaW5lckF0dHJzLmZpbHRlcihmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAvLyBhbGxvdyB2dWUtbG9hZGVyL3Z1ZWlmeSBzY29wZWQgY3NzIGF0dHJpYnV0ZXNcbiAgICAgICAgcmV0dXJuIGF0dHIubmFtZS5pbmRleE9mKCdfdi0nKSA8IDAgJiZcbiAgICAgICAgLy8gYWxsb3cgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICFvblJFLnRlc3QoYXR0ci5uYW1lKSAmJlxuICAgICAgICAvLyBhbGxvdyBzbG90c1xuICAgICAgICBhdHRyLm5hbWUgIT09ICdzbG90JztcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICByZXR1cm4gJ1wiJyArIGF0dHIubmFtZSArICdcIic7XG4gICAgICB9KTtcbiAgICAgIGlmIChuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHBsdXJhbCA9IG5hbWVzLmxlbmd0aCA+IDE7XG4gICAgICAgIHdhcm4oJ0F0dHJpYnV0ZScgKyAocGx1cmFsID8gJ3MgJyA6ICcgJykgKyBuYW1lcy5qb2luKCcsICcpICsgKHBsdXJhbCA/ICcgYXJlJyA6ICcgaXMnKSArICcgaWdub3JlZCBvbiBjb21wb25lbnQgJyArICc8JyArIG9wdGlvbnMuZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgJz4gYmVjYXVzZSAnICsgJ3RoZSBjb21wb25lbnQgaXMgYSBmcmFnbWVudCBpbnN0YW5jZTogJyArICdodHRwOi8vdnVlanMub3JnL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNGcmFnbWVudF9JbnN0YW5jZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzID0gb3B0aW9ucy5fcmVwbGFjZXJBdHRycyA9IG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJvb3RMaW5rRm4odm0sIGVsLCBzY29wZSkge1xuICAgICAgLy8gbGluayBjb250ZXh0IHNjb3BlIGRpcnNcbiAgICAgIHZhciBjb250ZXh0ID0gdm0uX2NvbnRleHQ7XG4gICAgICB2YXIgY29udGV4dERpcnM7XG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0TGlua0ZuKSB7XG4gICAgICAgIGNvbnRleHREaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRleHRMaW5rRm4oY29udGV4dCwgZWwsIG51bGwsIHNjb3BlKTtcbiAgICAgICAgfSwgY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxpbmsgc2VsZlxuICAgICAgdmFyIHNlbGZEaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocmVwbGFjZXJMaW5rRm4pIHJlcGxhY2VyTGlua0ZuKHZtLCBlbCk7XG4gICAgICB9LCB2bSk7XG5cbiAgICAgIC8vIHJldHVybiB0aGUgdW5saW5rIGZ1bmN0aW9uIHRoYXQgdGVhcnNkb3duIGNvbnRleHRcbiAgICAgIC8vIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgICAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgc2VsZkRpcnMsIGNvbnRleHQsIGNvbnRleHREaXJzKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgYSBub2RlIGFuZCByZXR1cm4gYSBub2RlTGlua0ZuIGJhc2VkIG9uIHRoZVxuICAgKiBub2RlIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfVxuICAgKi9cblxuICBmdW5jdGlvbiBjb21waWxlTm9kZShub2RlLCBvcHRpb25zKSB7XG4gICAgdmFyIHR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgIGlmICh0eXBlID09PSAxICYmIG5vZGUudGFnTmFtZSAhPT0gJ1NDUklQVCcpIHtcbiAgICAgIHJldHVybiBjb21waWxlRWxlbWVudChub2RlLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDMgJiYgbm9kZS5kYXRhLnRyaW0oKSkge1xuICAgICAgcmV0dXJuIGNvbXBpbGVUZXh0Tm9kZShub2RlLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbi5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfVxuICAgKi9cblxuICBmdW5jdGlvbiBjb21waWxlRWxlbWVudChlbCwgb3B0aW9ucykge1xuICAgIC8vIHByZXByb2Nlc3MgdGV4dGFyZWFzLlxuICAgIC8vIHRleHRhcmVhIHRyZWF0cyBpdHMgdGV4dCBjb250ZW50IGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgIC8vIGp1c3QgYmluZCBpdCBhcyBhbiBhdHRyIGRpcmVjdGl2ZSBmb3IgdmFsdWUuXG4gICAgaWYgKGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIHZhciB0b2tlbnMgPSBwYXJzZVRleHQoZWwudmFsdWUpO1xuICAgICAgaWYgKHRva2Vucykge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJzp2YWx1ZScsIHRva2Vuc1RvRXhwKHRva2VucykpO1xuICAgICAgICBlbC52YWx1ZSA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbGlua0ZuO1xuICAgIHZhciBoYXNBdHRycyA9IGVsLmhhc0F0dHJpYnV0ZXMoKTtcbiAgICAvLyBjaGVjayB0ZXJtaW5hbCBkaXJlY3RpdmVzIChmb3IgJiBpZilcbiAgICBpZiAoaGFzQXR0cnMpIHtcbiAgICAgIGxpbmtGbiA9IGNoZWNrVGVybWluYWxEaXJlY3RpdmVzKGVsLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZWxlbWVudCBkaXJlY3RpdmVzXG4gICAgaWYgKCFsaW5rRm4pIHtcbiAgICAgIGxpbmtGbiA9IGNoZWNrRWxlbWVudERpcmVjdGl2ZXMoZWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBjaGVjayBjb21wb25lbnRcbiAgICBpZiAoIWxpbmtGbikge1xuICAgICAgbGlua0ZuID0gY2hlY2tDb21wb25lbnQoZWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgIGlmICghbGlua0ZuICYmIGhhc0F0dHJzKSB7XG4gICAgICBsaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhlbC5hdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmtGbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21waWxlIGEgdGV4dE5vZGUgYW5kIHJldHVybiBhIG5vZGVMaW5rRm4uXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dE5vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7RnVuY3Rpb258bnVsbH0gdGV4dE5vZGVMaW5rRm5cbiAgICovXG5cbiAgZnVuY3Rpb24gY29tcGlsZVRleHROb2RlKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAvLyBza2lwIG1hcmtlZCB0ZXh0IG5vZGVzXG4gICAgaWYgKG5vZGUuX3NraXApIHtcbiAgICAgIHJldHVybiByZW1vdmVUZXh0O1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSBwYXJzZVRleHQobm9kZS53aG9sZVRleHQpO1xuICAgIGlmICghdG9rZW5zKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBtYXJrIGFkamFjZW50IHRleHQgbm9kZXMgYXMgc2tpcHBlZCxcbiAgICAvLyBiZWNhdXNlIHdlIGFyZSB1c2luZyBub2RlLndob2xlVGV4dCB0byBjb21waWxlXG4gICAgLy8gYWxsIGFkamFjZW50IHRleHQgbm9kZXMgdG9nZXRoZXIuIFRoaXMgZml4ZXNcbiAgICAvLyBpc3N1ZXMgaW4gSUUgd2hlcmUgc29tZXRpbWVzIGl0IHNwbGl0cyB1cCBhIHNpbmdsZVxuICAgIC8vIHRleHQgbm9kZSBpbnRvIG11bHRpcGxlIG9uZXMuXG4gICAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIHdoaWxlIChuZXh0ICYmIG5leHQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIG5leHQuX3NraXAgPSB0cnVlO1xuICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdmFyIGVsLCB0b2tlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgZWwgPSB0b2tlbi50YWcgPyBwcm9jZXNzVGV4dFRva2VuKHRva2VuLCBvcHRpb25zKSA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKTtcbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZVRleHROb2RlTGlua0ZuKHRva2VucywgZnJhZywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogTGlua2VyIGZvciBhbiBza2lwcGVkIHRleHQgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7VGV4dH0gbm9kZVxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVUZXh0KHZtLCBub2RlKSB7XG4gICAgcmVtb3ZlKG5vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYSBzaW5nbGUgdGV4dCB0b2tlbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge05vZGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHByb2Nlc3NUZXh0VG9rZW4odG9rZW4sIG9wdGlvbnMpIHtcbiAgICB2YXIgZWw7XG4gICAgaWYgKHRva2VuLm9uZVRpbWUpIHtcbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodG9rZW4udmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodG9rZW4uaHRtbCkge1xuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3YtaHRtbCcpO1xuICAgICAgICBzZXRUb2tlblR5cGUoJ2h0bWwnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElFIHdpbGwgY2xlYW4gdXAgZW1wdHkgdGV4dE5vZGVzIGR1cmluZ1xuICAgICAgICAvLyBmcmFnLmNsb25lTm9kZSh0cnVlKSwgc28gd2UgaGF2ZSB0byBnaXZlIGl0XG4gICAgICAgIC8vIHNvbWV0aGluZyBoZXJlLi4uXG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnKTtcbiAgICAgICAgc2V0VG9rZW5UeXBlKCd0ZXh0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFRva2VuVHlwZSh0eXBlKSB7XG4gICAgICBpZiAodG9rZW4uZGVzY3JpcHRvcikgcmV0dXJuO1xuICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKHRva2VuLnZhbHVlKTtcbiAgICAgIHRva2VuLmRlc2NyaXB0b3IgPSB7XG4gICAgICAgIG5hbWU6IHR5cGUsXG4gICAgICAgIGRlZjogZGlyZWN0aXZlc1t0eXBlXSxcbiAgICAgICAgZXhwcmVzc2lvbjogcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgICAgIGZpbHRlcnM6IHBhcnNlZC5maWx0ZXJzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSBmdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyBhIHRleHROb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHRva2Vuc1xuICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAgICovXG5cbiAgZnVuY3Rpb24gbWFrZVRleHROb2RlTGlua0ZuKHRva2VucywgZnJhZykge1xuICAgIHJldHVybiBmdW5jdGlvbiB0ZXh0Tm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlKSB7XG4gICAgICB2YXIgZnJhZ0Nsb25lID0gZnJhZy5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IHRvQXJyYXkoZnJhZ0Nsb25lLmNoaWxkTm9kZXMpO1xuICAgICAgdmFyIHRva2VuLCB2YWx1ZSwgbm9kZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgaWYgKHRva2VuLnRhZykge1xuICAgICAgICAgIG5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgIGlmICh0b2tlbi5vbmVUaW1lKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IChzY29wZSB8fCB2bSkuJGV2YWwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRva2VuLmh0bWwpIHtcbiAgICAgICAgICAgICAgcmVwbGFjZShub2RlLCBwYXJzZVRlbXBsYXRlKHZhbHVlLCB0cnVlKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdm0uX2JpbmREaXIodG9rZW4uZGVzY3JpcHRvciwgbm9kZSwgaG9zdCwgc2NvcGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVwbGFjZShlbCwgZnJhZ0Nsb25lKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgYSBub2RlIGxpc3QgYW5kIHJldHVybiBhIGNoaWxkTGlua0ZuLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGVMaXN0fSBub2RlTGlzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNvbXBpbGVOb2RlTGlzdChub2RlTGlzdCwgb3B0aW9ucykge1xuICAgIHZhciBsaW5rRm5zID0gW107XG4gICAgdmFyIG5vZGVMaW5rRm4sIGNoaWxkTGlua0ZuLCBub2RlO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZUxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZUxpc3RbaV07XG4gICAgICBub2RlTGlua0ZuID0gY29tcGlsZU5vZGUobm9kZSwgb3B0aW9ucyk7XG4gICAgICBjaGlsZExpbmtGbiA9ICEobm9kZUxpbmtGbiAmJiBub2RlTGlua0ZuLnRlcm1pbmFsKSAmJiBub2RlLnRhZ05hbWUgIT09ICdTQ1JJUFQnICYmIG5vZGUuaGFzQ2hpbGROb2RlcygpID8gY29tcGlsZU5vZGVMaXN0KG5vZGUuY2hpbGROb2Rlcywgb3B0aW9ucykgOiBudWxsO1xuICAgICAgbGlua0Zucy5wdXNoKG5vZGVMaW5rRm4sIGNoaWxkTGlua0ZuKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmtGbnMubGVuZ3RoID8gbWFrZUNoaWxkTGlua0ZuKGxpbmtGbnMpIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgY2hpbGQgbGluayBmdW5jdGlvbiBmb3IgYSBub2RlJ3MgY2hpbGROb2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxGdW5jdGlvbj59IGxpbmtGbnNcbiAgICogQHJldHVybiB7RnVuY3Rpb259IGNoaWxkTGlua0ZuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1ha2VDaGlsZExpbmtGbihsaW5rRm5zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNoaWxkTGlua0ZuKHZtLCBub2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAgIHZhciBub2RlLCBub2RlTGlua0ZuLCBjaGlsZHJlbkxpbmtGbjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gMCwgbCA9IGxpbmtGbnMubGVuZ3RoOyBpIDwgbDsgbisrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tuXTtcbiAgICAgICAgbm9kZUxpbmtGbiA9IGxpbmtGbnNbaSsrXTtcbiAgICAgICAgY2hpbGRyZW5MaW5rRm4gPSBsaW5rRm5zW2krK107XG4gICAgICAgIC8vIGNhY2hlIGNoaWxkTm9kZXMgYmVmb3JlIGxpbmtpbmcgcGFyZW50LCBmaXggIzY1N1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHRvQXJyYXkobm9kZS5jaGlsZE5vZGVzKTtcbiAgICAgICAgaWYgKG5vZGVMaW5rRm4pIHtcbiAgICAgICAgICBub2RlTGlua0ZuKHZtLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuTGlua0ZuKSB7XG4gICAgICAgICAgY2hpbGRyZW5MaW5rRm4odm0sIGNoaWxkTm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgZm9yIGVsZW1lbnQgZGlyZWN0aXZlcyAoY3VzdG9tIGVsZW1lbnRzIHRoYXQgc2hvdWxkXG4gICAqIGJlIHJlc292bGVkIGFzIHRlcm1pbmFsIGRpcmVjdGl2ZXMpLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNoZWNrRWxlbWVudERpcmVjdGl2ZXMoZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGFnID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChjb21tb25UYWdSRS50ZXN0KHRhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZWxlbWVudERpcmVjdGl2ZXMnLCB0YWcpO1xuICAgIGlmIChkZWYpIHtcbiAgICAgIHJldHVybiBtYWtlVGVybWluYWxOb2RlTGlua0ZuKGVsLCB0YWcsICcnLCBvcHRpb25zLCBkZWYpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGEgY29tcG9uZW50LiBJZiB5ZXMsIHJldHVyblxuICAgKiBhIGNvbXBvbmVudCBsaW5rIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICovXG5cbiAgZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gY2hlY2tDb21wb25lbnRBdHRyKGVsLCBvcHRpb25zKTtcbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICB2YXIgcmVmID0gZmluZFJlZihlbCk7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgbmFtZTogJ2NvbXBvbmVudCcsXG4gICAgICAgIHJlZjogcmVmLFxuICAgICAgICBleHByZXNzaW9uOiBjb21wb25lbnQuaWQsXG4gICAgICAgIGRlZjogaW50ZXJuYWxEaXJlY3RpdmVzLmNvbXBvbmVudCxcbiAgICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgICAgbGl0ZXJhbDogIWNvbXBvbmVudC5keW5hbWljXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgY29tcG9uZW50TGlua0ZuID0gZnVuY3Rpb24gY29tcG9uZW50TGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlYWN0aXZlKChzY29wZSB8fCB2bSkuJHJlZnMsIHJlZiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgdm0uX2JpbmREaXIoZGVzY3JpcHRvciwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICAgIH07XG4gICAgICBjb21wb25lbnRMaW5rRm4udGVybWluYWwgPSB0cnVlO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudExpbmtGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgYW4gZWxlbWVudCBmb3IgdGVybWluYWwgZGlyZWN0aXZlcyBpbiBmaXhlZCBvcmRlci5cbiAgICogSWYgaXQgZmluZHMgb25lLCByZXR1cm4gYSB0ZXJtaW5hbCBsaW5rIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICAgKi9cblxuICBmdW5jdGlvbiBjaGVja1Rlcm1pbmFsRGlyZWN0aXZlcyhlbCwgb3B0aW9ucykge1xuICAgIC8vIHNraXAgdi1wcmVcbiAgICBpZiAoZ2V0QXR0cihlbCwgJ3YtcHJlJykgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBza2lwO1xuICAgIH1cbiAgICAvLyBza2lwIHYtZWxzZSBibG9jaywgYnV0IG9ubHkgaWYgZm9sbG93aW5nIHYtaWZcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCd2LWVsc2UnKSkge1xuICAgICAgdmFyIHByZXYgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgaWYgKHByZXYgJiYgcHJldi5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgICAgICByZXR1cm4gc2tpcDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHZhbHVlLCBkaXJOYW1lO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGVybWluYWxEaXJlY3RpdmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZGlyTmFtZSA9IHRlcm1pbmFsRGlyZWN0aXZlc1tpXTtcbiAgICAgIHZhbHVlID0gZWwuZ2V0QXR0cmlidXRlKCd2LScgKyBkaXJOYW1lKTtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtYWtlVGVybWluYWxOb2RlTGlua0ZuKGVsLCBkaXJOYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2tpcCgpIHt9XG4gIHNraXAudGVybWluYWwgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBCdWlsZCBhIG5vZGUgbGluayBmdW5jdGlvbiBmb3IgYSB0ZXJtaW5hbCBkaXJlY3RpdmUuXG4gICAqIEEgdGVybWluYWwgbGluayBmdW5jdGlvbiB0ZXJtaW5hdGVzIHRoZSBjdXJyZW50XG4gICAqIGNvbXBpbGF0aW9uIHJlY3Vyc2lvbiBhbmQgaGFuZGxlcyBjb21waWxhdGlvbiBvZiB0aGVcbiAgICogc3VidHJlZSBpbiB0aGUgZGlyZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJOYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW2RlZl1cbiAgICogQHJldHVybiB7RnVuY3Rpb259IHRlcm1pbmFsTGlua0ZuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4oZWwsIGRpck5hbWUsIHZhbHVlLCBvcHRpb25zLCBkZWYpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUodmFsdWUpO1xuICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgbmFtZTogZGlyTmFtZSxcbiAgICAgIGV4cHJlc3Npb246IHBhcnNlZC5leHByZXNzaW9uLFxuICAgICAgZmlsdGVyczogcGFyc2VkLmZpbHRlcnMsXG4gICAgICByYXc6IHZhbHVlLFxuICAgICAgLy8gZWl0aGVyIGFuIGVsZW1lbnQgZGlyZWN0aXZlLCBvciBpZi9mb3JcbiAgICAgIC8vICMyMzY2IG9yIGN1c3RvbSB0ZXJtaW5hbCBkaXJlY3RpdmVcbiAgICAgIGRlZjogZGVmIHx8IHJlc29sdmVBc3NldChvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpck5hbWUpXG4gICAgfTtcbiAgICAvLyBjaGVjayByZWYgZm9yIHYtZm9yIGFuZCByb3V0ZXItdmlld1xuICAgIGlmIChkaXJOYW1lID09PSAnZm9yJyB8fCBkaXJOYW1lID09PSAncm91dGVyLXZpZXcnKSB7XG4gICAgICBkZXNjcmlwdG9yLnJlZiA9IGZpbmRSZWYoZWwpO1xuICAgIH1cbiAgICB2YXIgZm4gPSBmdW5jdGlvbiB0ZXJtaW5hbE5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgICAgaWYgKGRlc2NyaXB0b3IucmVmKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKChzY29wZSB8fCB2bSkuJHJlZnMsIGRlc2NyaXB0b3IucmVmLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHZtLl9iaW5kRGlyKGRlc2NyaXB0b3IsIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgfTtcbiAgICBmbi50ZXJtaW5hbCA9IHRydWU7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhlIGRpcmVjdGl2ZXMgb24gYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbGlua2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fE5hbWVkTm9kZU1hcH0gYXR0cnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNvbXBpbGVEaXJlY3RpdmVzKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgdmFyIGkgPSBhdHRycy5sZW5ndGg7XG4gICAgdmFyIGRpcnMgPSBbXTtcbiAgICB2YXIgYXR0ciwgbmFtZSwgdmFsdWUsIHJhd05hbWUsIHJhd1ZhbHVlLCBkaXJOYW1lLCBhcmcsIG1vZGlmaWVycywgZGlyRGVmLCB0b2tlbnMsIG1hdGNoZWQ7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXR0ciA9IGF0dHJzW2ldO1xuICAgICAgbmFtZSA9IHJhd05hbWUgPSBhdHRyLm5hbWU7XG4gICAgICB2YWx1ZSA9IHJhd1ZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgIHRva2VucyA9IHBhcnNlVGV4dCh2YWx1ZSk7XG4gICAgICAvLyByZXNldCBhcmdcbiAgICAgIGFyZyA9IG51bGw7XG4gICAgICAvLyBjaGVjayBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG5cbiAgICAgIC8vIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uc1xuICAgICAgaWYgKHRva2Vucykge1xuICAgICAgICB2YWx1ZSA9IHRva2Vuc1RvRXhwKHRva2Vucyk7XG4gICAgICAgIGFyZyA9IG5hbWU7XG4gICAgICAgIHB1c2hEaXIoJ2JpbmQnLCBkaXJlY3RpdmVzLmJpbmQsIHRva2Vucyk7XG4gICAgICAgIC8vIHdhcm4gYWdhaW5zdCBtaXhpbmcgbXVzdGFjaGVzIHdpdGggdi1iaW5kXG4gICAgICAgIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ2NsYXNzJyAmJiBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKGF0dHJzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIGF0dHIubmFtZSA9PT0gJzpjbGFzcycgfHwgYXR0ci5uYW1lID09PSAndi1iaW5kOmNsYXNzJztcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgd2FybignY2xhc3M9XCInICsgcmF3VmFsdWUgKyAnXCI6IERvIG5vdCBtaXggbXVzdGFjaGUgaW50ZXJwb2xhdGlvbiAnICsgJ2FuZCB2LWJpbmQgZm9yIFwiY2xhc3NcIiBvbiB0aGUgc2FtZSBlbGVtZW50LiBVc2Ugb25lIG9yIHRoZSBvdGhlci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuXG4gICAgICAgIC8vIHNwZWNpYWwgYXR0cmlidXRlOiB0cmFuc2l0aW9uXG4gICAgICAgIGlmICh0cmFuc2l0aW9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgIG1vZGlmaWVycy5saXRlcmFsID0gIWJpbmRSRS50ZXN0KG5hbWUpO1xuICAgICAgICAgIHB1c2hEaXIoJ3RyYW5zaXRpb24nLCBpbnRlcm5hbERpcmVjdGl2ZXMudHJhbnNpdGlvbik7XG4gICAgICAgIH0gZWxzZVxuXG4gICAgICAgICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBhcmcgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICAgICAgcHVzaERpcignb24nLCBkaXJlY3RpdmVzLm9uKTtcbiAgICAgICAgICB9IGVsc2VcblxuICAgICAgICAgICAgLy8gYXR0cmlidXRlIGJpbmRpbmdzXG4gICAgICAgICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgZGlyTmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgICAgICAgaWYgKGRpck5hbWUgPT09ICdzdHlsZScgfHwgZGlyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIHB1c2hEaXIoZGlyTmFtZSwgaW50ZXJuYWxEaXJlY3RpdmVzW2Rpck5hbWVdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmcgPSBkaXJOYW1lO1xuICAgICAgICAgICAgICAgIHB1c2hEaXIoJ2JpbmQnLCBkaXJlY3RpdmVzLmJpbmQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2VcblxuICAgICAgICAgICAgICAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICAgICAgICBpZiAobWF0Y2hlZCA9IG5hbWUubWF0Y2goZGlyQXR0clJFKSkge1xuICAgICAgICAgICAgICAgIGRpck5hbWUgPSBtYXRjaGVkWzFdO1xuICAgICAgICAgICAgICAgIGFyZyA9IG1hdGNoZWRbMl07XG5cbiAgICAgICAgICAgICAgICAvLyBza2lwIHYtZWxzZSAod2hlbiB1c2VkIHdpdGggdi1zaG93KVxuICAgICAgICAgICAgICAgIGlmIChkaXJOYW1lID09PSAnZWxzZScpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpckRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpck5hbWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgYXNzZXJ0QXNzZXQoZGlyRGVmLCAnZGlyZWN0aXZlJywgZGlyTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRpckRlZikge1xuICAgICAgICAgICAgICAgICAgcHVzaERpcihkaXJOYW1lLCBkaXJEZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1c2ggYSBkaXJlY3RpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyTmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBkZWZcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaW50ZXJwVG9rZW5zXVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gcHVzaERpcihkaXJOYW1lLCBkZWYsIGludGVycFRva2Vucykge1xuICAgICAgdmFyIGhhc09uZVRpbWVUb2tlbiA9IGludGVycFRva2VucyAmJiBoYXNPbmVUaW1lKGludGVycFRva2Vucyk7XG4gICAgICB2YXIgcGFyc2VkID0gIWhhc09uZVRpbWVUb2tlbiAmJiBwYXJzZURpcmVjdGl2ZSh2YWx1ZSk7XG4gICAgICBkaXJzLnB1c2goe1xuICAgICAgICBuYW1lOiBkaXJOYW1lLFxuICAgICAgICBhdHRyOiByYXdOYW1lLFxuICAgICAgICByYXc6IHJhd1ZhbHVlLFxuICAgICAgICBkZWY6IGRlZixcbiAgICAgICAgYXJnOiBhcmcsXG4gICAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgICAgICAvLyBjb252ZXJzaW9uIGZyb20gaW50ZXJwb2xhdGlvbiBzdHJpbmdzIHdpdGggb25lLXRpbWUgdG9rZW5cbiAgICAgICAgLy8gdG8gZXhwcmVzc2lvbiBpcyBkaWZmZXJlZCB1bnRpbCBkaXJlY3RpdmUgYmluZCB0aW1lIHNvIHRoYXQgd2VcbiAgICAgICAgLy8gaGF2ZSBhY2Nlc3MgdG8gdGhlIGFjdHVhbCB2bSBjb250ZXh0IGZvciBvbmUtdGltZSBiaW5kaW5ncy5cbiAgICAgICAgZXhwcmVzc2lvbjogcGFyc2VkICYmIHBhcnNlZC5leHByZXNzaW9uLFxuICAgICAgICBmaWx0ZXJzOiBwYXJzZWQgJiYgcGFyc2VkLmZpbHRlcnMsXG4gICAgICAgIGludGVycDogaW50ZXJwVG9rZW5zLFxuICAgICAgICBoYXNPbmVUaW1lOiBoYXNPbmVUaW1lVG9rZW5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChkaXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG1ha2VOb2RlTGlua0ZuKGRpcnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBtb2RpZmllcnMgZnJvbSBkaXJlY3RpdmUgYXR0cmlidXRlIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMobmFtZSkge1xuICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgaSA9IG1hdGNoLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgcmVzW21hdGNoW2ldLnNsaWNlKDEpXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSBsaW5rIGZ1bmN0aW9uIGZvciBhbGwgZGlyZWN0aXZlcyBvbiBhIHNpbmdsZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkaXJlY3RpdmVzXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBkaXJlY3RpdmVzTGlua0ZuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1ha2VOb2RlTGlua0ZuKGRpcmVjdGl2ZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgICAvLyByZXZlcnNlIGFwcGx5IGJlY2F1c2UgaXQncyBzb3J0ZWQgbG93IHRvIGhpZ2hcbiAgICAgIHZhciBpID0gZGlyZWN0aXZlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZtLl9iaW5kRGlyKGRpcmVjdGl2ZXNbaV0sIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBpbnRlcnBvbGF0aW9uIHN0cmluZyBjb250YWlucyBvbmUtdGltZSB0b2tlbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHRva2Vuc1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuICBmdW5jdGlvbiBoYXNPbmVUaW1lKHRva2Vucykge1xuICAgIHZhciBpID0gdG9rZW5zLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAodG9rZW5zW2ldLm9uZVRpbWUpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzcGVjaWFsQ2hhclJFID0gL1teXFx3XFwtOlxcLl0vO1xuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGFuIGVsZW1lbnQgb3IgYSBEb2N1bWVudEZyYWdtZW50IGJhc2VkIG9uIGFcbiAgICogaW5zdGFuY2Ugb3B0aW9uIG9iamVjdC4gVGhpcyBhbGxvd3MgdXMgdG8gdHJhbnNjbHVkZVxuICAgKiBhIHRlbXBsYXRlIG5vZGUvZnJhZ21lbnQgYmVmb3JlIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkLFxuICAgKiBzbyB0aGUgcHJvY2Vzc2VkIGZyYWdtZW50IGNhbiB0aGVuIGJlIGNsb25lZCBhbmQgcmV1c2VkXG4gICAqIGluIHYtZm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAgICovXG5cbiAgZnVuY3Rpb24gdHJhbnNjbHVkZShlbCwgb3B0aW9ucykge1xuICAgIC8vIGV4dHJhY3QgY29udGFpbmVyIGF0dHJpYnV0ZXMgdG8gcGFzcyB0aGVtIGRvd25cbiAgICAvLyB0byBjb21waWxlciwgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgY29tcGlsZWQgaW5cbiAgICAvLyBwYXJlbnQgc2NvcGUuIHdlIGFyZSBtdXRhdGluZyB0aGUgb3B0aW9ucyBvYmplY3QgaGVyZVxuICAgIC8vIGFzc3VtaW5nIHRoZSBzYW1lIG9iamVjdCB3aWxsIGJlIHVzZWQgZm9yIGNvbXBpbGVcbiAgICAvLyByaWdodCBhZnRlciB0aGlzLlxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zLl9jb250YWluZXJBdHRycyA9IGV4dHJhY3RBdHRycyhlbCk7XG4gICAgfVxuICAgIC8vIGZvciB0ZW1wbGF0ZSB0YWdzLCB3aGF0IHdlIHdhbnQgaXMgaXRzIGNvbnRlbnQgYXNcbiAgICAvLyBhIGRvY3VtZW50RnJhZ21lbnQgKGZvciBmcmFnbWVudCBpbnN0YW5jZXMpXG4gICAgaWYgKGlzVGVtcGxhdGUoZWwpKSB7XG4gICAgICBlbCA9IHBhcnNlVGVtcGxhdGUoZWwpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50ICYmICFvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICAgIG9wdGlvbnMudGVtcGxhdGUgPSAnPHNsb3Q+PC9zbG90Pic7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgICAgICBvcHRpb25zLl9jb250ZW50ID0gZXh0cmFjdENvbnRlbnQoZWwpO1xuICAgICAgICBlbCA9IHRyYW5zY2x1ZGVUZW1wbGF0ZShlbCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0ZyYWdtZW50KGVsKSkge1xuICAgICAgLy8gYW5jaG9ycyBmb3IgZnJhZ21lbnQgaW5zdGFuY2VcbiAgICAgIC8vIHBhc3NpbmcgaW4gYHBlcnNpc3Q6IHRydWVgIHRvIGF2b2lkIHRoZW0gYmVpbmdcbiAgICAgIC8vIGRpc2NhcmRlZCBieSBJRSBkdXJpbmcgdGVtcGxhdGUgY2xvbmluZ1xuICAgICAgcHJlcGVuZChjcmVhdGVBbmNob3IoJ3Ytc3RhcnQnLCB0cnVlKSwgZWwpO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoY3JlYXRlQW5jaG9yKCd2LWVuZCcsIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlIG9wdGlvbi5cbiAgICogSWYgdGhlIHJlcGxhY2Ugb3B0aW9uIGlzIHRydWUgdGhpcyB3aWxsIHN3YXAgdGhlICRlbC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRyYW5zY2x1ZGVUZW1wbGF0ZShlbCwgb3B0aW9ucykge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgdmFyIGZyYWcgPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0cnVlKTtcbiAgICBpZiAoZnJhZykge1xuICAgICAgdmFyIHJlcGxhY2VyID0gZnJhZy5maXJzdENoaWxkO1xuICAgICAgdmFyIHRhZyA9IHJlcGxhY2VyLnRhZ05hbWUgJiYgcmVwbGFjZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKG9wdGlvbnMucmVwbGFjZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1lvdSBhcmUgbW91bnRpbmcgYW4gaW5zdGFuY2Ugd2l0aCBhIHRlbXBsYXRlIHRvICcgKyAnPGJvZHk+LiBUaGlzIHdpbGwgcmVwbGFjZSA8Ym9keT4gZW50aXJlbHkuIFlvdSAnICsgJ3Nob3VsZCBwcm9iYWJseSB1c2UgYHJlcGxhY2U6IGZhbHNlYCBoZXJlLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZXJlIGFyZSBtYW55IGNhc2VzIHdoZXJlIHRoZSBpbnN0YW5jZSBtdXN0XG4gICAgICAgIC8vIGJlY29tZSBhIGZyYWdtZW50IGluc3RhbmNlOiBiYXNpY2FsbHkgYW55dGhpbmcgdGhhdFxuICAgICAgICAvLyBjYW4gY3JlYXRlIG1vcmUgdGhhbiAxIHJvb3Qgbm9kZXMuXG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gbXVsdGktY2hpbGRyZW4gdGVtcGxhdGVcbiAgICAgICAgZnJhZy5jaGlsZE5vZGVzLmxlbmd0aCA+IDEgfHxcbiAgICAgICAgLy8gbm9uLWVsZW1lbnQgdGVtcGxhdGVcbiAgICAgICAgcmVwbGFjZXIubm9kZVR5cGUgIT09IDEgfHxcbiAgICAgICAgLy8gc2luZ2xlIG5lc3RlZCBjb21wb25lbnRcbiAgICAgICAgdGFnID09PSAnY29tcG9uZW50JyB8fCByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpIHx8IGhhc0JpbmRBdHRyKHJlcGxhY2VyLCAnaXMnKSB8fFxuICAgICAgICAvLyBlbGVtZW50IGRpcmVjdGl2ZVxuICAgICAgICByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2VsZW1lbnREaXJlY3RpdmVzJywgdGFnKSB8fFxuICAgICAgICAvLyBmb3IgYmxvY2tcbiAgICAgICAgcmVwbGFjZXIuaGFzQXR0cmlidXRlKCd2LWZvcicpIHx8XG4gICAgICAgIC8vIGlmIGJsb2NrXG4gICAgICAgIHJlcGxhY2VyLmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5fcmVwbGFjZXJBdHRycyA9IGV4dHJhY3RBdHRycyhyZXBsYWNlcik7XG4gICAgICAgICAgbWVyZ2VBdHRycyhlbCwgcmVwbGFjZXIpO1xuICAgICAgICAgIHJldHVybiByZXBsYWNlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOiAnICsgdGVtcGxhdGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBhIGNvbXBvbmVudCBjb250YWluZXIncyBhdHRyaWJ1dGVzXG4gICAqIGludG8gYSBwbGFpbiBvYmplY3QgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGV4dHJhY3RBdHRycyhlbCkge1xuICAgIGlmIChlbC5ub2RlVHlwZSA9PT0gMSAmJiBlbC5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgIHJldHVybiB0b0FycmF5KGVsLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSB0aGUgYXR0cmlidXRlcyBvZiB0d28gZWxlbWVudHMsIGFuZCBtYWtlIHN1cmVcbiAgICogdGhlIGNsYXNzIG5hbWVzIGFyZSBtZXJnZWQgcHJvcGVybHkuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZnJvbVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRvXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1lcmdlQXR0cnMoZnJvbSwgdG8pIHtcbiAgICB2YXIgYXR0cnMgPSBmcm9tLmF0dHJpYnV0ZXM7XG4gICAgdmFyIGkgPSBhdHRycy5sZW5ndGg7XG4gICAgdmFyIG5hbWUsIHZhbHVlO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgdmFsdWUgPSBhdHRyc1tpXS52YWx1ZTtcbiAgICAgIGlmICghdG8uaGFzQXR0cmlidXRlKG5hbWUpICYmICFzcGVjaWFsQ2hhclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdG8uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsYXNzJyAmJiAhcGFyc2VUZXh0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS50cmltKCkuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgICBhZGRDbGFzcyh0bywgY2xzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNjYW4gYW5kIGRldGVybWluZSBzbG90IGNvbnRlbnQgZGlzdHJpYnV0aW9uLlxuICAgKiBXZSBkbyB0aGlzIGR1cmluZyB0cmFuc2NsdXNpb24gaW5zdGVhZCBhdCBjb21waWxlIHRpbWUgc28gdGhhdFxuICAgKiB0aGUgZGlzdHJpYnV0aW9uIGlzIGRlY291cGxlZCBmcm9tIHRoZSBjb21waWxhdGlvbiBvcmRlciBvZlxuICAgKiB0aGUgc2xvdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRlbnRcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVTbG90cyh2bSwgY29udGVudCkge1xuICAgIGlmICghY29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY29udGVudHMgPSB2bS5fc2xvdENvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgZWwsIG5hbWU7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZW50LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZWwgPSBjb250ZW50LmNoaWxkcmVuW2ldO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICAgIGlmIChuYW1lID0gZWwuZ2V0QXR0cmlidXRlKCdzbG90JykpIHtcbiAgICAgICAgKGNvbnRlbnRzW25hbWVdIHx8IChjb250ZW50c1tuYW1lXSA9IFtdKSkucHVzaChlbCk7XG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBjb250ZW50cykge1xuICAgICAgY29udGVudHNbbmFtZV0gPSBleHRyYWN0RnJhZ21lbnQoY29udGVudHNbbmFtZV0sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoY29udGVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIGNvbnRlbnRzWydkZWZhdWx0J10gPSBleHRyYWN0RnJhZ21lbnQoY29udGVudC5jaGlsZE5vZGVzLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBxdWFsaWZpZWQgY29udGVudCBub2RlcyBmcm9tIGEgbm9kZSBsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGVMaXN0fSBub2Rlc1xuICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICAgKi9cblxuICBmdW5jdGlvbiBleHRyYWN0RnJhZ21lbnQobm9kZXMsIHBhcmVudCkge1xuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIG5vZGVzID0gdG9BcnJheShub2Rlcyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAoaXNUZW1wbGF0ZShub2RlKSAmJiAhbm9kZS5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSAmJiAhbm9kZS5oYXNBdHRyaWJ1dGUoJ3YtZm9yJykpIHtcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICBub2RlID0gcGFyc2VUZW1wbGF0ZShub2RlKTtcbiAgICAgIH1cbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cblxuXG4gIHZhciBjb21waWxlciA9IE9iamVjdC5mcmVlemUoe1xuICBcdGNvbXBpbGU6IGNvbXBpbGUsXG4gIFx0Y29tcGlsZUFuZExpbmtQcm9wczogY29tcGlsZUFuZExpbmtQcm9wcyxcbiAgXHRjb21waWxlUm9vdDogY29tcGlsZVJvb3QsXG4gIFx0dGVybWluYWxEaXJlY3RpdmVzOiB0ZXJtaW5hbERpcmVjdGl2ZXMsXG4gIFx0dHJhbnNjbHVkZTogdHJhbnNjbHVkZSxcbiAgXHRyZXNvbHZlU2xvdHM6IHJlc29sdmVTbG90c1xuICB9KTtcblxuICBmdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgICAvKipcbiAgICAgKiBBY2Nlc3NvciBmb3IgYCRkYXRhYCBwcm9wZXJ0eSwgc2luY2Ugc2V0dGluZyAkZGF0YVxuICAgICAqIHJlcXVpcmVzIG9ic2VydmluZyB0aGUgbmV3IG9iamVjdCBhbmQgdXBkYXRpbmdcbiAgICAgKiBwcm94aWVkIHByb3BlcnRpZXMuXG4gICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0RhdGEpIHtcbiAgICAgICAgaWYgKG5ld0RhdGEgIT09IHRoaXMuX2RhdGEpIHtcbiAgICAgICAgICB0aGlzLl9zZXREYXRhKG5ld0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTZXR1cCB0aGUgc2NvcGUgb2YgYW4gaW5zdGFuY2UsIHdoaWNoIGNvbnRhaW5zOlxuICAgICAqIC0gb2JzZXJ2ZWQgZGF0YVxuICAgICAqIC0gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgICAqIC0gdXNlciBtZXRob2RzXG4gICAgICogLSBtZXRhIHByb3BlcnRpZXNcbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2luaXRQcm9wcygpO1xuICAgICAgdGhpcy5faW5pdE1ldGEoKTtcbiAgICAgIHRoaXMuX2luaXRNZXRob2RzKCk7XG4gICAgICB0aGlzLl9pbml0RGF0YSgpO1xuICAgICAgdGhpcy5faW5pdENvbXB1dGVkKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgcHJvcHMuXG4gICAgICovXG5cbiAgICBWdWUucHJvdG90eXBlLl9pbml0UHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgICB2YXIgZWwgPSBvcHRpb25zLmVsO1xuICAgICAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgICAgIGlmIChwcm9wcyAmJiAhZWwpIHtcbiAgICAgICAgJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1Byb3BzIHdpbGwgbm90IGJlIGNvbXBpbGVkIGlmIG5vIGBlbGAgb3B0aW9uIGlzICcgKyAncHJvdmlkZWQgYXQgaW5zdGFudGlhdGlvbi4nKTtcbiAgICAgIH1cbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBjb252ZXJ0IHN0cmluZyBzZWxlY3RvcnMgaW50byBlbGVtZW50IG5vd1xuICAgICAgZWwgPSBvcHRpb25zLmVsID0gcXVlcnkoZWwpO1xuICAgICAgdGhpcy5fcHJvcHNVbmxpbmtGbiA9IGVsICYmIGVsLm5vZGVUeXBlID09PSAxICYmIHByb3BzXG4gICAgICAvLyBwcm9wcyBtdXN0IGJlIGxpbmtlZCBpbiBwcm9wZXIgc2NvcGUgaWYgaW5zaWRlIHYtZm9yXG4gICAgICA/IGNvbXBpbGVBbmRMaW5rUHJvcHModGhpcywgZWwsIHByb3BzLCB0aGlzLl9zY29wZSkgOiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBkYXRhLlxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS5faW5pdERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGF0YUZuID0gdGhpcy4kb3B0aW9ucy5kYXRhO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhID0gZGF0YUZuID8gZGF0YUZuKCkgOiB7fTtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXMuX3Byb3BzO1xuICAgICAgdmFyIHJ1bnRpbWVEYXRhID0gdGhpcy5fcnVudGltZURhdGEgPyB0eXBlb2YgdGhpcy5fcnVudGltZURhdGEgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9ydW50aW1lRGF0YSgpIDogdGhpcy5fcnVudGltZURhdGEgOiBudWxsO1xuICAgICAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgIHZhciBpLCBrZXk7XG4gICAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIC8vIHRoZXJlIGFyZSB0d28gc2NlbmFyaW9zIHdoZXJlIHdlIGNhbiBwcm94eSBhIGRhdGEga2V5OlxuICAgICAgICAvLyAxLiBpdCdzIG5vdCBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wXG4gICAgICAgIC8vIDIuIGl0J3MgcHJvdmlkZWQgdmlhIGEgaW5zdGFudGlhdGlvbiBvcHRpb24gQU5EIHRoZXJlIGFyZSBub1xuICAgICAgICAvLyAgICB0ZW1wbGF0ZSBwcm9wIHByZXNlbnRcbiAgICAgICAgaWYgKCFwcm9wcyB8fCAhaGFzT3duKHByb3BzLCBrZXkpIHx8IHJ1bnRpbWVEYXRhICYmIGhhc093bihydW50aW1lRGF0YSwga2V5KSAmJiBwcm9wc1trZXldLnJhdyA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3Byb3h5KGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignRGF0YSBmaWVsZCBcIicgKyBrZXkgKyAnXCIgaXMgYWxyZWFkeSBkZWZpbmVkICcgKyAnYXMgYSBwcm9wLiBVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG9ic2VydmUgZGF0YVxuICAgICAgb2JzZXJ2ZShkYXRhLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3dhcCB0aGUgaW5zdGFuY2UncyAkZGF0YS4gQ2FsbGVkIGluICRkYXRhJ3Mgc2V0dGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld0RhdGFcbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuX3NldERhdGEgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgbmV3RGF0YSA9IG5ld0RhdGEgfHwge307XG4gICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICB0aGlzLl9kYXRhID0gbmV3RGF0YTtcbiAgICAgIHZhciBrZXlzLCBrZXksIGk7XG4gICAgICAvLyB1bnByb3h5IGtleXMgbm90IHByZXNlbnQgaW4gbmV3IGRhdGFcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhvbGREYXRhKTtcbiAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCEoa2V5IGluIG5ld0RhdGEpKSB7XG4gICAgICAgICAgdGhpcy5fdW5wcm94eShrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBwcm94eSBrZXlzIG5vdCBhbHJlYWR5IHByb3hpZWQsXG4gICAgICAvLyBhbmQgdHJpZ2dlciBjaGFuZ2UgZm9yIGNoYW5nZWQgdmFsdWVzXG4gICAgICBrZXlzID0gT2JqZWN0LmtleXMobmV3RGF0YSk7XG4gICAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghaGFzT3duKHRoaXMsIGtleSkpIHtcbiAgICAgICAgICAvLyBuZXcgcHJvcGVydHlcbiAgICAgICAgICB0aGlzLl9wcm94eShrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbGREYXRhLl9fb2JfXy5yZW1vdmVWbSh0aGlzKTtcbiAgICAgIG9ic2VydmUobmV3RGF0YSwgdGhpcyk7XG4gICAgICB0aGlzLl9kaWdlc3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJveHkgYSBwcm9wZXJ0eSwgc28gdGhhdFxuICAgICAqIHZtLnByb3AgPT09IHZtLl9kYXRhLnByb3BcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuX3Byb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgLy8gbmVlZCB0byBzdG9yZSByZWYgdG8gc2VsZiBoZXJlXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlc2UgZ2V0dGVyL3NldHRlcnMgbWlnaHRcbiAgICAgICAgLy8gYmUgY2FsbGVkIGJ5IGNoaWxkIHNjb3BlcyB2aWFcbiAgICAgICAgLy8gcHJvdG90eXBlIGluaGVyaXRhbmNlLlxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIHByb3h5R2V0dGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2RhdGFba2V5XTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gcHJveHlTZXR0ZXIodmFsKSB7XG4gICAgICAgICAgICBzZWxmLl9kYXRhW2tleV0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVW5wcm94eSBhIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS5fdW5wcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZvcmNlIHVwZGF0ZSBvbiBldmVyeSB3YXRjaGVyIGluIHNjb3BlLlxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl93YXRjaGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5fd2F0Y2hlcnNbaV0udXBkYXRlKHRydWUpOyAvLyBzaGFsbG93IHVwZGF0ZXNcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0dXAgY29tcHV0ZWQgcHJvcGVydGllcy4gVGhleSBhcmUgZXNzZW50aWFsbHlcbiAgICAgKiBzcGVjaWFsIGdldHRlci9zZXR0ZXJzXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBub29wKCkge31cbiAgICBWdWUucHJvdG90eXBlLl9pbml0Q29tcHV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLiRvcHRpb25zLmNvbXB1dGVkO1xuICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICAgICAgICB2YXIgZGVmID0ge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWYuZ2V0ID0gbWFrZUNvbXB1dGVkR2V0dGVyKHVzZXJEZWYsIHRoaXMpO1xuICAgICAgICAgICAgZGVmLnNldCA9IG5vb3A7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZi5nZXQgPSB1c2VyRGVmLmdldCA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlID8gbWFrZUNvbXB1dGVkR2V0dGVyKHVzZXJEZWYuZ2V0LCB0aGlzKSA6IGJpbmQodXNlckRlZi5nZXQsIHRoaXMpIDogbm9vcDtcbiAgICAgICAgICAgIGRlZi5zZXQgPSB1c2VyRGVmLnNldCA/IGJpbmQodXNlckRlZi5zZXQsIHRoaXMpIDogbm9vcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlQ29tcHV0ZWRHZXR0ZXIoZ2V0dGVyLCBvd25lcikge1xuICAgICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihvd25lciwgZ2V0dGVyLCBudWxsLCB7XG4gICAgICAgIGxhenk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyKCkge1xuICAgICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHVwIGluc3RhbmNlIG1ldGhvZHMuIE1ldGhvZHMgbXVzdCBiZSBib3VuZCB0byB0aGVcbiAgICAgKiBpbnN0YW5jZSBzaW5jZSB0aGV5IG1pZ2h0IGJlIHBhc3NlZCBkb3duIGFzIGEgcHJvcCB0b1xuICAgICAqIGNoaWxkIGNvbXBvbmVudHMuXG4gICAgICovXG5cbiAgICBWdWUucHJvdG90eXBlLl9pbml0TWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtZXRob2RzID0gdGhpcy4kb3B0aW9ucy5tZXRob2RzO1xuICAgICAgaWYgKG1ldGhvZHMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgICAgICB0aGlzW2tleV0gPSBiaW5kKG1ldGhvZHNba2V5XSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBtZXRhIGluZm9ybWF0aW9uIGxpa2UgJGluZGV4LCAka2V5ICYgJHZhbHVlLlxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS5faW5pdE1ldGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWV0YXMgPSB0aGlzLiRvcHRpb25zLl9tZXRhO1xuICAgICAgaWYgKG1ldGFzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtZXRhcykge1xuICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHRoaXMsIGtleSwgbWV0YXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGV2ZW50UkUgPSAvXnYtb246fF5ALztcblxuICBmdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gICAgLyoqXG4gICAgICogU2V0dXAgdGhlIGluc3RhbmNlJ3Mgb3B0aW9uIGV2ZW50cyAmIHdhdGNoZXJzLlxuICAgICAqIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgd2UgcHVsbCBpdCBmcm9tIHRoZVxuICAgICAqIGluc3RhbmNlJ3MgbWV0aG9kcyBieSBuYW1lLlxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS5faW5pdEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLl9hc0NvbXBvbmVudCkge1xuICAgICAgICByZWdpc3RlckNvbXBvbmVudEV2ZW50cyh0aGlzLCBvcHRpb25zLmVsKTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVyQ2FsbGJhY2tzKHRoaXMsICckb24nLCBvcHRpb25zLmV2ZW50cyk7XG4gICAgICByZWdpc3RlckNhbGxiYWNrcyh0aGlzLCAnJHdhdGNoJywgb3B0aW9ucy53YXRjaCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHYtb24gZXZlbnRzIG9uIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudEV2ZW50cyh2bSwgZWwpIHtcbiAgICAgIHZhciBhdHRycyA9IGVsLmF0dHJpYnV0ZXM7XG4gICAgICB2YXIgbmFtZSwgaGFuZGxlcjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgICBpZiAoZXZlbnRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShldmVudFJFLCAnJyk7XG4gICAgICAgICAgaGFuZGxlciA9ICh2bS5fc2NvcGUgfHwgdm0uX2NvbnRleHQpLiRldmFsKGF0dHJzW2ldLnZhbHVlLCB0cnVlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuX2Zyb21QYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdm0uJG9uKG5hbWUucmVwbGFjZShldmVudFJFKSwgaGFuZGxlcik7XG4gICAgICAgICAgfSBlbHNlIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm4oJ3Ytb246JyArIG5hbWUgKyAnPVwiJyArIGF0dHJzW2ldLnZhbHVlICsgJ1wiJyArICh2bS4kb3B0aW9ucy5uYW1lID8gJyBvbiBjb21wb25lbnQgPCcgKyB2bS4kb3B0aW9ucy5uYW1lICsgJz4nIDogJycpICsgJyBleHBlY3RzIGEgZnVuY3Rpb24gdmFsdWUsIGdvdCAnICsgaGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgY2FsbGJhY2tzIGZvciBvcHRpb24gZXZlbnRzIGFuZCB3YXRjaGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJDYWxsYmFja3Modm0sIGFjdGlvbiwgaGFzaCkge1xuICAgICAgaWYgKCFoYXNoKSByZXR1cm47XG4gICAgICB2YXIgaGFuZGxlcnMsIGtleSwgaSwgajtcbiAgICAgIGZvciAoa2V5IGluIGhhc2gpIHtcbiAgICAgICAgaGFuZGxlcnMgPSBoYXNoW2tleV07XG4gICAgICAgIGlmIChpc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlcnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0byByZWdpc3RlciBhbiBldmVudC93YXRjaCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd8T2JqZWN0fSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBoYW5kbGVyO1xuICAgICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdm1bYWN0aW9uXShrZXksIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gICAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzICYmIG1ldGhvZHNbaGFuZGxlcl07XG4gICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICB2bVthY3Rpb25dKGtleSwgbWV0aG9kLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignVW5rbm93biBtZXRob2Q6IFwiJyArIGhhbmRsZXIgKyAnXCIgd2hlbiAnICsgJ3JlZ2lzdGVyaW5nIGNhbGxiYWNrIGZvciAnICsgYWN0aW9uICsgJzogXCInICsga2V5ICsgJ1wiLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgJiYgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVyLmhhbmRsZXIsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHVwIHJlY3Vyc2l2ZSBhdHRhY2hlZC9kZXRhY2hlZCBjYWxsc1xuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS5faW5pdERPTUhvb2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy4kb24oJ2hvb2s6YXR0YWNoZWQnLCBvbkF0dGFjaGVkKTtcbiAgICAgIHRoaXMuJG9uKCdob29rOmRldGFjaGVkJywgb25EZXRhY2hlZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgYXR0YWNoZWQgaG9vayBvbiBjaGlsZHJlblxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gb25BdHRhY2hlZCgpIHtcbiAgICAgIGlmICghdGhpcy5faXNBdHRhY2hlZCkge1xuICAgICAgICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChjYWxsQXR0YWNoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRvciB0byBjYWxsIGF0dGFjaGVkIGhvb2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY2FsbEF0dGFjaChjaGlsZCkge1xuICAgICAgaWYgKCFjaGlsZC5faXNBdHRhY2hlZCAmJiBpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgICAgIGNoaWxkLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byByZWN1cnNpdmVseSBjYWxsIGRldGFjaGVkIGhvb2sgb24gY2hpbGRyZW5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIG9uRGV0YWNoZWQoKSB7XG4gICAgICBpZiAodGhpcy5faXNBdHRhY2hlZCkge1xuICAgICAgICB0aGlzLl9pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2FsbERldGFjaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0b3IgdG8gY2FsbCBkZXRhY2hlZCBob29rXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGNhbGxEZXRhY2goY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5faXNBdHRhY2hlZCAmJiAhaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgICAgICBjaGlsZC5fY2FsbEhvb2soJ2RldGFjaGVkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBhbGwgaGFuZGxlcnMgZm9yIGEgaG9va1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhvb2tcbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuX2NhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3ByZS1ob29rOicgKyBob29rKTtcbiAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuJG9wdGlvbnNbaG9va107XG4gICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbiAgLyoqXG4gICAqIEEgZGlyZWN0aXZlIGxpbmtzIGEgRE9NIGVsZW1lbnQgd2l0aCBhIHBpZWNlIG9mIGRhdGEsXG4gICAqIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyBhbiBleHByZXNzaW9uLlxuICAgKiBJdCByZWdpc3RlcnMgYSB3YXRjaGVyIHdpdGggdGhlIGV4cHJlc3Npb24gYW5kIGNhbGxzXG4gICAqIHRoZSBET00gdXBkYXRlIGZ1bmN0aW9uIHdoZW4gYSBjaGFuZ2UgaXMgdHJpZ2dlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvclxuICAgKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBuYW1lXG4gICAqICAgICAgICAgICAgICAgICAtIHtPYmplY3R9IGRlZlxuICAgKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBleHByZXNzaW9uXG4gICAqICAgICAgICAgICAgICAgICAtIHtBcnJheTxPYmplY3Q+fSBbZmlsdGVyc11cbiAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGxpdGVyYWxcbiAgICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gYXR0clxuICAgKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSByYXdcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZiAtIGRpcmVjdGl2ZSBkZWZpbml0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdIC0gdHJhbnNjbHVzaW9uIGhvc3QgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gb3duZXIgZnJhZ21lbnRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBEaXJlY3RpdmUoZGVzY3JpcHRvciwgdm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIHRoaXMudm0gPSB2bTtcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgLy8gY29weSBkZXNjcmlwdG9yIHByb3BlcnRpZXNcbiAgICB0aGlzLmRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yO1xuICAgIHRoaXMubmFtZSA9IGRlc2NyaXB0b3IubmFtZTtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBkZXNjcmlwdG9yLmV4cHJlc3Npb247XG4gICAgdGhpcy5hcmcgPSBkZXNjcmlwdG9yLmFyZztcbiAgICB0aGlzLm1vZGlmaWVycyA9IGRlc2NyaXB0b3IubW9kaWZpZXJzO1xuICAgIHRoaXMuZmlsdGVycyA9IGRlc2NyaXB0b3IuZmlsdGVycztcbiAgICB0aGlzLmxpdGVyYWwgPSB0aGlzLm1vZGlmaWVycyAmJiB0aGlzLm1vZGlmaWVycy5saXRlcmFsO1xuICAgIC8vIHByaXZhdGVcbiAgICB0aGlzLl9sb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ib3VuZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IG51bGw7XG4gICAgLy8gbGluayBjb250ZXh0XG4gICAgdGhpcy5faG9zdCA9IGhvc3Q7XG4gICAgdGhpcy5fc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLl9mcmFnID0gZnJhZztcbiAgICAvLyBzdG9yZSBkaXJlY3RpdmVzIG9uIG5vZGUgaW4gZGV2IG1vZGVcbiAgICBpZiAoJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuZWwpIHtcbiAgICAgIHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzID0gdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMgfHwgW107XG4gICAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBkaXJlY3RpdmUsIG1peGluIGRlZmluaXRpb24gcHJvcGVydGllcyxcbiAgICogc2V0dXAgdGhlIHdhdGNoZXIsIGNhbGwgZGVmaW5pdGlvbiBiaW5kKCkgYW5kIHVwZGF0ZSgpXG4gICAqIGlmIHByZXNlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZcbiAgICovXG5cbiAgRGlyZWN0aXZlLnByb3RvdHlwZS5fYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHRoaXMuZGVzY3JpcHRvcjtcblxuICAgIC8vIHJlbW92ZSBhdHRyaWJ1dGVcbiAgICBpZiAoKG5hbWUgIT09ICdjbG9haycgfHwgdGhpcy52bS5faXNDb21waWxlZCkgJiYgdGhpcy5lbCAmJiB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSkge1xuICAgICAgdmFyIGF0dHIgPSBkZXNjcmlwdG9yLmF0dHIgfHwgJ3YtJyArIG5hbWU7XG4gICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICB9XG5cbiAgICAvLyBjb3B5IGRlZiBwcm9wZXJ0aWVzXG4gICAgdmFyIGRlZiA9IGRlc2NyaXB0b3IuZGVmO1xuICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnVwZGF0ZSA9IGRlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5kKHRoaXMsIGRlZik7XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgZGlyZWN0aXZlIHBhcmFtc1xuICAgIHRoaXMuX3NldHVwUGFyYW1zKCk7XG5cbiAgICAvLyBpbml0aWFsIGJpbmRcbiAgICBpZiAodGhpcy5iaW5kKSB7XG4gICAgICB0aGlzLmJpbmQoKTtcbiAgICB9XG4gICAgdGhpcy5fYm91bmQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMubGl0ZXJhbCkge1xuICAgICAgdGhpcy51cGRhdGUgJiYgdGhpcy51cGRhdGUoZGVzY3JpcHRvci5yYXcpO1xuICAgIH0gZWxzZSBpZiAoKHRoaXMuZXhwcmVzc2lvbiB8fCB0aGlzLm1vZGlmaWVycykgJiYgKHRoaXMudXBkYXRlIHx8IHRoaXMudHdvV2F5KSAmJiAhdGhpcy5fY2hlY2tTdGF0ZW1lbnQoKSkge1xuICAgICAgLy8gd3JhcHBlZCB1cGRhdGVyIGZvciBjb250ZXh0XG4gICAgICB2YXIgZGlyID0gdGhpcztcbiAgICAgIGlmICh0aGlzLnVwZGF0ZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUgPSBmdW5jdGlvbiAodmFsLCBvbGRWYWwpIHtcbiAgICAgICAgICBpZiAoIWRpci5fbG9ja2VkKSB7XG4gICAgICAgICAgICBkaXIudXBkYXRlKHZhbCwgb2xkVmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91cGRhdGUgPSBub29wO1xuICAgICAgfVxuICAgICAgdmFyIHByZVByb2Nlc3MgPSB0aGlzLl9wcmVQcm9jZXNzID8gYmluZCh0aGlzLl9wcmVQcm9jZXNzLCB0aGlzKSA6IG51bGw7XG4gICAgICB2YXIgcG9zdFByb2Nlc3MgPSB0aGlzLl9wb3N0UHJvY2VzcyA/IGJpbmQodGhpcy5fcG9zdFByb2Nlc3MsIHRoaXMpIDogbnVsbDtcbiAgICAgIHZhciB3YXRjaGVyID0gdGhpcy5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHRoaXMudm0sIHRoaXMuZXhwcmVzc2lvbiwgdGhpcy5fdXBkYXRlLCAvLyBjYWxsYmFja1xuICAgICAge1xuICAgICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICAgIHR3b1dheTogdGhpcy50d29XYXksXG4gICAgICAgIGRlZXA6IHRoaXMuZGVlcCxcbiAgICAgICAgcHJlUHJvY2VzczogcHJlUHJvY2VzcyxcbiAgICAgICAgcG9zdFByb2Nlc3M6IHBvc3RQcm9jZXNzLFxuICAgICAgICBzY29wZTogdGhpcy5fc2NvcGVcbiAgICAgIH0pO1xuICAgICAgLy8gdi1tb2RlbCB3aXRoIGluaXRhbCBpbmxpbmUgdmFsdWUgbmVlZCB0byBzeW5jIGJhY2sgdG9cbiAgICAgIC8vIG1vZGVsIGluc3RlYWQgb2YgdXBkYXRlIHRvIERPTSBvbiBpbml0LiBUaGV5IHdvdWxkXG4gICAgICAvLyBzZXQgdGhlIGFmdGVyQmluZCBob29rIHRvIGluZGljYXRlIHRoYXQuXG4gICAgICBpZiAodGhpcy5hZnRlckJpbmQpIHtcbiAgICAgICAgdGhpcy5hZnRlckJpbmQoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy51cGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUod2F0Y2hlci52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXR1cCBhbGwgcGFyYW0gYXR0cmlidXRlcywgZS5nLiB0cmFjay1ieSxcbiAgICogdHJhbnNpdGlvbi1tb2RlLCBldGMuLi5cbiAgICovXG5cbiAgRGlyZWN0aXZlLnByb3RvdHlwZS5fc2V0dXBQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmFtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgLy8gc3dhcCB0aGUgcGFyYW1zIGFycmF5IHdpdGggYSBmcmVzaCBvYmplY3QuXG4gICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBpID0gcGFyYW1zLmxlbmd0aDtcbiAgICB2YXIga2V5LCB2YWwsIG1hcHBlZEtleTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBrZXkgPSBwYXJhbXNbaV07XG4gICAgICBtYXBwZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgdmFsID0gZ2V0QmluZEF0dHIodGhpcy5lbCwga2V5KTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAvLyBkeW5hbWljXG4gICAgICAgIHRoaXMuX3NldHVwUGFyYW1XYXRjaGVyKG1hcHBlZEtleSwgdmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0YXRpY1xuICAgICAgICB2YWwgPSBnZXRBdHRyKHRoaXMuZWwsIGtleSk7XG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucGFyYW1zW21hcHBlZEtleV0gPSB2YWwgPT09ICcnID8gdHJ1ZSA6IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0dXAgYSB3YXRjaGVyIGZvciBhIGR5bmFtaWMgcGFyYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb25cbiAgICovXG5cbiAgRGlyZWN0aXZlLnByb3RvdHlwZS5fc2V0dXBQYXJhbVdhdGNoZXIgPSBmdW5jdGlvbiAoa2V5LCBleHByZXNzaW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgdW53YXRjaCA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kd2F0Y2goZXhwcmVzc2lvbiwgZnVuY3Rpb24gKHZhbCwgb2xkVmFsKSB7XG4gICAgICBzZWxmLnBhcmFtc1trZXldID0gdmFsO1xuICAgICAgLy8gc2luY2Ugd2UgYXJlIGluIGltbWVkaWF0ZSBtb2RlLFxuICAgICAgLy8gb25seSBjYWxsIHRoZSBwYXJhbSBjaGFuZ2UgY2FsbGJhY2tzIGlmIHRoaXMgaXMgbm90IHRoZSBmaXJzdCB1cGRhdGUuXG4gICAgICBpZiAoY2FsbGVkKSB7XG4gICAgICAgIHZhciBjYiA9IHNlbGYucGFyYW1XYXRjaGVycyAmJiBzZWxmLnBhcmFtV2F0Y2hlcnNba2V5XTtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IuY2FsbChzZWxmLCB2YWwsIG9sZFZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgICAgdXNlcjogZmFsc2VcbiAgICB9KTsodGhpcy5fcGFyYW1VbndhdGNoRm5zIHx8ICh0aGlzLl9wYXJhbVVud2F0Y2hGbnMgPSBbXSkpLnB1c2godW53YXRjaCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBkaXJlY3RpdmUgaXMgYSBmdW5jdGlvbiBjYWxsZXJcbiAgICogYW5kIGlmIHRoZSBleHByZXNzaW9uIGlzIGEgY2FsbGFibGUgb25lLiBJZiBib3RoIHRydWUsXG4gICAqIHdlIHdyYXAgdXAgdGhlIGV4cHJlc3Npb24gYW5kIHVzZSBpdCBhcyB0aGUgZXZlbnRcbiAgICogaGFuZGxlci5cbiAgICpcbiAgICogZS5nLiBvbi1jbGljaz1cImErK1wiXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG4gIERpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uO1xuICAgIGlmIChleHByZXNzaW9uICYmIHRoaXMuYWNjZXB0U3RhdGVtZW50ICYmICFpc1NpbXBsZVBhdGgoZXhwcmVzc2lvbikpIHtcbiAgICAgIHZhciBmbiA9IHBhcnNlRXhwcmVzc2lvbihleHByZXNzaW9uKS5nZXQ7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtO1xuICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcbiAgICAgICAgc2NvcGUuJGV2ZW50ID0gZTtcbiAgICAgICAgZm4uY2FsbChzY29wZSwgc2NvcGUpO1xuICAgICAgICBzY29wZS4kZXZlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICAgICAgaGFuZGxlciA9IHNjb3BlLl9hcHBseUZpbHRlcnMoaGFuZGxlciwgbnVsbCwgdGhpcy5maWx0ZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlKGhhbmRsZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgd2l0aCB0aGUgc2V0dGVyLlxuICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gdHdvLXdheSBkaXJlY3RpdmVzXG4gICAqIGUuZy4gdi1tb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcHVibGljXG4gICAqL1xuXG4gIERpcmVjdGl2ZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodGhpcy50d29XYXkpIHtcbiAgICAgIHRoaXMuX3dpdGhMb2NrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fd2F0Y2hlci5zZXQodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oJ0RpcmVjdGl2ZS5zZXQoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB0d29XYXknICsgJ2RpcmVjdGl2ZXMuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgZnVuY3Rpb24gd2hpbGUgcHJldmVudGluZyB0aGF0IGZ1bmN0aW9uIGZyb21cbiAgICogdHJpZ2dlcmluZyB1cGRhdGVzIG9uIHRoaXMgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKi9cblxuICBEaXJlY3RpdmUucHJvdG90eXBlLl93aXRoTG9jayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLl9sb2NrZWQgPSB0cnVlO1xuICAgIGZuLmNhbGwoc2VsZik7XG4gICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fbG9ja2VkID0gZmFsc2U7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF0dGFjaGVzIGEgRE9NIGV2ZW50IGxpc3RlbmVyXG4gICAqIHRvIHRoZSBkaXJlY3RpdmUgZWxlbWVudCBhbmQgYXV0b21ldGljYWxseSB0ZWFycyBpdCBkb3duXG4gICAqIGR1cmluZyB1bmJpbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdXG4gICAqL1xuXG4gIERpcmVjdGl2ZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgICBvbih0aGlzLmVsLCBldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7KHRoaXMuX2xpc3RlbmVycyB8fCAodGhpcy5fbGlzdGVuZXJzID0gW10pKS5wdXNoKFtldmVudCwgaGFuZGxlcl0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZWFyZG93biB0aGUgd2F0Y2hlciBhbmQgY2FsbCB1bmJpbmQuXG4gICAqL1xuXG4gIERpcmVjdGl2ZS5wcm90b3R5cGUuX3RlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9ib3VuZCkge1xuICAgICAgdGhpcy5fYm91bmQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLnVuYmluZCkge1xuICAgICAgICB0aGlzLnVuYmluZCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3dhdGNoZXIpIHtcbiAgICAgICAgdGhpcy5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgICAgfVxuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICBpID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIG9mZih0aGlzLmVsLCBsaXN0ZW5lcnNbaV1bMF0sIGxpc3RlbmVyc1tpXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB1bndhdGNoRm5zID0gdGhpcy5fcGFyYW1VbndhdGNoRm5zO1xuICAgICAgaWYgKHVud2F0Y2hGbnMpIHtcbiAgICAgICAgaSA9IHVud2F0Y2hGbnMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgdW53YXRjaEZuc1tpXSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuZWwpIHtcbiAgICAgICAgdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMuJHJlbW92ZSh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudm0gPSB0aGlzLmVsID0gdGhpcy5fd2F0Y2hlciA9IHRoaXMuX2xpc3RlbmVycyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdi1yZWYgZm9yIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlXG4gICAgICovXG5cbiAgICBWdWUucHJvdG90eXBlLl91cGRhdGVSZWYgPSBmdW5jdGlvbiAocmVtb3ZlKSB7XG4gICAgICB2YXIgcmVmID0gdGhpcy4kb3B0aW9ucy5fcmVmO1xuICAgICAgaWYgKHJlZikge1xuICAgICAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLl9jb250ZXh0KS4kcmVmcztcbiAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgIGlmIChyZWZzW3JlZl0gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJlZnNbcmVmXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbcmVmXSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNjbHVkZSwgY29tcGlsZSBhbmQgbGluayBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSBwcmUtY29tcGlsZWQgbGlua2VyIGlzIGF2YWlsYWJsZSwgdGhhdCBtZWFucyB0aGVcbiAgICAgKiBwYXNzZWQgaW4gZWxlbWVudCB3aWxsIGJlIHByZS10cmFuc2NsdWRlZCBhbmQgY29tcGlsZWRcbiAgICAgKiBhcyB3ZWxsIC0gYWxsIHdlIG5lZWQgdG8gZG8gaXMgdG8gY2FsbCB0aGUgbGlua2VyLlxuICAgICAqXG4gICAgICogT3RoZXJ3aXNlIHdlIG5lZWQgdG8gY2FsbCB0cmFuc2NsdWRlL2NvbXBpbGUvbGluayBoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuXG4gICAgICAvLyB0cmFuc2NsdWRlIGFuZCBpbml0IGVsZW1lbnRcbiAgICAgIC8vIHRyYW5zY2x1ZGUgY2FuIHBvdGVudGlhbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8ga2VlcCByZWZlcmVuY2U7IHRoaXMgc3RlcCBhbHNvIGluamVjdHNcbiAgICAgIC8vIHRoZSB0ZW1wbGF0ZSBhbmQgY2FjaGVzIHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gICAgICAvLyBvbiB0aGUgY29udGFpbmVyIG5vZGUgYW5kIHJlcGxhY2VyIG5vZGUuXG4gICAgICB2YXIgb3JpZ2luYWwgPSBlbDtcbiAgICAgIGVsID0gdHJhbnNjbHVkZShlbCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0RWxlbWVudChlbCk7XG5cbiAgICAgIC8vIGhhbmRsZSB2LXByZSBvbiByb290IG5vZGUgKCMyMDI2KVxuICAgICAgaWYgKGVsLm5vZGVUeXBlID09PSAxICYmIGdldEF0dHIoZWwsICd2LXByZScpICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcm9vdCBpcyBhbHdheXMgY29tcGlsZWQgcGVyLWluc3RhbmNlLCBiZWNhdXNlXG4gICAgICAvLyBjb250YWluZXIgYXR0cnMgYW5kIHByb3BzIGNhbiBiZSBkaWZmZXJlbnQgZXZlcnkgdGltZS5cbiAgICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IHRoaXMuX2NvbnRleHQgJiYgdGhpcy5fY29udGV4dC4kb3B0aW9ucztcbiAgICAgIHZhciByb290TGlua2VyID0gY29tcGlsZVJvb3QoZWwsIG9wdGlvbnMsIGNvbnRleHRPcHRpb25zKTtcblxuICAgICAgLy8gcmVzb2x2ZSBzbG90IGRpc3RyaWJ1dGlvblxuICAgICAgcmVzb2x2ZVNsb3RzKHRoaXMsIG9wdGlvbnMuX2NvbnRlbnQpO1xuXG4gICAgICAvLyBjb21waWxlIGFuZCBsaW5rIHRoZSByZXN0XG4gICAgICB2YXIgY29udGVudExpbmtGbjtcbiAgICAgIHZhciBjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgIC8vIGNvbXBvbmVudCBjb21waWxhdGlvbiBjYW4gYmUgY2FjaGVkXG4gICAgICAvLyBhcyBsb25nIGFzIGl0J3Mgbm90IHVzaW5nIGlubGluZS10ZW1wbGF0ZVxuICAgICAgaWYgKG9wdGlvbnMuX2xpbmtlckNhY2hhYmxlKSB7XG4gICAgICAgIGNvbnRlbnRMaW5rRm4gPSBjdG9yLmxpbmtlcjtcbiAgICAgICAgaWYgKCFjb250ZW50TGlua0ZuKSB7XG4gICAgICAgICAgY29udGVudExpbmtGbiA9IGN0b3IubGlua2VyID0gY29tcGlsZShlbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbGluayBwaGFzZVxuICAgICAgLy8gbWFrZSBzdXJlIHRvIGxpbmsgcm9vdCB3aXRoIHByb3Agc2NvcGUhXG4gICAgICB2YXIgcm9vdFVubGlua0ZuID0gcm9vdExpbmtlcih0aGlzLCBlbCwgdGhpcy5fc2NvcGUpO1xuICAgICAgdmFyIGNvbnRlbnRVbmxpbmtGbiA9IGNvbnRlbnRMaW5rRm4gPyBjb250ZW50TGlua0ZuKHRoaXMsIGVsKSA6IGNvbXBpbGUoZWwsIG9wdGlvbnMpKHRoaXMsIGVsKTtcblxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9zaXRlIHVubGluayBmdW5jdGlvblxuICAgICAgLy8gdG8gYmUgY2FsbGVkIGR1cmluZyBpbnN0YW5jZSBkZXN0cnVjdGlvblxuICAgICAgdGhpcy5fdW5saW5rRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3RVbmxpbmtGbigpO1xuICAgICAgICAvLyBwYXNzaW5nIGRlc3Ryb3lpbmc6IHRydWUgdG8gYXZvaWQgc2VhcmNoaW5nIGFuZFxuICAgICAgICAvLyBzcGxpY2luZyB0aGUgZGlyZWN0aXZlc1xuICAgICAgICBjb250ZW50VW5saW5rRm4odHJ1ZSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBmaW5hbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgICAgIGlmIChvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgICAgcmVwbGFjZShvcmlnaW5hbCwgZWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc0NvbXBpbGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NhbGxIb29rKCdjb21waWxlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGluc3RhbmNlIGVsZW1lbnQuIENhbGxlZCBpbiB0aGUgcHVibGljXG4gICAgICogJG1vdW50KCkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS5faW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGlmIChpc0ZyYWdtZW50KGVsKSkge1xuICAgICAgICB0aGlzLl9pc0ZyYWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kZWwgPSB0aGlzLl9mcmFnbWVudFN0YXJ0ID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgICAgdGhpcy5fZnJhZ21lbnRFbmQgPSBlbC5sYXN0Q2hpbGQ7XG4gICAgICAgIC8vIHNldCBwZXJzaXN0ZWQgdGV4dCBhbmNob3JzIHRvIGVtcHR5XG4gICAgICAgIGlmICh0aGlzLl9mcmFnbWVudFN0YXJ0Lm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgdGhpcy5fZnJhZ21lbnRTdGFydC5kYXRhID0gdGhpcy5fZnJhZ21lbnRFbmQuZGF0YSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZyYWdtZW50ID0gZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRlbCA9IGVsO1xuICAgICAgfVxuICAgICAgdGhpcy4kZWwuX192dWVfXyA9IHRoaXM7XG4gICAgICB0aGlzLl9jYWxsSG9vaygnYmVmb3JlQ29tcGlsZScpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIGJpbmQgYSBkaXJlY3RpdmUgdG8gYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gZGlyZWN0aXZlIG5hbWVcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgICAtIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlc2MgLSBwYXJzZWQgZGlyZWN0aXZlIGRlc2NyaXB0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmICAtIGRpcmVjdGl2ZSBkZWZpbml0aW9uIG9iamVjdFxuICAgICAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSB0cmFuc2NsdXNpb24gaG9zdCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gICAgICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gb3duZXIgZnJhZ21lbnRcbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuX2JpbmREaXIgPSBmdW5jdGlvbiAoZGVzY3JpcHRvciwgbm9kZSwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAgIHRoaXMuX2RpcmVjdGl2ZXMucHVzaChuZXcgRGlyZWN0aXZlKGRlc2NyaXB0b3IsIHRoaXMsIG5vZGUsIGhvc3QsIHNjb3BlLCBmcmFnKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlYXJkb3duIGFuIGluc3RhbmNlLCB1bm9ic2VydmVzIHRoZSBkYXRhLCB1bmJpbmQgYWxsIHRoZVxuICAgICAqIGRpcmVjdGl2ZXMsIHR1cm4gb2ZmIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzLCBldGMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZSAtIHdoZXRoZXIgdG8gcmVtb3ZlIHRoZSBET00gbm9kZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyQ2xlYW51cCAtIGlmIHRydWUsIGRlZmVyIGNsZWFudXAgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGNhbGxlZCBsYXRlclxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmUsIGRlZmVyQ2xlYW51cCkge1xuICAgICAgaWYgKHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgaWYgKCFkZWZlckNsZWFudXApIHtcbiAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVzdHJveVJlYWR5O1xuICAgICAgdmFyIHBlbmRpbmdSZW1vdmFsO1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAvLyBDbGVhbnVwIHNob3VsZCBiZSBjYWxsZWQgZWl0aGVyIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3lzbHkgYXNcbiAgICAgIC8vIGNhbGxiYWNrIG9mIHRoaXMuJHJlbW92ZSgpLCBvciBpZiByZW1vdmUgYW5kIGRlZmVyQ2xlYW51cCBhcmUgZmFsc2UuXG4gICAgICAvLyBJbiBhbnkgY2FzZSBpdCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGFsbCBvdGhlciByZW1vdmluZywgdW5iaW5kaW5nIGFuZFxuICAgICAgLy8gdHVybmluZyBvZiBpcyBkb25lXG4gICAgICB2YXIgY2xlYW51cElmUG9zc2libGUgPSBmdW5jdGlvbiBjbGVhbnVwSWZQb3NzaWJsZSgpIHtcbiAgICAgICAgaWYgKGRlc3Ryb3lSZWFkeSAmJiAhcGVuZGluZ1JlbW92YWwgJiYgIWRlZmVyQ2xlYW51cCkge1xuICAgICAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gcmVtb3ZlIERPTSBlbGVtZW50XG4gICAgICBpZiAocmVtb3ZlICYmIHRoaXMuJGVsKSB7XG4gICAgICAgIHBlbmRpbmdSZW1vdmFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kcmVtb3ZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwZW5kaW5nUmVtb3ZhbCA9IGZhbHNlO1xuICAgICAgICAgIGNsZWFudXBJZlBvc3NpYmxlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jYWxsSG9vaygnYmVmb3JlRGVzdHJveScpO1xuICAgICAgdGhpcy5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB2YXIgaTtcbiAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50LiBvbmx5IG5lY2Vzc2FyeVxuICAgICAgLy8gaWYgcGFyZW50IGlzIG5vdCBiZWluZyBkZXN0cm95ZWQgYXMgd2VsbC5cbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLiRwYXJlbnQ7XG4gICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgcGFyZW50LiRjaGlsZHJlbi4kcmVtb3ZlKHRoaXMpO1xuICAgICAgICAvLyB1bnJlZ2lzdGVyIHJlZiAocmVtb3ZlOiB0cnVlKVxuICAgICAgICB0aGlzLl91cGRhdGVSZWYodHJ1ZSk7XG4gICAgICB9XG4gICAgICAvLyBkZXN0cm95IGFsbCBjaGlsZHJlbi5cbiAgICAgIGkgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHRoaXMuJGNoaWxkcmVuW2ldLiRkZXN0cm95KCk7XG4gICAgICB9XG4gICAgICAvLyB0ZWFyZG93biBwcm9wc1xuICAgICAgaWYgKHRoaXMuX3Byb3BzVW5saW5rRm4pIHtcbiAgICAgICAgdGhpcy5fcHJvcHNVbmxpbmtGbigpO1xuICAgICAgfVxuICAgICAgLy8gdGVhcmRvd24gYWxsIGRpcmVjdGl2ZXMuIHRoaXMgYWxzbyB0ZWFyc2Rvd24gYWxsXG4gICAgICAvLyBkaXJlY3RpdmUtb3duZWQgd2F0Y2hlcnMuXG4gICAgICBpZiAodGhpcy5fdW5saW5rRm4pIHtcbiAgICAgICAgdGhpcy5fdW5saW5rRm4oKTtcbiAgICAgIH1cbiAgICAgIGkgPSB0aGlzLl93YXRjaGVycy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHRoaXMuX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHNlbGYgb24gJGVsXG4gICAgICBpZiAodGhpcy4kZWwpIHtcbiAgICAgICAgdGhpcy4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGRlc3Ryb3lSZWFkeSA9IHRydWU7XG4gICAgICBjbGVhbnVwSWZQb3NzaWJsZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCB0byBlbnN1cmUgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGFmdGVyIHRoZSBsZWF2ZSB0cmFuc2l0aW9uIGlmIHRoZXJlXG4gICAgICogaXMgYW55LlxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgc2VsZiBmcm9tIG93bmVyIGZyYWdtZW50XG4gICAgICAvLyBkbyBpdCBpbiBjbGVhbnVwIHNvIHRoYXQgd2UgY2FuIGNhbGwgJGRlc3Ryb3kgd2l0aFxuICAgICAgLy8gZGVmZXIgcmlnaHQgd2hlbiBhIGZyYWdtZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQuXG4gICAgICBpZiAodGhpcy5fZnJhZykge1xuICAgICAgICB0aGlzLl9mcmFnLmNoaWxkcmVuLiRyZW1vdmUodGhpcyk7XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgICBpZiAodGhpcy5fZGF0YS5fX29iX18pIHtcbiAgICAgICAgdGhpcy5fZGF0YS5fX29iX18ucmVtb3ZlVm0odGhpcyk7XG4gICAgICB9XG4gICAgICAvLyBDbGVhbiB1cCByZWZlcmVuY2VzIHRvIHByaXZhdGUgcHJvcGVydGllcyBhbmQgb3RoZXJcbiAgICAgIC8vIGluc3RhbmNlcy4gcHJlc2VydmUgcmVmZXJlbmNlIHRvIF9kYXRhIHNvIHRoYXQgcHJveHlcbiAgICAgIC8vIGFjY2Vzc29ycyBzdGlsbCB3b3JrLiBUaGUgb25seSBwb3RlbnRpYWwgc2lkZSBlZmZlY3RcbiAgICAgIC8vIGhlcmUgaXMgdGhhdCBtdXRhdGluZyB0aGUgaW5zdGFuY2UgYWZ0ZXIgaXQncyBkZXN0cm95ZWRcbiAgICAgIC8vIG1heSBhZmZlY3QgdGhlIHN0YXRlIG9mIG90aGVyIGNvbXBvbmVudHMgdGhhdCBhcmUgc3RpbGxcbiAgICAgIC8vIG9ic2VydmluZyB0aGUgc2FtZSBvYmplY3QsIGJ1dCB0aGF0IHNlZW1zIHRvIGJlIGFcbiAgICAgIC8vIHJlYXNvbmFibGUgcmVzcG9uc2liaWxpdHkgZm9yIHRoZSB1c2VyIHJhdGhlciB0aGFuXG4gICAgICAvLyBhbHdheXMgdGhyb3dpbmcgYW4gZXJyb3Igb24gdGhlbS5cbiAgICAgIHRoaXMuJGVsID0gdGhpcy4kcGFyZW50ID0gdGhpcy4kcm9vdCA9IHRoaXMuJGNoaWxkcmVuID0gdGhpcy5fd2F0Y2hlcnMgPSB0aGlzLl9jb250ZXh0ID0gdGhpcy5fc2NvcGUgPSB0aGlzLl9kaXJlY3RpdmVzID0gbnVsbDtcbiAgICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgICAgdGhpcy5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fY2FsbEhvb2soJ2Rlc3Ryb3llZCcpO1xuICAgICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICAgIHRoaXMuJG9mZigpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtaXNjTWl4aW4gKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgbGlzdCBvZiBmaWx0ZXIgKGRlc2NyaXB0b3JzKSB0byBhIHZhbHVlLlxuICAgICAqIFVzaW5nIHBsYWluIGZvciBsb29wcyBoZXJlIGJlY2F1c2UgdGhpcyB3aWxsIGJlIGNhbGxlZCBpblxuICAgICAqIHRoZSBnZXR0ZXIgb2YgYW55IHdhdGNoZXIgd2l0aCBmaWx0ZXJzIHNvIGl0IGlzIHZlcnlcbiAgICAgKiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBbb2xkVmFsdWVdXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVyc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gd3JpdGVcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS5fYXBwbHlGaWx0ZXJzID0gZnVuY3Rpb24gKHZhbHVlLCBvbGRWYWx1ZSwgZmlsdGVycywgd3JpdGUpIHtcbiAgICAgIHZhciBmaWx0ZXIsIGZuLCBhcmdzLCBhcmcsIG9mZnNldCwgaSwgbCwgaiwgaztcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBmaWx0ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuICAgICAgICBmbiA9IHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGZpbHRlci5uYW1lKTtcbiAgICAgICAgaWYgKCdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGFzc2VydEFzc2V0KGZuLCAnZmlsdGVyJywgZmlsdGVyLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm4pIGNvbnRpbnVlO1xuICAgICAgICBmbiA9IHdyaXRlID8gZm4ud3JpdGUgOiBmbi5yZWFkIHx8IGZuO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSBjb250aW51ZTtcbiAgICAgICAgYXJncyA9IHdyaXRlID8gW3ZhbHVlLCBvbGRWYWx1ZV0gOiBbdmFsdWVdO1xuICAgICAgICBvZmZzZXQgPSB3cml0ZSA/IDIgOiAxO1xuICAgICAgICBpZiAoZmlsdGVyLmFyZ3MpIHtcbiAgICAgICAgICBmb3IgKGogPSAwLCBrID0gZmlsdGVyLmFyZ3MubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBhcmcgPSBmaWx0ZXIuYXJnc1tqXTtcbiAgICAgICAgICAgIGFyZ3NbaiArIG9mZnNldF0gPSBhcmcuZHluYW1pYyA/IHRoaXMuJGdldChhcmcudmFsdWUpIDogYXJnLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIGEgY29tcG9uZW50LCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgY29tcG9uZW50XG4gICAgICogaXMgZGVmaW5lZCBub3JtYWxseSBvciB1c2luZyBhbiBhc3luYyBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqIFJlc29sdmVzIHN5bmNocm9ub3VzbHkgaWYgYWxyZWFkeSByZXNvbHZlZCwgb3RoZXJ3aXNlXG4gICAgICogcmVzb2x2ZXMgYXN5bmNocm9ub3VzbHkgYW5kIGNhY2hlcyB0aGUgcmVzb2x2ZWRcbiAgICAgKiBjb25zdHJ1Y3RvciBvbiB0aGUgZmFjdG9yeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICovXG5cbiAgICBWdWUucHJvdG90eXBlLl9yZXNvbHZlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGlkLCBjYikge1xuICAgICAgdmFyIGZhY3RvcnkgPSByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCBpZCk7XG4gICAgICBpZiAoJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydEFzc2V0KGZhY3RvcnksICdjb21wb25lbnQnLCBpZCk7XG4gICAgICB9XG4gICAgICBpZiAoIWZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gYXN5bmMgY29tcG9uZW50IGZhY3RvcnlcbiAgICAgIGlmICghZmFjdG9yeS5vcHRpb25zKSB7XG4gICAgICAgIGlmIChmYWN0b3J5LnJlc29sdmVkKSB7XG4gICAgICAgICAgLy8gY2FjaGVkXG4gICAgICAgICAgY2IoZmFjdG9yeS5yZXNvbHZlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmFjdG9yeS5yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAvLyBwb29sIGNhbGxiYWNrc1xuICAgICAgICAgIGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmYWN0b3J5LnJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgdmFyIGNicyA9IGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcyA9IFtjYl07XG4gICAgICAgICAgZmFjdG9yeS5jYWxsKHRoaXMsIGZ1bmN0aW9uIHJlc29sdmUocmVzKSB7XG4gICAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChyZXMpKSB7XG4gICAgICAgICAgICAgIHJlcyA9IFZ1ZS5leHRlbmQocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICAgICAgICBmYWN0b3J5LnJlc29sdmVkID0gcmVzO1xuICAgICAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNic1tpXShyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICAgICAgICAgICdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6ICcgKyBpZCArICcuICcgKyAocmVhc29uID8gJ1xcblJlYXNvbjogJyArIHJlYXNvbiA6ICcnKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vcm1hbCBjb21wb25lbnRcbiAgICAgICAgY2IoZmFjdG9yeSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBmaWx0ZXJSRSQxID0gL1tefF1cXHxbXnxdLztcblxuICBmdW5jdGlvbiBkYXRhQVBJIChWdWUpIHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIGZyb20gYW4gZXhwcmVzc2lvbiBvbiB0aGlzIHZtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FzU3RhdGVtZW50XVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG5cbiAgICBWdWUucHJvdG90eXBlLiRnZXQgPSBmdW5jdGlvbiAoZXhwLCBhc1N0YXRlbWVudCkge1xuICAgICAgdmFyIHJlcyA9IHBhcnNlRXhwcmVzc2lvbihleHApO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICBpZiAoYXNTdGF0ZW1lbnQgJiYgIWlzU2ltcGxlUGF0aChleHApKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzdGF0ZW1lbnRIYW5kbGVyKCkge1xuICAgICAgICAgICAgc2VsZi4kYXJndW1lbnRzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlcy5nZXQuY2FsbChzZWxmLCBzZWxmKTtcbiAgICAgICAgICAgIHNlbGYuJGFyZ3VtZW50cyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiByZXMuZ2V0LmNhbGwodGhpcywgdGhpcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIGZyb20gYW4gZXhwcmVzc2lvbiBvbiB0aGlzIHZtLlxuICAgICAqIFRoZSBleHByZXNzaW9uIG11c3QgYmUgYSB2YWxpZCBsZWZ0LWhhbmRcbiAgICAgKiBleHByZXNzaW9uIGluIGFuIGFzc2lnbm1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gICAgICogQHBhcmFtIHsqfSB2YWxcbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuJHNldCA9IGZ1bmN0aW9uIChleHAsIHZhbCkge1xuICAgICAgdmFyIHJlcyA9IHBhcnNlRXhwcmVzc2lvbihleHAsIHRydWUpO1xuICAgICAgaWYgKHJlcyAmJiByZXMuc2V0KSB7XG4gICAgICAgIHJlcy5zZXQuY2FsbCh0aGlzLCB0aGlzLCB2YWwpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBwcm9wZXJ0eSBvbiB0aGUgVk1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGRlbCh0aGlzLl9kYXRhLCBrZXkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXYXRjaCBhbiBleHByZXNzaW9uLCB0cmlnZ2VyIGNhbGxiYWNrIHdoZW4gaXRzXG4gICAgICogdmFsdWUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBleHBPckZuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlZXBcbiAgICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gaW1tZWRpYXRlXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IC0gdW53YXRjaEZuXG4gICAgICovXG5cbiAgICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChleHBPckZuLCBjYiwgb3B0aW9ucykge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIHZhciBwYXJzZWQ7XG4gICAgICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKGV4cE9yRm4pO1xuICAgICAgICBleHBPckZuID0gcGFyc2VkLmV4cHJlc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwge1xuICAgICAgICBkZWVwOiBvcHRpb25zICYmIG9wdGlvbnMuZGVlcCxcbiAgICAgICAgc3luYzogb3B0aW9ucyAmJiBvcHRpb25zLnN5bmMsXG4gICAgICAgIGZpbHRlcnM6IHBhcnNlZCAmJiBwYXJzZWQuZmlsdGVycyxcbiAgICAgICAgdXNlcjogIW9wdGlvbnMgfHwgb3B0aW9ucy51c2VyICE9PSBmYWxzZVxuICAgICAgfSk7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4oKSB7XG4gICAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGEgdGV4dCBkaXJlY3RpdmUsIGluY2x1ZGluZyBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthc1N0YXRlbWVudF1cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG5cbiAgICBWdWUucHJvdG90eXBlLiRldmFsID0gZnVuY3Rpb24gKHRleHQsIGFzU3RhdGVtZW50KSB7XG4gICAgICAvLyBjaGVjayBmb3IgZmlsdGVycy5cbiAgICAgIGlmIChmaWx0ZXJSRSQxLnRlc3QodGV4dCkpIHtcbiAgICAgICAgdmFyIGRpciA9IHBhcnNlRGlyZWN0aXZlKHRleHQpO1xuICAgICAgICAvLyB0aGUgZmlsdGVyIHJlZ2V4IGNoZWNrIG1pZ2h0IGdpdmUgZmFsc2UgcG9zaXRpdmVcbiAgICAgICAgLy8gZm9yIHBpcGVzIGluc2lkZSBzdHJpbmdzLCBzbyBpdCdzIHBvc3NpYmxlIHRoYXRcbiAgICAgICAgLy8gd2UgZG9uJ3QgZ2V0IGFueSBmaWx0ZXJzIGhlcmVcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuJGdldChkaXIuZXhwcmVzc2lvbiwgYXNTdGF0ZW1lbnQpO1xuICAgICAgICByZXR1cm4gZGlyLmZpbHRlcnMgPyB0aGlzLl9hcHBseUZpbHRlcnModmFsLCBudWxsLCBkaXIuZmlsdGVycykgOiB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBmaWx0ZXJcbiAgICAgICAgcmV0dXJuIHRoaXMuJGdldCh0ZXh0LCBhc1N0YXRlbWVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludGVycG9sYXRlIGEgcGllY2Ugb2YgdGVtcGxhdGUgdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS4kaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgdmFyIHRva2VucyA9IHBhcnNlVGV4dCh0ZXh0KTtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBpZiAodG9rZW5zKSB7XG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHZtLiRldmFsKHRva2Vuc1swXS52YWx1ZSkgKyAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi50YWcgPyB2bS4kZXZhbCh0b2tlbi52YWx1ZSkgOiB0b2tlbi52YWx1ZTtcbiAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvZyBpbnN0YW5jZSBkYXRhIGFzIGEgcGxhaW4gSlMgb2JqZWN0XG4gICAgICogc28gdGhhdCBpdCBpcyBlYXNpZXIgdG8gaW5zcGVjdCBpbiBjb25zb2xlLlxuICAgICAqIFRoaXMgbWV0aG9kIGFzc3VtZXMgY29uc29sZSBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gICAgICovXG5cbiAgICBWdWUucHJvdG90eXBlLiRsb2cgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdmFyIGRhdGEgPSBwYXRoID8gZ2V0UGF0aCh0aGlzLl9kYXRhLCBwYXRoKSA6IHRoaXMuX2RhdGE7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhID0gY2xlYW4oZGF0YSk7XG4gICAgICB9XG4gICAgICAvLyBpbmNsdWRlIGNvbXB1dGVkIGZpZWxkc1xuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuJG9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgICAgICBkYXRhW2tleV0gPSBjbGVhbih0aGlzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcm9wcykge1xuICAgICAgICAgIGZvciAoa2V5IGluIHRoaXMuX3Byb3BzKSB7XG4gICAgICAgICAgICBkYXRhW2tleV0gPSBjbGVhbih0aGlzW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFwiY2xlYW5cIiBhIGdldHRlci9zZXR0ZXIgY29udmVydGVkIG9iamVjdCBpbnRvIGEgcGxhaW5cbiAgICAgKiBvYmplY3QgY29weS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAtIG9ialxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGNsZWFuKG9iaikge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZG9tQVBJIChWdWUpIHtcbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBvbi1pbnN0YW5jZSBuZXh0VGljay4gVGhlIGNhbGxiYWNrIGlzXG4gICAgICogYXV0by1ib3VuZCB0byB0aGUgaW5zdGFuY2UsIGFuZCB0aGlzIGF2b2lkcyBjb21wb25lbnRcbiAgICAgKiBtb2R1bGVzIGhhdmluZyB0byByZWx5IG9uIHRoZSBnbG9iYWwgVnVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICBuZXh0VGljayhmbiwgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBpbnN0YW5jZSB0byB0YXJnZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuJGFwcGVuZFRvID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gaW5zZXJ0KHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLCBhcHBlbmQsIGFwcGVuZFdpdGhUcmFuc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJlcGVuZCBpbnN0YW5jZSB0byB0YXJnZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuJHByZXBlbmRUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgICAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KTtcbiAgICAgIGlmICh0YXJnZXQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQuZmlyc3RDaGlsZCwgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGFwcGVuZFRvKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgaW5zdGFuY2UgYmVmb3JlIHRhcmdldFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS4kYmVmb3JlID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gaW5zZXJ0KHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLCBiZWZvcmVXaXRoQ2IsIGJlZm9yZVdpdGhUcmFuc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGluc3RhbmNlIGFmdGVyIHRhcmdldFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS4kYWZ0ZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICAgIHRhcmdldCA9IHF1ZXJ5KHRhcmdldCk7XG4gICAgICBpZiAodGFyZ2V0Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQubmV4dFNpYmxpbmcsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRhcHBlbmRUbyh0YXJnZXQucGFyZW50Tm9kZSwgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgaW5zdGFuY2UgZnJvbSBET01cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAgICovXG5cbiAgICBWdWUucHJvdG90eXBlLiRyZW1vdmUgPSBmdW5jdGlvbiAoY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgICBpZiAoIXRoaXMuJGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNiICYmIGNiKCk7XG4gICAgICB9XG4gICAgICB2YXIgaW5Eb2N1bWVudCA9IHRoaXMuX2lzQXR0YWNoZWQgJiYgaW5Eb2ModGhpcy4kZWwpO1xuICAgICAgLy8gaWYgd2UgYXJlIG5vdCBpbiBkb2N1bWVudCwgbm8gbmVlZCB0byBjaGVja1xuICAgICAgLy8gZm9yIHRyYW5zaXRpb25zXG4gICAgICBpZiAoIWluRG9jdW1lbnQpIHdpdGhUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcmVhbENiID0gZnVuY3Rpb24gcmVhbENiKCkge1xuICAgICAgICBpZiAoaW5Eb2N1bWVudCkgc2VsZi5fY2FsbEhvb2soJ2RldGFjaGVkJyk7XG4gICAgICAgIGlmIChjYikgY2IoKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5faXNGcmFnbWVudCkge1xuICAgICAgICByZW1vdmVOb2RlUmFuZ2UodGhpcy5fZnJhZ21lbnRTdGFydCwgdGhpcy5fZnJhZ21lbnRFbmQsIHRoaXMsIHRoaXMuX2ZyYWdtZW50LCByZWFsQ2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9wID0gd2l0aFRyYW5zaXRpb24gPT09IGZhbHNlID8gcmVtb3ZlV2l0aENiIDogcmVtb3ZlV2l0aFRyYW5zaXRpb247XG4gICAgICAgIG9wKHRoaXMuJGVsLCB0aGlzLCByZWFsQ2IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNoYXJlZCBET00gaW5zZXJ0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3AxIC0gb3AgZm9yIG5vbi10cmFuc2l0aW9uIGluc2VydFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wMiAtIG9wIGZvciB0cmFuc2l0aW9uIGluc2VydFxuICAgICAqIEByZXR1cm4gdm1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGluc2VydCh2bSwgdGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24sIG9wMSwgb3AyKSB7XG4gICAgICB0YXJnZXQgPSBxdWVyeSh0YXJnZXQpO1xuICAgICAgdmFyIHRhcmdldElzRGV0YWNoZWQgPSAhaW5Eb2ModGFyZ2V0KTtcbiAgICAgIHZhciBvcCA9IHdpdGhUcmFuc2l0aW9uID09PSBmYWxzZSB8fCB0YXJnZXRJc0RldGFjaGVkID8gb3AxIDogb3AyO1xuICAgICAgdmFyIHNob3VsZENhbGxIb29rID0gIXRhcmdldElzRGV0YWNoZWQgJiYgIXZtLl9pc0F0dGFjaGVkICYmICFpbkRvYyh2bS4kZWwpO1xuICAgICAgaWYgKHZtLl9pc0ZyYWdtZW50KSB7XG4gICAgICAgIG1hcE5vZGVSYW5nZSh2bS5fZnJhZ21lbnRTdGFydCwgdm0uX2ZyYWdtZW50RW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIG9wKG5vZGUsIHRhcmdldCwgdm0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wKHZtLiRlbCwgdGFyZ2V0LCB2bSwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZENhbGxIb29rKSB7XG4gICAgICAgIHZtLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3Igc2VsZWN0b3JzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gcXVlcnkoZWwpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCkgOiBlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgb3BlcmF0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGFwcGVuZChlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICBpZiAoY2IpIGNiKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0QmVmb3JlIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge1Z1ZX0gdm0gLSB1bnVzZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBiZWZvcmVXaXRoQ2IoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gICAgICBiZWZvcmUoZWwsIHRhcmdldCk7XG4gICAgICBpZiAoY2IpIGNiKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIHtWdWV9IHZtIC0gdW51c2VkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlV2l0aENiKGVsLCB2bSwgY2IpIHtcbiAgICAgIHJlbW92ZShlbCk7XG4gICAgICBpZiAoY2IpIGNiKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXZlbnRzQVBJIChWdWUpIHtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgKHRoaXMuX2V2ZW50c1tldmVudF0gfHwgKHRoaXMuX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gICAgICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICovXG5cbiAgICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gb24oKSB7XG4gICAgICAgIHNlbGYuJG9mZihldmVudCwgb24pO1xuICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgb24uZm4gPSBmbjtcbiAgICAgIHRoaXMuJG9uKGV2ZW50LCBvbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAgICAgKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICovXG5cbiAgICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICB2YXIgY2JzO1xuICAgICAgLy8gYWxsXG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHBhcmVudCkge1xuICAgICAgICAgIGZvciAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgICBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgICAgICAgICAgaWYgKGNicykge1xuICAgICAgICAgICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtY2JzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgICBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgICAgaWYgKCFjYnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtY2JzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY2IgPSBjYnNbaV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgLTEpO1xuICAgICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGFuIGV2ZW50IG9uIHNlbGYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gc2hvdWxkUHJvcGFnYXRlXG4gICAgICovXG5cbiAgICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgaXNTb3VyY2UgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnO1xuICAgICAgZXZlbnQgPSBpc1NvdXJjZSA/IGV2ZW50IDogZXZlbnQubmFtZTtcbiAgICAgIHZhciBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgICAgdmFyIHNob3VsZFByb3BhZ2F0ZSA9IGlzU291cmNlIHx8ICFjYnM7XG4gICAgICBpZiAoY2JzKSB7XG4gICAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgaGFja3kgc29sdXRpb24gdG8gdGhlIHF1ZXN0aW9uIHJhaXNlZFxuICAgICAgICAvLyBpbiAjMjEwMjogZm9yIGFuIGlubGluZSBjb21wb25lbnQgbGlzdGVuZXIgbGlrZSA8Y29tcCBAdGVzdD1cImRvVGhpc1wiPixcbiAgICAgICAgLy8gdGhlIHByb3BhZ2F0aW9uIGhhbmRsaW5nIGlzIHNvbWV3aGF0IGJyb2tlbi4gVGhlcmVmb3JlIHdlXG4gICAgICAgIC8vIG5lZWQgdG8gdHJlYXQgdGhlc2UgaW5saW5lIGNhbGxiYWNrcyBkaWZmZXJlbnRseS5cbiAgICAgICAgdmFyIGhhc1BhcmVudENicyA9IGlzU291cmNlICYmIGNicy5zb21lKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIHJldHVybiBjYi5fZnJvbVBhcmVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNQYXJlbnRDYnMpIHtcbiAgICAgICAgICBzaG91bGRQcm9wYWdhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNiID0gY2JzW2ldO1xuICAgICAgICAgIHZhciByZXMgPSBjYi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICBpZiAocmVzID09PSB0cnVlICYmICghaGFzUGFyZW50Q2JzIHx8IGNiLl9mcm9tUGFyZW50KSkge1xuICAgICAgICAgICAgc2hvdWxkUHJvcGFnYXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzaG91bGRQcm9wYWdhdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGJyb2FkY2FzdCBhbiBldmVudCB0byBhbGwgY2hpbGRyZW4gaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudFxuICAgICAqIEBwYXJhbSB7Li4uKn0gYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuJGJyb2FkY2FzdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGlzU291cmNlID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJztcbiAgICAgIGV2ZW50ID0gaXNTb3VyY2UgPyBldmVudCA6IGV2ZW50Lm5hbWU7XG4gICAgICAvLyBpZiBubyBjaGlsZCBoYXMgcmVnaXN0ZXJlZCBmb3IgdGhpcyBldmVudCxcbiAgICAgIC8vIHRoZW4gdGhlcmUncyBubyBuZWVkIHRvIGJyb2FkY2FzdC5cbiAgICAgIGlmICghdGhpcy5fZXZlbnRzQ291bnRbZXZlbnRdKSByZXR1cm47XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRjaGlsZHJlbjtcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgICAgaWYgKGlzU291cmNlKSB7XG4gICAgICAgIC8vIHVzZSBvYmplY3QgZXZlbnQgdG8gaW5kaWNhdGUgbm9uLXNvdXJjZSBlbWl0XG4gICAgICAgIC8vIG9uIGNoaWxkcmVuXG4gICAgICAgIGFyZ3NbMF0gPSB7IG5hbWU6IGV2ZW50LCBzb3VyY2U6IHRoaXMgfTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB2YXIgc2hvdWxkUHJvcGFnYXRlID0gY2hpbGQuJGVtaXQuYXBwbHkoY2hpbGQsIGFyZ3MpO1xuICAgICAgICBpZiAoc2hvdWxkUHJvcGFnYXRlKSB7XG4gICAgICAgICAgY2hpbGQuJGJyb2FkY2FzdC5hcHBseShjaGlsZCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBwcm9wYWdhdGUgYW4gZXZlbnQgdXAgdGhlIHBhcmVudCBjaGFpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7Li4uKn0gYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuJGRpc3BhdGNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgc2hvdWxkUHJvcGFnYXRlID0gdGhpcy4kZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKCFzaG91bGRQcm9wYWdhdGUpIHJldHVybjtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLiRwYXJlbnQ7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgIC8vIHVzZSBvYmplY3QgZXZlbnQgdG8gaW5kaWNhdGUgbm9uLXNvdXJjZSBlbWl0XG4gICAgICAvLyBvbiBwYXJlbnRzXG4gICAgICBhcmdzWzBdID0geyBuYW1lOiBldmVudCwgc291cmNlOiB0aGlzIH07XG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIHNob3VsZFByb3BhZ2F0ZSA9IHBhcmVudC4kZW1pdC5hcHBseShwYXJlbnQsIGFyZ3MpO1xuICAgICAgICBwYXJlbnQgPSBzaG91bGRQcm9wYWdhdGUgPyBwYXJlbnQuJHBhcmVudCA6IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSBsaXN0ZW5lciBjb3VudHMgb24gYWxsIHBhcmVudHMuXG4gICAgICogVGhpcyBib29ra2VlcGluZyBhbGxvd3MgJGJyb2FkY2FzdCB0byByZXR1cm4gZWFybHkgd2hlblxuICAgICAqIG5vIGNoaWxkIGhhcyBsaXN0ZW5lZCB0byBhIGNlcnRhaW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291bnRcbiAgICAgKi9cblxuICAgIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgICBmdW5jdGlvbiBtb2RpZnlMaXN0ZW5lckNvdW50KHZtLCBldmVudCwgY291bnQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgICAgLy8gaG9va3MgZG8gbm90IGdldCBicm9hZGNhc3RlZCBzbyBubyBuZWVkXG4gICAgICAvLyB0byBkbyBib29ra2VlcGluZyBmb3IgdGhlbVxuICAgICAgaWYgKCFwYXJlbnQgfHwgIWNvdW50IHx8IGhvb2tSRS50ZXN0KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuX2V2ZW50c0NvdW50W2V2ZW50XSA9IChwYXJlbnQuX2V2ZW50c0NvdW50W2V2ZW50XSB8fCAwKSArIGNvdW50O1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsaWZlY3ljbGVBUEkgKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIFNldCBpbnN0YW5jZSB0YXJnZXQgZWxlbWVudCBhbmQga2ljayBvZmYgdGhlIGNvbXBpbGF0aW9uXG4gICAgICogcHJvY2Vzcy4gVGhlIHBhc3NlZCBpbiBgZWxgIGNhbiBiZSBhIHNlbGVjdG9yIHN0cmluZywgYW5cbiAgICAgKiBleGlzdGluZyBFbGVtZW50LCBvciBhIERvY3VtZW50RnJhZ21lbnQgKGZvciBibG9ja1xuICAgICAqIGluc3RhbmNlcykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxzdHJpbmd9IGVsXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGlmICh0aGlzLl9pc0NvbXBpbGVkKSB7XG4gICAgICAgICdkZXZlbG9wbWVudCcgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCckbW91bnQoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWwgPSBxdWVyeShlbCk7XG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21waWxlKGVsKTtcbiAgICAgIHRoaXMuX2luaXRET01Ib29rcygpO1xuICAgICAgaWYgKGluRG9jKHRoaXMuJGVsKSkge1xuICAgICAgICB0aGlzLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgICAgICAgcmVhZHkuY2FsbCh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJG9uY2UoJ2hvb2s6YXR0YWNoZWQnLCByZWFkeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFyayBhbiBpbnN0YW5jZSBhcyByZWFkeS5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NhbGxIb29rKCdyZWFkeScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlYXJkb3duIHRoZSBpbnN0YW5jZSwgc2ltcGx5IGRlbGVnYXRlIHRvIHRoZSBpbnRlcm5hbFxuICAgICAqIF9kZXN0cm95LlxuICAgICAqL1xuXG4gICAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmUsIGRlZmVyQ2xlYW51cCkge1xuICAgICAgdGhpcy5fZGVzdHJveShyZW1vdmUsIGRlZmVyQ2xlYW51cCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnRpYWxseSBjb21waWxlIGEgcGllY2Ugb2YgRE9NIGFuZCByZXR1cm4gYVxuICAgICAqIGRlY29tcGlsZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7VnVlfSBbaG9zdF1cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cblxuICAgIFZ1ZS5wcm90b3R5cGUuJGNvbXBpbGUgPSBmdW5jdGlvbiAoZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgICByZXR1cm4gY29tcGlsZShlbCwgdGhpcy4kb3B0aW9ucywgdHJ1ZSkodGhpcywgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBleHBvc2VkIFZ1ZSBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQVBJIGNvbnZlbnRpb25zOlxuICAgKiAtIHB1YmxpYyBBUEkgbWV0aG9kcy9wcm9wZXJ0aWVzIGFyZSBwcmVmaXhlZCB3aXRoIGAkYFxuICAgKiAtIGludGVybmFsIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZml4ZWQgd2l0aCBgX2BcbiAgICogLSBub24tcHJlZml4ZWQgcHJvcGVydGllcyBhcmUgYXNzdW1lZCB0byBiZSBwcm94aWVkIHVzZXJcbiAgICogICBkYXRhLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFZ1ZShvcHRpb25zKSB7XG4gICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGluc3RhbGwgaW50ZXJuYWxzXG4gIGluaXRNaXhpbihWdWUpO1xuICBzdGF0ZU1peGluKFZ1ZSk7XG4gIGV2ZW50c01peGluKFZ1ZSk7XG4gIGxpZmVjeWNsZU1peGluKFZ1ZSk7XG4gIG1pc2NNaXhpbihWdWUpO1xuXG4gIC8vIGluc3RhbGwgaW5zdGFuY2UgQVBJc1xuICBkYXRhQVBJKFZ1ZSk7XG4gIGRvbUFQSShWdWUpO1xuICBldmVudHNBUEkoVnVlKTtcbiAgbGlmZWN5Y2xlQVBJKFZ1ZSk7XG5cbiAgdmFyIHNsb3QgPSB7XG5cbiAgICBwcmlvcml0eTogU0xPVCxcbiAgICBwYXJhbXM6IFsnbmFtZSddLFxuXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIC8vIHRoaXMgd2FzIHJlc29sdmVkIGR1cmluZyBjb21wb25lbnQgdHJhbnNjbHVzaW9uXG4gICAgICB2YXIgbmFtZSA9IHRoaXMucGFyYW1zLm5hbWUgfHwgJ2RlZmF1bHQnO1xuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLnZtLl9zbG90Q29udGVudHMgJiYgdGhpcy52bS5fc2xvdENvbnRlbnRzW25hbWVdO1xuICAgICAgaWYgKCFjb250ZW50IHx8ICFjb250ZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICB0aGlzLmZhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBpbGUoY29udGVudC5jbG9uZU5vZGUodHJ1ZSksIHRoaXMudm0uX2NvbnRleHQsIHRoaXMudm0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKGNvbnRlbnQsIGNvbnRleHQsIGhvc3QpIHtcbiAgICAgIGlmIChjb250ZW50ICYmIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZWwuaGFzQ2hpbGROb2RlcygpICYmIGNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiYgY29udGVudC5jaGlsZE5vZGVzWzBdLm5vZGVUeXBlID09PSAxICYmIGNvbnRlbnQuY2hpbGROb2Rlc1swXS5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBpbnNlcnRlZCBzbG90IGhhcyB2LWlmXG4gICAgICAgICAgLy8gaW5qZWN0IGZhbGxiYWNrIGNvbnRlbnQgYXMgdGhlIHYtZWxzZVxuICAgICAgICAgIHZhciBlbHNlQmxvY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICAgIGVsc2VCbG9jay5zZXRBdHRyaWJ1dGUoJ3YtZWxzZScsICcnKTtcbiAgICAgICAgICBlbHNlQmxvY2suaW5uZXJIVE1MID0gdGhpcy5lbC5pbm5lckhUTUw7XG4gICAgICAgICAgLy8gdGhlIGVsc2UgYmxvY2sgc2hvdWxkIGJlIGNvbXBpbGVkIGluIGNoaWxkIHNjb3BlXG4gICAgICAgICAgZWxzZUJsb2NrLl9jb250ZXh0ID0gdGhpcy52bTtcbiAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsc2VCbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjb3BlID0gaG9zdCA/IGhvc3QuX3Njb3BlIDogdGhpcy5fc2NvcGU7XG4gICAgICAgIHRoaXMudW5saW5rID0gY29udGV4dC4kY29tcGlsZShjb250ZW50LCBob3N0LCBzY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXBsYWNlKHRoaXMuZWwsIGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlKHRoaXMuZWwpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmYWxsYmFjazogZnVuY3Rpb24gZmFsbGJhY2soKSB7XG4gICAgICB0aGlzLmNvbXBpbGUoZXh0cmFjdENvbnRlbnQodGhpcy5lbCwgdHJ1ZSksIHRoaXMudm0pO1xuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIGlmICh0aGlzLnVubGluaykge1xuICAgICAgICB0aGlzLnVubGluaygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcGFydGlhbCA9IHtcblxuICAgIHByaW9yaXR5OiBQQVJUSUFMLFxuXG4gICAgcGFyYW1zOiBbJ25hbWUnXSxcblxuICAgIC8vIHdhdGNoIGNoYW5nZXMgdG8gbmFtZSBmb3IgZHluYW1pYyBwYXJ0aWFsc1xuICAgIHBhcmFtV2F0Y2hlcnM6IHtcbiAgICAgIG5hbWU6IGZ1bmN0aW9uIG5hbWUodmFsdWUpIHtcbiAgICAgICAgdklmLnJlbW92ZS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmluc2VydCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LXBhcnRpYWwnKTtcbiAgICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgICAgdGhpcy5pbnNlcnQodGhpcy5wYXJhbXMubmFtZSk7XG4gICAgfSxcblxuICAgIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KGlkKSB7XG4gICAgICB2YXIgcGFydGlhbCA9IHJlc29sdmVBc3NldCh0aGlzLnZtLiRvcHRpb25zLCAncGFydGlhbHMnLCBpZCk7XG4gICAgICBpZiAoJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydEFzc2V0KHBhcnRpYWwsICdwYXJ0aWFsJywgaWQpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCBwYXJ0aWFsKTtcbiAgICAgICAgdklmLmluc2VydC5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgICAgdGhpcy5mcmFnLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGVsZW1lbnREaXJlY3RpdmVzID0ge1xuICAgIHNsb3Q6IHNsb3QsXG4gICAgcGFydGlhbDogcGFydGlhbFxuICB9O1xuXG4gIHZhciBjb252ZXJ0QXJyYXkgPSB2Rm9yLl9wb3N0UHJvY2VzcztcblxuICAvKipcbiAgICogTGltaXQgZmlsdGVyIGZvciBhcnJheXNcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAoRGVjaW1hbCBleHBlY3RlZClcbiAgICovXG5cbiAgZnVuY3Rpb24gbGltaXRCeShhcnIsIG4sIG9mZnNldCkge1xuICAgIG9mZnNldCA9IG9mZnNldCA/IHBhcnNlSW50KG9mZnNldCwgMTApIDogMDtcbiAgICBuID0gdG9OdW1iZXIobik7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJyA/IGFyci5zbGljZShvZmZzZXQsIG9mZnNldCArIG4pIDogYXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlciBmaWx0ZXIgZm9yIGFycmF5c1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZGVsaW1pdGVyXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gLi4uZGF0YUtleXNcbiAgICovXG5cbiAgZnVuY3Rpb24gZmlsdGVyQnkoYXJyLCBzZWFyY2gsIGRlbGltaXRlcikge1xuICAgIGFyciA9IGNvbnZlcnRBcnJheShhcnIpO1xuICAgIGlmIChzZWFyY2ggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBhcnIuZmlsdGVyKHNlYXJjaCk7XG4gICAgfVxuICAgIC8vIGNhc3QgdG8gbG93ZXJjYXNlIHN0cmluZ1xuICAgIHNlYXJjaCA9ICgnJyArIHNlYXJjaCkudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBhbGxvdyBvcHRpb25hbCBgaW5gIGRlbGltaXRlclxuICAgIC8vIGJlY2F1c2Ugd2h5IG5vdFxuICAgIHZhciBuID0gZGVsaW1pdGVyID09PSAnaW4nID8gMyA6IDI7XG4gICAgLy8gZXh0cmFjdCBhbmQgZmxhdHRlbiBrZXlzXG4gICAgdmFyIGtleXMgPSB0b0FycmF5KGFyZ3VtZW50cywgbikucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICAgIHJldHVybiBwcmV2LmNvbmNhdChjdXIpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGl0ZW0sIGtleSwgdmFsLCBqO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaXRlbSA9IGFycltpXTtcbiAgICAgIHZhbCA9IGl0ZW0gJiYgaXRlbS4kdmFsdWUgfHwgaXRlbTtcbiAgICAgIGogPSBrZXlzLmxlbmd0aDtcbiAgICAgIGlmIChqKSB7XG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgIGlmIChrZXkgPT09ICcka2V5JyAmJiBjb250YWlucyQxKGl0ZW0uJGtleSwgc2VhcmNoKSB8fCBjb250YWlucyQxKGdldFBhdGgodmFsLCBrZXkpLCBzZWFyY2gpKSB7XG4gICAgICAgICAgICByZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250YWlucyQxKGl0ZW0sIHNlYXJjaCkpIHtcbiAgICAgICAgcmVzLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogRmlsdGVyIGZpbHRlciBmb3IgYXJyYXlzXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzb3J0S2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZXZlcnNlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9yZGVyQnkoYXJyLCBzb3J0S2V5LCByZXZlcnNlKSB7XG4gICAgYXJyID0gY29udmVydEFycmF5KGFycik7XG4gICAgaWYgKCFzb3J0S2V5KSB7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICB2YXIgb3JkZXIgPSByZXZlcnNlICYmIHJldmVyc2UgPCAwID8gLTEgOiAxO1xuICAgIC8vIHNvcnQgb24gYSBjb3B5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGFycmF5XG4gICAgcmV0dXJuIGFyci5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChzb3J0S2V5ICE9PSAnJGtleScpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICckdmFsdWUnIGluIGEpIGEgPSBhLiR2YWx1ZTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGIpICYmICckdmFsdWUnIGluIGIpIGIgPSBiLiR2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGEgPSBpc09iamVjdChhKSA/IGdldFBhdGgoYSwgc29ydEtleSkgOiBhO1xuICAgICAgYiA9IGlzT2JqZWN0KGIpID8gZ2V0UGF0aChiLCBzb3J0S2V5KSA6IGI7XG4gICAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IG9yZGVyIDogLW9yZGVyO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0cmluZyBjb250YWluIGhlbHBlclxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNvbnRhaW5zJDEodmFsLCBzZWFyY2gpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChjb250YWlucyQxKHZhbFtrZXlzW2ldXSwgc2VhcmNoKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoY29udGFpbnMkMSh2YWxbaV0sIHNlYXJjaCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWwudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc2VhcmNoKSA+IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkaWdpdHNSRSA9IC8oXFxkezN9KSg/PVxcZCkvZztcblxuICAvLyBhc3NldCBjb2xsZWN0aW9ucyBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LlxuICB2YXIgZmlsdGVycyA9IHtcblxuICAgIG9yZGVyQnk6IG9yZGVyQnksXG4gICAgZmlsdGVyQnk6IGZpbHRlckJ5LFxuICAgIGxpbWl0Qnk6IGxpbWl0QnksXG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmdpZnkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZW50XG4gICAgICovXG5cbiAgICBqc29uOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKHZhbHVlLCBpbmRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCBOdW1iZXIoaW5kZW50KSB8fCAyKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogJ2FiYycgPT4gJ0FiYydcbiAgICAgKi9cblxuICAgIGNhcGl0YWxpemU6IGZ1bmN0aW9uIGNhcGl0YWxpemUodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHJldHVybiAnJztcbiAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiB2YWx1ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbHVlLnNsaWNlKDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAnYWJjJyA9PiAnQUJDJ1xuICAgICAqL1xuXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiB1cHBlcmNhc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IHZhbHVlLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSA6ICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAnQWJDJyA9PiAnYWJjJ1xuICAgICAqL1xuXG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiBsb3dlcmNhc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA6ICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAxMjM0NSA9PiAkMTIsMzQ1LjAwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2lnblxuICAgICAqL1xuXG4gICAgY3VycmVuY3k6IGZ1bmN0aW9uIGN1cnJlbmN5KHZhbHVlLCBfY3VycmVuY3kpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSB8fCAhdmFsdWUgJiYgdmFsdWUgIT09IDApIHJldHVybiAnJztcbiAgICAgIF9jdXJyZW5jeSA9IF9jdXJyZW5jeSAhPSBudWxsID8gX2N1cnJlbmN5IDogJyQnO1xuICAgICAgdmFyIHN0cmluZ2lmaWVkID0gTWF0aC5hYnModmFsdWUpLnRvRml4ZWQoMik7XG4gICAgICB2YXIgX2ludCA9IHN0cmluZ2lmaWVkLnNsaWNlKDAsIC0zKTtcbiAgICAgIHZhciBpID0gX2ludC5sZW5ndGggJSAzO1xuICAgICAgdmFyIGhlYWQgPSBpID4gMCA/IF9pbnQuc2xpY2UoMCwgaSkgKyAoX2ludC5sZW5ndGggPiAzID8gJywnIDogJycpIDogJyc7XG4gICAgICB2YXIgX2Zsb2F0ID0gc3RyaW5naWZpZWQuc2xpY2UoLTMpO1xuICAgICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyAnLScgOiAnJztcbiAgICAgIHJldHVybiBzaWduICsgX2N1cnJlbmN5ICsgaGVhZCArIF9pbnQuc2xpY2UoaSkucmVwbGFjZShkaWdpdHNSRSwgJyQxLCcpICsgX2Zsb2F0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAnaXRlbScgPT4gJ2l0ZW1zJ1xuICAgICAqXG4gICAgICogQHBhcmFtc1xuICAgICAqICBhbiBhcnJheSBvZiBzdHJpbmdzIGNvcnJlc3BvbmRpbmcgdG9cbiAgICAgKiAgdGhlIHNpbmdsZSwgZG91YmxlLCB0cmlwbGUgLi4uIGZvcm1zIG9mIHRoZSB3b3JkIHRvXG4gICAgICogIGJlIHBsdXJhbGl6ZWQuIFdoZW4gdGhlIG51bWJlciB0byBiZSBwbHVyYWxpemVkXG4gICAgICogIGV4Y2VlZHMgdGhlIGxlbmd0aCBvZiB0aGUgYXJncywgaXQgd2lsbCB1c2UgdGhlIGxhc3RcbiAgICAgKiAgZW50cnkgaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIGUuZy4gWydzaW5nbGUnLCAnZG91YmxlJywgJ3RyaXBsZScsICdtdWx0aXBsZSddXG4gICAgICovXG5cbiAgICBwbHVyYWxpemU6IGZ1bmN0aW9uIHBsdXJhbGl6ZSh2YWx1ZSkge1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gYXJncy5sZW5ndGggPiAxID8gYXJnc1t2YWx1ZSAlIDEwIC0gMV0gfHwgYXJnc1thcmdzLmxlbmd0aCAtIDFdIDogYXJnc1swXSArICh2YWx1ZSA9PT0gMSA/ICcnIDogJ3MnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVib3VuY2UgYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSA9IDMwMFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuXG4gICAgZGVib3VuY2U6IGZ1bmN0aW9uIGRlYm91bmNlKGhhbmRsZXIsIGRlbGF5KSB7XG4gICAgICBpZiAoIWhhbmRsZXIpIHJldHVybjtcbiAgICAgIGlmICghZGVsYXkpIHtcbiAgICAgICAgZGVsYXkgPSAzMDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2RlYm91bmNlKGhhbmRsZXIsIGRlbGF5KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5zdGFsbEdsb2JhbEFQSSAoVnVlKSB7XG4gICAgLyoqXG4gICAgICogVnVlIGFuZCBldmVyeSBjb25zdHJ1Y3RvciB0aGF0IGV4dGVuZHMgVnVlIGhhcyBhblxuICAgICAqIGFzc29jaWF0ZWQgb3B0aW9ucyBvYmplY3QsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZCBkdXJpbmdcbiAgICAgKiBjb21waWxhdGlvbiBzdGVwcyBhcyBgdGhpcy5jb25zdHJ1Y3Rvci5vcHRpb25zYC5cbiAgICAgKlxuICAgICAqIFRoZXNlIGNhbiBiZSBzZWVuIGFzIHRoZSBkZWZhdWx0IG9wdGlvbnMgb2YgZXZlcnlcbiAgICAgKiBWdWUgaW5zdGFuY2UuXG4gICAgICovXG5cbiAgICBWdWUub3B0aW9ucyA9IHtcbiAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICBlbGVtZW50RGlyZWN0aXZlczogZWxlbWVudERpcmVjdGl2ZXMsXG4gICAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICAgICAgdHJhbnNpdGlvbnM6IHt9LFxuICAgICAgY29tcG9uZW50czoge30sXG4gICAgICBwYXJ0aWFsczoge30sXG4gICAgICByZXBsYWNlOiB0cnVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4cG9zZSB1c2VmdWwgaW50ZXJuYWxzXG4gICAgICovXG5cbiAgICBWdWUudXRpbCA9IHV0aWw7XG4gICAgVnVlLmNvbmZpZyA9IGNvbmZpZztcbiAgICBWdWUuc2V0ID0gc2V0O1xuICAgIFZ1ZVsnZGVsZXRlJ10gPSBkZWw7XG4gICAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9sbG93aW5nIGFyZSBleHBvc2VkIGZvciBhZHZhbmNlZCB1c2FnZSAvIHBsdWdpbnNcbiAgICAgKi9cblxuICAgIFZ1ZS5jb21waWxlciA9IGNvbXBpbGVyO1xuICAgIFZ1ZS5GcmFnbWVudEZhY3RvcnkgPSBGcmFnbWVudEZhY3Rvcnk7XG4gICAgVnVlLmludGVybmFsRGlyZWN0aXZlcyA9IGludGVybmFsRGlyZWN0aXZlcztcbiAgICBWdWUucGFyc2VycyA9IHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgZGlyZWN0aXZlOiBkaXJlY3RpdmUsXG4gICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICAgKi9cblxuICAgIFZ1ZS5jaWQgPSAwO1xuICAgIHZhciBjaWQgPSAxO1xuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbmRPcHRpb25zXG4gICAgICovXG5cbiAgICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICAgIHZhciBpc0ZpcnN0RXh0ZW5kID0gU3VwZXIuY2lkID09PSAwO1xuICAgICAgaWYgKGlzRmlyc3RFeHRlbmQgJiYgZXh0ZW5kT3B0aW9ucy5fQ3Rvcikge1xuICAgICAgICByZXR1cm4gZXh0ZW5kT3B0aW9ucy5fQ3RvcjtcbiAgICAgIH1cbiAgICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICAgIGlmICgnZGV2ZWxvcG1lbnQnICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICB3YXJuKCdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWNhdGVycyBhbmQgdGhlIGh5cGhlbi4nKTtcbiAgICAgICAgICBuYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIFN1YiA9IGNyZWF0ZUNsYXNzKG5hbWUgfHwgJ1Z1ZUNvbXBvbmVudCcpO1xuICAgICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhTdXBlci5vcHRpb25zLCBleHRlbmRPcHRpb25zKTtcbiAgICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuICAgICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb25cbiAgICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICAgIH0pO1xuICAgICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICAgIH1cbiAgICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgICBpZiAoaXNGaXJzdEV4dGVuZCkge1xuICAgICAgICBleHRlbmRPcHRpb25zLl9DdG9yID0gU3ViO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN1YjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdWItY2xhc3MgY29uc3RydWN0b3Igd2l0aCB0aGVcbiAgICAgKiBnaXZlbiBuYW1lLiBUaGlzIGdpdmVzIHVzIG11Y2ggbmljZXIgb3V0cHV0IHdoZW5cbiAgICAgKiBsb2dnaW5nIGluc3RhbmNlcyBpbiB0aGUgY29uc29sZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDbGFzcyhuYW1lKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyAqL1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uICcgKyBjbGFzc2lmeShuYW1lKSArICcgKG9wdGlvbnMpIHsgdGhpcy5faW5pdChvcHRpb25zKSB9JykoKTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3LWZ1bmMgKi9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbHVnaW4gc3lzdGVtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luXG4gICAgICovXG5cbiAgICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcGx1Z2luLmluc3RhbGxlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBnbG9iYWwgbWl4aW4gYnkgbWVyZ2luZyBpdCBpbnRvIHRoZSBkZWZhdWx0XG4gICAgICogb3B0aW9ucy5cbiAgICAgKi9cblxuICAgIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgVnVlLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoVnVlLm9wdGlvbnMsIG1peGluKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgICAqIHNpZ25hdHVyZTpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7Kn0gZGVmaW5pdGlvblxuICAgICAqL1xuXG4gICAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChpZCwgZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgKGNvbW1vblRhZ1JFLnRlc3QoaWQpIHx8IHJlc2VydmVkVGFnUkUudGVzdChpZCkpKSB7XG4gICAgICAgICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArICdpZDogJyArIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGlkO1xuICAgICAgICAgICAgZGVmaW5pdGlvbiA9IFZ1ZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gZXhwb3NlIGludGVybmFsIHRyYW5zaXRpb24gQVBJXG4gICAgZXh0ZW5kKFZ1ZS50cmFuc2l0aW9uLCB0cmFuc2l0aW9uKTtcbiAgfVxuXG4gIGluc3RhbGxHbG9iYWxBUEkoVnVlKTtcblxuICBWdWUudmVyc2lvbiA9ICcxLjAuMTgnO1xuXG4gIC8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgIH0gZWxzZSBpZiAoJ2RldmVsb3BtZW50JyAhPT0gJ3Byb2R1Y3Rpb24nICYmIGluQnJvd3NlciAmJiAvQ2hyb21lXFwvXFxkKy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgKyAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBWdWU7XG5cbn0pKTsiLCJcbi8vIEJpbmQgVGhlIENvbmZpZ3VyYXRpb25zXG5pbXBvcnQgJy4vc3RvcmVzL2NvbmYuanMnXG5pbXBvcnQgJy4vcm91dGVyL2NvbmYuanMnXG4iLCJcbi8vIEltcG9ydCBWdWUgUm91dGVyXG5pbXBvcnQgVnVlIGZyb20gJy4uL2xpYnMvdnVlLmpzJztcbmltcG9ydCBWdWVSb3V0ZXIgZnJvbSAnLi4vbGlicy92dWUtcm91dGVyLm1pbi5qcyc7XG5cbi8vIGltcG9ydCBjb21wb25lbnRzXG5pbXBvcnQgYXBwIGZyb20gJy4uL2NvbXBvbmVudHMvYXBwLnZ1ZSc7XG5cbi8vIGltcG9ydCBtYXBcbmltcG9ydCBtYXAgZnJvbSAnLi9tYXAuanMnO1xuXG4vLyBJbXBvcnQgc2VydmljZXNcbmltcG9ydCBzZXJ2aWNlcyBmcm9tICcuLi9zdG9yZXMvc2VydmljZXMuanMnO1xuXG5cblxuLyoqXG4gIFZVRSBST1VURVIgQ09ORklHVVJBVElPTlxuKi9cblxuKGZ1bmN0aW9uICgpIHtcblxuICAvLyBNYWtlIG5ldyBWdWVSb3V0ZXIgSW5zdGFuY2VcbiAgVnVlLnVzZShWdWVSb3V0ZXIpXG4gIGxldCByb3V0ZXIgPSBuZXcgVnVlUm91dGVyKClcbiAgXG4gIC8vIE1ha2UgaXQgZ2xvYmFsXG4gIGdsb2JhbC5yb3V0ZXIgPSByb3V0ZXJcblxuICAvLyBSZWdpc3RlciBSb3V0ZXNcbiAgcm91dGVyLm1hcChtYXApXG5cbiAgLy8gSGFuZGxlIG5vdCBmb3VuZCByb3V0ZXNcbiAgcm91dGVyLnJlZGlyZWN0KHsgJyonIDogJy8nIH0pXG5cbiAgLy8gQmVmb3JlIFJvdXRpbmcgRXZlbnRzXG4gIHJvdXRlci5iZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gRmFrZSBMb2FkaW5nIEJhclxuICAgIHZhciBjdXJUaW1lID0gMDtcbiAgICBmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgICAgdmFyIGN1ciA9IHBhcnNlRmxvYXQoc2VydmljZXMuc3RhdGUucHJvZ3Jlc3MpO1xuICAgICAgY3VyID0gaXNOYU4oY3VyKSA/IDAgOiBjdXI7XG5cbiAgICAgIHZhciB0byA9IDEwMDsgLy8gVGhlIExhc3QgVW5pdCBTaG91bGQgQmVcblxuICAgICAgdmFyIGR1cmF0aW9uID0gNzUwO1xuXG4gICAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRTZWNvbmRzKCkgKyAnLCcgKyBuZXcgRGF0ZSgpLmdldE1pbGxpc2Vjb25kcygpO1xuICAgICAgdmFyIHN0YXJ0ID0rIG5ldyBEYXRlKCk7XG4gICAgICBjaGVjaygpO1xuXG4gICAgICBmdW5jdGlvbiBjaGVjaygpIHtcbiAgICAgICAgaWYgKGN1ciAhPSB0bykge1xuXG4gICAgICAgICAgKGN1ciArICh0byAvIDYwKSkgPiB0byA/IGN1ciA9IHRvIDogY3VyICs9ICh0byAvIDYwKTtcblxuICAgICAgICAgIHNlcnZpY2VzLnByb2dyZXNzX3RvKGN1cilcblxuICAgICAgICAgIC8vIGN1clRpbWUgKz0gZHVyYXRpb24vNjA7XG4gICAgICAgICAgdmFyIHRpbWUgPSsgbmV3IERhdGUoKSAtIHN0YXJ0O1xuXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNoZWNrKCk7XG4gICAgICAgICAgfSwgZHVyYXRpb24gLyA2MCk7IC8vIDYwIEZQUyAtIEhhcnVueWEgMTAwMC82MCAtXy1cblxuICAgICAgICB9XG4gICAgICB9Ly8gY2hlY2soKVxuXG4gICAgfVxuXG4gICAgYW5pbWF0ZSgpXG4gICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPSAwXG5cbiAgfSlcblxuXG4gIC8qKlxuICAgIE1PVU5UIFRIRSBWVUVcbiAgKi9cblxuICAvLyBNYWtlIGEgbmV3IGNvbXBvbmVudHNcbiAgbGV0IEFwcCA9IFZ1ZS5leHRlbmQoYXBwKVxuXG4gIC8vIE1vdW50IFRoZSBBcHBcbiAgcm91dGVyLnN0YXJ0KEFwcCwnI2FwcCcpXG5cbn0pKClcbiIsIlxuZXhwb3J0IGRlZmF1bHQge1xuICAnLyc6IHtcbiAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvcGFnZXMvaG9tZS52dWUnKSxcbiAgfSxcblxuICAnL3Byb2R1Y3QvOnByb2R1Y3ROYW1lJzoge1xuICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi4vY29tcG9uZW50cy9wYWdlcy9kZXRpbC52dWUnKSxcbiAgfSxcblxuICAnL2NhdGVnb3J5LzpjYXRlZ29yeSc6IHtcbiAgICBjb21wb25lbnQ6IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvcGFnZXMvY2F0ZWdvcnkudnVlJyksXG4gIH0sXG5cbiAgJy9zZWFyY2gnOiB7XG4gICAgY29tcG9uZW50OiByZXF1aXJlKCcuLi9jb21wb25lbnRzL3BhZ2VzL3NlYXJjaC52dWUnKSxcbiAgfSxcblxuICAnL2NhcnQvJzoge1xuICAgIGNvbXBvbmVudDogcmVxdWlyZSgnLi4vY29tcG9uZW50cy9wYWdlcy9jYXJ0LnZ1ZScpLFxuICB9LFxuXG59XG4iLCJcbmltcG9ydCBzZXJ2aWNlcyBmcm9tICcuL3NlcnZpY2VzLmpzJztcbmltcG9ydCBwcm9kdWN0U3RvcmUgZnJvbSAnLi9wcm9kdWN0LmpzJztcblxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgbmFtZTogJ2NhcnQnLFxuXG4gIHN0YXRlOiB7XG4gICAgYWxsOiBbXSxcbiAgICB0b3RhbEl0ZW06IDBcbiAgfSxcblxuXG4gIC8qKlxuICAgIFNldCB0aGUgc3RhdGVcbiAgICBAcGFyYW0ge09iamVjdH0gdmFsXG4gICovXG4gIHNldCh2YWwpe1xuICAgIGxldCBtZSA9IHRoaXNcblxuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXModmFsKVxuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBtZS5zdGF0ZVtrZXldID0gdmFsW2tleV1cbiAgICB9KVxuXG4gICAgbWUudG90YWxfaXRlbSgpXG5cbiAgICBzZXJ2aWNlcy5iYWNrdXBfdG9fbG9jYWxfc3RvcmFnZSgpXG4gIH0sXG5cblxuICAvLyAvKipcbiAgLy8gICBGaW5kIEl0ZW1cbiAgLy8gICBAcGFyYW0ge09iamVjdH0gY2FydF9pdGVtXG4gIC8vICovXG4gIC8vIGZpbmRfaXRlbShjYXJ0SXRlbSl7XG4gIC8vICAgbGV0IG1lID0gdGhpc1xuICAvL1xuICAvLyAgIC8vIEZpbmQgVGhlIFByb2R1Y3RcbiAgLy8gICBsZXQgYWxsSXRlbSA9IG1lLnN0YXRlLmFsbFxuICAvLyAgIGxldCBmaW5kSXRlbSA9IGFsbEl0ZW0uZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PSBjYXJ0SXRlbS5uYW1lKVxuICAvL1xuICAvLyAgIHJldHVybiBmaW5kSXRlbVxuICAvLyB9LFxuXG5cblxuICAvKipcbiAgICBBZGQgaXRlbSB0byBjYXJ0XG4gICAgQHBhcmFtIHtPYmplY3R9IHZhbFxuICAqL1xuICBhZGRfaXRlbSh2YWwpe1xuICAgIGxldCBtZSA9IHRoaXNcblxuICAgIC8vIHJlbW92ZSBWdWUgd2F0Y2hlclxuICAgIHZhbCA9IGNsZWFuVXAodmFsKVxuXG4gICAgLy8gRGVzdHJ1Y3R1cmluZyB0aGUgdmFsXG4gICAgbGV0IHsgcHJvZHVjdDogcHJvZHVjdCwgY29sb3I6IGNvbG9yIH0gPSB2YWxcblxuICAgIHByb2R1Y3RTdG9yZS5kZWNyZWFzZV9zdG9jayh7XG4gICAgICBwcm9kdWN0OiBwcm9kdWN0LFxuICAgICAgY29sb3I6IGNvbG9yXG4gICAgfSlcblxuICAgIC8vIFByZXBhcmUgdGhlIGZvcm1hdCBvZiB0aGUgY2FydCBJdGVtXG4gICAgbGV0IGNhcnRJdGVtID0ge1xuICAgICAgbmFtZTogcHJvZHVjdC5uYW1lLFxuICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgcHJpY2U6IHByb2R1Y3QucHJpY2UsXG4gICAgICBhbW91bnQ6IDFcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIHRvIEFkZCBpdGVtIHRvIHRoZSBjYXJ0XG4gICAgbGV0IGFsbENhcnRJdGVtID0gbWUuc3RhdGUuYWxsXG4gICAgbGV0IGR1cGxpY2F0ZWQgPSBhbGxDYXJ0SXRlbS5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09IGNhcnRJdGVtLm5hbWUgJiYgaXRlbS5jb2xvciA9PSBjYXJ0SXRlbS5jb2xvcilcblxuICAgIC8vIGlmIGR1cGxpY2F0ZSBpdGVtLCBhZGQgdGhlIGFtb3VudFxuICAgIGlmICggZHVwbGljYXRlZCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICBsZXQgaW5kZXhPZkR1cGxpY2F0ZWRJdGVtID0gYWxsQ2FydEl0ZW0uaW5kZXhPZihkdXBsaWNhdGVkKVxuICAgICAgYWxsQ2FydEl0ZW1baW5kZXhPZkR1cGxpY2F0ZWRJdGVtXS5hbW91bnQgPSBkdXBsaWNhdGVkLmFtb3VudCArIDFcbiAgICB9IGVsc2Uge1xuICAgICAgYWxsQ2FydEl0ZW0ucHVzaChjYXJ0SXRlbSlcbiAgICB9XG5cbiAgICBtZS50b3RhbF9pdGVtKClcblxuICAgIHNlcnZpY2VzLmJhY2t1cF90b19sb2NhbF9zdG9yYWdlKClcbiAgfSxcblxuXG4gIC8qKlxuICAgIENhbGN1bGF0ZSB0aGUgdG90YWwgb2YgdGhlIGNhcnQgaXRlbXNcbiAgKi9cbiAgdG90YWxfaXRlbSgpe1xuICAgIGxldCB0b3RhbCA9IDBcbiAgICB0aGlzLnN0YXRlLmFsbC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICB0b3RhbCArPSBpdGVtLmFtb3VudFxuICAgIH0pXG4gICAgdGhpcy5zdGF0ZS50b3RhbEl0ZW0gPSB0b3RhbFxuICB9LFxuXG5cbiAgLyoqXG4gICAgQ2hlY2sgb3V0XG4gICovXG4gIGNoZWNrb3V0KCl7XG4gICAgdGhpcy5zdGF0ZS5hbGwgPSBbXVxuICAgIHRoaXMuc3RhdGUudG90YWxJdGVtID0gMFxuICAgIHNlcnZpY2VzLmJhY2t1cF90b19sb2NhbF9zdG9yYWdlKClcbiAgfVxuXG59O1xuIiwiXG4vLyBJbXBvcnQgdGhlIGxpYnJhcnlcbmltcG9ydCBWdWUgZnJvbSAnLi4vbGlicy92dWUuanMnXG5pbXBvcnQgVnVlU2ltcGxlU3RvcmUgZnJvbSAnLi4vbGlicy92dWUtc2ltcGxlLXN0b3JlLmpzJ1xuXG4vLyBJbXBvcnQgQWxsIFN0b3JlIE9uY2VcbmltcG9ydCBzZXJ2aWNlcyBmcm9tICcuL3NlcnZpY2VzLmpzJztcbmltcG9ydCBwcm9kdWN0U3RvcmUgZnJvbSAnLi9wcm9kdWN0LmpzJztcbmltcG9ydCBjYXJ0U3RvcmUgZnJvbSAnLi9jYXJ0LmpzJztcblxuKGZ1bmN0aW9uICgpIHtcbiAgLy8gSW5zdGFsbCBWdWUgU2ltcGxlIFN0b3JlXG4gIFZ1ZS51c2UoIFZ1ZVNpbXBsZVN0b3JlLHsgc3RvcmVzOiBbIHNlcnZpY2VzLCBwcm9kdWN0U3RvcmUsIGNhcnRTdG9yZSBdLCBkZWJ1ZzogdHJ1ZSB9IClcbn0pKClcbiIsIlxuaW1wb3J0IHNlcnZpY2VzIGZyb20gJy4vc2VydmljZXMuanMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICBuYW1lOiAncHJvZHVjdCcsXG5cbiAgc3RhdGU6IHtcbiAgICBhbGw6IFtdXG4gIH0sXG5cblxuICAvKipcbiAgICBTZXQgdGhlIHN0YXRlXG4gICAgQHBhcmFtIHtPYmplY3R9IHZhbFxuICAqL1xuICBzZXQodmFsKXtcbiAgICBsZXQgbWUgPSB0aGlzXG5cbiAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHZhbClcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgbWUuc3RhdGVba2V5XSA9IHZhbFtrZXldXG4gICAgfSlcblxuICAgIG1lLm9yZ2FuaXplKG1lLnN0YXRlLmFsbClcbiAgICBzZXJ2aWNlcy5iYWNrdXBfdG9fbG9jYWxfc3RvcmFnZSgpXG4gIH0sXG5cblxuICAvKipcbiAgICBPcmdhbml6ZSB0aGUgcHJvZHVjdHNcbiAgICBAcGFyYW0ge09iamVjdH0gcHJvZHVjdHNcbiAgKi9cbiAgb3JnYW5pemUocHJvZHVjdHMpe1xuICAgIGxldCBtZSA9IHRoaXNcbiAgICBwcm9kdWN0cy5mb3JFYWNoKChwcm9kdWN0KSA9PiB7XG4gICAgICAvLyBDb252ZXJ0IHRoZSBwcm9kdWN0IG5hbWUgdG8ga2ViYWItY2FzZVxuICAgICAgcHJvZHVjdC5rZWJhYk5hbWUgPSBwcm9kdWN0Lm5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMvaWcsJy0nKVxuICAgIH0pXG4gIH0sXG5cblxuICAvKipcbiAgICBGaW5kIFRoZSBQcm9kdWN0XG4gICAgQHBhcmFtIHtPYmplY3R9IHByb2R1Y3RcbiAgKi9cbiAgZmluZF9wcm9kdWN0KHByb2R1Y3Qpe1xuICAgIGxldCBtZSA9IHRoaXNcblxuICAgIC8vIEZpbmQgVGhlIFByb2R1Y3RcbiAgICBsZXQgYWxsUHJvZHVjdCA9IG1lLnN0YXRlLmFsbFxuICAgIGxldCBmaW5kUHJvZHVjdCA9IGFsbFByb2R1Y3QuZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PSBwcm9kdWN0Lm5hbWUpXG4gICAgcmV0dXJuIGZpbmRQcm9kdWN0XG4gIH0sXG5cblxuICAvKipcbiAgICBEZWNyZWFzZSB0aGUgYW1vdW50IG9mIHRoZSBzdG9ja1xuICAgIEBwYXJhbSB7T2JqZWN0fSB2YWxcbiAgKi9cbiAgZGVjcmVhc2Vfc3RvY2sodmFsKXtcbiAgICBsZXQgbWUgPSB0aGlzXG5cbiAgICAvLyByZW1vdmUgVnVlIHdhdGNoZXJcbiAgICB2YWwgPSBjbGVhblVwKHZhbClcblxuICAgIC8vIERlc3RydWN0dXJpbmcgdGhlIHZhbFxuICAgIGxldCB7IHByb2R1Y3Q6IHByb2R1Y3QsIGNvbG9yOiBjb2xvciB9ID0gdmFsXG5cbiAgICAvLyBkZWNyZWFzZSB0aGUgc3RvY2sgb2YgdGhlIHByb2R1Y3RcbiAgICBsZXQgdGhlUHJvZHVjdCA9IG1lLmZpbmRfcHJvZHVjdChwcm9kdWN0KVxuXG4gICAgLy8gRmluZCB0aGUgY29sb3IgdGhlbiByZWR1Y2UgdGhlIHN0b2NrIGFtb3VudFxuICAgIGxldCBhbGxTdG9jayA9IHRoZVByb2R1Y3Quc3RvY2tzXG4gICAgbGV0IGZpbmRDb2xvciA9IGFsbFN0b2NrLmZpbmQoc3RvY2sgPT4gc3RvY2suY29sb3IgPT0gY29sb3IpXG4gICAgbGV0IGluZGV4T2ZDb2xvciA9IGFsbFN0b2NrLmluZGV4T2YoZmluZENvbG9yKVxuICAgIGFsbFN0b2NrW2luZGV4T2ZDb2xvcl0uc3RvY2sgPSBmaW5kQ29sb3Iuc3RvY2sgLSAxIC8vIEZpbmFsbHkgLV8tXG5cbiAgICBzZXJ2aWNlcy5iYWNrdXBfdG9fbG9jYWxfc3RvcmFnZSgpXG4gIH0sXG5cblxuXG4gIC8qKlxuICAgIFRvZ2dsZSBMaWtlIHRoZSBQcm9kdWN0XG4gICAgQHBhcmFtIHtPYmplY3R9IHZhbFxuICAqL1xuICB0b2dnbGVfbGlrZSh2YWwpe1xuICAgIGxldCBtZSA9IHRoaXNcblxuICAgIC8vIHJlbW92ZSBWdWUgd2F0Y2hlclxuICAgIHZhbCA9IGNsZWFuVXAodmFsKVxuXG4gICAgLy8gRGVzdHJ1Y3R1cmluZyB0aGUgdmFsXG4gICAgbGV0IHsgcHJvZHVjdDogcHJvZHVjdCB9ID0gdmFsXG5cbiAgICBsZXQgdGhlUHJvZHVjdCA9IG1lLmZpbmRfcHJvZHVjdChwcm9kdWN0KVxuXG4gICAgdGhlUHJvZHVjdC5saWtlZCA9ICFwcm9kdWN0Lmxpa2VkXG5cbiAgICBzZXJ2aWNlcy5iYWNrdXBfdG9fbG9jYWxfc3RvcmFnZSgpXG4gIH0sXG5cblxuICAvKipcbiAgICBhZGQgYSBjb21tZW50IHRvIHRoZSBQcm9kdWN0XG4gICAgQHBhcmFtIHtPYmplY3R9IHZhbFxuICAqL1xuICBhZGRfY29tbWVudCh2YWwpe1xuICAgIGxldCBtZSA9IHRoaXNcblxuICAgIC8vIHJlbW92ZSBWdWUgd2F0Y2hlclxuICAgIHZhbCA9IGNsZWFuVXAodmFsKVxuXG4gICAgLy8gRGVzdHJ1Y3R1cmluZyB0aGUgdmFsXG4gICAgbGV0IHsgcHJvZHVjdDogcHJvZHVjdCwgY29udGVudDogY29udGVudCB9ID0gdmFsXG5cbiAgICBsZXQgdGhlUHJvZHVjdCA9IG1lLmZpbmRfcHJvZHVjdChwcm9kdWN0KVxuXG4gICAgdGhlUHJvZHVjdC5jb21tZW50cy5wdXNoKHsgY29udGVudDogY29udGVudCB9KVxuXG4gICAgc2VydmljZXMuYmFja3VwX3RvX2xvY2FsX3N0b3JhZ2UoKVxuICB9LFxuXG5cbiAgLyoqXG4gICAgZGVsZXRlIGEgY29tbWVudCB0byB0aGUgUHJvZHVjdFxuICAgIEBwYXJhbSB7T2JqZWN0fSB2YWxcbiAgKi9cbiAgZGVsZXRlX2NvbW1lbnQodmFsKXtcbiAgICBsZXQgbWUgPSB0aGlzXG5cbiAgICAvLyByZW1vdmUgVnVlIHdhdGNoZXJcbiAgICB2YWwgPSBjbGVhblVwKHZhbClcblxuICAgIC8vIERlc3RydWN0dXJpbmcgdGhlIHZhbFxuICAgIGxldCB7IHByb2R1Y3Q6IHByb2R1Y3QsIGNvbW1lbnQ6IGNvbW1lbnQgfSA9IHZhbFxuXG4gICAgbGV0IHRoZVByb2R1Y3QgPSBtZS5maW5kX3Byb2R1Y3QocHJvZHVjdClcblxuICAgIGxldCBpbmRleE9mQ29tbWVudCA9IHRoZVByb2R1Y3QuY29tbWVudHMuaW5kZXhPZihjb21tZW50KVxuICAgIHRoZVByb2R1Y3QuY29tbWVudHMuc3BsaWNlKGluZGV4T2ZDb21tZW50LDEpXG5cbiAgICBzZXJ2aWNlcy5iYWNrdXBfdG9fbG9jYWxfc3RvcmFnZSgpXG4gIH0sXG5cbn07XG4iLCJcbmltcG9ydCBwcm9kdWN0U3RvcmUgZnJvbSAnLi9wcm9kdWN0LmpzJztcbmltcG9ydCBjYXJ0U3RvcmUgZnJvbSAnLi9jYXJ0LmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gIG5hbWU6IFwic2VydmljZXNcIixcblxuICBzdGF0ZToge1xuICAgIHByb2dyZXNzOiAwXG4gIH0sXG5cbiAgLyoqXG4gICAgU2V0IHRoZSBJbml0aWFsIFN0YXRlXG4gICovXG4gIGluaXRpYWxfc3RhdGUoKXtcbiAgICBsZXQgZnJvbUxvY2FsU3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndnVlLW1pbmktc2hvcCcpXG5cbiAgICAvLyBJZiBsb2NhbFN0b3JhZ2UgZGF0YSBpcyBsZW5ndGhcbiAgICBpZiAoZnJvbUxvY2FsU3RvcmFnZSAhPT0gbnVsbCkge1xuXG4gICAgICBmcm9tTG9jYWxTdG9yYWdlID0gSlNPTi5wYXJzZShmcm9tTG9jYWxTdG9yYWdlKVxuXG4gICAgICAvLyBEZXN0cnVjdHVyaW5nIEZpcnN0XG4gICAgICBsZXQgeyBwcm9kdWN0OiBwcm9kdWN0LCBjYXJ0OiBjYXJ0IH0gPSBmcm9tTG9jYWxTdG9yYWdlXG5cbiAgICAgIHByb2R1Y3RTdG9yZS5zZXQoeyBhbGw6IHByb2R1Y3QuYWxsIH0pXG4gICAgICBjYXJ0U3RvcmUuc2V0KHsgYWxsOiBjYXJ0LmFsbCB9KVxuICAgIH1cbiAgICAvLyBXaGVuIGRhdGEgaW4gdGhlIGxvY2FsIFN0b3JhZ2UgaXMgbnVsbFxuICAgIGVsc2Uge1xuICAgICAgcHJvZHVjdFN0b3JlLnNldCh7XG4gICAgICAgIGFsbDogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiSXBob25lIDUgU1wiLFxuICAgICAgICAgICAgaW1nOiAnLi9hc3NldHMvaW1nL21vYmlsZS5qcGcnLFxuICAgICAgICAgICAgcHJpY2U6IDkwMDAwMDAsXG4gICAgICAgICAgICBzdG9ja3M6IFtcbiAgICAgICAgICAgICAgeyBjb2xvcjogXCJibGFja1wiLCBzdG9jazogMzAgfSxcbiAgICAgICAgICAgICAgeyBjb2xvcjogXCJzaWx2ZXJcIiwgc3RvY2s6IDIwIH0sXG4gICAgICAgICAgICAgIHsgY29sb3I6IFwiZ29sZFwiLCBzdG9jazogMTAgfSxcbiAgICAgICAgICAgICAgeyBjb2xvcjogXCJyb3NlIGdvbGRcIiwgc3RvY2s6IDUgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBsaWtlZDogZmFsc2UsXG4gICAgICAgICAgICBkZXRhaWw6IFwiPHA+VGhpcyBpcyB0aGUgZGV0YWlscyBvZiB0aGUgSXBob25lLCBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLjxicj48YnI+TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQsIHNlZCBkbyBlaXVzbW9kIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiBVdCBlbmltIGFkIG1pbmltIHZlbmlhbSwgcXVpcyBub3N0cnVkIGV4ZXJjaXRhdGlvbiB1bGxhbWNvIGxhYm9yaXMgbmlzaSB1dCBhbGlxdWlwIGV4IGVhIGNvbW1vZG8gY29uc2VxdWF0LiBEdWlzIGF1dGUgaXJ1cmUgZG9sb3IgaW4gcmVwcmVoZW5kZXJpdCBpbiB2b2x1cHRhdGUgdmVsaXQgZXNzZSBjaWxsdW0gZG9sb3JlIGV1IGZ1Z2lhdCBudWxsYSBwYXJpYXR1ci4gRXhjZXB0ZXVyIHNpbnQgb2NjYWVjYXQgY3VwaWRhdGF0IG5vbiBwcm9pZGVudCwgc3VudCBpbiBjdWxwYSBxdWkgb2ZmaWNpYSBkZXNlcnVudCBtb2xsaXQgYW5pbSBpZCBlc3QgbGFib3J1bS48L3A+XCIsXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBbICdwaG9uZScgXSxcbiAgICAgICAgICAgIGNvbW1lbnRzOiBbXG4gICAgICAgICAgICAgIHsgY29udGVudDogXCJXYWFhaC4uIGtlcmVuIGJpbmdpdCBIcG55YSFcIiB9LFxuICAgICAgICAgICAgICB7IGNvbnRlbnQ6IFwiQmFyYW5nbnlhIFNhbXBhaSBkZW5nYW4gU2VsYW1hdCBHYW4sIE1ha2FzaWguIFBhY2thZ2luZy1ueWEganVnYSBiYWd1cyEgUmVjb21tZW5kZWQgYmFuZ2V0IGRlaCBwb2tva255YVwiIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcIlNtYXJ0IFBob25lIEFwcGxlXCIsXG4gICAgICAgICAgICBpbWc6ICcuL2Fzc2V0cy9pbWcvaGktdGVjaC10b3lzLmpwZycsXG4gICAgICAgICAgICBwcmljZTogMTA1MDAwMDAsXG4gICAgICAgICAgICBzdG9ja3M6IFtcbiAgICAgICAgICAgICAgeyBjb2xvcjogXCJ3aGl0ZVwiLCBzdG9jazogNTAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBsaWtlZDogZmFsc2UsXG4gICAgICAgICAgICBkZXRhaWw6IFwiPHA+VGhpcyBpcyB0aGUgZGV0YWlscyBvZiB0aGUgSXBob25lLCBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLjxicj48YnI+TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQsIHNlZCBkbyBlaXVzbW9kIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiBVdCBlbmltIGFkIG1pbmltIHZlbmlhbSwgcXVpcyBub3N0cnVkIGV4ZXJjaXRhdGlvbiB1bGxhbWNvIGxhYm9yaXMgbmlzaSB1dCBhbGlxdWlwIGV4IGVhIGNvbW1vZG8gY29uc2VxdWF0LiBEdWlzIGF1dGUgaXJ1cmUgZG9sb3IgaW4gcmVwcmVoZW5kZXJpdCBpbiB2b2x1cHRhdGUgdmVsaXQgZXNzZSBjaWxsdW0gZG9sb3JlIGV1IGZ1Z2lhdCBudWxsYSBwYXJpYXR1ci4gRXhjZXB0ZXVyIHNpbnQgb2NjYWVjYXQgY3VwaWRhdGF0IG5vbiBwcm9pZGVudCwgc3VudCBpbiBjdWxwYSBxdWkgb2ZmaWNpYSBkZXNlcnVudCBtb2xsaXQgYW5pbSBpZCBlc3QgbGFib3J1bS48L3A+XCIsXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBbICdwaG9uZScgXSxcbiAgICAgICAgICAgIGNvbW1lbnRzOiBbXG4gICAgICAgICAgICAgIHsgY29udGVudDogXCJQaW50ZXIgYmluZ2l0IEhwbnlhIVwiIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcIkJvb2sgQW5kIFBlblwiLFxuICAgICAgICAgICAgaW1nOiAnLi9hc3NldHMvaW1nL2hpLXRlY2gtdG95cy0yLmpwZycsXG4gICAgICAgICAgICBwcmljZTogMTUwMDAwLFxuICAgICAgICAgICAgc3RvY2tzOiBbXG4gICAgICAgICAgICAgIHsgY29sb3I6IFwiYnJvd25cIiwgc3RvY2s6IDE1MCB9LFxuICAgICAgICAgICAgICB7IGNvbG9yOiBcInNpbHZlclwiLCBzdG9jazogMTUgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBsaWtlZDogZmFsc2UsXG4gICAgICAgICAgICBkZXRhaWw6IFwiPHA+VGhpcyBpcyB0aGUgZGV0YWlscyBvZiB0aGUgSXBob25lLCBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLjxicj48YnI+TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQsIHNlZCBkbyBlaXVzbW9kIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiBVdCBlbmltIGFkIG1pbmltIHZlbmlhbSwgcXVpcyBub3N0cnVkIGV4ZXJjaXRhdGlvbiB1bGxhbWNvIGxhYm9yaXMgbmlzaSB1dCBhbGlxdWlwIGV4IGVhIGNvbW1vZG8gY29uc2VxdWF0LiBEdWlzIGF1dGUgaXJ1cmUgZG9sb3IgaW4gcmVwcmVoZW5kZXJpdCBpbiB2b2x1cHRhdGUgdmVsaXQgZXNzZSBjaWxsdW0gZG9sb3JlIGV1IGZ1Z2lhdCBudWxsYSBwYXJpYXR1ci4gRXhjZXB0ZXVyIHNpbnQgb2NjYWVjYXQgY3VwaWRhdGF0IG5vbiBwcm9pZGVudCwgc3VudCBpbiBjdWxwYSBxdWkgb2ZmaWNpYSBkZXNlcnVudCBtb2xsaXQgYW5pbSBpZCBlc3QgbGFib3J1bS48L3A+XCIsXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBbICdhY2Nlc3NvcmllcycgXSxcbiAgICAgICAgICAgIGNvbW1lbnRzOiBbXG4gICAgICAgICAgICAgIHsgY29udGVudDogXCJCdWt1bnlhIEVsZWdhbiEgU2F5YSBzdWthIGRlbmdhbiBXYXJuYW55YVwiIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcIkZsYXR0eSBQaG9uZSBXaXRoIEVhcnBob25lXCIsXG4gICAgICAgICAgICBpbWc6ICcuL2Fzc2V0cy9pbWcvbW9iaWxlLTIuanBnJyxcbiAgICAgICAgICAgIHByaWNlOiA3NTAwMDAwLFxuICAgICAgICAgICAgc3RvY2tzOiBbXG4gICAgICAgICAgICAgIHsgY29sb3I6IFwid2hpdGVcIiwgc3RvY2s6IDIwIH0sXG4gICAgICAgICAgICAgIHsgY29sb3I6IFwiYmxhY2tcIiwgc3RvY2s6IDEwIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbGlrZWQ6IGZhbHNlLFxuICAgICAgICAgICAgZGV0YWlsOiBcIjxwPlRoaXMgaXMgdGhlIGRldGFpbHMgb2YgdGhlIElwaG9uZSwgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQsIHNlZCBkbyBlaXVzbW9kIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiBVdCBlbmltIGFkIG1pbmltIHZlbmlhbSwgcXVpcyBub3N0cnVkIGV4ZXJjaXRhdGlvbiB1bGxhbWNvIGxhYm9yaXMgbmlzaSB1dCBhbGlxdWlwIGV4IGVhIGNvbW1vZG8gY29uc2VxdWF0LiBEdWlzIGF1dGUgaXJ1cmUgZG9sb3IgaW4gcmVwcmVoZW5kZXJpdCBpbiB2b2x1cHRhdGUgdmVsaXQgZXNzZSBjaWxsdW0gZG9sb3JlIGV1IGZ1Z2lhdCBudWxsYSBwYXJpYXR1ci4gRXhjZXB0ZXVyIHNpbnQgb2NjYWVjYXQgY3VwaWRhdGF0IG5vbiBwcm9pZGVudCwgc3VudCBpbiBjdWxwYSBxdWkgb2ZmaWNpYSBkZXNlcnVudCBtb2xsaXQgYW5pbSBpZCBlc3QgbGFib3J1bS48YnI+PGJyPkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1YS4gVXQgZW5pbSBhZCBtaW5pbSB2ZW5pYW0sIHF1aXMgbm9zdHJ1ZCBleGVyY2l0YXRpb24gdWxsYW1jbyBsYWJvcmlzIG5pc2kgdXQgYWxpcXVpcCBleCBlYSBjb21tb2RvIGNvbnNlcXVhdC4gRHVpcyBhdXRlIGlydXJlIGRvbG9yIGluIHJlcHJlaGVuZGVyaXQgaW4gdm9sdXB0YXRlIHZlbGl0IGVzc2UgY2lsbHVtIGRvbG9yZSBldSBmdWdpYXQgbnVsbGEgcGFyaWF0dXIuIEV4Y2VwdGV1ciBzaW50IG9jY2FlY2F0IGN1cGlkYXRhdCBub24gcHJvaWRlbnQsIHN1bnQgaW4gY3VscGEgcXVpIG9mZmljaWEgZGVzZXJ1bnQgbW9sbGl0IGFuaW0gaWQgZXN0IGxhYm9ydW0uPC9wPlwiLFxuICAgICAgICAgICAgY2F0ZWdvcmllczogWyAncGhvbmUnIF0sXG4gICAgICAgICAgICBjb21tZW50czogW1xuICAgICAgICAgICAgICB7IGNvbnRlbnQ6IFwiRWFycGhvbmVueWEgTWFudGFicyBHYW4hXCIgfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiQm9vayBBbmQgUGVuXCIsXG4gICAgICAgICAgICBpbWc6ICcuL2Fzc2V0cy9pbWcvaGktdGVjaC10b3lzLTIuanBnJyxcbiAgICAgICAgICAgIHByaWNlOiAxNTAwMDAsXG4gICAgICAgICAgICBzdG9ja3M6IFtcbiAgICAgICAgICAgICAgeyBjb2xvcjogXCJicm93blwiLCBzdG9jazogMTUwIH0sXG4gICAgICAgICAgICAgIHsgY29sb3I6IFwic2lsdmVyXCIsIHN0b2NrOiAxNSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGxpa2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGRldGFpbDogXCI8cD5UaGlzIGlzIHRoZSBkZXRhaWxzIG9mIHRoZSBJcGhvbmUsIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1YS4gVXQgZW5pbSBhZCBtaW5pbSB2ZW5pYW0sIHF1aXMgbm9zdHJ1ZCBleGVyY2l0YXRpb24gdWxsYW1jbyBsYWJvcmlzIG5pc2kgdXQgYWxpcXVpcCBleCBlYSBjb21tb2RvIGNvbnNlcXVhdC4gRHVpcyBhdXRlIGlydXJlIGRvbG9yIGluIHJlcHJlaGVuZGVyaXQgaW4gdm9sdXB0YXRlIHZlbGl0IGVzc2UgY2lsbHVtIGRvbG9yZSBldSBmdWdpYXQgbnVsbGEgcGFyaWF0dXIuIEV4Y2VwdGV1ciBzaW50IG9jY2FlY2F0IGN1cGlkYXRhdCBub24gcHJvaWRlbnQsIHN1bnQgaW4gY3VscGEgcXVpIG9mZmljaWEgZGVzZXJ1bnQgbW9sbGl0IGFuaW0gaWQgZXN0IGxhYm9ydW0uPGJyPjxicj5Mb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLjwvcD5cIixcbiAgICAgICAgICAgIGNhdGVnb3JpZXM6IFsgJ2FjY2Vzc29yaWVzJyBdLFxuICAgICAgICAgICAgY29tbWVudHM6IFtcbiAgICAgICAgICAgICAgeyBjb250ZW50OiBcIkJ1a3VueWEgRWxlZ2FuISBTYXlhIHN1a2EgZGVuZ2FuIFdhcm5hbnlhXCIgfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiQW4gSXBhZFwiLFxuICAgICAgICAgICAgaW1nOiAnLi9hc3NldHMvaW1nL2lwYWQuanBnJyxcbiAgICAgICAgICAgIHByaWNlOiAxMDAwMDAwMCxcbiAgICAgICAgICAgIHN0b2NrczogW1xuICAgICAgICAgICAgICB7IGNvbG9yOiBcImJsYWNrXCIsIHN0b2NrOiAxMCB9LFxuICAgICAgICAgICAgICB7IGNvbG9yOiBcInNpbHZlclwiLCBzdG9jazogMTAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGxpa2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGRldGFpbDogXCI8cD5UaGlzIGlzIHRoZSBkZXRhaWxzIG9mIHRoZSBJcGFkLCBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLjxicj48YnI+TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQsIHNlZCBkbyBlaXVzbW9kIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiBVdCBlbmltIGFkIG1pbmltIHZlbmlhbSwgcXVpcyBub3N0cnVkIGV4ZXJjaXRhdGlvbiB1bGxhbWNvIGxhYm9yaXMgbmlzaSB1dCBhbGlxdWlwIGV4IGVhIGNvbW1vZG8gY29uc2VxdWF0LiBEdWlzIGF1dGUgaXJ1cmUgZG9sb3IgaW4gcmVwcmVoZW5kZXJpdCBpbiB2b2x1cHRhdGUgdmVsaXQgZXNzZSBjaWxsdW0gZG9sb3JlIGV1IGZ1Z2lhdCBudWxsYSBwYXJpYXR1ci4gRXhjZXB0ZXVyIHNpbnQgb2NjYWVjYXQgY3VwaWRhdGF0IG5vbiBwcm9pZGVudCwgc3VudCBpbiBjdWxwYSBxdWkgb2ZmaWNpYSBkZXNlcnVudCBtb2xsaXQgYW5pbSBpZCBlc3QgbGFib3J1bS48L3A+XCIsXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBbICdwYWQnIF0sXG4gICAgICAgICAgICBjb21tZW50czogW1xuICAgICAgICAgICAgICB7IGNvbnRlbnQ6IFwiU3VrYWsgYmFuZ2V0IHNhbWEgeWFuZyB3YXJuYSBNZXJhaFwiIH0sXG4gICAgICAgICAgICAgIHsgY29udGVudDogXCJCYXJhbmdueWEgU2FtcGFpIGRlbmdhbiBTZWxhbWF0IEdhbiwgTWFrYXNpaC4gUGFja2FnaW5nLW55YSBqdWdhIGJhZ3VzISBSZWNvbW1lbmRlZCBiYW5nZXQgZGVoIHBva29rbnlhXCIgfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcIk1vYmlsZSBJT1NcIixcbiAgICAgICAgICAgIGltZzogJy4vYXNzZXRzL2ltZy9pb3MuanBnJyxcbiAgICAgICAgICAgIHByaWNlOiAxMzAwMDAwMCxcbiAgICAgICAgICAgIHN0b2NrczogW1xuICAgICAgICAgICAgICB7IGNvbG9yOiBcImdvbGRcIiwgc3RvY2s6IDEwIH0sXG4gICAgICAgICAgICAgIHsgY29sb3I6IFwiYmxhY2tcIiwgc3RvY2s6IDEwIH0sXG4gICAgICAgICAgICAgIHsgY29sb3I6IFwic2lsdmVyXCIsIHN0b2NrOiAxMCB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbGlrZWQ6IGZhbHNlLFxuICAgICAgICAgICAgZGV0YWlsOiBcIjxwPlRoaXMgaXMgdGhlIGRldGFpbHMgb2YgdGhlIE1vYmlsZSBJT1MsIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1YS4gVXQgZW5pbSBhZCBtaW5pbSB2ZW5pYW0sIHF1aXMgbm9zdHJ1ZCBleGVyY2l0YXRpb24gdWxsYW1jbyBsYWJvcmlzIG5pc2kgdXQgYWxpcXVpcCBleCBlYSBjb21tb2RvIGNvbnNlcXVhdC4gRHVpcyBhdXRlIGlydXJlIGRvbG9yIGluIHJlcHJlaGVuZGVyaXQgaW4gdm9sdXB0YXRlIHZlbGl0IGVzc2UgY2lsbHVtIGRvbG9yZSBldSBmdWdpYXQgbnVsbGEgcGFyaWF0dXIuIEV4Y2VwdGV1ciBzaW50IG9jY2FlY2F0IGN1cGlkYXRhdCBub24gcHJvaWRlbnQsIHN1bnQgaW4gY3VscGEgcXVpIG9mZmljaWEgZGVzZXJ1bnQgbW9sbGl0IGFuaW0gaWQgZXN0IGxhYm9ydW0uPGJyPjxicj5Mb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLjwvcD5cIixcbiAgICAgICAgICAgIGNhdGVnb3JpZXM6IFsgJ3Bob25lJyBdLFxuICAgICAgICAgICAgY29tbWVudHM6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0pXG4gICAgfSAvLyBlbHNlXG4gIH0sIC8vIGluaXRpYWxfc3RhdGUoKVxuXG5cblxuICAvKipcbiAgICBnZXQgQWxsIHN0YXRlIG9mIHRoZSBBcHBcbiAgKi9cbiAgZ2V0X2FsbCgpe1xuICAgIGxldCBwcm9kdWN0ID0gcHJvZHVjdFN0b3JlLnN0YXRlXG4gICAgbGV0IGNhcnQgPSBjYXJ0U3RvcmUuc3RhdGVcbiAgICBsZXQgc3RhdGUgPSB7IHByb2R1Y3QsIGNhcnQgfVxuICAgIHJldHVybiBzdGF0ZVxuICB9LFxuXG5cbiAgLyoqXG4gICAgQmFja3VwIEFsbCBzdGF0ZSB0byB0aGUgTG9jYWwgU3RvcmFnZVxuICAqL1xuICBiYWNrdXBfdG9fbG9jYWxfc3RvcmFnZSgpe1xuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndnVlLW1pbmktc2hvcCcsIEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0X2FsbCgpKSlcbiAgfSxcblxuXG4gIC8qKlxuICAgIENsb3NpbmcgdGhlIEFjdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25fbmFtZVxuICAgIEBwYXJhbSB7T2JqZWN0fSB2YWxcbiAgKi9cbiAgY2xvc2VfdGhlX2FjdGlvbihhY3Rpb25fbmFtZSwgdmFsKXtcbiAgICB0aGlzLmJhY2t1cF90b19sb2NhbF9zdG9yYWdlKClcbiAgICBjb25zb2xlLmxvZyhhY3Rpb25fbmFtZSx2YWwpO1xuICB9LFxuXG4gIC8qKlxuICAgIFNldCB0aGUgdmFsdWUgb2YgdGhlIHByb2dyZXNzIGJhclxuICAgIEBwYXJhbSB7SW50fSBudW1cbiAgKi9cbiAgcHJvZ3Jlc3NfdG8obnVtKXtcbiAgICB0aGlzLnN0YXRlLnByb2dyZXNzID0gbnVtXG4gIH1cblxufTtcbiJdfQ==
